###!/usr/bin/python
# -*- coding: utf-8 -*-

from artisanlib import __version__
from artisanlib import __revision__
from artisanlib import __build__

# ABOUT
# This program shows how to plot the temperature and its rate of change from a
# Fuji PID or a thermocouple meter.

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later versison. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#########################   POLICIES  ###########################################################################
# 1  STRINGS
#
# When possible, use QString and Unicode characters in user inputs. Use ASCII only for serial comm (raw data).
# There are two ways to create a unicode string: u"one way" and unicode("second way").
# There are two ways to create a QString: u("one way") and the return of QTfunction()
# There are several ways to create ASCII strings: "one way", str("second way"), and return of python function().
# Inmideately convert ascii strings to Unicode at return of functions by using unicode().
# There is 7 bits Ascii, and then there is 8 bit Western Europe Ascii.
# WARNING: If an ascii str contains characters outside the 7 bit range, Python raises UnicodeEncodeError exception.
#################################################################################################################


import os
import sys  # @UnusedImport
import ast
import platform
import math
import time as libtime
import copy
import datetime
import warnings
import string as libstring
import html as htmllib
import numpy
import subprocess
import shlex
import binascii
import codecs
import uuid
import threading
import multiprocessing
import re
import textwrap
import natsort
import gc
import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)


import urllib.parse as urlparse  # @Reimport
import urllib.request as urllib  # @Reimport

import prettytable  # @UnresolvedImport

try: # activate support for hiDPI screens on Windows
    if str(platform.system()).startswith("Windows"):
        os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "1"
except:
    pass

# write logtrace to Console on OS X:
#try:
#..
#except Exception as e:
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    import traceback
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))


from PyQt5.QtWidgets import (QLayout,QAction, QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog, QGraphicsDropShadowEffect,  # @Reimport
                         QInputDialog, QGroupBox, QDialog, QLineEdit, QTimeEdit, QTableWidgetSelectionRange, # @Reimport
                         QSizePolicy, QGridLayout, QVBoxLayout, QHBoxLayout, QPushButton, QDialogButtonBox, # @Reimport
                         QLCDNumber, QSpinBox, QComboBox, QHeaderView, QAbstractItemView, # @Reimport 
                         QSlider, QTabWidget, QStackedWidget, QTextEdit, QRadioButton, # @Reimport
                         QColorDialog, QFrame, QCheckBox,QStatusBar, QProgressDialog, # @Reimport
                         QListView, QStyleFactory, QTableWidget, QTableWidgetItem, QMenu, QDoubleSpinBox,QButtonGroup) # @Reimport
from PyQt5.QtGui import (QImageReader, QWindow, QFontMetrics,  # @Reimport
                            QKeySequence,QStandardItem, #QImage,
                            QPixmap,QColor,QPalette,QDesktopServices,QIcon,  # @Reimport
                            QRegExpValidator,QDoubleValidator, QIntValidator,QPainter, QFont,QBrush, QRadialGradient,QCursor)  # @Reimport
from PyQt5.QtPrintSupport import (QPrinter,QPrintDialog)  # @Reimport
from PyQt5.QtCore import (QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, pyqtSignal, pyqtSlot,  # @Reimport
                          qVersion,QTime, QTimer, QFile, QIODevice, QTextStream, QSettings,   # @Reimport
                          QRegExp, QDate, QUrl, QDir, Qt, QPoint, QEvent, QDateTime, QThread, QSemaphore, qInstallMessageHandler)  # @Reimport
from PyQt5.QtNetwork import QLocalSocket, QLocalServer # @UnusedImport

try: # hidden import to allow pyinstaller build on OS X to include the PyQt5.x private sip module
    from PyQt5 import sip # @UnusedImport
except:
    pass

from artisanlib.suppress_errors import suppress_stdout_stderr

with suppress_stdout_stderr():
    import matplotlib as mpl
    from matplotlib import cm

# on OS X / PyQt5 one needs to
#   export DYLD_FRAMEWORK_PATH=~/Qt5.5.0/5.5/clang_64/lib/
# (see Mac OS X specific notes in the PyQt5 documentation)
#print(QImageReader.supportedImageFormats())
#print(QLibraryInfo.location(QLibraryInfo.PluginsPath))

svgsupport = next((x for x in QImageReader.supportedImageFormats() if x == b'svg'),None)

from functools import reduce as freduce
mpl.use('Qt5Agg')

from matplotlib.figure import Figure
from matplotlib import rcParams
import matplotlib.patches as patches
import matplotlib.transforms as transforms
import matplotlib.ticker as ticker
import matplotlib.patheffects as PathEffects

import matplotlib.backends.backend_pdf # @UnusedImport
import matplotlib.backends.backend_svg # @UnusedImport
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas  # @Reimport
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar # @Reimport
from matplotlib.backend_bases import LocationEvent as mplLocationevent

import matplotlib.backends.qt_editor.figureoptions as figureoptions

from Phidget22.DeviceID import DeviceID
from Phidget22.Devices.TemperatureSensor import TemperatureSensor as PhidgetTemperatureSensor
from Phidget22.Devices.HumiditySensor import HumiditySensor as PhidgetHumiditySensor
from Phidget22.Devices.PressureSensor import PressureSensor as PhidgetPressureSensor
from Phidget22.Devices.VoltageRatioInput import VoltageRatioInput  # @UnusedWildImport
from Phidget22.Devices.VoltageInput import VoltageInput # @UnusedWildImport
from Phidget22.Devices.DigitalInput import DigitalInput # @UnusedWildImport
from Phidget22.Devices.DigitalOutput import DigitalOutput # @UnusedWildImport 
from Phidget22.Devices.VoltageOutput import VoltageOutput # @UnusedWildImport
from Phidget22.Devices.RCServo import RCServo # @UnusedWildImport
from Phidget22.Devices.CurrentInput import CurrentInput # @UnusedWildImport
from Phidget22.Devices.FrequencyCounter import FrequencyCounter # @UnusedWildImport
from Phidget22.Devices.DCMotor import DCMotor # @UnusedWildImport
from Phidget22.Phidget import Phidget as PhidgetDriver


# fix socket.inet_pton on Windows (used by pymodbus TCP/UDP)
try:
    if str(platform.system()).startswith("Windows"):
        import win_inet_pton # @UnresolvedImport @UnusedImport
except:
    pass


#---------------------------------------------------------------------------#
# configure the service logging and use _logger.debug("..") statements
#---------------------------------------------------------------------------#
#import logging
#import logging.handlers as Handlers
#logging.basicConfig()
#myFormatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
#log = logging.getLogger()
#log.setLevel(logging.DEBUG)
#filehandler = Handlers.RotatingFileHandler(os.getenv("HOME") + "/Desktop/artisan-logfile", maxBytes=1024*1024)
#filehandler.setFormatter(myFormatter)
#log.addHandler(filehandler)
#_logger = logging.getLogger(__name__)
#---------------------------------------------------------------------------#



import unicodedata # @UnresolvedImport
from unidecode import unidecode

import artisanlib.arabic_reshaper
from artisanlib.util import appFrozen, decs2string, stringp, uchr, u, d, encodeLocal, hex2int, s2a, cmd2str, str2cmd
from artisanlib.s7port import s7port
from artisanlib.modbusport import modbusport
from artisanlib.qtsingleapplication import QtSingleApplication
from artisanlib.phidgets import PhidgetManager
from artisanlib.sliderStyle import *
from artisanlib.cropster import extractProfileCropsterXLS
from artisanlib.giesen import extractProfileGiesenCSV
from artisanlib.ikawa import extractProfileIkawaCSV
from artisanlib.simulator import Simulator

from yoctopuce.yocto_api import YAPI, YRefParam


# maps Artisan thermocouple types (order as listed in the menu; see phidget1048_types) to Phidget thermocouple types
# 1 => k-type (default)
# 2 => j-type
# 3 => e-type
# 4 => t-type
def PHIDGET_THERMOCOUPLE_TYPE(tp):
    from Phidget22.ThermocoupleType import ThermocoupleType
    if tp == 2:
        return ThermocoupleType.THERMOCOUPLE_TYPE_J
    elif tp == 3:
        return ThermocoupleType.THERMOCOUPLE_TYPE_E
    elif tp == 4:
        return ThermocoupleType.THERMOCOUPLE_TYPE_T
    else:
        return ThermocoupleType.THERMOCOUPLE_TYPE_K

# maps Artisan RTD wire setups (order as listed in the menu; see phidget1200_wireValues) to Phdiget wire setups
# 0 => 2-wire (default)
# 2 => 3-wire
# 3 => 4-wire
def PHIDGET_RTD_WIRE(tp):
    from Phidget22.RTDWireSetup import RTDWireSetup
    if tp == 1:
        return RTDWireSetup.RTD_WIRE_SETUP_3WIRE
    elif tp == 2:
        return RTDWireSetup.RTD_WIRE_SETUP_4WIRE
    else:
        return RTDWireSetup.RTD_WIRE_SETUP_2WIRE
     
# maps Artisan RTD types (order as listed in the menu; see phidget1200_formulaValues) to Phdiget RTD types
# 0 => PT100 3850 (default)
# 2 => PT100 3920
# 3 => PT1000 3850
# 4 => PT1000 3920        
def PHIDGET_RTD_TYPE(tp):
    from Phidget22.RTDType import RTDType
    if tp == 1:
        return RTDType.RTD_TYPE_PT100_3920
    elif tp == 2:
        return RTDType.RTD_TYPE_PT1000_3850
    elif tp == 3:
        return RTDType.RTD_TYPE_PT1000_3920
    else:
        return RTDType.RTD_TYPE_PT100_3850
    
# maps Artisan gain values (see phidget1046_gainValues) to Phidgets gain values
# defaults to no gain (BRIDGE_GAIN_1)
# not supported:
#   2x Amplification => BRIDGE_GAIN_2
#   4x Amplification => BRIDGE_GAIN_4
def PHIDGET_GAIN_VALUE(gv):
    from Phidget22.BridgeGain import BridgeGain as BG  # @UnusedImport
    if gv == 2:
        return BG.BRIDGE_GAIN_8 # 8x Amplification
    elif gv == 3:	
        return BG.BRIDGE_GAIN_16 # 16x Amplification
    elif gv == 4:	
        return BG.BRIDGE_GAIN_32 # 32x Amplification
    elif gv == 5:
        return BG.BRIDGE_GAIN_64 # 64x Amplification
    elif gv == 6:	
        return BG.BRIDGE_GAIN_128 # 128x Amplification
    else:
        return BG.BRIDGE_GAIN_1 # no gain


umlaute_dict = {
   uchr(228): 'ae',  # U+00E4   \xc3\xa4
   uchr(246): 'oe',  # U+00F6   \xc3\xb6
   uchr(252): 'ue',  # U+00FC   \xc3\xbc
   uchr(196): 'Ae',  # U+00C4   \xc3\x84
   uchr(214): 'Oe',  # U+00D6   \xc3\x96
   uchr(220): 'Ue',  # U+00DC   \xc3\x9c
   uchr(223): 'ss',  # U+00DF   \xc3\x9f
}

def toASCII(s):
    if s is None:
        return None
    else:
        utf8_string = u(s)
        if locale.startswith("de"):
            for k in umlaute_dict.keys():
                utf8_string = utf8_string.replace(k, umlaute_dict[k])
        return unidecode(utf8_string)


def path2url(path):
    return urlparse.urljoin(
      'file:', urllib.pathname2url(path))
        
# remaining artifacts from Qt4/5 compatibility layer:
def toInt(x):
    if x is None:
        return 0
    else:
        try:
            return int(x)
        except:
            return 0
def toString(x):
    return str(x)
def toList(x):
    if x is None:
        return []
    else:
        return list(x)
def toFloat(x):
    if x is None:
        return 0.
    else:
        try:
            return float(x)
        except:
            return 0.
def toDouble(x):
    if x is None:
        return 0.
    else:
        try:
            return float(x)
        except:
            return 0.
def toBool(x):
    if x is None:
        return False
    else:
        if isinstance(x,str):
            if x in ["false","False"]:
                return False
            else:
                return True
        else:
            return bool(x)
def toStringList(x):
    if x:
        return [u(s) for s in x]
    else:
        return []
def toMap(x):
    return x
def removeAll(l,s):
    for _ in range(l.count(s)):  # @UndefinedVariable
        l.remove(s) 

platf = str(platform.system())


#######################################################################################
#################### Main Application  ################################################
#######################################################################################


appGuid = '9068bd2fa8e54945a6be1f1a0a589e92'
viewerAppGuid = '9068bd2fa8e54945a6be1f1a0a589e93'

class Artisan(QtSingleApplication):
    def __init__(self, args):
        super(Artisan, self).__init__(appGuid,viewerAppGuid,args)
        
        self.focusChanged.connect(self.appRaised)
        self.sentToBackground = None # set to timestamp on putting app to background without any open dialog
        self.plus_sync_cache_expiration = 2*60 # how long a plus sync is valid in seconds
        
        if multiprocessing.current_process().name == 'MainProcess' and self.isRunning():
            self.artisanviewerMode = True
            if self.isRunningViewer(): sys.exit(0) # there is already one ArtisanViewer running, we terminate
        else:
            self.artisanviewerMode = False
        self.messageReceived.connect(self.receiveMessage)
    
    @pyqtSlot("QWidget*","QWidget*")
    def appRaised(self,oldFocusWidget,newFocusWidget):
        try:
            if not sip.isdeleted(aw): # sip not supported on older PyQt versions (eg. RPi)
                if oldFocusWidget is None and newFocusWidget is not None and aw is not None and aw.centralWidget() == newFocusWidget and self.sentToBackground is not None:
                    #focus gained
                    try:
                        if aw is not None and aw.plus_account is not None and aw.qmc.roastUUID is not None and aw.curFile is not None and \
                                libtime.time() - self.sentToBackground > self.plus_sync_cache_expiration:
                                plus.sync.getUpdate(aw.qmc.roastUUID,aw.curFile)
                    except:
                        pass
                    self.sentToBackground = None
                        
                elif oldFocusWidget is not None and newFocusWidget is None and aw is not None and aw.centralWidget() == oldFocusWidget:
                    # focus released
                    self.sentToBackground = libtime.time() # keep the timestamp on sending the app with the main window to background
                else: # on raising another dialog/widget was open, reset timer
                    self.sentToBackground = None
        except:
            pass
        
    # takes a QUrl and interprets it as follows
    # artisan://roast/<UUID> : loads profile from path associated with the given roast <UUID>
    def open_url(self, url):
        if not aw.qmc.flagon: # only if not yet monitoring
            if url.scheme() == "artisan" and url.authority() == 'roast':
                roast_UUID = url.toString(QUrl.RemoveScheme | QUrl.RemoveAuthority | QUrl.RemoveQuery | QUrl.RemoveFragment | QUrl.StripTrailingSlash)[1:]
                if aw.qmc.roastUUID is None or aw.qmc.roastUUID != roast_UUID:
                    # not yet open, lets try to find the path to that roastUUID and open it
                    profile_path = plus.register.getPath(roast_UUID)
                    if profile_path:
                        aw.sendmessage(QApplication.translate("Message","URL open profile: {0}",None).format(profile_path))
                        QTimer.singleShot(20,lambda : aw.loadFile(profile_path))
    
    @pyqtSlot(str)
    def receiveMessage(self,msg):
        url = QUrl()
        url.setUrl(msg)
        self.open_url(url)

    def event(self, event):
        if event.type() == QEvent.FileOpen:
            try:
                url = event.url()
                if url.isValid() and url.scheme() != "file" and (event.file() is None or event.file() == ""):
                    self.open_url(event.url())
                else:
                    if not aw.qmc.flagstart:
                        filename = u(event.file())
                        qfile = QFileInfo(filename)
                        file_suffix = u(qfile.suffix())
                        if file_suffix == "alog":
                            # load Artisan profile on double-click on *.alog file
                            QTimer.singleShot(20,lambda : aw.loadFile(filename))
                        elif file_suffix == "alrm":
                            # load Artisan alarms on double-click on *.alrm file
                            QTimer.singleShot(20,lambda : aw.loadAlarms(filename))
                        elif file_suffix == "apal":
                            # load Artisan palettes on double-click on *.apal file
                            QTimer.singleShot(20,lambda : aw.getPalettes(filename,aw.buttonpalette))
            except:
                pass
            return 1
        else:
            return super(Artisan, self).event(event)

args = sys.argv
if sys.platform.startswith("linux"):
    # avoid a GTK bug in Ubuntu Unity
    args = args + ['-style','Fusion']
#if platf == 'Windows':
#    # highDPI support must be set before creating the Application instance
#    try:
#        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
#        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)
#    except Exception as e:
#        pass
app = Artisan(args)

# On the first run if there are legacy settings under "YourQuest" but no new settings under "artisan-scope" then the legacy settings 
# will be copied to the new settings location. Once settings exist under "artisan-scope" the legacy settings under "YourQuest" will
# no longer be read or saved.  At start-up, versions of Artisan before to v2.0 will no longer share settings with versions v2.0 and after. 
# Settings can be shared among all versions of Artisan by explicitly saving and loading them using Help>Save/Load Settings.
try:
    app.setApplicationName("Artisan")                                       #needed by QSettings() to store windows geometry in operating system

    app.setOrganizationName("YourQuest")                                    #needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain("p.code.google.com")                          #needed by QSettings() to store windows geometry in operating system
    legacysettings = QSettings()
    app.setOrganizationName("artisan-scope")                                #needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain("artisan-scope.org")                          #needed by QSettings() to store windows geometry in operating system
    newsettings = QSettings()
    
    settingsRelocated = False
    # copy settings from legacy to new if newsettings do not exist, legacysettings do exist, and were not previously copied 
#    if not newsettings.contains("Mode") and legacysettings.contains("Mode") and not legacysettings.contains("_settingsCopied"):
    if not newsettings.contains("Mode") and legacysettings.contains("Mode") and not legacysettings.value("_settingsCopied") == 1:
        settingsRelocated = True
        # copy Artisan settings
        for key in legacysettings.allKeys():
            newsettings.setValue(key,legacysettings.value(key))
        legacysettings.setValue("_settingsCopied", 1)  # prevents copying again in the future, this key not cleared by a Factory Reset

        # copy ArtisanViewer settings
        app.setApplicationName("ArtisanViewer")                                       #needed by QSettings() to store windows geometry in operating system

        app.setOrganizationName("YourQuest")                                    #needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain("p.code.google.com")                          #needed by QSettings() to store windows geometry in operating system
        legacysettings = QSettings()
        app.setOrganizationName("artisan-scope")                                #needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain("artisan-scope.org")                          #needed by QSettings() to store windows geometry in operating system
        newsettings = QSettings()
        for key in legacysettings.allKeys():
            newsettings.setValue(key,legacysettings.value(key))
    del legacysettings   #free up memmory?
    del newsettings      #free up memmory?
except:
    pass
    
app.setApplicationName("Artisan")                                       #needed by QSettings() to store windows geometry in operating system
app.setOrganizationName("artisan-scope")                                #needed by QSettings() to store windows geometry in operating system
app.setOrganizationDomain("artisan-scope.org")                          #needed by QSettings() to store windows geometry in operating system
#app.setOrganizationName("YourQuest")                                   #needed by QSettings() to store windows geometry in operating system
#app.setOrganizationDomain("p.code.google.com")                          #needed by QSettings() to store windows geometry in operating system
    
if platf == 'Windows':
    app.setWindowIcon(QIcon("artisan.png"))
#    try:
#        # activate scaling for hiDPI screen support on Windows
#        app.setAttribute(Qt.AA_EnableHighDpiScaling)
#        if hasattr(QStyleFactory, 'AA_UseHighDpiPixmaps'):
#            app.setAttribute(Qt.AA_UseHighDpiPixmaps)
#    except Exception as e:
#        pass


deltaLabelPrefix = "<html>&Delta;&thinsp;</html>" # prefix constant for labels to compose DeltaET/BT by prepending this prefix to ET/BT labels
if platf == 'Linux':
    deltaLabelUTF8 = u("Delta")
else:
    deltaLabelUTF8 = u("\u0394\u2009") # u("\u03B4") # prefix for non HTML Qt Widgets like QPushbuttons
deltaLabelBigPrefix = u("<big><b>&Delta;</b></big>&thinsp;<big><b>") # same as above for big/bold use cases
deltaLabelMathPrefix = u("$\Delta\/$")  # prefix for labels in matplibgraphs to compose DeltaET/BT by prepending this prefix to ET/BT labels


# platform dependent imports:
if sys.platform.startswith("darwin"):
    # control app napping on OS X >= 10.9
    import appnope  # @UnresolvedImport
    # import module to detect if OS X dark mode is active or not
    import darkdetect # @UnresolvedImport
    # to establish a thread pool on OS X
    import objc  # @UnresolvedImport @UnusedImport # pyobjc seems not to be needed anylonger 
    import Foundation  # @UnresolvedImport
#   list_ports module patched for P3k from new pyserial GitHub repository

# to make py2exe happy with scipy >0.11
def __dependencies_for_freezing():
    import matplotlib.numerix # not to break bbfreeze 1.1.3 on Linux  @UnresolvedImport @UnusedImport
    from scipy.sparse.csgraph import _validation # @UnresolvedImport @UnusedImport
    from scipy.special import _ufuncs_cxx # @UnresolvedImport @UnusedImport
    from scipy import integrate # @UnresolvedImport @UnusedImport
    from scipy import interpolate # @UnresolvedImport @UnusedImport
#    from scipy.optimize import curve_fit # @UnresolvedImport @UnusedImport
    # to make bbfreeze on Linux and py2exe on Win/Py3 happy with scipy > 0.17.0
    import scipy.linalg.cython_blas # @UnresolvedImport @UnusedImport
    import scipy.linalg.cython_lapack # @UnresolvedImport @UnusedImport
    
    import appdirs # @UnresolvedImport @UnusedImport
    import packaging # @UnresolvedImport @UnusedImport
    import packaging.version # @UnresolvedImport @UnusedImport
    import packaging.specifiers # @UnresolvedImport @UnusedImport
    import packaging.markers # @UnresolvedImport @UnusedImport
    import packaging.requirements # @UnresolvedImport @UnusedImport
    
    import PyQt5.QtSvg  # @UnusedImport
    import PyQt5.QtXml  # @UnusedImport
    import PyQt5.QtDBus # needed for QT5 builds  # @UnusedImport
    import PyQt5.QtPrintSupport # needed for by platform plugin libqcocoa  # @UnusedImport
    
    # for gevent bundling
    from gevent import core, resolver_thread, resolver_ares, socket, threadpool, thread, threading, select, subprocess, pywsgi, server, hub # @UnusedImport @Reimport 

del __dependencies_for_freezing


#Localization support
global locale

if QSettings().contains('resetqsettings') and not toInt(QSettings().value('resetqsettings')):
    locale = toString(QSettings().value('locale'))
    if locale is None or locale == "en_US":
        locale = "en"
else:
    locale = ""
supported_languages = [
    "ar",
    "de",
    "el",
    "en",
    "es",
    "fa",
    "fi",
    "fr",
    "he",
    "hu",
    "id",
    "it",
    "ja",
    "ko",
    "nl",
    "no",
    "pt",
    "pt_BR",
    "pl",
    "ru",
    "sv",
    "th",
    "tr",
    "zh",
    "zh_CN",
    "zh_TW",
]
if len(locale) == 0:
    if platform.system() == 'Darwin':
        from Cocoa import NSUserDefaults # @UnresolvedImport
        defs = NSUserDefaults.standardUserDefaults()
        langs = defs.objectForKey_("AppleLanguages")
        if langs.objectAtIndex_(0)[:3] == "zh_" or langs.objectAtIndex_(0)[:3] == "pt_":
            locale = langs.objectAtIndex_(0)[:5]
        else:
            locale = langs.objectAtIndex_(0)[:2]
    else:
        if QLocale.system().name()[:2] == "zh_" or QLocale.system().name()[:2] == "pt_":
            locale = QLocale.system().name()[:5]
        else:
            locale = QLocale.system().name()[:2]
    if locale in supported_languages:
        QSettings().setValue('locale', locale)

if locale is None or len(locale) == 0:
    locale = "en"

#load Qt default translations from QLibrary
qtTranslator = QTranslator()
if qtTranslator.load("qtbase_" + locale, QLibraryInfo.location(QLibraryInfo.TranslationsPath)):
    app.installTranslator(qtTranslator)
#find Qt default translations in Unix binaries
elif qtTranslator.load("qtbase_" + locale, QApplication.applicationDirPath() + "/translations"):
    app.installTranslator(qtTranslator)
#find Qt default translations in Mac binary
elif qtTranslator.load("qtbase_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(qtTranslator)
# qtbase_ translations added to the Artisan source as they are not in the official Qt builds
elif qtTranslator.load("qtbase_" + locale, "translations"):
    app.installTranslator(qtTranslator)

#load Artisan translations
appTranslator = QTranslator()
#find application translations in source folder
if appTranslator.load("artisan_" + locale, "translations"):
    app.installTranslator(appTranslator)
#find application translations in Unix binaries
elif appTranslator.load("artisan_" + locale, QApplication.applicationDirPath() + "/translations"):
    app.installTranslator(appTranslator)
#find application translations in Mac binary
elif appTranslator.load("artisan_" + locale, QApplication.applicationDirPath() + "/../translations"):
    app.installTranslator(appTranslator)


from const import UIconst
from artisanlib import pid
from artisanlib.time import ArtisanTime

# import artisan.plus module
import plus.config
import plus.util
import plus.sync
import plus.queue
import plus.controller
import plus.register

#######################################################################################
#################### Ambient Data Collection  #########################################
#######################################################################################

class AmbientThread(QThread):
    def __init__(self):
        super(AmbientThread,self).__init__()

    def run(self):
        libtime.sleep(2.5) # wait a moment after ON until all other devices are attached
        try:
            aw.qmc.getAmbientData()
        except:
            pass

#######################################################################################
#################### GRAPH DRAWING WINDOW  ############################################
#######################################################################################

class tgraphcanvas(FigureCanvas):
    updategraphicsSignal = pyqtSignal()
    updateLargeLCDsTimeSignal = pyqtSignal(str)
    updateLargeLCDsReadingsSignal = pyqtSignal(str,str)
    updateLargeLCDsSignal = pyqtSignal(str,str,str)
    
    def __init__(self,parent,dpi):

        #default palette of colors
        self.alpha = {"analysismask":0.4,"statsanalysisbkgnd":1.0,"legendbg":0.4}
        self.palette = {"background":'white',"grid":'#E5E5E5',"ylabel":'#808080',"xlabel":'#808080',"title":'#0C6AA6',
                        "rect1":'#E5E5E5',"rect2":'#B2B2B2',"rect3":'#E5E5E5',"rect4":'#bde0ee',"rect5":'lightgrey',
                        "et":'#cc0f50',"bt":'#0A5C90',"xt":'#404040',"deltaet":'#cc0f50',
                        "deltabt":'#0A5C90',"markers":'black',"text":'black',"watermarks":'yellow',"timeguide":'#0A5C90',
                        "canvas":'#F8F8F8',"legendbg":'white',"legendborder":'darkgrey', 
                        "specialeventbox":'#ff5871',"specialeventtext":'white', 
                        "bgeventmarker":'white',"bgeventtext":'black',
                        "mettext":'white',"metbox":'#CC0F50',
                        "aucguide":'#0c6aa6',"messages":'black',"aucarea":'#767676',
                        "analysismask":'#bababa',"statsanalysisbkgnd":"#ffffff"}
        self.palette1 = self.palette.copy()
        self.EvalueColor_default = ['#43a7cf','#49B160','#800080','#ad0427']
        self.EvalueTextColor_default = ['white','white','white','white']

        self.artisanflavordefaultlabels = [QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Aftertaste",None),
                                            QApplication.translate("Textbox", "Clean Cup",None),
                                            QApplication.translate("Textbox", "Head",None),
                                            QApplication.translate("Textbox", "Fragrance",None),
                                            QApplication.translate("Textbox", "Sweetness",None),
                                            QApplication.translate("Textbox", "Aroma",None),
                                            QApplication.translate("Textbox", "Balance",None),
                                            QApplication.translate("Textbox", "Body",None)]

        # custom labels are stored in the application settings and can be edited by the user
        self.customflavorlabels = self.artisanflavordefaultlabels

        self.SCCAflavordefaultlabels = [QApplication.translate("Textbox", "Sour",None),
                                        QApplication.translate("Textbox", "Flavor",None),
                                        QApplication.translate("Textbox", "Critical\nStimulus",None),
                                        QApplication.translate("Textbox", "Aftertaste",None),
                                        QApplication.translate("Textbox", "Bitter",None),
                                        QApplication.translate("Textbox", "Astringency",None),
                                        QApplication.translate("Textbox", "Solubles\nConcentration",None),
                                        QApplication.translate("Textbox", "Mouthfeel",None),
                                        QApplication.translate("Textbox", "Other",None),
                                        QApplication.translate("Textbox", "Aromatic\nComplexity",None),
                                        QApplication.translate("Textbox", "Roast\nColor",None),
                                        QApplication.translate("Textbox", "Aromatic\nPungency",None),
                                        QApplication.translate("Textbox", "Sweet",None),
                                        QApplication.translate("Textbox", "Acidity",None),
                                        QApplication.translate("Textbox", "pH",None),
                                        QApplication.translate("Textbox", "Balance",None)]

        self.CQIflavordefaultlabels =  [QApplication.translate("Textbox", "Fragance",None),
                                        QApplication.translate("Textbox", "Aroma",None),
                                        QApplication.translate("Textbox", "Flavor",None),
                                        QApplication.translate("Textbox", "Acidity",None),
                                        QApplication.translate("Textbox", "Body",None),
                                        QApplication.translate("Textbox", "Aftertaste",None)]

        self.SweetMariasflavordefaultlabels = [QApplication.translate("Textbox", "Dry Fragrance",None),
                                            QApplication.translate("Textbox", "Uniformity",None),
                                            QApplication.translate("Textbox", "Complexity",None),
                                            QApplication.translate("Textbox", "Clean Cup",None),
                                            QApplication.translate("Textbox", "Sweetness",None),
                                            QApplication.translate("Textbox", "Finish",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Flavor",None),
                                            QApplication.translate("Textbox", "Brightness",None),
                                            QApplication.translate("Textbox", "Wet Aroma",None)]

        self.Cflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance",None),
                                            QApplication.translate("Textbox", "Aroma",None),
                                            QApplication.translate("Textbox", "Taste",None),
                                            QApplication.translate("Textbox", "Nose",None),
                                            QApplication.translate("Textbox", "Aftertaste",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Acidity",None)]

        self.Eflavordefaultlabels = [QApplication.translate("Textbox", "Fragrance-Aroma",None),
                                            QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Flavor",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Aftertaste",None),
                                            QApplication.translate("Textbox", "Balance",None)]


        self.coffeegeekflavordefaultlabels = [QApplication.translate("Textbox", "Aroma",None),
                                            QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Mouthfeel",None),
                                            QApplication.translate("Textbox", "Flavour",None),
                                            QApplication.translate("Textbox", "Aftertaste",None),
                                            QApplication.translate("Textbox", "Balance",None)]

        self.Intelligentsiaflavordefaultlabels = [QApplication.translate("Textbox", "Sweetness",None),
                                            QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Finish",None)]

        self.IstitutoInternazionaleAssaggiatoriCaffe = [QApplication.translate("Textbox", "Roast Color",None),
                                            QApplication.translate("Textbox", "Crema Texture",None),
                                            QApplication.translate("Textbox", "Crema Volume",None),
                                            QApplication.translate("Textbox", "Fragrance",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Bitterness",None),
                                            QApplication.translate("Textbox", "Defects",None),
                                            QApplication.translate("Textbox", "Aroma Intensity",None),
                                            QApplication.translate("Textbox", "Aroma Persistence",None),
                                            QApplication.translate("Textbox", "Balance",None)]

        self.WorldCoffeeRoastingChampionship = [QApplication.translate("Textbox", "Aroma",None),
                                            QApplication.translate("Textbox", "Flavour",None),
                                            QApplication.translate("Textbox", "Flavour",None),
                                            QApplication.translate("Textbox", "Aftertaste",None),
                                            QApplication.translate("Textbox", "Acidity",None),
                                            QApplication.translate("Textbox", "Body",None),
                                            QApplication.translate("Textbox", "Balance",None),
                                            QApplication.translate("Textbox", "Balance",None),
                                            QApplication.translate("Textbox", "Overall",None),
                                            QApplication.translate("Textbox", "Overall",None)]

        self.ax1 = self.ax2 = None

        self.flavorlabels = list(self.artisanflavordefaultlabels)
        #Initial flavor parameters. 
        self.flavors = [5., 5., 5., 5., 5., 5., 5., 5., 5.]
        self.flavorstartangle = 90
        self.flavoraspect = 1.0  #aspect ratio
        # flavor chart graph plots and annotations
        self.flavorchart_plotf = None
        self.flavorchart_angles = None
        self.flavorchart_plot = None
        self.flavorchart_fill = None
        self.flavorchart_labels = None
        self.flavorchart_total = None

        #F = Fahrenheit; C = Celsius        
        self.mode = "F"
        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if QSettings().value('AppleTemperatureUnit') == 'Celsius':
                    self.mode = "C"
            except:
                pass
                
        self.mode_tempsliders = self.mode # the temperature mode of event slider to convert min/max limits
        
        self.errorlog = []

        # default delay between readings in miliseconds
        self.default_delay = 3000 # default 3s
        self.delay = self.default_delay
        self.min_delay = 500 # 1000
        
        # oversampling flag
        self.oversampling = False
        self.oversampling_min_delay = 1000 # in contrast to what the user dialog says (3000) we enable oversampling already with 1s
        
        # extra event sampling interval in miliseconds. If 0, then extra sampling commands are sent "in sync" with the standard sampling commands
        self.extra_event_sampling_delay = 0 # sync, 0.5s, 1.0s, 1.5s,.., 5s => 0, 500, 1000, 1500, ..

        #watermarks limits: dryphase1, dryphase2 (DRY), midphase (FCs), and finish phase Y limits
        self.phases_fahrenheit_defaults = [300,300,390,450]
        self.phases_celsius_defaults = [150,150,200,230]
        self.phases = list(self.phases_fahrenheit_defaults) # contains either the phases_filter or phases_espresso, depending on the mode
        #this flag makes the main push buttons DryEnd, and FCstart change the phases[1] and phases[2] respectively
        self.phasesbuttonflag = True #False no change; True make the DRY and FC buttons change the phases during roast automatically
        self.phasesfromBackgroundflag = False # False: no change; True: set phases from background profile on load
        self.watermarksflag = True

        #show phases LCDs during roasts
        self.phasesLCDflag = True
        self.phasesLCDmode = 1 # one of 0: time, 1: percentage, 2: temp mode
        self.phasesLCDmode_l = [1,1,1]
        self.phasesLCDmode_all = [False,False,False]


        #statistics flags selects to display: stat. time, stat. bar, (stat. flavors), stat. area, stat. deg/min, stat. ETBTarea
        # NOTE: stat. flavors not used anymore. The code has been removed.
        self.statisticsflags = [1,1,0,1,0,0]
        self.statisticsmode = 1 # one of 0: standard computed values, 1: roast properties
        
        # Area Under Curve (AUC)
        self.AUCbegin = 1 # counting begins after 0: CHARGE, 1: TP (default), 2: DE, 3: FCs
        self.AUCbase = 212 # base temperature above which the area is calculated (default 212F/110C)
        self.AUCbaseFlag = False # if True, base AUC is taken from BT at AUCbegin event
        self.AUCtarget = 640 # target AUC for prediction
        self.AUCbackground = -1 # AUC of background profile or -1 if none loaded
        self.AUCtargetFlag = False # if True, target is taken from the background else from self.AUCtarget
        self.AUCguideFlag = False # if True a prediction line is drawn at the time the target area is reached considering current RoR
        self.AUClcdFlag = False # if True a AUC LCD is displayed next to the phases LCDs to show current AUC or AUC difference to target
        self.AUCLCDmode = 0 # one of 0: abs value, 1: delta to target/background, 2: AUC since FCs
        self.AUCvalue = 0 # the running AUC value calculated during recording
        self.AUCsinceFCs = 0 # the running AUC since FCs calculated during recording
        self.AUCguideTime = 0 # the expected time in seconds the AUC target is reached (calculated by the AUC guide mechanism)
        self.AUCshowFlag = False

        #DEVICES
        self.device = 18                                    # default device selected to None (18). Calls appropiate function
        
        # Phidget variables
        
        self.phidget_dataRatesStrings = ["32ms","64ms","128ms","256ms","512ms","768ms","1s"] # too fast: "8ms","16ms","32ms","64ms","0.12s",
        self.phidget_dataRatesValues = [32,64,128,256,512,768,1024] # 8,16,32,64,128,
        
        # probe type values (along the Phidgets21 lib): k-type => 1, j-type => 2, e-type => 3, t-type => 4
        # Artisan will keep on using the Phidgets21 mapping
        self.phidget1048_types = [1,1,1,1] # defaults all to k-type probes (values are 0-based)
        self.phidget1048_async = [False]*4
        self.phidget1048_changeTriggers = [0.2]*4
        self.phidget1048_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1048_changeTriggersStrings = list(map(lambda x:'{0:.1f}C'.format(x),self.phidget1048_changeTriggersValues))
        # add 0.02C and 0.05C change triggers
        self.phidget1048_changeTriggersValues.insert(1,0.05)
        self.phidget1048_changeTriggersValues.insert(1,0.02)
        self.phidget1048_changeTriggersStrings.insert(1,"0.05C")
        self.phidget1048_changeTriggersStrings.insert(1,"0.02C")
        self.phidget1048_dataRate = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active on v21 API, 256ms on v22 API)

        self.phidget1045_async = False
        self.phidget1045_changeTrigger = 0.2
        self.phidget1045_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1045_changeTriggersStrings = list(map(lambda x:str(x) + "C",self.phidget1045_changeTriggersValues))
        # add 0.02C and 0.05C change triggers
        self.phidget1045_changeTriggersValues.insert(1,0.05)
        self.phidget1045_changeTriggersValues.insert(1,0.02)
        self.phidget1045_changeTriggersStrings.insert(1,"0.05C")
        self.phidget1045_changeTriggersStrings.insert(1,"0.02C")
        self.phidget1045_emissivity = 1.0
        self.phidget1045_dataRate = 256
        
        self.phidget1200_async = False
        self.phidget1200_formula = 0
        self.phidget1200_formulaValues = ["PT100  3850", "PT100  3920","PT1000 3850", "PT1000 3920"]
        self.phidget1200_wire = 0
        self.phidget1200_wireValues = ["2-wire", "3-wire","4-wire"]
        self.phidget1200_changeTrigger = 0.2
        self.phidget1200_changeTriggersValues = [x / 10.0 for x in range(0, 11, 1)]
        self.phidget1200_changeTriggersStrings = list(map(lambda x:str(x) + "C",self.phidget1200_changeTriggersValues))
        # add 0.02C and 0.05C change triggers
        self.phidget1200_changeTriggersValues.insert(1,0.05)
        self.phidget1200_changeTriggersValues.insert(1,0.02)
        self.phidget1200_changeTriggersStrings.insert(1,"0.05C")
        self.phidget1200_changeTriggersStrings.insert(1,"0.02C")
        self.phidget1200_dataRate = 250
        self.phidget1200_dataRatesStrings = ["250ms","500ms","750ms","1s"]
        self.phidget1200_dataRatesValues = [250,500,700,1024]

        self.phidget1046_async = [False]*4
        self.phidget1046_gain = [1]*4 # defaults to no gain (values are 0-based)
        self.phidget1046_gainValues = ["1", "8","16","32","64","128"] # 1 for no gain
        self.phidget1046_formula = [1]*4 # 0: 1K Ohm Wheatstone Bridge, 1: 1K Ohm Voltage Divider, 2: raw
        self.phidget1046_formulaValues = ["WS", "Div","raw"]
        self.phidget1046_dataRate = 256 # in ms; (Phidgets default 8ms, 16ms if wireless is active)
        
        self.phidgetRemoteFlag = False # if True the specified remote server is harvestd to potentially attache Phidget devices
        self.phidgetRemoteOnlyFlag = False # if True only Phidgets attached to remote servers are attached
        self.phidgetServerID = ""
        self.phidgetPassword = ""
        self.phidgetPort = 5661
        self.phidgetServerAdded = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetServiceDiscoveryStarted = False # this should be set on PhidgetNetwork.addServer and cleared on PhidgetNetwork.removeServer
        self.phidgetManager = None
        
        self.probatManager = None
                
        self.yoctoRemoteFlag = False
        self.yoctoServerID = "127.0.0.1"
        self.YOCTOchanUnit = "C" # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan1Unit = "C" # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTOchan2Unit = "C" # indicates the unit ("C" or "F") of the readings as received from the device
        self.YOCTO_emissivity = 1.0
        self.YOCTO_async = [False]*2
        self.YOCTO_dataRate = 256 # in ms
        self.YOCTO_dataRatesStrings = ["32ms","64ms","128ms","256ms","512ms","768ms","1s","1s*"]
        self.YOCTO_dataRatesValues = [32,64,128,256,512,768,1000,1024] # the 1024 mode returns every sec an average over the period, while 1000 returns every second the last sample
        
        self.phidget1018valueFactor = 1000 # we map the 0-5V voltage returned by the Phidgets22 API to mV (0-5000)
        self.phidget1018_async = [False]*8
        self.phidget1018_ratio = [False]*8 # if True VoltageRatio instead of VoltageInput is returned
        self.phidget1018_dataRates = [256]*8 # in ms; (Phidgets default 256ms, min is 8ms, 16ms if wireless is active), max 1000ms
                # with the new PhidgetsAPI the 1011/1018 dataRate is from 1ms to 1.000ms
        self.phidget1018_changeTriggers = [10]*8
        self.phidget1018_changeTriggersValues = range(0,51,1)
        self.phidget1018_changeTriggersStrings = list(map(lambda x:u(x*10)+u("mV"),self.phidget1018_changeTriggersValues))

        self.phidgetDAQ1400_powerSupplyStrings = ["--","12V","24V"]
        self.phidgetDAQ1400_powerSupply = 1
        self.phidgetDAQ1400_inputModeStrings = ["NPN","PNP"]
        self.phidgetDAQ1400_inputMode = 0

        #menu of thermocouple devices
        #device with first letter + only shows in extra device tab
        #device with first letter - does not show in any tab (but its position in the list is important)
        # device labels (used in Dialog config).

        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:" in the code
        # - add to self.devices
        self.devices = [#Fuji PID               #0
                       "Omega HH806AU",         #1
                       "Omega HH506RA",         #2
                       "CENTER 309",            #3
                       "CENTER 306",            #4
                       "CENTER 305",            #5
                       "CENTER 304",            #6
                       "CENTER 303",            #7
                       "CENTER 302",            #8
                       "CENTER 301",            #9
                       "CENTER 300",            #10
                       "VOLTCRAFT K204",        #11
                       "VOLTCRAFT K202",        #12
                       "VOLTCRAFT 300K",        #13
                       "VOLTCRAFT 302KJ",       #14
                       "EXTECH 421509",         #15
                       "Omega HH802U",          #16
                       "Omega HH309",           #17
                       "NONE",                  #18
                       "-ARDUINOTC4",           #19
                       "TE VA18B",              #20
                       "+CENTER 309 34",        #21
                       "+PID SV/DUTY %",        #22
                       "Omega HHM28[6]",        #23
                       "+VOLTCRAFT K204 34",    #24
                       "+Virtual",              #25
                       "-DTAtemperature",       #26
                       "Program",               #27
                       "+ArduinoTC4 34",        #28
                       "MODBUS",                #29
                       "VOLTCRAFT K201",        #30
                       "Amprobe TMD-56",        #31
                       "+ArduinoTC4 56",        #32
                       "+MODBUS 34",            #33
                       "Phidget 1048 4xTC 01",  #34
                       "+Phidget 1048 4xTC 23", #35
                       "+Phidget 1048 4xTC AT", #36
                       "Phidget 1046 4xRTD 01", #37
                       "+Phidget 1046 4xRTD 23",#38
                       "Mastech MS6514",        #39
                       "Phidget IO 01",         #40
                       "+Phidget IO 23",        #41
                       "+Phidget IO 45",        #42
                       "+Phidget IO 67",        #43
                       "+ArduinoTC4 78",        #44
                       "Yocto Thermocouple",    #45
                       "Yocto PT100",           #46
                       "Phidget 1045 IR",       #47
                       "+Program 34",           #48
                       "+Program 56",           #49
                       "DUMMY",                 #50
                       "+CENTER 304 34",        #51
                       "Phidget 1051 1xTC 01",  #52
                       "Hottop BT/ET",          #53
                       "+Hottop Heater/Fan",    #54
                       "+MODBUS 56",            #55
                       "Apollo DT301",          #56
                       "EXTECH 755",            #57
                       "Phidget TMP1101 4xTC 01",  #58
                       "+Phidget TMP1101 4xTC 23", #59
                       "+Phidget TMP1101 4xTC AT", #60
                       "Phidget TMP1100 1xTC",  #61
                       "Phidget 1011 IO 01",    #62
                       "Phidget HUB IO 01", #63
                       "+Phidget HUB IO 23",#64
                       "+Phidget HUB IO 45",#65
                       "-Omega HH806W",         #66 NOT WORKING 
                       "VOLTCRAFT PL-125-T2",   #67
                       "Phidget TMP1200 1xRTD", #68
                       "Phidget IO Digital 01",         #69
                       "+Phidget IO Digital 23",        #70
                       "+Phidget IO Digital 45",        #71
                       "+Phidget IO Digital 67",        #72
                       "Phidget 1011 IO Digital 01",    #73
                       "Phidget HUB IO Digital 01", #74
                       "+Phidget HUB IO Digital 23",#75
                       "+Phidget HUB IO Digital 45",#76
                       "VOLTCRAFT PL-125-T4",       #77
                       "+VOLTCRAFT PL-125-T4 34",   #78
                       "S7",                        #79
                       "+S7 34",                    #80
                       "+S7 56",                    #81
                       "+S7 78",                    #82
                       "Aillio Bullet R1 BT/DT",             #83
                       "+Aillio Bullet R1 Heater/Fan",       #84
                       "+Aillio Bullet R1 BT RoR/Drum",      #85
                       "+Aillio Bullet R1 Voltage/Exhaust",  #86
                       "+Aillio Bullet R1 State/Fan RPM",    #87
                       "+Program 78",               #88
                       "+Program 910",              #89
                       "+Slider 01",                #90
                       "+Slider 23",                #91
                       "Probat Middleware",                  #92
                       "+Probat Middleware burner/drum",     #93
                       "+Probat Middleware fan/pressure",    #94
                       "Phidget DAQ1400 Current",   #95
                       "Phidget DAQ1400 Frequency", #96
                       "Phidget DAQ1400 Digital",   #97
                       "Phidget DAQ1400 Voltage",   #98
                       "Aillio Bullet R1 IBTS/BT",  #99
                       "Yocto IR",                  #100
                       "Behmor BT/CT",              #101
                       "+Behmor 34",                #102
                       "VICTOR 86B",                #103
                       "+Behmor 56",                #104
                       "+Behmor 78",                #105
                       "Phidget HUB IO 0",          #106
                       "Phidget HUB IO Digital 0",  #107
                       "Yocto 4-20mA Rx",           #108
                       "+MODBUS 78",                #109
                       "+S7 910",                   #110
                       ]

        # ADD DEVICE:
        # ids of (main) devices (without a + in front of their name string) 
        # that do NOT communicate via any serial port thus do not need any serial port configuration
        self.nonSerialDevices = [
            27, # Program
            34, # Phidget 1048 4xTC 01
            37, # Phidget 1046 4xRTD 01
            40, # Phidget IO 01
            45, # Yocto Thermocouple
            46, # Yocto PT100
            47, # Phidget 1045 IR
            52, # Phidget 1051 1xTC 01
            58, # Phidget TMP1101 4xTC 01
            61, # Phidget TMP1100 1xTC
            62, # Phidget 1011 IO 01
            63, # Phidget HUB IO 01
            68, # Phidget TMP1200 1xRTD
            69, # Phidget IO Digital 01
            73, # Phidget 1011 IO Digital 01
            74, # Phidget HUB IO Digital 01
            79, # S7
            83, # Aillio Bullet R1 BT/DT
            92, # Probat Middleware
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            99, # Aillio Bullet R1 IBTS/BT
            100, # Yocto IR
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            108  # Yocto 4-20mA Rx
        ]
        
        # ADD DEVICE:
        # ids of (main) Phidget devices (without a + in front of their name string) 
        self.phidgetDevices = [
            34, # Phidget 1048
            37, # Phidget 1046
            40, # Phidget IO
            47, # Phidget 1045
            52, # Phidget 1051
            58, # Phidget TMP1101
            61, # Phidget TMP1100
            62, # Phidget 1011
            63, # Phidget HUB IO 01
            68, # Phidget TMP1200
            69, # Phidget IO Digital
            73, # Phidget 1011 IO Digital
            74, # Phidget HUB IO Digital 01
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107  # Phidget HUB IO Digital 0
        ]
                 
        # ADD DEVICE:
        # ids of devices temperature conversions should not be applied
        self.nonTempDevices = [
            22, # +PID SV/DUTY %
            25, # +Virtual
            40, # Phidget IO 01
            41, # +Phidget IO 23
            42, # +Phidget IO 45
            43, # +Phidget IO 67
            50, # DUMMY
            54, # +Hottop Heater/Fan
            57, # EXTECH 755
            62, # Phidget 1011 IO 01
            63, # Phidget HUB IO 01
            64, # +Phidget HUB IO 23
            65, # +Phidget HUB IO 45
            69, # Phidget IO Digital 01
            70, # +Phidget IO Digital 23
            71, # +Phidget IO Digital 45
            72, # +Phidget IO Digital 67
            73, # Phidget 1011 IO Digital 01
            74, # Phidget HUB IO Digital 0
            75, # +Phidget HUB IO Digital 23
            76, # +Phidget HUB IO Digital 45
            84, # +Aillio Bullet R1 Heater/Fan
            87, # +Aillio Bullet R1 State
            90, # +Slider 01
            91, # +Slider 23
            93, # +Probat Middleware burner/drum"
            94, # +Probat Middleware fan/pressure"
            95, # Phidget DAQ1400 Current
            96, # Phidget DAQ1400 Frequency
            97, # Phidget DAQ1400 Digital
            98, # Phidget DAQ1400 Voltage
            106, # Phidget HUB IO 0
            107, # Phidget HUB IO Digital 0
            108  # Yocto 4-20mA Rx
        ]

        #extra devices
        self.extradevices = []                                      # list with indexes for extra devices
        self.extratimex = []                                        # individual time for each extra device (more accurate). List of lists (2 dimension)
        self.extradevicecolor1 = []                                 # extra line 1 color. list with colors.
        self.extradevicecolor2 = []                                 # extra line 2 color. list with colors.
        self.extratemp1,self.extratemp2 = [],[]                     # extra temp1, temp2. List of lists
        self.extrastemp1,self.extrastemp2 = [],[]                   # smoothed extra temp1, temp2. List of lists
        self.extractimex1,self.extractimex2,self.extractemp1,self.extractemp2 = [],[],[],[] # variants of extratimex/extratemp1/extratemp2 with -1 dropout values removed
        self.extratemp1lines,self.extratemp2lines = [],[]           # lists with extra lines for speed drawing
        self.extraname1,self.extraname2 = [],[]                     # name of labels for line (like ET or BT) - legend
        self.extramathexpression1,self.extramathexpression2 = [],[]           # list with user defined math evaluating strings. Example "2*cos(x)"
        self.extralinestyles1,self.extralinestyles2 = [],[]         # list of extra curve line styles
        self.extradrawstyles1,self.extradrawstyles2 = [],[]         # list of extra curve drawing styles
        self.extralinewidths1,self.extralinewidths2 = [],[]         # list of extra curve linewidth
        self.extramarkers1,self.extramarkers2 = [],[]               # list of extra curve marker styles
        self.extramarkersizes1,self.extramarkersizes2 = [],[]       # list of extra curve marker size
        
        self.devicetablecolumnwidths = []
        
        # the following two list are generated on ON from the extradevices types and might be longer or smaller than len(self.extradevices)
        # if no entry is available, a temperature curve that needs C<->F translation is assumed
        # note that ET/BT main curves are assumed to always hold temperatures
        self.extraNoneTempHint1 = []                                # list of flags indicating which extra 1 curves are not holding temperature values
        self.extraNoneTempHint2 = []                                # list of flags indicating which extra 1 curves are not holding temperature values

        #holds math expressions to plot
        self.plotcurves=[""]*9
        self.plotcurvecolor = ["black"]*9

        self.tight_layout_params = {"pad":.3,"h_pad":0.0,"w_pad":0.0} # slightly less space for axis labels
#        self.tight_layout_params = True
        self.fig = Figure(tight_layout=self.tight_layout_params,frameon=True,dpi=dpi)
        # with tight_layout=True, the matplotlib canvas expands to the maximum using figure.autolayout

        self.fig.patch.set_facecolor(str(self.palette["canvas"]))

        self.ax = self.fig.add_subplot(111,facecolor=self.palette["background"])
        self.delta_ax = self.ax.twinx()

        #legend location
        self.legendloc = 7
        self.legendloc_pos = None # holds the custom position of the legend set on profile load and reset after first redraw
        
        self.fig.subplots_adjust(
            # all values in percent
            top=0.93, # the top of the subplots of the figure (default: 0.9)
            bottom=0.1, # the bottom of the subplots of the figure (default: 0.1)
            left=0.067, # the left side of the subplots of the figure (default: 0.125)
            right=.925) # the right side of the subplots of the figure (default: 0.9
        FigureCanvas.__init__(self, self.fig)
                    
        # important to make the Qt canvas transparent (note that this changes stylesheets of childs like popups too!):
        self.fig.canvas.setStyleSheet("background-color:transparent;") # default is white

        self.onclick_cid = self.fig.canvas.mpl_connect('button_press_event', self.onclick)
        self.oncpick_cid = self.fig.canvas.mpl_connect('pick_event', self.onpick)
        self.ondraw_cid = self.fig.canvas.mpl_connect('draw_event', self._draw_event)
        
        self.fig.canvas.mpl_connect('button_release_event', self.onrelease_after_pick)

        # set the parent widget
        self.setParent(parent)
        # we define the widget as
        FigureCanvas.setSizePolicy(self,QSizePolicy.Expanding,QSizePolicy.Expanding)  #@UndefinedVariable
        # notify the system of updated policy
        FigureCanvas.updateGeometry(self)  #@UndefinedVariable

        # the rate of chage of temperature
        self.rateofchange1 = 0.0
        self.rateofchange2 = 0.0

        #read and plot on/off flag
        self.flagon = False  # Artisan turned on
        self.flagstart = False # Artisan logging
        self.flagKeepON = False # turn Artisan ON again after pressing OFF during recording
        self.flagsampling = False # if True, Artisan is still in the sampling phase and one has to wait for its end to turn OFF
        self.flagsamplingthreadrunning = False
        #log flag that tells to log ET when using device 18 (manual mode)
        self.manuallogETflag = 0
        
        self.zoom_follow = False # if True, Artisan "follows" BT in the center by panning during recording. Activated via a click on the ZOOM icon while ZOOM is active
        
        #self.flagalignFCs = False
        self.alignEvent = 0 # 0:CHARGE, 1:DRY, 2:FCs, 3:FCe, 4:SCs, 5:SCe, 6:DROP, 7:ALL
        
        self.replayType = 0 # 0: by time, 1: by BT, 2: by ET
        self.replayedBackgroundEvents = [] # set of BackgroundEvent indicies that have already been replayed (cleared in ClearMeasurements)
        self.beepedBackgroundEvents = [] # set of BackgroundEvent indicies that have already been beeped for (cleared in ClearMeasurements)

        self.roastpropertiesflag = 1  #resets roast properties if not zero
        self.roastpropertiesAutoOpenFlag = 0  #open roast properties dialog if not zero
        self.title = QApplication.translate("Scope Title", "Roaster Scope",None)
        self.title_show_always = False
        self.ambientTemp = 0.
        self.ambientTempSource = 0 # indicates the temperature curve that is used to automatically fill the ambient temperature on DROP
#                                  # 0 : None; 1 : ET, 2 : BT, 3 : 0xT1, 4 : 0xT2,
        self.ambient_temperature_device = 0
        self.ambient_pressure = 0.
        self.ambient_pressure_device = 0
        self.ambient_humidity = 0.
        self.ambient_humidity_device = 0
        self.elevation = 0
        
        self.temperaturedevicefunctionlist = [
            "",                #0
            "Phidget HUM1000", #1
            "Yocto Meteo",     #2
        ]
        self.humiditydevicefunctionlist = [
            "",                #0
            "Phidget HUM1000", #1
            "Yocto Meteo",     #2
        ]
        self.pressuredevicefunctionlist = [
            "",                #0
            "Phidget PRE1000", #1
            "Yocto Meteo",     #2
        ]
        
        self.moisture_greens = 0.
        self.moisture_roasted = 0.
        self.greens_temp = 0.
        
        self.beansize = 0.0
        self.beansize_min = 0
        self.beansize_max = 0

        self.whole_color = 0
        self.ground_color = 0
        self.color_systems = ["","Tonino","ColorTest","Colorette","ColorTrack","Agtron"]
        self.color_system_idx = 0

        # roast property flags
        self.heavyFC_flag = False
        self.lowFC_flag = False
        self.lightCut_flag = False
        self.darkCut_flag = False
        self.drops_flag = False
        self.oily_flag = False
        self.uneven_flag = False
        self.tipping_flag = False
        self.scorching_flag = False
        self.divots_flag = False

        #list to store the time in seconds of each reading. Most IMPORTANT variable.
        self.timex = []

        self.smooth_curves_on_recording = False # by default we do not smooth curves during recording
        
        #lists to store temps and rates of change. Second most IMPORTANT variables. All need same dimension.
        #self.temp1 = ET ; self.temp2 = BT; self.delta1 = deltaMET; self.delta2 = deltaBT
        self.temp1,self.temp2,self.delta1, self.delta2 = [],[],[],[]
        self.stemp1,self.stemp2 = [],[] # smoothed versions of temp1/temp2 used in redraw()
        self.tstemp1,self.tstemp2 = [],[] # (temporarily) smoothed version of temp1/temp2 used in sample() to compute the RoR
        self.ctimex1, self.ctimex2, self.ctemp1,self.ctemp2 = [], [],[],[] # (potential shorter) variants of timex/temp1/temp2 with -1 dropout values removed
        self.unfiltereddelta1, self.unfiltereddelta2 = [],[] # used in sample()   

        #indexes for CHARGE[0],DRYe[1],FCs[2],FCe[3],SCs[4],SCe[5],DROP[6] and COOLe[7]
        #Example: Use as self.timex[self.timeindex[1]] to get the time of DryEnd
        #Example: Use self.temp2[self.timeindex[4]] to get the BT temperature of SCs

        self.timeindex = [-1,0,0,0,0,0,0,0] #CHARGE index init set to -1 as 0 could be an actal index used

        #applies a Y(x) function to ET or BT 
        self.ETfunction,self.BTfunction = "",""
        
        #applies a Y(x) function to DeltaET or DeltaBT
        self.DeltaETfunction,self.DeltaBTfunction = "",""

        #put a "aw.qmc.safesaveflag = True" whenever there is a change of a profile like at [DROP], edit properties Dialog, etc
        #prevents accidentally deleting a modified profile. ("dirty file")
        #ATTENTION: never change this flag directly. Use the methods aw.qmc.fileDirty() and aw.qmc.fileClean() instead!!
        self.safesaveflag = False
        
        self.pid = pid.PID()

        #background profile
        self.background = False
        self.backgroundprofile = None
        self.backgroundDetails = True
        self.backgroundeventsflag = True
        self.backgroundpath = ""
        self.backgroundUUID = None
        self.backgroundmovespeed = 30
        self.titleB = ""
        self.roastbatchnrB = 0
        self.roastbatchprefixB = ""
        self.roastbatchposB = 1
        self.temp1B,self.temp2B,self.temp1BX,self.temp2BX,self.timeB = [],[],[],[],[]
        self.stemp1B,self.stemp2B,self.stemp1BX,self.stemp2BX = [],[],[],[] # smoothed versions of the background curves
        self.extraname1B,self.extraname2B = [],[]
        self.extratimexB = []
        self.xtcurveidx = 0 # the selected extra background courve to be displayed
        self.delta1B,self.delta2B = [],[]
        self.timeindexB = [-1,0,0,0,0,0,0,0]
        self.TP_time_B = -1 # the time in seconds the backgrounds TP should be placed (originally retrieved from file, see TP_time_B_loaded)
        self.TP_time_B_loaded = -1 # the time in seconds the background TP happend. While TP_time_B changes if background is moved, TP_time_b_loaded does not change and should be used for display
        self.backgroundEvents = [] #indexes of background events
        self.backgroundEtypes = []
        self.backgroundEvalues = []
        self.backgroundEStrings = []
        self.backgroundalpha = 0.2
        self.backgroundmetcolor = self.palette["et"]
        self.backgroundbtcolor = self.palette["bt"]
        self.backgroundxtcolor = self.palette["xt"]
        self.backgrounddeltaetcolor = self.palette["deltaet"]
        self.backgrounddeltabtcolor = self.palette["deltabt"]
        self.backmoveflag = 1 # aligns background on redraw if 1
        self.detectBackgroundEventTime = 20 #seconds
        self.backgroundReproduce = False
        self.backgroundReproduceBeep = False
        self.backgroundPlaybackEvents = False
        self.backgroundPlaybackDROP = False
        self.Betypes = [QApplication.translate("ComboBox", "Air",None),
                        QApplication.translate("ComboBox", "Drum",None),
                        QApplication.translate("ComboBox", "Damper",None),
                        QApplication.translate("ComboBox", "Burner",None),
                        "--"]
        self.backgroundFlavors = []
        self.flavorbackgroundflag = False
        #background by value
        self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
        self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
        self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color="grey")
        self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color="darkgrey")
        self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color="slategrey")
        self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color="slateblue")

        # background Deltas
        self.DeltaETBflag = False
        self.DeltaBTBflag = True  
    
        # projection variables of change of rate
        self.HUDflag = False
        self.hudresizeflag = False
        self.ETtarget = 300
        self.ET2target = 350
        self.BTtarget = 200
        self.BT2target = 250
        self.hudETpid = [5,240,60]    # HUD pid: p = 20, i = 60, d = 13
        self.pidpreviouserror = 0  # temporary storage of pid error

        #General notes. Accessible through "edit graph properties" of graph menu. WYSIWYG viewer/editor.
        self.roastertype = ""
        self.machinesetup = ""
        self.operator = ""
        self.drumspeed = ""
        self.roastingnotes = ""
        self.cuppingnotes = ""
        self.roastdate = QDateTime.currentDateTime()
        # system batch nr system
        self.roastepoch = self.roastdate.toTime_t() # in seconds
        self.lastroastepoch = self.roastepoch # the epoch of the last roast in seconds
        self.batchcounter = -1 # global batch counter; if batchcounter is -1, batchcounter system is inactive
        self.batchsequence = 1 # global counter of position in sequence of batches of one session
        self.batchprefix = ""
        self.neverUpdateBatchCounter = False
        # profile batch nr
        self.roastbatchnr = 0 # batch number of the roast; if roastbatchnr=0, prefix/counter is hidden/inactiv (initialized to 0 on roast START)
        self.roastbatchprefix = self.batchprefix # batch prefix of the roast
        self.roastbatchpos = 1 # position of the roast in the roast session (first batch, second batch,..)
        self.roasttzoffset = libtime.timezone # timezone offset to be added to roastepoch to get time in local timezone; NOTE: this is not set/updated on loading a .alog profile!
        # profile UUID
        self.roastUUID = None
        
#PLUS
        # the default store selected by the user (save in the  app settings)
        self.plus_default_store = None
        # the current profiles coffee or blend and associated store ids (saved in the *.alog profile)
        self.plus_store = None # holds the plus hr_id of the selected store of the current profile or None
        self.plus_store_label = None # holds the plus label of the selected store of the current profile or None
        self.plus_coffee = None # holds the plus hr_id of the selected coffee of the current profile or None
        self.plus_coffee_label = None # holds the plus label of the selected coffee of the current profile or None
        self.plus_blend_spec = None # the plus blend structure [<blend_label>,[[<coffee_label>,<hr_id>,<ratio>],...,[<coffee_label>,<hr_id>,<ratio>]]] # label + ingredients
        self.plus_blend_spec_labels = None # a list of labels as long as the list of ingredients in self.plus_blend_spec or None
        self.plus_blend_label = None # holds the plus selected label of the selected blend of the current profile or None
        self.plus_sync_record_hash = None

        self.beans = ""

        #flags to show projections, draw Delta ET, and draw Delta BT
        self.projectFlag = True
        self.ETcurve = True
        self.BTcurve = True
        self.ETlcd = True
        self.BTlcd = True
        self.swaplcds = False # draw ET curver on top of BT curve and show ET LCD above BT LCD by default
        self.LCDdecimalplaces = 1
        self.DeltaETflag = False
        self.DeltaBTflag = True
        self.DeltaETlcdflag = False
        self.DeltaBTlcdflag = True
        self.swapdeltalcds = False
        self.HUDbuttonflag = False
        self.PIDbuttonflag = True # TC4 PID firmware available?
        self.Controlbuttonflag = False # PID Control active (either internal/external or Fuji)
        # user filter values x are translated as follows to internal filter values: y = x*2 + 1 (to go the other direction: x = y/2)
        # this is to ensure, that only uneven window values are used and no wrong shift is happening through smoothing
        self.deltaETfilter = 17 # => corresponds to 2 on the user interface
        self.deltaBTfilter = 17 # => corresponds to 2 on the user interface
        self.curvefilter = 3 # => corresponds to 1 on the user interface
        self.deltaETspan = 6 # the time period taken to compute one deltaET value (1-30sec)
        self.deltaBTspan = 6 # the time period taken to compute one deltaBT value (1-30sec)
        self.deltaETsamples = 2 # the number of samples that make up the delta span, to be used in the delta computations (> 0!)
        self.deltaBTsamples = 2 # the number of samples that make up the delta span, to be used in the delta computations (> 0!)
        self.profile_sampling_interval = None # will be updated on loading a profile
        self.background_profile_sampling_interval = None # will be updated on loading a profile into the background
        
#        self.altsmoothing = False # toggle between standard and alternative smoothing approach
#        self.smoothingwindowsize = 3 # window size of the alternative smoothing approach

        self.optimalSmoothing = False

        self.patheffects = 1
        self.graphstyle = 0
        self.graphfont = 0

        #variables to configure the 8 default buttons
        # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END; 
        self.buttonvisibility = [True,True,True,True,True,False,True,True]
        self.buttonactions = [0]*8
        self.buttonactionstrings = [""]*8
        #variables to configure the 0: ON, 1: OFF, 2: SAMPLE, 3:RESET, 4:START
        self.extrabuttonactions = [0]*3
        self.extrabuttonactionstrings = [""]*3
        #variables to configure the 0:RESET, 1:START
        self.xextrabuttonactions = [0]*2
        self.xextrabuttonactionstrings = [""]*2

        #flag to activate the automatic marking of the CHARGE and DROP events
        self.autoChargeFlag = True
        self.autoDropFlag = True
        #autodetected CHARGE and DROP index
        self.autoChargeIdx = 0
        self.autoDropIdx = 0

        self.markTPflag = True
        self.autoTPIdx = 0 # set by sample() on recognition and cleared once TP is marked

        # flags to control automatic DRY and FCs events based on phases limits
        self.autoDRYflag = False
        self.autoFCsFlag = False
        
        self.autoCHARGEenabled = True # get's disabled on undo of the CHARGE event and prevents further autoCHARGE marks
        self.autoDRYenabled = True # get's disabled on undo of the DRY event and prevents further autoDRY marks
        self.autoFCsenabled = True # get's disabled on undo of the FCs event and prevents further autoFCs marks
        self.autoDROPsenabled = True # get's disabled on undo of the DROP event and prevents further autoDROP marks
        
        self.autoDryIdx = 0 # set by sample() on recognition and cleared once DRY is marked
        self.autoFCsIdx = 0 # set by sample() on recognition and cleared once FCs is marked
        

        # projection variables of change of rate
        self.projectionconstant = 1
        self.projectionmode = 0     # 0 = linear; 1 = newton
        
        # profile transformator mapping mode
        self.transMappingMode = 0 # 0: discrete, 1: linear, 2: quadratic

        self.weight_units = ["g","Kg","lb","oz"]
        #[0]weight in, [1]weight out, [2]units (string)
        self.weight = [0,0,self.weight_units[0]]

        self.volume_units = ["l","gal","qt","pt","cup","ml"]
        #[0]volume in, [1]volume out, [2]units (string)
        self.volume = [0,0,self.volume_units[0]]
        
        #[0]probe weight, [1]weight unit, [2]probe volume, [3]volume unit
#        self.density = [0.,self.weight_units[0],1.,self.volume_units[0]]
        self.density = [0,"g",1.,"l"]
        # density weight and volume units are not to be used any longer and assumed to be fixed to g/l
        # thus also probe volume is not used anymore, and only self.density[0] holds the green been density in g/l
        
        self.density_roasted = [0,"g",1.,"l"] # this holds the roasted beans density in g/l
        
        
        if platform.system() == 'Darwin':
            # try to "guess" the users preferred temperature unit
            try:
                if not QSettings().value('AppleMetricUnits'):
                    self.weight = [0,0,self.weight_units[2]]
                    self.volume = [0,0,self.volume_units[1]]
            except:
                pass
        
        self.volumeCalcUnit = 0
        self.volumeCalcWeightInStr = ""
        self.volumeCalcWeightOutStr = ""
        
        # container scale tare
        self.container_names = []
        self.container_weights = [] # all weights in g and as int
        self.container_idx = -1 # the empty field (as -1 + 2 = 1)

        #stores _indexes_ of self.timex to record events. 
        # Use as self.timex[self.specialevents[x]] to get the time of an event
        # use self.temp2[self.specialevents[x]] to get the BT temperature of an event.
        self.specialevents = []
        #ComboBox text event types. They can be modified in eventsDlg()
        self.etypes = [QApplication.translate("ComboBox", "Air",None),
                       QApplication.translate("ComboBox", "Drum",None),
                       QApplication.translate("ComboBox", "Damper",None),
                       QApplication.translate("ComboBox", "Burner",None),
                       "--"]
        #default etype settings to restore
        self.etypesdefault = [QApplication.translate("ComboBox", "Air",None),
                              QApplication.translate("ComboBox", "Drum",None),
                              QApplication.translate("ComboBox", "Damper",None),
                              QApplication.translate("ComboBox", "Burner",None),
                              "--"]
        #stores the type of each event as index of self.etypes. None = 0, Power = 1, etc.
        self.specialeventstype = []
        #stores text string descriptions for each event.
        self.specialeventsStrings = []
        #event values are from 0-10
        #stores the value for each event
        self.specialeventsvalue = []
        #flag that makes the events location type bars (horizontal bars) appear on the plot. flag read on redraw()
        # 0 = no event bars; 1 = type bars (4 bars); 2 = value bars; 3 = split (combination of 0 and 2); 4 = merge (as 2, values rendered on lines)
        self.eventsGraphflag = 2
        self.clampEvents = False # if True, custom events are drawn w.r.t. the temperature scale
        self.renderEventsDescr = False # if True, descriptions are rendered instead of type/value tags
        self.eventslabelschars = 6 # maximal number of chars to render as events label
        #flag that shows events in the graph
        self.eventsshowflag = 1
        #flag that shows major event annotations in the graph
        self.annotationsflag = 1
        #shows events anchored to the BT curve if true, events anchored to greater of ET or BT curve if false
        self.showeventsonbt = False
        #selectively show/hide event types 
        self.showEtypes = [True]*5
        #plot events by value
        self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
        self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
        self.EvalueColor = self.EvalueColor_default.copy()
        self.EvalueTextColor = self.EvalueTextColor_default.copy()
        self.EvalueMarker = ["o","s","h","D"]
        self.EvalueMarkerSize = [4,4,4,4]
        self.Evaluelinethickness = [1,1,1,1]
        self.Evaluealpha = [.8,.8,.8,.8]
        #the event value position bars are calculated at redraw()
        self.eventpositionbars = [0.]*120
        self.specialeventannotations = ["","","",""]
        self.specialeventannovisibilities = [0,0,0,0]
        
        #curve styles
        self.linestyle_default = "-"
        self.drawstyle_default = "default"
        self.linewidth_default = 1.5
        self.back_linewidth_default = 2
        self.delta_linewidth_default = 1
        self.back_delta_linewidth_default = 1.5
        self.extra_linewidth_default = 1
        self.marker_default = None
        self.markersize_default = 6

        self.BTlinestyle = self.linestyle_default
        self.BTdrawstyle = self.drawstyle_default
        self.BTlinewidth = self.linewidth_default
        self.BTmarker = self.marker_default
        self.BTmarkersize = self.markersize_default
        self.ETlinestyle = self.linestyle_default
        self.ETdrawstyle = self.drawstyle_default
        self.ETlinewidth = self.linewidth_default
        self.ETmarker = self.marker_default
        self.ETmarkersize = self.markersize_default
        self.BTdeltalinestyle = self.linestyle_default
        self.BTdeltadrawstyle = self.drawstyle_default
        self.BTdeltalinewidth = self.delta_linewidth_default
        self.BTdeltamarker = self.marker_default
        self.BTdeltamarkersize = self.markersize_default
        self.ETdeltalinestyle = self.linestyle_default
        self.ETdeltadrawstyle = self.drawstyle_default
        self.ETdeltalinewidth = self.delta_linewidth_default
        self.ETdeltamarker = self.marker_default
        self.ETdeltamarkersize = self.markersize_default
        self.BTbacklinestyle = self.linestyle_default
        self.BTbackdrawstyle = self.drawstyle_default
        self.BTbacklinewidth = self.back_linewidth_default
        self.BTbackmarker = self.marker_default
        self.BTbackmarkersize = self.markersize_default
        self.ETbacklinestyle = self.linestyle_default
        self.ETbackdrawstyle = self.drawstyle_default
        self.ETbacklinewidth = self.back_linewidth_default
        self.ETbackmarker = self.marker_default
        self.ETbackmarkersize = self.markersize_default
        self.XTbacklinestyle = self.linestyle_default
        self.XTbackdrawstyle = self.drawstyle_default
        self.XTbacklinewidth = self.extra_linewidth_default
        self.XTbackmarker = self.marker_default
        self.XTbackmarkersize = self.markersize_default                
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.back_delta_linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.back_delta_linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default
        self.BTBdeltalinestyle = self.linestyle_default
        self.BTBdeltadrawstyle = self.drawstyle_default
        self.BTBdeltalinewidth = self.linewidth_default
        self.BTBdeltamarker = self.marker_default
        self.BTBdeltamarkersize = self.markersize_default
        self.ETBdeltalinestyle = self.linestyle_default
        self.ETBdeltadrawstyle = self.drawstyle_default
        self.ETBdeltalinewidth = self.linewidth_default
        self.ETBdeltamarker = self.marker_default
        self.ETBdeltamarkersize = self.markersize_default

        #Temperature Alarms lists. Data is written in  alarmDlg 
        self.alarmflag = []    # 0 = OFF; 1 = ON flags
        self.alarmguard = []   # points to another alarm by index that has to be triggered before; -1 indicates no guard
        self.alarmnegguard = []   # points to another alarm by index that should not has been triggered before; -1 indicates no guard
        self.alarmtime = []    # time event after which each alarm becomes efective. Usage: self.timeindex[self.alarmtime[i]]
#                              # -1 equals None
        self.alarmoffset = []  # for timed alarms, the seconds after alarmtime the alarm is triggered
        self.alarmtime2menuidx = [2,4,5,6,7,8,9,10,3,0,11,1] # maps self.alarmtime index to menu idx (to move TP in menu from index 9 to 3)
        self.menuidx2alarmtime = [9,-1,0,8,1,2,3,4,5,6,7,10] # inverse of above (note that those two are only inverse in one direction!)
        self.alarmcond = []    # 0 = falls below; 1 = rises above
        # alarmstate is set to 'not triggered' on reset(). This is needed so that the user does not have to turn the alarms ON next roast after alarm being used once.
        self.alarmstate = []   # <idx>=triggered, -1=not triggered. 
        self.alarmsource = []   # -3=None, -2=DeltaET, -1=DeltaBT, 0=ET , 1=BT, 2=extratemp1[0], 3=extratemp2[0], 4=extratemp2[1],....
        self.alarmtemperature = []  # set temperature number (example 500; can be negative)
        self.alarmaction = []       # -1 = no action; 0 = open a window;
                                    # 1 = call program with a filepath equal to alarmstring; 
                                    # 2 = activate button with number given in description; 
                                    # 3,4,5,6 = move slider with value given in description
                                    # 7 (START), 8 (DRY), 9 (FCs), 10 (FCe), 11 (SCs), 12 (SCe), 13 (DROP), 14 (COOL), 15 (OFF)
                                    # 16 (CHARGE),
                                    # 17 (RampSoak_ON), 18 (RampSoak_OFF), 19 (PID_ON), 20 (PID_OFF)
        self.alarmbeep = []    # 0 = OFF; 1 = ON flags
        self.alarmstrings = []      # text descriptions, action to take, or filepath to call another program (comments after # are ignored)
        self.alarmtablecolumnwidths = []
        self.silent_alarms = False # if this is true (can be set via a Artisan Command button action "alarm(1)", alarms are triggered, but actions are not fired

        self.loadalarmsfromprofile = False # if set, alarms are loaded from profile
        self.loadalarmsfrombackground = False # if set, alarms are loaded from background profiles
        self.alarmsfile = "" # filename alarms were loaded from
        self.temporaryalarmflag = -3 #holds temporary index value of triggered alarm in updategraphics()
        self.TPalarmtimeindex = None # is set to the current  aw.qmc.timeindex by sample(), if alarms are defined and once the TP is detected
        
        self.tempory_sample_trigger_redraw = False

        self.temporarysetsv = None #set by sample() to a new SV to be send to the PID by updategraphics() within the GUI thread as this moves the SV slider        
        self.temporary_error = None # set by adderror() to a new error message, send to the message line by updategraphics()
        self.temporarymovepositiveslider = None # set by pidcontrol.setEnergy (indirectly called from sample())
                # holds tuple (slidernr,value) and is executued and reset by updategraphics
        self.temporarymovenegativeslider = None
        self.temporayslider_force_move = True # if True move the slider independent of the slider position to fire slider action!
        
        self.quantifiedEvent = [] # holds an event quantified during sample(), a tuple [<eventnr>,<value>,<recordEvent>]

        self.loadaxisfromprofile = False # if set, axis are loaded from profile
        
        # set initial limits for X and Y axes. But they change after reading the previous seetings at aw.settingsload()
        self.startofx_default = -30
        self.endofx_default = 600 # 10min*60
        
        self.ylimit_F_default = 500
        self.ylimit_min_F_default = 100
        self.ygrid_F_default = 100
        self.zlimit_F_default = 45
        self.zlimit_min_F_default = 0
        self.zgrid_F_default = 10
        
        self.ylimit_C_default = 250
        self.ylimit_min_C_default = 0
        self.ygrid_C_default = 50
        self.zlimit_C_default = 25
        self.zlimit_min_C_default = 0
        self.zgrid_C_default = 5
        
        self.temp_grid = False
        self.time_grid = False
        
        # maximum accepted min/max settings for y and z axis
        self.zlimit_max = 500
        self.zlimit_min_max = -500
        self.ylimit_max = 9999
        self.ylimit_min_max = -9999
        
        #----
        # set limits to F defaults
        
        self.ylimit = self.ylimit_F_default
        self.ylimit_min = self.ylimit_min_F_default
        self.zlimit = self.zlimit_F_default
        self.zlimit_min = self.zlimit_min_F_default
       
        
        # RoR display limits
        # user configurable RoR limits (only applied if flag is True; applied before TP during recording as well as full redraw)
        self.RoRlimitFlag = True
        self.RoRlimit = 95
        self.RoRlimitm = -95
        # system fixed RoR limits (only applied if flag is True; usually higher than the user configurable once and always applied)
        self.maxRoRlimit = 170
        # axis limits
        self.endofx = self.endofx_default
        self.startofx = self.startofx_default
        self.resetmaxtime = 600  #time when pressing RESET: 10min*60
        self.chargemintime = self.startofx_default  #time when pressing CHARGE: -30sec
        self.fixmaxtime = False # if true, do not automatically extend the endofx by 3min if needed because the measurements get out of the x-axis
        self.locktimex = False # if true, do not set time axis min and max from profile on load
        self.autotimex = True # automatically set time axis min and max from profile CHARGE/DROP on load
        self.locktimex_start = self.startofx_default # seconds of x-axis min as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.locktimex_end = self.endofx_default # seconds of x-axis max as locked by locktimex (needs to be interpreted wrt. CHARGE index)
        self.xgrid = 120   #initial time separation; 60 = 1 minute
        self.ygrid = self.ygrid_F_default  #initial temperature separation
        self.zgrid = self.zgrid_F_default   #initial RoR separation
        self.gridstyles =    ["-","--","-.",":"," "]  #solid,dashed,dash-dot,dotted,None
        self.gridlinestyle = 0
        self.gridthickness = 1
        self.gridalpha = .2
        self.xrotation = 0

        #height of statistics bar
        self.statisticsheight = 650
        self.statisticsupper = 655
        self.statisticslower = 617

        # autosave
        self.autosaveflag = 0
        self.autosaveprefix = ""
        self.autosavepath = ""
        self.autosavealsopath = ""
        
        self.autosaveimage = False # if true save an image along alog files
        self.autosaveimageformat = "PDF" # one of the supported image file formats PDF, SVG, PNG, JPEG, BMP, CSV, JSON
        
        #used to place correct height of text to avoid placing text over text (annotations)
        self.ystep_down = 0
        self.ystep_up = 0

        self.ax.set_xlim(self.startofx, self.endofx)
        self.ax.set_ylim(self.ylimit_min,self.ylimit)
        
        if self.delta_ax:
            self.delta_ax.set_xlim(self.startofx, self.endofx)
            self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
            self.delta_ax.set_autoscale_on(False)

        # disable figure autoscale
        self.ax.set_autoscale_on(False)

        #set grid + axle labels + title
        grid_axis = None
        if self.temp_grid and self.time_grid:
            grid_axis = 'both'
        elif self.temp_grid:
            grid_axis = 'y'
        elif self.time_grid:
            grid_axis = 'x'
        if grid_axis is not None:
            self.ax.grid(True,axis=grid_axis,color=self.palette["grid"],linestyle = self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha)

        #change label colors
        for label in self.ax.yaxis.get_ticklabels():
            label.set_color(self.palette["ylabel"])

        for label in self.ax.xaxis.get_ticklabels():
            label.set_color(self.palette["xlabel"])
            
        self.backgroundETcurve = True
        self.backgroundBTcurve = True

        # generates first "empty" plot (lists are empty) of temperature and deltaT
        self.l_temp1 = None
        self.l_temp2 = None
        self.l_delta1 = None
        self.l_delta2 = None
        self.l_back1 = None
        self.l_back2 = None
        self.l_back3 = None # one extra background curve
        self.l_delta1B = None
        self.l_delta2B = None

        self.l_BTprojection = None
        self.l_ETprojection = None
        
        self.l_AUCguide = None

        self.l_horizontalcrossline = None
        self.l_verticalcrossline = None

        self.l_timeline = None
        
        self.legend = None

        self.l_eventtype1dots = None
        self.l_eventtype2dots = None
        self.l_eventtype3dots = None
        self.l_eventtype4dots = None
        
        self.l_annotations = []
        self.l_background_annotations = []

        # NOTE: the l_annotations_pos_dict is set on profile load and its positions are prefered over those in l_annotations_dict, but deleted at the end of the first redraw()
        self.l_annotations_dict = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time annotations
        self.l_annotations_pos_dict = {} # associating event ids (-1:TP, 0:CHARGE, 1:DRY,...) to its pair of draggable temp and time xyann coordinate pairs
        self.l_event_flags_dict = {} # assocating event flag annotations id (event number) to its draggable text annotation
        self.l_event_flags_pos_dict = {} # assocating event flag annotations id (event number) to its draggable text xyann coordinates
        
        self.ai = None # holds background logo image

        ###########################  TIME  CLOCK     ##########################
        # create an object time to measure and record time (in miliseconds)

        self.timeclock = ArtisanTime() #QTime()
        self.timeclock.setHMS(0,0,0,0)

        ############################  Thread Server #################################################
        #server that spawns a thread dynamically to sample temperature (press button ON to make a thread press OFF button to kill it)
        self.threadserver = Athreadserver()

        
        ##########################     Designer variables       #################################
        self.designerflag = False
        self.designerconnections = [None,None,None,None]   #mouse event ids
        self.mousepress = None
        self.indexpoint = 0
        self.workingline = 2  #selects ET or BT
        self.eventtimecopy = []
        self.specialeventsStringscopy = []
        self.specialeventsvaluecopy = []
        self.specialeventstypecopy = []
        self.currentx = 0               #used to add point when right click
        self.currenty = 0               #used to add point when right click
        self.designertimeinit = [50,300,540,560,660,700,800,900]
#        if self.mode == "C":
##                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
#            self.designertemp1init = [290,290,290,290,290,290,290,290]
#            self.designertemp2init = [200,150,200,210,220,225,240,240]   #CHARGE,DRY END,FCs, FCe,SCs,SCe,DROP,COOL
#        elif self.mode == "F":
#            self.designertemp1init = [500,500,500,500,500,500,500,500]
#            self.designertemp2init = [380,300,390,395,410,412,420,420]
        self.BTsplinedegree = 3
        self.ETsplinedegree = 3
        self.reproducedesigner = 0      #flag to add events to help reproduce (replay) the profile: 0 = none; 1 = sv; 2 = ramp

        ###########################         filterDropOut variables     ################################

        # constants

        self.filterDropOut_replaceRoR_period = 3
        self.filterDropOut_spikeRoR_period = 3

        # defaults

        self.filterDropOut_tmin_C_default = 10
        self.filterDropOut_tmax_C_default = 700
        self.filterDropOut_tmin_F_default = 50
        self.filterDropOut_tmax_F_default = 1292
        self.filterDropOut_spikeRoR_dRoR_limit_C_default = 4.2
        self.filterDropOut_spikeRoR_dRoR_limit_F_default = 7

        # variables

        self.filterDropOuts = True # Smooth Spikes
        self.filterDropOut_tmin = self.filterDropOut_tmin_F_default
        self.filterDropOut_tmax = self.filterDropOut_tmax_F_default
        self.filterDropOut_spikeRoR_dRoR_limit = self.filterDropOut_spikeRoR_dRoR_limit_F_default # the limit of additional RoR in temp/sec compared to previous readings
        self.minmaxLimits = False
        self.dropSpikes = False

        self.swapETBT = False

        ###########################         wheel graph variables     ################################
        self.wheelflag = False
        #data containers for wheel
        self.wheelnames,self.segmentlengths,self.segmentsalpha,self.wheellabelparent,self.wheelcolor = [],[],[],[],[]

        

        #properties
        #store radius of each circle as percentage(sum of all must at all times add up to 100.0%)
        self.wradii = [25.,20.,20.,35.]
        #starting angle for each circle (0-360).
        self.startangle = [0,0,0,0]
        #text projection: 0 = Flat, 1 = perpendicular to center, 2 = radial from center
        self.projection = [0,1,1,2]
        self.wheeltextsize = [10,10,10,10]
        self.wheelcolorpattern = 0                  #pattern
        self.wheeledge = .02                        #overlaping decorative edge
        self.wheellinewidth = 1
        self.wheellinecolor = "black"               #initial color of lines
        self.wheeltextcolor = "black"               #initial color of text
        self.wheelconnections = [0,0,0]
        self.wheelx,self.wheelz = 0,0                   #temp variables to pass index values
        self.wheellocationx,self.wheellocationz = 0.,0.  #temp vars to pass mouse location (angleX+radiusZ)
        self.wheelaspect = 1.0
        
        # a nicer demo flavor wheel
        self.wheelnames = [[''], ['Fruity', 'Sour', 'Green', 'Other', 'Roasted', 'Spices', 'Nutty', 'Sweet', 'Floral'], ['Floral', 'Berry', 'Dried fruit', 'Other fruit', 'Citrus fruit', 'Sour', 'Alcohol', 'Olive oil', 'Raw', 'Green', 'Beany', 'Musty', 'Chemical', 'Pipe tobaco', 'Tobaco', 'Burnt', 'Cereal', 'Pungent', 'Pepper', 'Brown spice', 'Nutty', 'Cocoa', 'Brown sugar', 'Vanilla', 'Vanillin', 'Overall sweet', 'Sweet Aromatics', 'Black Tea']]
        self.segmentsalpha = [[0.09], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]]
        self.segmentlengths = [[100.0], [11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 11.86125, 5.109999999999999], [2.5549999999999997, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 5.930625, 5.930625, 2.9653125, 2.9653125, 2.9653125, 2.9653125, 3.95375, 3.95375, 3.95375, 5.930625, 5.930625, 2.37225, 2.37225, 2.37225, 2.37225, 2.37225, 2.5549999999999997]]
        self.wheellabelparent = [[0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 8, 8, 9]]
        self.wheelcolor = [['#fdfffb'], ['#cd001b', '#dea20e', '#186923', '#1693a6', '#bb3424', '#9b0f2f', '#976751', '#de4126', '#cf0055'], ['#d6588a', '#d33440', '#bb3435', '#ed513b', '#d47e1d', '#d9b913', '#a08727', '#91a41f', '#5e7927', '#309543', '#4d8a6d', '#8ca3a9', '#65b4c0', '#be9452', '#d7b06b', '#b07351', '#d4a04f', '#653540', '#bf2732', '#9f3845', '#ba7456', '#ac623b', '#c84347', '#f4866d', '#ee5e61', '#df4255', '#c33d4d', '#844a5a']]
        self.wheellinecolor = '#ffffff'
        self.wheeltextcolor = '#ffffff'
        self.wradii = [7.83, 30.9006201171875, 61.2693798828125]
        self.startangle = [0, 42, 33]
        self.wheeledge = 0.01
        self.wheellinewidth = 2
        self.projection = [1, 2, 2]
        

        self.samplingsemaphore = QSemaphore(1)
        self.messagesemaphore = QSemaphore(1)
        self.errorsemaphore = QSemaphore(1)
        self.serialsemaphore = QSemaphore(1)
        self.eventactionsemaphore = QSemaphore(1)
        self.updateBackgroundSemaphore = QSemaphore(1)

        #flag to plot cross lines from mouse
        self.crossmarker = False
        self.crossmouseid = 0
        

        #########  temporary serial variables
        #temporary storage to pass values. Holds extra T3 and T4 values for center 309
        self.extra309T3 = -1
        self.extra309T4 = -1
        self.extra309TX = 0.
        
        #temporary storage to pass values. Holds all values retrieved from a Hottop roaster
        self.hottop_ET = -1
        self.hottop_BT = -1
        self.hottop_HEATER = 0 # 0-100
        self.hottop_MAIN_FAN = 0 # 0-10 (!)
        self.hottop_TX = 0.

        #temporary storage to pass values. Holds all values retrieved from an R1 roaster
        self.R1_DT = -1
        self.R1_BT = -1
        self.R1_BT_ROR = -1
        self.R1_EXIT_TEMP = -1
        self.R1_HEATER = 0 # 0-9
        self.R1_FAN = 0 # 0-12
        self.R1_DRUM = 0 # 1-9
        self.R1_VOLTAGE = 0 # 0-300
        self.R1_TX = 0.
        self.R1_STATE = 0
        self.R1_FAN_RPM = 0
        self.R1_STATE_STR = ""
        


        #used by extra device +ArduinoTC4_XX to pass values
        self.extraArduinoT1 = 0.
        self.extraArduinoT2 = 0.
        self.extraArduinoT3 = 0. # heater duty %
        self.extraArduinoT4 = 0. # fan duty %
        self.extraArduinoT5 = 0. # SV
        self.extraArduinoT6 = 0. # TC4 internal ambient temperature
        
        # used by the ProbatMiddleware extra devices
        # +ProbatMiddleware_burner_drum and
        # +ProbatMidleware_fan_pressure
        self.ProbatMiddleware_burner = -1
        self.ProbatMiddleware_drum = -1
        self.ProbatMiddleware_fan = -1
        self.ProbatMiddleware_pressure = -1
        
        
        #used by extra device +Program_34, +Program_56, +Program_78 and +Program_910 to pass values
        self.program_t3 = -1
        self.program_t4 = -1
        self.program_t5 = -1
        self.program_t6 = -1
        self.program_t7 = -1
        self.program_t8 = -1
        self.program_t9 = -1
        self.program_t10 = -1

        #temporary storage to pass values. Holds the power % ducty cycle of Fuji PIDs and ET-BT
        self.dutycycle = -1
        self.dutycycleTX = 0.
        self.currentpidsv = 0.

        self.linecount = None # linecount cache for resetlines(); has to be reseted if visibility of ET/BT or extra lines or background ET/BT changes
        self.deltalinecount = None # deltalinecoutn cache for resetdeltalines(); has to be reseted if visibility of deltaET/deltaBT or background deltaET/deltaBT

        #variables to organize the delayed update of the backgrounds for bitblitting
        self.ax_background = None
        self.delayTimeout = 10
        self.block_update = False
        
        # flag to toggle between Temp and RoR scale of xy-display
        self.fmt_data_RoR = False

        #holds last values calculated from plotter
        self.plotterstack = [0]*10
        #holds results for each equation (9 total)
        self.plotterequationresults = [[],[],[],[],[],[],[],[],[]]
        #message string for plotter 
        self.plottermessage = ""
        
        self.alarm_popup_timout = 10
        

        #buffers for real time symbolic evaluation
        self.RTtemp1=0.
        self.RTtemp2=0.        
        self.RTextratemp1=[]
        self.RTextratemp2=[]
        self.RTextratx=[]
        
        if self.mode == "C":
            self.mode = "F"
            self.celsiusMode()
            self.phases = self.phases_celsius_defaults
            
        #Extras more info
        self.idx_met = None
        self.showmet = False
        self.met_annotate = []
        self.extendevents = True
        self.statssummary = False        
        self.showtimeguide = True
        self.statsmaxchrperline = 30
        
        #mouse cross lines measurement 
        self.baseX,self.baseY = None, None
        self.base_horizontalcrossline, self.base_verticalcrossline = None, None
        self.base_messagevisible = False  
        
        #threshold for deltaE color difference comparisons
        self.colorDifferenceThreshold = 20   
        
        #references to legend objects
        self.handles = []   
        self.labels = []    
        
        #used for picked event messages
        self.eventmessage = ""
        self.backgroundeventmessage = ""
        self.eventmessagetimer = None
        
        self.resizeredrawing = 0 # holds timestamp of last resize triggered redraw
        
        self.logoimg = None # holds the background logo image
        self.analysisresultsloc_default = [.49,.5]
        self.analysisresultsloc = self.analysisresultsloc_default
        self.analysispickflag = False
        self.analysisresultsstr = ""
        self.analysisstartchoice = 1
        self.analysisoffset = 180
        self.curvefitstartchoice = 0
        self.curvefitoffset = 180
        self.segmentresultsloc_default = [.5,.5]
        self.segmentresultsloc = self.segmentresultsloc_default
        self.segmentpickflag = False
        self.segmentdeltathreshold = 0.6
        self.segmentsamplesthreshold = 3
        
        self.stats_summary_rect = None
        
        self.updategraphicsSignal.connect(self.updategraphics)
        self.updateLargeLCDsSignal.connect(self.updateLargeLCDs)
        self.updateLargeLCDsReadingsSignal.connect(self.updateLargeLCDsReadings)
        self.updateLargeLCDsTimeSignal.connect(self.updateLargeLCDsTime)

    #NOTE: empty Figure is initialy drawn at the end of aw.settingsload()
    #################################    FUNCTIONS    ###################################
    #####################################################################################

    def fileDirty(self):
        try:
            if aw.curFile:
                aw.setWindowTitle("* {} - {}".format(aw.strippedName(aw.curFile),aw.windowTitle))
            else:
                aw.setWindowTitle("* {}".format(aw.windowTitle))
        except:
            pass
        self.safesaveflag = True
    
    def fileClean(self):
        try:
            if aw.curFile:
                aw.setWindowTitle("{} - {}".format(aw.strippedName(aw.curFile),aw.windowTitle))
            else:
                aw.setWindowTitle(aw.windowTitle)
        except:
            pass
        self.safesaveflag = False

    def resizeEvent(self, event):
        super(tgraphcanvas,self).resizeEvent(event)
        # we only trigger a redraw on resize if a watermark is displayed to fix its aspect ratio
        if aw.redrawOnResize and aw.logofilename != "":
            dw = event.size().width() - event.oldSize().width()   # width change
            dh = event.size().height() - event.oldSize().height() # height change
            t = libtime.time()
            # ensure that we redraw during resize only once per second
            if self.resizeredrawing + 0.5 < t and ((dw != 0) or (dh != 0)):
                self.resizeredrawing = t
                QTimer.singleShot(1, lambda : self.redraw(recomputeAllDeltas=False))
    
    # update the aw.qmc.deltaBTspan and deltaETspan from the given sampling interval, aw.qmc.deltaETsamples and aw.qmc.deltaBTsamples
    # interval is expected in seconds (either from the profile on load or from the sampling interval set for recording)
    def updateDeltaSamples(self):
        if self.flagstart or self.profile_sampling_interval is None:
            interval = self.delay / 1000.
        else:
            interval = self.profile_sampling_interval
        self.deltaBTsamples = int(max(1,self.deltaBTspan / interval))
        self.deltaETsamples = int(max(1,self.deltaETspan / interval))
    
    # hack to make self.ax receive onPick events although it is drawn behind self.delta_ax
    # NOTE: this hack slows down redraw!
#    def draw(self):
#        if self.ax and self.delta_ax: #self.designerflag and self.ax and self.delta_ax:
#            self.ax.set_zorder(0)
#            self.delta_ax.set_zorder(0.1)
#        FigureCanvas.draw(self)
#        if self.ax and self.delta_ax: #self.designerflag and self.ax and self.delta_ax:
#            self.ax.set_zorder(0.1)
#            self.delta_ax.set_zorder(0)

    # returns the prefix of length l of s and adds eclipse
    def abbrevString(self,s,l):
        if len(s) > l:
            return s[:l-1] + "..."
        else:
            return s

    def updateBackground(self):
        if not self.block_update:
            try:
                aw.qmc.updateBackgroundSemaphore.acquire(1)
                self.block_update = True
                self.doUpdate()
            finally:
                if aw.qmc.updateBackgroundSemaphore.available() < 1:
                    aw.qmc.updateBackgroundSemaphore.release(1)

    def doUpdate(self):
        if not self.designerflag:
            self.resetlinecountcaches() # ensure that the line counts are up to date
            self.resetlines() # get rid of HUD, projection, cross lines and AUC line
            self.resetdeltalines() # just in case
            
            
            try:
                self.fig.canvas.draw() # the triggered _draw_event(self,evt) function resets the self.in_draw_event if done
                #self.fig.canvas.draw_idle() # ask the canvas to kindly draw it self some time in the future when Qt thinks it is convenient
                # make sure that the GUI framework has a chance to run its event loop
                # and clear any GUI events.  This needs to be in a try/except block
                # because the default implemenation of this method is to raise
                # NotImplementedError        
                #self.fig.canvas.flush_events() # don't FLUSH event as this can lead to a second redraw started from within the same GUI thread and 
                # causen a hang by the blocked semaphore
            except:
                pass
            
            self.ax_background = self.fig.canvas.copy_from_bbox(aw.qmc.ax.get_figure().bbox)
            
        self.block_update = False

    def getetypes(self):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        return self.etypes

    def etypesf(self, i):
        if len(self.etypes) == 4:
            self.etypes.append("--")
        if i > 4:
            return self.etypes[i-5]
        else:
            return self.etypes[i]

    def Betypesf(self, i, prefix=False):
        if len(self.Betypes) == 4:
            self.Betypes.append("--")
        if prefix and i < 4:
            return u("Background")+self.Betypes[i]
        else:
            return self.Betypes[i]

    def ambientTempSourceAvg(self):
        res = None
        if self.ambientTempSource:
            try:
                start = 0
                end = len(aw.qmc.temp1) - 1
                if self.timeindex[0] > -1: # CHARGE
                    start = self.timeindex[0]
                if self.timeindex[6] > 0: # DROP
                    end = self.timeindex[6]
                if self.ambientTempSource == 1: # from ET
                    res = numpy.mean([e for e in aw.qmc.temp1[start:end] if e is not None and e != -1])
                elif self.ambientTempSource == 2: # from BT
                    res = numpy.mean([e for e in aw.qmc.temp2[start:end] if e is not None and e != -1])
                elif self.ambientTempSource > 2 and ((self.ambientTempSource - 3) < (2*len(aw.qmc.extradevices))): 
                    # from an extra device
                    if (self.ambientTempSource)%2==0:
                        res = numpy.mean([e for e in aw.qmc.extratemp2[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1])
                    else:
                        res = numpy.mean([e for e in aw.qmc.extratemp1[(self.ambientTempSource - 3)//2][start:end] if e is not None and e != -1])
            except: # the array to average over might get empty and mean thus invoking an exception
                pass
        if res:
            res = aw.float2float(res)
        return res

    def updateAmbientTempFromPhidgetModulesOrCurve(self):
        if not self.ambientTempSource:
            AT_device = None
            try:
                AT_device = aw.qmc.extradevices.index(36)
            except:
                try:
                    AT_device = aw.qmc.extradevices.index(60)
                except:
                    pass
            if AT_device is not None:
                # 1048_AT channel #36, TMP1101_AT channel #60
                # we try to access that devices first channel to retrieve the temperature data
                try:
                    ser = aw.extraser[AT_device]
                    if ser.PhidgetTemperatureSensor is not None:
                        at = ser.PhidgetTemperatureSensor[0].getTemperature()
                        if aw.qmc.mode == "F":
                                at = aw.float2float(aw.qmc.fromCtoF(at))
                        aw.qmc.ambientTemp = aw.float2float(at)
                except:
                    pass
            # in case the AT channel of the 1048 or the TMP1101 is not used as extra device, we try to attach to it anyhow and read the temp off
            elif aw.qmc.ambientTemp == 0.0 and aw.qmc.device in [34,58]: # Phidget 1048 or TMP1101 channel 4 (use internal temp)
                try:
                    if aw.ser.PhidgetTemperatureSensor is not None and aw.ser.PhidgetTemperatureSensor[0].getAttached():
                        ambient = PhidgetTemperatureSensor()
                        ambient.setDeviceSerialNumber(aw.ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber())
                        if aw.qmc.device == 58:
                            ambient.setHubPort(aw.ser.PhidgetTemperatureSensor[0].getHubPort())
                        ambient.setChannel(4)
                        ambient.openWaitForAttachment(1000) # timeout in ms
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                        t = ambient.getTemperature()
                        if aw.qmc.mode == "F":
                            aw.qmc.ambientTemp = aw.float2float(aw.qmc.fromCtoF(t))
                        else:
                            aw.qmc.ambientTemp = aw.float2float(t)
                        if ambient.getAttached():
                            ambient.close()
                except:
                    pass
        res = aw.qmc.ambientTempSourceAvg()
        if res is not None and (isinstance(res, float) or isinstance(res, int)) and not math.isnan(res):
            aw.qmc.ambientTemp = aw.float2float(float(res))

    def updateAmbientTemp(self):
        self.updateAmbientTempFromPhidgetModulesOrCurve()
        try:
            aw.qmc.startPhidgetManager()
            aw.qmc.getAmbientData()
        except:
            pass

    # eventsvalues maps the given internal event value v to an external event int value as displayed to the user as special event value
    # v is expected to be float value of range [-11.0,11.0]
    # negative values are not used as event values, but as step arguments in extra button definitions
    #   11.0 => 100
    #   10.1 => 91
    #   10.0 => 90
    #   1.1 => 1
    #   1.0 => 0
    #     0 => 0
    #  -1.0 => 0
    #  -1.1 => -1
    # -10.0 => -90
    # -10.1 => -91
    # -11.0 => -100
    def eventsInternal2ExternalValue(self,v):
        if v is None:
            return 0
        elif (v <= 1.0) and (v >= -1.0):
            return 0
        elif v < -1.0:
            return -(int(round(abs(v)*10)) - 10)
        else:
            return int(round(v*10)) - 10
            
    # the inverse of eventsInternal2ExternalValue, converting an external to an internal event value
    def eventsExternal2InternalValue(self,v):
        if v< 1.0 and v > -1.0:
            return 1.0
        elif v>=1.0:
            return v/10. + 1.
        else:
            return v/10. - 1.

    # eventsvalues maps the given number v to a string to be displayed to the user as special event value
    # v is expected to be float value of range [0-10]
    # negative values are mapped to ""
    # 0.1 to "1"
    # ..
    # 1.0 to "10"
    # .. 
    # 10.0 to "100"
    def eventsvalues(self,v):
        return u(self.eventsInternal2ExternalValue(v))
            
    # 100.0 to "10" and 10.1 to "1"
    def eventsvaluesShort(self,v):
        value = v*10. - 10.
        if value == -10:
            return "0"
        elif value < 0:
            return ""
        else:
            if True: #aw.qmc.LCDdecimalplaces:
                return u(int(round(value)))
            else:
                return u(int(round(value / 10.)))

    # the inverse to eventsvalues above (string -> value)
    def str2eventsvalue(self,s):
        st = s.strip()
        if st is None or len(st) == 0:
            return -1
        else:
            return self.eventsExternal2InternalValue(float(st))

    # hook up to mpls event handling framework for draw events
    # this is emitted after the canvas has finished a full redraw
    def _draw_event(self, _):
        #self.fig.canvas.flush_events() # THIS prevents the black border on >Qt5.5, but slows down things (especially resizings) on redraw otherwise!!!
        self.ax_background = None

    @pyqtSlot()
    def sendeventmessage(self):
        self.eventmessagetimer = None
        if len(self.backgroundeventmessage) != 0:
            aw.sendmessage(self.backgroundeventmessage,append=True)
            self.backgroundeventmessage = ""
            self.starteventmessagetimer(2)  #hack to ensure that the background event message is written first
            return
        if len(self.eventmessage) != 0:
            aw.sendmessage(self.eventmessage,append=True)
            self.eventmessage = ""

    def starteventmessagetimer(self,time=120):
        if self.eventmessagetimer:
            self.eventmessagetimer.stop()
            self.eventmessagetimer.deleteLater()
        self.eventmessagetimer = QTimer()
        self.eventmessagetimer.timeout.connect(self.sendeventmessage)
        self.eventmessagetimer.setSingleShot(True)
        self.eventmessagetimer.start(time)
    
    def onpick(self,event):
        try:
            # display MET information by clicking on the MET marker
            if isinstance(event.artist, matplotlib.text.Annotation) and self.showmet and event.artist in [self.met_annotate]:
                if self.met_timex_temp1_delta[2] is not None and self.met_timex_temp1_delta[2] >= 0:
                    met_time_str = str(self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate("Message","seconds before FCs", None)
                else:
                    met_time_str = str(-self.met_timex_temp1_delta[2])
                    met_time_msg = QApplication.translate("Message","seconds after FCs", None)
                    
                message = "MET {}{} @ {}, {} {}".format(
                    str(aw.float2float(self.met_timex_temp1_delta[1],1)),
                    aw.qmc.mode,
                    self.stringfromseconds(self.met_timex_temp1_delta[0]),
                    met_time_str,
                    met_time_msg)
                aw.sendmessage(message)

            # the analysis results were clicked
            elif aw.analysisresultsanno is not None and isinstance(event.artist, matplotlib.text.Annotation) and event.artist in [aw.analysisresultsanno]:
                self.analysispickflag = True

            # the segment results were clicked
            elif aw.segmentresultsanno is not None and isinstance(event.artist, matplotlib.text.Annotation) and event.artist in [aw.segmentresultsanno]:
                self.segmentpickflag = True

            # toggle visibility of graph lines by clicking on the legend 
            elif self.legend is not None and event.artist != self.legend and (isinstance(event.artist, matplotlib.lines.Line2D) or isinstance(event.artist, matplotlib.text.Text)) \
                and event.artist not in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots] \
                and event.artist not in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                idx = None
                # deltaLabelMathPrefix (legend label)
                # deltaLabelUTF8 (artist)
                if isinstance(event.artist, matplotlib.text.Text):
                    try:
                        label = event.artist.get_text()
                        idx = self.labels.index(label)
                    except:
                        pass
                    try:
                        # toggle also the visibility of the legend handle
                        clean_label = label.replace(deltaLabelMathPrefix,deltaLabelUTF8)
                        artist = next((x for x in self.legend_lines if x.get_label() == clean_label), None)
                        if artist:
                            artist.set_visible(not artist.get_visible())
                    except:
                        pass
#                elif isinstance(event.artist, matplotlib.lines.Line2D):
#                    try:
#                        label = event.artist.get_label().replace(deltaLabelUTF8,deltaLabelMathPrefix)
#                        idx = self.labels.index(label)
#                    except:
#                        pass
#                    # toggle also the visibility of the legend handle
#                    event.artist.set_visible(not event.artist.get_visible())
                # toggle the visibility of the corresponding line
                if idx is not None:
                    artist = self.handles[idx]
                    artist.set_visible(not artist.get_visible())
            
            # show event information by clicking on event lines in step, step+ and combo modes
            elif isinstance(event.artist, matplotlib.lines.Line2D):
                if isinstance(event.ind, (int)):
                    ind = event.ind
                else:
                    if not len(event.ind): return
                    ind = event.ind[0]    
                digits = (1 if aw.qmc.LCDdecimalplaces else 0)
                if event.artist in [self.l_backgroundeventtype1dots,self.l_backgroundeventtype2dots,self.l_backgroundeventtype3dots,self.l_backgroundeventtype4dots]:
                    timex = self.backgroundtime2index(event.artist.get_xdata()[ind])
                    for i in range(len(self.backgroundEvents)):
                        if re.search('(Background'+self.Betypesf(self.backgroundEtypes[i])+')',str(event.artist))\
                        and (self.backgroundEvents[i] == timex or self.backgroundEvents[i] -1 == timex or self.backgroundEvents[i] + 1 == timex):
                            if aw.qmc.timeindex[0] != -1:
                                start = aw.qmc.timex[aw.qmc.timeindex[0]]
                            else:
                                start = 0
                            if len(self.backgroundeventmessage) != 0:
                                self.backgroundeventmessage += u(" | ")
                            else:
                                self.backgroundeventmessage += u("Background: ")
                            self.backgroundeventmessage += u(self.Betypesf(self.backgroundEtypes[i])) + u(" = ") + self.eventsvalues(self.backgroundEvalues[i])
                            if aw.qmc.renderEventsDescr and self.backgroundEStrings[i] and self.backgroundEStrings[i]!="":
                                self.backgroundeventmessage += u(" (") + u(self.backgroundEStrings[i].strip()[:aw.qmc.eventslabelschars]) + u(")")
                            self.backgroundeventmessage += u(" @ ") + self.stringfromseconds(self.timeB[self.backgroundEvents[i]] - start) + " " + str(aw.float2float(self.temp2B[self.backgroundEvents[i]],digits)) + aw.qmc.mode
                            self.starteventmessagetimer()
                            break
                elif event.artist in [self.l_eventtype1dots,self.l_eventtype2dots,self.l_eventtype3dots,self.l_eventtype4dots]:
                    timex = self.time2index(event.artist.get_xdata()[ind])
                    for i in range(len(self.specialevents)):
                        if re.search('('+self.etypesf(self.specialeventstype[i])+')',str(event.artist))\
                        and (self.specialevents[i] == timex or self.specialevents[i] + 1 == timex or self.specialevents[i] -1 == timex):
                            if aw.qmc.timeindex[0] != -1:
                                start = aw.qmc.timex[aw.qmc.timeindex[0]]
                            else:
                                start = 0
                            if len(self.eventmessage) != 0:
                                self.eventmessage += u(" | ")
                            self.eventmessage += u(self.etypesf(self.specialeventstype[i])) + u(" = ") + self.eventsvalues(self.specialeventsvalue[i])
                            if aw.qmc.renderEventsDescr and self.specialeventsStrings[i] and self.specialeventsStrings[i]!="":
                                self.eventmessage += u(" (") + u(self.specialeventsStrings[i].strip()[:aw.qmc.eventslabelschars]) + u(")")
                            self.eventmessage += u(" @ ") + self.stringfromseconds(self.timex[self.specialevents[i]] - start) + " " + str(aw.float2float(self.temp2[self.specialevents[i]],digits)) + aw.qmc.mode
                            self.starteventmessagetimer()
                            break
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " onpick() {0}").format(str(e)),exc_tb.tb_lineno)
            
    def onrelease_after_pick(self,_):
        if self.legend is not None:
            QTimer.singleShot(1,self.updateBackground)

    def onrelease(self,event):     # NOTE: onrelease() is connected/disconnected in togglecrosslines()
        try:
            if event.button == 1: 
                self.baseX,self.baseY = None, None
                self.base_horizontalcrossline, self.base_verticalcrossline = None, None
            # save the location of analysis results after dragging
            if self.analysispickflag:
                self.analysispickflag = False
                corners = aw.qmc.ax.transAxes.inverted().transform(aw.analysisresultsanno.get_bbox_patch().get_extents())
                aw.qmc.analysisresultsloc = (corners[0][0], corners[0][1] + (corners[1][1] - corners[0][1])/2)
            # save the location of segment results after dragging
            if self.segmentpickflag:
                self.segmentpickflag = False
                corners = aw.qmc.ax.transAxes.inverted().transform(aw.segmentresultsanno.get_bbox_patch().get_extents())
                aw.qmc.segmentresultsloc = (corners[0][0], corners[0][1] + (corners[1][1] - corners[0][1])/2)
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " onclick() {0}").format(str(e)),exc_tb.tb_lineno)


    def disconnect_draggableannotations_motion_notifiers(self):
        cids = []
        try:
            if 'motion_notify_event' in aw.qmc.fig.canvas.callbacks.callbacks:
                motion_notify_event_handlers = aw.qmc.fig.canvas.callbacks.callbacks['motion_notify_event']
                for cid, func_ref in motion_notify_event_handlers.items():
                    func = func_ref()
                    if func.__self__ is not None: # a bound method
                        c = func.__self__.__class__
                        if c == matplotlib.offsetbox.DraggableAnnotation:
                            cids.append(cid)
            # disconnecting all established motion_notify_event_handlers of DraggableAnnotations
            for cid in cids:
                aw.qmc.fig.canvas.mpl_disconnect(cid)
        except:
            pass


    def onclick(self,event):
        try:
            if not self.designerflag and event.inaxes is None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button == 3:
                aw.qmc.statisticsmode = (aw.qmc.statisticsmode + 1)%2
                aw.qmc.writecharacteristics()
                aw.qmc.fig.canvas.draw_idle()

#PLUS
            elif not self.designerflag and event.inaxes is None and not aw.qmc.flagstart and not aw.qmc.flagon and event.button == 1 and event.dblclick==True and \
                    event.x < event.y and aw.plus_account is not None and aw.qmc.roastUUID is not None:
                QDesktopServices.openUrl(QUrl(plus.util.roastLink(aw.qmc.roastUUID), QUrl.TolerantMode))
            
            elif event.button == 1 and event.inaxes and aw.qmc.crossmarker and not self.designerflag and not self.wheelflag and not aw.qmc.flagon:
                self.baseX,self.baseY = event.xdata, event.ydata
                if self.base_horizontalcrossline is None and self.base_verticalcrossline is None:
                    # Mark starting point of click-and-drag with a marker
                    self.base_horizontalcrossline, = self.ax.plot(self.baseX,self.baseY,'r+', markersize=20)
                    self.base_verticalcrossline, = self.ax.plot(self.baseX,self.baseY,'wo', markersize = 2)
            elif event.button == 3 and event.inaxes and not self.designerflag and not self.wheelflag:# and not self.flagon:
                timex = self.time2index(event.xdata)
                if timex > 0:
                    menu = QMenu(aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
#                    menu.setStyleSheet("QMenu::item {background-color: palette(window); selection-color: palette(window); selection-background-color: darkBlue;}")
                    # populate menu
                    ac = QAction(menu)
                    bt = self.temp2[timex]
                    if self.mode == "C":
                        btdelta = 50
                    else:
                        btdelta = 70
                    if bt != -1 and abs(bt-event.ydata) < btdelta:
                        # we surpress the popup if not clicked close enough to the BT curve
                        if self.timeindex[0] > -1:
                            ac.setText(u(QApplication.translate("Label", "at")) + u(" ") + self.stringfromseconds(event.xdata - self.timex[self.timeindex[0]]))
                        else:
                            ac.setText(u(QApplication.translate("Label", "at")) + u(" ") + self.stringfromseconds(event.xdata))
                        ac.setEnabled(False)
                        menu.addAction(ac)
                        for k in [(u(QApplication.translate("Label","CHARGE")),0),
                                  (u(QApplication.translate("Label","DRY END")),1),
                                  (u(QApplication.translate("Label","FC START")),2),
                                  (u(QApplication.translate("Label","FC END")),3),
                                  (u(QApplication.translate("Label","SC START")),4),
                                  (u(QApplication.translate("Label","SC END")),5),
                                  (u(QApplication.translate("Label","DROP")),6),
                                  (u(QApplication.translate("Label","COOL")),7)]:
                            idx_before = idx_after = 0
                            for i in range(k[1]):
                                if self.timeindex[i] and self.timeindex[i] != -1:
                                    idx_before = self.timeindex[i]
                            for i in range(6,k[1],-1) :
                                if self.timeindex[i] and self.timeindex[i] != -1:
                                    idx_after = self.timeindex[i]
                            if ((not idx_before) or timex > idx_before) and ((not idx_after) or timex < idx_after):
                                if not self.flagstart or (k[1] == 0 and self.timeindex[0] > -1) or (k[1] != 0 and self.timeindex[k[1]] != 0): # only add menu item during recording if already a value is set (via a button)
                                    ac = QAction(menu)
                                    ac.key = (k[1],timex)
                                    ac.setText(" " + k[0])
                                    menu.addAction(ac)
                        # add user EVENT entry
                        ac = QAction(menu)
                        ac.setText(u(" ") + u(QApplication.translate("Label", "EVENT")))
                        ac.key = (-1,timex)
                        menu.addAction(ac)
                        
                        # we deactivate all active motion_notify_event_handlers of draggable annotations that might have been connected by this click to
                        # avoid redraw conficts between Artisan canvas bitblit caching and the matplotlib internal bitblit caches.
                        self.disconnect_draggableannotations_motion_notifiers()
                        
                        # show menu
                        menu.triggered.connect(self.event_popup_action)
                        menu.popup(QCursor.pos())
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " onclick() {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot("QAction*")
    def event_popup_action(self,action):
        if action.key[0] >= 0:
            # we check if this is the first DROP mark on this roast
            firstDROP = (action.key[0] == 6 and self.timeindex[6] == 0)
            self.timeindex[action.key[0]] = action.key[1]
            # clear custom label positions cache entry
            if action.key[0] in aw.qmc.l_annotations_dict:
                del aw.qmc.l_annotations_dict[action.key[0]]
            if action.key[0] == 0: # CHARGE
                # realign to background
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            elif action.key[0] == 6: # DROP
                try:
                    # update ambient temperature if a ambient temperature source is configured and no value yet established
                    aw.qmc.updateAmbientTempFromPhidgetModulesOrCurve()
                except Exception:
                    pass
#PLUS
                # only on first setting the DROP event (not set yet and no previous DROP undone), we upload to PLUS
                if firstDROP and aw.qmc.autoDROPenabled and aw.plus_account is not None:
                    try:
                        aw.updatePlusStatus()
                    except:
                        pass
                        # add to out-queue
                    try:
                        plus.queue.addRoast()
                    except:
                        pass
            
            # update phases
            elif action.key[0] == 1 and self.phasesbuttonflag: # DRY
                self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
            elif action.key[0] == 2 and self.phasesbuttonflag: # FCs
                self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
            
            aw.qmc.fileDirty()
            self.redraw(recomputeAllDeltas=(action.key[0] in [0,6])) # on moving CHARGE or DROP, we have to recompute the Deltas
        else:
            # add a special event at the current timepoint
            dlg = customEventDlg(aw,action.key[1])
            if dlg.exec_():
                self.specialevents.append(action.key[1]) # absolut time index
                self.specialeventstype.append(dlg.type) # default: "--"
                self.specialeventsStrings.append(dlg.description)
                self.specialeventsvalue.append(dlg.value)
                
                try:
                    dlg.dialogbuttons.accepted.disconnect()
                    dlg.dialogbuttons.rejected.disconnect()
                    QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                    try: # sip not supported on older PyQt versions (RPi!)
                        sip.delete(dlg)
                        #print(sip.isdeleted(dlg))
                    except:
                        pass
                except:
                    pass
                aw.qmc.fileDirty()
                self.redraw(recomputeAllDeltas=(action.key[0] in [0,6])) # on moving CHARGE or DROP, we have to recompute the Deltas
            else:
                try:
                    dlg.dialogbuttons.accepted.disconnect()
                    dlg.dialogbuttons.rejected.disconnect()
                    QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                    try: # sip not supported on older PyQt versions (RPi!)
                        sip.delete(dlg)
                        #print(sip.isdeleted(dlg))
                    except:
                        pass
                except:
                    pass
        
    def updateWebLCDs(self,bt=None,et=None,time=None,alertTitle=None,alertText=None,alertTimeout=None):
        try:
            url = "http://127.0.0.1:" + str(aw.WebLCDsPort) + "/send"
            headers = {'content-type': 'application/json'}
            payload = {'data': {}}
            if bt is not None:
                payload['data']['bt'] = bt
            if et is not None:
                payload['data']['et'] = et
            if time is not None:
                payload['data']['time'] = time
            if alertText is not None:
                payload['alert'] = {}
                payload['alert']['text'] = alertText
                if alertTitle:
                    payload['alert']['title'] = alertTitle
                if alertTimeout:
                    payload['alert']['timeout'] = alertTimeout
            from requests import post as request_post
            from json import dumps as json_dumps
            request_post(url, data=json_dumps(payload),headers=headers,timeout=0.3)
        except Exception:
            pass
    
    # note that partial values might be given here (time might update, but not the values)
    @pyqtSlot(str,str,str)
    def updateLargeLCDs(self,bt,et,time):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.updateValues([et],[bt],time=time)
        except:
            pass

    @pyqtSlot(str,str)
    def updateLargeLCDsReadings(self,bt,et):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.updateValues([et],[bt])
        except:
            pass

    @pyqtSlot(str)
    def updateLargeLCDsTime(self,time):
        try:
            if aw.largeLCDs_dialog is not None:
                aw.largeLCDs_dialog.updateValues([],[],time=time)
        except:
            pass            
            
    # note that partial values might be given here
    def updateLargeDeltaLCDs(self,deltabt=None,deltaet=None):
        try:
            if aw.largeDeltaLCDs_dialog is not None:
                aw.largeDeltaLCDs_dialog.updateValues([deltaet],[deltabt])
        except:
            pass

    # note that partial values might be given here
    def updateLargePIDLCDs(self,sv=None,duty=None):
        try:
            if aw.largePIDLCDs_dialog is not None:
                aw.largePIDLCDs_dialog.updateValues([sv],[duty])
        except:
            pass

    def updateLargeExtraLCDs(self,extra1=None,extra2=None):
        try:
            if aw.largeExtraLCDs_dialog is not None:
                aw.largeExtraLCDs_dialog.updateValues(extra1,extra2)
        except:
            pass

    # returns True if the extra device n, channel c, is of type MODBUS or S7, has no factor defined and is of type int
    # channel c is either 0 or 1
    def intChannel(self,n,c):
        if aw.qmc.extradevices[n] == 29: # MODBUS
            if c == 0:
                return not aw.modbus.inputFloats[0] and aw.modbus.inputDivs[0] == 0 and aw.modbus.inputModes[0] == ""
            else:
                return not aw.modbus.inputFloats[1] and aw.modbus.inputDivs[1] == 0 and aw.modbus.inputModes[1] == "" 
        elif aw.qmc.extradevices[n] == 33: # MODBUS_34
            if c == 0:
                return not aw.modbus.inputFloats[2] and aw.modbus.inputDivs[2] == 0 and aw.modbus.inputModes[2] == ""
            else:
                return not aw.modbus.inputFloats[3] and aw.modbus.inputDivs[3] == 0 and aw.modbus.inputModes[3] == ""
        elif aw.qmc.extradevices[n] == 55: # MODBUS_56
            if c == 0:
                return not aw.modbus.inputFloats[4] and aw.modbus.inputDivs[4] == 0 and aw.modbus.inputModes[4] == ""
            else:
                return not aw.modbus.inputFloats[5] and aw.modbus.inputDivs[5] == 0 and aw.modbus.inputModes[5] == ""
        elif aw.qmc.extradevices[n] == 109: # MODBUS_78
            if c == 0:
                return not aw.modbus.inputFloats[6] and aw.modbus.inputDivs[6] == 0 and aw.modbus.inputModes[6] == ""
            else:
                return not aw.modbus.inputFloats[7] and aw.modbus.inputDivs[7] == 0 and aw.modbus.inputModes[7] == ""
        elif aw.qmc.extradevices[n] == 70: # S7
            return aw.s7.type[0+c] == 0 and aw.s7.mode[0+c] == 0 and aw.s7.div[0+c] == 0
        elif aw.qmc.extradevices[n] == 80: # S7_34
            return aw.s7.type[2+c] == 0 and aw.s7.mode[2+c] == 0 and aw.s7.div[2+c] == 0
        elif aw.qmc.extradevices[n] == 81: # S7_56
            return aw.s7.type[4+c] == 0 and aw.s7.mode[4+c] == 0 and aw.s7.div[4+c] == 0
        elif aw.qmc.extradevices[n] == 82: # S7_78
            return aw.s7.type[6+c] == 0 and aw.s7.mode[6+c] == 0 and aw.s7.div[6+c] == 0
        elif aw.qmc.extradevices[n] == 110: # S7_910
            return aw.s7.type[8+c] == 0 and aw.s7.mode[8+c] == 0 and aw.s7.div[8+c] == 0
        else:
            False

    def update_additional_artists(self):
        if aw.qmc.flagstart and ((aw.qmc.device == 18 and aw.simulator is None) or aw.qmc.showtimeguide) and aw.qmc.l_timeline is not None: # not NONE device
            tx = int(aw.qmc.timeclock.elapsed()/1000.)
            #aw.qmc.l_timeline.set_data([tx,tx], [aw.qmc.ylimit_min,aw.qmc.ylimit])
            aw.qmc.l_timeline.set_data([tx,tx], aw.qmc.ax.get_ylim())
            aw.qmc.ax.draw_artist(aw.qmc.l_timeline)
        if aw.qmc.projectFlag:
            if self.l_BTprojection is not None and aw.qmc.BTcurve:
                aw.qmc.ax.draw_artist(self.l_BTprojection)
            if self.l_ETprojection is not None and aw.qmc.ETcurve:
                aw.qmc.ax.draw_artist(self.l_ETprojection)
        if aw.qmc.AUCguideFlag and aw.qmc.AUCguideTime and aw.qmc.AUCguideTime > 0:
            aw.qmc.ax.draw_artist(self.l_AUCguide)

    # runs from GUI thread.
    # this function is called by a signal at the end of the thread sample()
    # during sample, updates to GUI widgets or anything GUI must be done here (never from thread)
    @pyqtSlot()
    def updategraphics(self):
        try:
            if self.flagon:
                #### lock shared resources #####
                aw.qmc.samplingsemaphore.acquire(1)
                try:
                    if len(self.timex):
                        if self.LCDdecimalplaces:
                            lcdformat = "%.1f"
                        else:
                            lcdformat = "%.0f"
                        etstr = "--"
                        try: # if self.temp1 is None, which should never be the case, this fails
                            if len(self.temp1) and -100 < self.temp1[-1] < 1000:
                                etstr = lcdformat%float(self.temp1[-1])            # ET
                            elif self.LCDdecimalplaces and len(self.temp1) and -10000 < self.temp1[-1] < 100000:
                                etstr = "%.0f"%float(self.temp1[-1])
                        except:
                            pass
                        aw.lcd2.display(etstr)
                        btstr = "--"
                        try:
                            if len(self.temp2) and -100 < self.temp2[-1] < 1000:
                                btstr = lcdformat%float(self.temp2[-1])            # BT
                            elif self.LCDdecimalplaces and len(self.temp2) and -10000 < self.temp2[-1] < 100000:
                                btstr = "%.0f"%float(self.temp2[-1])
                        except:
                            pass
                        aw.lcd3.display(btstr)
                        deltaetstr = "--"
                        deltabtstr = "--"
                        try:
                            if -100 < self.rateofchange1 < 1000:
                                deltaetstr = lcdformat%float(self.rateofchange1)        # rate of change MET (degress per minute)
                            aw.lcd4.display(deltaetstr)
                            if -100 < self.rateofchange2 < 1000:
                                deltabtstr = lcdformat%float(self.rateofchange2)        # rate of change BT (degrees per minute)
                            aw.lcd5.display(deltabtstr)
                            self.updateLargeDeltaLCDs(deltabt=deltabtstr,deltaet=deltaetstr)
                        except:
                            pass
                        try:                    
                            if aw.ser.showFujiLCDs and self.device == 0 or self.device == 26:         #extra LCDs for Fuji or DTA pid
                                pidsv = lcdformat%self.currentpidsv
                                aw.lcd6.display(pidsv)
                                pidduty = lcdformat%self.dutycycle
                                aw.lcd7.display(pidduty)
                                self.updateLargePIDLCDs(sv=pidsv,duty=pidduty)
                        except:
                            pass
    
                        ndev = len(self.extradevices)
                        extra1_values = []
                        extra2_values = []
                        for i in range(ndev):
                            if i < aw.nLCDS:
                                try:
                                    if self.extratemp1[i]:
                                        fmt = lcdformat
                                        v = float(self.extratemp1[i][-1])
                                        if (v.is_integer() and self.intChannel(i,0)):
                                            fmt = "%.0f"  
                                        if -100 < v < 1000:
                                            extra1_value = fmt%v # everything fits
                                        elif self.LCDdecimalplaces and -10000 < v < 100000:
                                            fmt = "%.0f"
                                            extra1_value = fmt%v
                                        else:
                                            extra1_value = "--"
                                        aw.extraLCD1[i].display(extra1_value)
                                        extra1_values.append(extra1_value)
                                except:
                                    extra1_value = "--"
                                    extra1_values.append(extra1_value)
                                    aw.extraLCD1[i].display(extra1_value)
                                try:
                                    if self.extratemp2[i]:
                                        fmt = lcdformat
                                        v = float(self.extratemp2[i][-1])
                                        if (v.is_integer() and self.intChannel(i,1)):
                                            fmt = "%.0f"  
                                        if -100 < v < 1000:
                                            extra2_value = fmt%v # everything fits
                                        elif self.LCDdecimalplaces and -10000 < v < 100000:
                                            fmt = "%.0f"
                                            extra2_value = fmt%v
                                        else:
                                            extra2_value = "--"
                                        aw.extraLCD2[i].display(extra2_value)
                                        extra2_values.append(extra2_value)
                                except:
                                    extra2_value = "--"
                                    extra2_values.append(extra2_value)
                                    aw.extraLCD2[i].display(extra2_value)
                                        
                        # update large LCDs (incl. Web LCDs)
                        timestr = None
                        if not self.flagstart:
                            timestr = "00:00"
                        if aw.WebLCDs:
                            self.updateWebLCDs(bt=btstr,et=etstr,time=timestr)
                        if timestr is None:
                            self.updateLargeLCDsReadingsSignal.emit(btstr,etstr)
                        else:
                            self.updateLargeLCDsSignal.emit(btstr,etstr,timestr)
                        self.updateLargeExtraLCDs(extra1=extra1_values,extra2=extra2_values)
                finally:
                    if aw.qmc.samplingsemaphore.available() < 1:
                        aw.qmc.samplingsemaphore.release(1)

                #check setSV
                if self.temporarysetsv is not None:
                    if aw.qmc.device == 0 and aw.fujipid.followBackground:
                        aw.fujipid.setsv(self.temporarysetsv,silent=True)
                    else:
                        aw.pidcontrol.setSV(self.temporarysetsv,init=False)
                self.temporarysetsv = None
                
                #check move slider pending actions
                if self.temporarymovepositiveslider:
                    slidernr,value = self.temporarymovepositiveslider
                    if aw.sliderpos(slidernr) != value or self.temporayslider_force_move:
                        aw.moveslider(slidernr,value) # move slider
                        aw.fireslideraction(slidernr) # fire action
                        self.temporayslider_force_move = False
                self.temporarymovepositiveslider = None
                if self.temporarymovenegativeslider:
                    slidernr,value = self.temporarymovenegativeslider
                    if aw.sliderpos(slidernr) != value or self.temporayslider_force_move:
                        aw.moveslider(slidernr,value) # move slider
                        aw.fireslideraction(slidernr) # fire action
                        self.temporayslider_force_move = False
                self.temporarymovenegativeslider = None
                        
                #write error message
                if self.temporary_error is not None:
                    aw.sendmessage(self.temporary_error)
                    self.temporary_error = None # clear flag
                    # update error dlg
                    if aw.error_dlg:
                        aw.error_dlg.update()
                        
                #update serial_dlg
                if aw.serial_dlg:
                    aw.serial_dlg.update()
                    
                #update message_dlg
                if aw.message_dlg:
                    aw.message_dlg.update()
                    
                #check quantified events; do this before the canvas is redraw as additional annotations might be added here, but do not recursively call updategraphics
                for el in self.quantifiedEvent:
                    try:
                        aw.moveslider(el[0],el[1])
                        if aw.qmc.flagstart:
                            value = aw.float2float((el[1] + 10.0) / 10.0)
                            aw.qmc.EventRecordAction(extraevent = 1,eventtype=el[0],eventvalue=value,eventdescription=u("Q")+aw.qmc.eventsvalues(value),doupdategraphics=False)
                    except:
                        pass
                self.quantifiedEvent = []
                    
                if self.flagstart:
                    if  aw.qmc.zoom_follow and aw.qmc.temp2 and len(aw.qmc.temp2)>0 and aw.qmc.temp1 and len(aw.qmc.temp1)>0: # aw.ntb._active == 'ZOOM'
                        # center current BT reading on canvas
                        bt = aw.qmc.temp2[-1]
                        tx = aw.qmc.timex[-1]
                        # get current limits
                        xlim = aw.qmc.ax.get_xlim()
                        xlim_offset = (xlim[1] - xlim[0]) / 2.
                        xlim_new = (tx - xlim_offset, tx + xlim_offset)
                        ylim = aw.qmc.ax.get_ylim()
                        ylim_offset = (ylim[1] - ylim[0]) / 2.
                        ylim_new = (bt - ylim_offset, bt + ylim_offset)
                        # set new limits to center current BT on canvas
                        aw.qmc.ax.set_xlim(xlim_new)
                        aw.qmc.ax.set_ylim(ylim_new)
                        two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag)))
                        if two_ax_mode and aw.qmc.delta_ax:
                            zlim = aw.qmc.delta_ax.set_ylim()
                            zlim_offset = (zlim[1] - zlim[0]) / 2.
                            btd = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,bt))[1]))[1])
                            zlim_new = (btd - zlim_offset, btd + zlim_offset)
                            aw.qmc.delta_ax.set_ylim(zlim_new)
                
                        if ylim != ylim_new or xlim != xlim_new or (two_ax_mode and zlim != zlim_new):
                            self.ax_background = None
                    
                    if aw.qmc.patheffects:
                        rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette["background"])]
                    else:
                        rcParams['path.effects'] = []

                    #auto mark CHARGE (this forces a realignment/redraw by reseting the cache ax_background)
                    if self.autoChargeIdx and aw.qmc.timeindex[0] < 0:
                        self.markCharge() # we do not reset the autoChargeIdx to avoid another trigger
                        self.autoChargeIdx = 0

                    #auto mark TP/DRY/FCs/DROP
                    # we set marks already here to have the canvas, incl. the projections, immediately redrawn
                    if self.autoTPIdx != 0:
                        self.markTP()
                        self.autoTPIdx = 0
                    if self.autoDryIdx != 0:
                        self.markDryEnd()
                        self.autoDryIdx = 0
                    if self.autoFCsIdx != 0:
                        self.mark1Cstart()
                        self.autoFCsIdx = 0
                    if self.autoDropIdx > 0 and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6]:
                        self.markDrop() # we do not reset the autoDropIdx here to avoid another trigger
                        self.autoDropIdx = -1 # we set the autoDropIdx to a negative value to prevent further triggers after undo markDROP
                
                    ##### updated canvas
                    try:
                        if not self.block_update:
                            if self.tempory_sample_trigger_redraw:
                                self.tempory_sample_trigger_redraw = False
                                aw.qmc.redraw()
                            else:
                            #-- start update display
                                #### lock shared resources to ensure that no other redraw is interfering with this one here #####
                                aw.qmc.samplingsemaphore.acquire(1)
                                try:
                                    if self.ax_background:
                                        self.fig.canvas.restore_region(self.ax_background)
                                        # draw eventtypes
    # this seems not to be needed and hides partially event by value "Combo-type" annotations
    #                                    if self.eventsshowflag and self.eventsGraphflag in [2,3,4]:
    #                                        aw.qmc.ax.draw_artist(self.l_eventtype1dots)
    #                                        aw.qmc.ax.draw_artist(self.l_eventtype2dots)
    #                                        aw.qmc.ax.draw_artist(self.l_eventtype3dots)
    #                                        aw.qmc.ax.draw_artist(self.l_eventtype4dots)
                                        # draw delta lines
                                        
                                        if aw.qmc.swapdeltalcds:
                                            if self.DeltaBTflag and self.l_delta2 is not None:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_delta2)
                                                except:
                                                    pass
                                            if self.DeltaETflag and self.l_delta1 is not None:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_delta1)
                                                except:
                                                    pass
                                        else:
                                            if self.DeltaETflag and self.l_delta1 is not None:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_delta1)
                                                except:
                                                    pass
                                            if self.DeltaBTflag and self.l_delta2 is not None:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_delta2)
                                                except:
                                                    pass
                                        
                                        # draw extra curves
                                        xtra_dev_lines1 = 0
                                        xtra_dev_lines2 = 0
    
                                        try:
                                            for i in range(min(len(aw.extraCurveVisibility1),len(aw.extraCurveVisibility1),len(self.extratimex),len(self.extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(self.extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                                                if aw.extraCurveVisibility1[i] and len(self.extratemp1lines) > xtra_dev_lines1:
                                                    try:
                                                        aw.qmc.ax.draw_artist(self.extratemp1lines[xtra_dev_lines1])
                                                    except:
                                                        pass
                                                    xtra_dev_lines1 = xtra_dev_lines1 + 1
                                                if aw.extraCurveVisibility2[i] and len(self.extratemp2lines) > xtra_dev_lines2:
                                                    try:
                                                        aw.qmc.ax.draw_artist(self.extratemp2lines[xtra_dev_lines2])
                                                    except:
                                                        pass
                                                    xtra_dev_lines2 = xtra_dev_lines2 + 1
                                        except:
                                            pass
                                        if aw.qmc.swaplcds:
                                            # draw ET
                                            if aw.qmc.ETcurve:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_temp1)
                                                except:
                                                    pass
                                            # draw BT
                                            if aw.qmc.BTcurve:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_temp2)
                                                except:
                                                    pass
                                        else:
                                            # draw BT
                                            if aw.qmc.BTcurve:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_temp2)
                                                except:
                                                    pass
                                            # draw ET
                                            if aw.qmc.ETcurve:
                                                try:
                                                    aw.qmc.ax.draw_artist(self.l_temp1)
                                                except:
                                                    pass
                                        
                                        try:
                                            if aw.qmc.BTcurve:
                                                for a in self.l_annotations:
                                                    aw.qmc.ax.draw_artist(a)
                                        except:
                                            pass
                                        
                                        try:
                                            self.update_additional_artists()
                                        except:
                                            pass
                                            
                                        self.fig.canvas.blit(aw.qmc.ax.get_figure().bbox)
    
                                    else:
                                        # we do not have a background to bitblit, so do a full redraw
                                        self.updateBackground() # does the canvas draw, but also fills the ax_background cache 
                                        self.update_additional_artists()
                                finally:
                                    if aw.qmc.samplingsemaphore.available() < 1:
                                        aw.qmc.samplingsemaphore.release(1)
                            #-- end update display
                        
                        if aw.qmc.background and (aw.qmc.timeindex[0] > -1 or aw.qmc.timeindexB[0] < 0):
                            if aw.qmc.backgroundReproduce or aw.qmc.backgroundPlaybackEvents:
                                aw.qmc.playbackevent()
                            if aw.qmc.backgroundPlaybackDROP:
                                aw.qmc.playbackdrop()
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " updategraphics() {0}").format(str(e)),exc_tb.tb_lineno)  
                        
                    #####
                    if aw.qmc.patheffects:
                        rcParams['path.effects'] = []

                    #update phase lcds
                    aw.updatePhasesLCDs(updateLabels=False)
                        
                    #update AUC lcd
                    if aw.qmc.AUClcdFlag:
                        aw.updateAUCLCD()

                    #check if HUD is ON (done after self.fig.canvas.draw())
                    if self.HUDflag:
                        try:
                            aw.showHUD[aw.HUDfunction]()
                        except:
                            pass
                
                #check triggered alarms
                if self.temporaryalarmflag > -3:
                    i = self.temporaryalarmflag  # reset self.temporaryalarmflag before calling alarm
                    self.temporaryalarmflag = -3 # self.setalarm(i) can take longer to run than the sampling interval 
                    self.setalarm(i)

        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " updategraphics() {0}").format(str(e)),exc_tb.tb_lineno)


    def updateLCDtime(self):
        if self.flagstart and self.flagon:
            tx = self.timeclock.elapsed()/1000.
            nextreading = 1000. - 1000.*(tx%1.)
            try:
                if type(self.timeindex) is list and len(self.timeindex) == 8: # ensure we have a valid self.timeindex array
                
                    if self.timeindex[0] != -1 and type(self.timex) is list and len(self.timex) > self.timeindex[0]:
                        ts = tx - self.timex[self.timeindex[0]]
                    else:
                        ts = tx
        
                    # if more than max cool (from statistics) past DROP and not yet COOLend turn the time LCD red:
                    if aw.qmc.timeindex[0]!=-1 and aw.qmc.timeindex[6] and not aw.qmc.timeindex[7] and len(self.timex) > self.timeindex[6]:
                        aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%('#147bb3',aw.lcdpaletteB["timer"]))
        
                    timestr = self.stringfromseconds(ts)
                    aw.lcd1.display(timestr)
                    
                    # update connected WebLCDs
                    if aw.WebLCDs:
                        self.updateWebLCDs(time=timestr)
                    if aw.largeLCDs_dialog:
                        self.updateLargeLCDsTimeSignal.emit(timestr)
            finally:            
                QTimer.singleShot(nextreading,self.updateLCDtime)
    
    @pyqtSlot(bool)
    def toggleHUD(self,_=False):
        aw.soundpop()
        #OFF
        if self.HUDflag:
            self.HUDflag = False
            aw.HUD.clear()
#            aw.button_18.setStyleSheet("QPushButton { background-color: #b5baff }")
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["HUD_OFF"])
            aw.stack.setCurrentIndex(0)
            self.resetlines()
            aw.sendmessage(QApplication.translate("Message","HUD OFF", None))
            
        #ON
        else:
            self.redraw(False,False)
            #load
            img = self.grab()
            aw.HUD.setPixmap(img)
            self.HUDflag = True
#            aw.button_18.setStyleSheet("QPushButton { background-color: #60ffed }")
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["HUD_ON"])
            aw.stack.setCurrentIndex(1)
            aw.sendmessage(QApplication.translate("Message","HUD ON", None))

    def refreshHUD(self):
        aw.stack.setCurrentIndex(0)
        self.redraw(False,False)
        img = self.grab()
        aw.HUD.setPixmap(img)
        aw.stack.setCurrentIndex(1)            

    # redraws at least the canvas if redraw=True and force=True
    def timealign(self,redraw=True,recompute=False,force=False):
        try:
            ptime = None
            btime = None
            if aw.qmc.alignEvent in [6,7] and self.timeindexB[6] and self.timeindex[6]: # DROP
                ptime = self.timex[self.timeindex[6]]
                btime = self.timeB[self.timeindexB[6]]
            elif aw.qmc.alignEvent in [5,7] and self.timeindexB[5] and self.timeindex[5]: # SCe
                ptime = self.timex[self.timeindex[5]]
                btime = self.timeB[self.timeindexB[5]]
            elif aw.qmc.alignEvent in [4,7] and self.timeindexB[4] and self.timeindex[4]: # SCs
                ptime = self.timex[self.timeindex[4]]
                btime = self.timeB[self.timeindexB[4]]
            elif aw.qmc.alignEvent in [3,7] and self.timeindexB[3] and self.timeindex[3]: # FCe
                ptime = self.timex[self.timeindex[3]]
                btime = self.timeB[self.timeindexB[3]]
            elif aw.qmc.alignEvent in [2,7] and self.timeindexB[2] and self.timeindex[2]: # FCs
                ptime = self.timex[self.timeindex[2]]
                btime = self.timeB[self.timeindexB[2]]
            elif aw.qmc.alignEvent in [1,7] and self.timeindexB[1] and self.timeindex[1]: # DRY
                ptime = self.timex[self.timeindex[1]]
                btime = self.timeB[self.timeindexB[1]]
            elif self.timeindexB[0] != -1 and self.timeindex[0] != -1: # CHARGE
                ptime = self.timex[self.timeindex[0]]
                btime = self.timeB[self.timeindexB[0]]
            elif self.timeindexB[0] != -1: # if no foreground profile, align 0:00 to the CHARGE event of the background profile
                ptime = 0
                btime = self.timeB[self.timeindexB[0]]
            if ptime is not None and btime is not None:
                difference = ptime - btime
                if difference > 0:
                    self.movebackground("right",abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif difference < 0:
                    self.movebackground("left",abs(difference))
                    self.backmoveflag = 0
                    if redraw:
                        self.redraw(recompute)
                elif redraw and force: # ensure that we at least redraw the canvas
                    self.updateBackground()
            elif redraw and force: # only on aligning with CHARGE we redraw even if nothing is moved to redraw the time axis
                self.updateBackground()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " timealign() {0}").format(str(ex)),exc_tb.tb_lineno)

    # we count
    # - foreground curves
    # . ET/BT, even if not visible
    # . all visible extra curves
    # . all foreground event curves
    # - background curves
    # . background ET/BT, even if not visible
    # . 3rd background curve only if visible
    # . background event curves if not empty
    def lenaxlines(self):
        active_curves = len(self.extratimex)
        curves = aw.extraCurveVisibility1[0:active_curves] + aw.extraCurveVisibility2[0:active_curves] + [aw.qmc.ETcurve,aw.qmc.BTcurve]
        c = curves.count(True)
        if aw.qmc.background:
            c += 2 # those are alwyays populated
            if aw.qmc.xtcurveidx > 0: # 3rd background curve set?
                idx3 = aw.qmc.xtcurveidx - 1
                n3 = idx3 // 2
                if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                    c += 1
            if aw.qmc.backgroundeventsflag and aw.qmc.eventsGraphflag in [2,3,4]:
                unique_etypes = set(aw.qmc.backgroundEtypes)
                # only those background event lines exists that are active and hold events
                active_background_events = list(map(lambda e : e < 4 and aw.qmc.showEtypes[e],unique_etypes)) # we remove the "untyped" event as this is only drawn as annotation
                c += sum(active_background_events)
        if aw.qmc.eventsshowflag and aw.qmc.eventsGraphflag in [2,3,4]:
            c += 4 # the foreground event lines (in contrast to the background ones) are always all present in those modes
        return c

    # we count
    # - deltaET if visible
    # - deltaBT if visible
    # - background deltaET if visible
    # - background deltaBT if visible
    def lendeltaaxlines(self):
        linecount = 0 
        if self.DeltaETflag:
            linecount += 1
        if  self.DeltaBTflag:
            linecount += 1
        if aw.qmc.background:
            if self.DeltaETBflag:
                linecount += 1
            if self.DeltaBTBflag:
                linecount += 1
        return linecount

    def resetlinecountcaches(self):
        aw.qmc.linecount = None
        aw.qmc.deltalinecount = None


# delta lines are now drawn on the main ax
    def resetlines(self):
        #note: delta curves are now in self.delta_ax and have been removed from the count of resetlines()
        if self.linecount is None:
            self.linecount = self.lenaxlines()
        if self.deltalinecount is None:
            self.deltalinecount = self.lendeltaaxlines()
        self.ax.lines = self.ax.lines[0:(self.linecount+self.deltalinecount)]

# delta lines are now drawn on the main ax
    def resetdeltalines(self):
        if self.deltalinecount is None:
            self.deltalinecount = self.lendeltaaxlines()
        if self.delta_ax:
            self.delta_ax.lines = []

    def setalarm(self,alarmnumber):
        self.alarmstate[alarmnumber] = max(0,len(self.timex) - 1) # we have to ensure that alarmstate of triggered alarms is never negativ
        
        aw.sendmessage(QApplication.translate("Message","Alarm {0} triggered", None).format(alarmnumber + 1))
        if not self.silent_alarms:
            if len(self.alarmbeep) > alarmnumber and self.alarmbeep[alarmnumber]:
                QApplication.beep()
            try:
                if self.alarmaction[alarmnumber] == 0:
                    # alarm popup message with 10sec timeout
                    amb = ArtisanMessageBox(aw,QApplication.translate("Message", "Alarm notice",None),u(self.alarmstrings[alarmnumber]),timeout=aw.qmc.alarm_popup_timout,modal=False)
                    amb.show()
                    #send alarm also to connected WebLCDs clients
                    if aw.WebLCDs and aw.WebLCDsAlerts:
                        aw.qmc.updateWebLCDs(alertText=u(self.alarmstrings[alarmnumber]),alertTimeout=10)
                elif self.alarmaction[alarmnumber] == 1:
                    # alarm call program
                    fname = u(self.alarmstrings[alarmnumber].split('#')[0])
    # take care, the QDir().current() directory changes with loads and saves                
    #                QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + fname, QUrl.TolerantMode))
                    if False and platf == 'Windows': # this Windows version fails on commands with arguments
                        f = "file:///{}/{}".format(u(QApplication.applicationDirPath()),u(fname))
                        res = QDesktopServices.openUrl(QUrl(f, QUrl.TolerantMode))
                    else:
                        # MacOS X: script is expected to sit next to the Artisan.app or being specified with its full path
                        # Linux: script is expected to sit next to the artisan binary or being specified with its full path
                        #
                        # to get the effect of speaking alarms a text containing the following two lines called "say.sh" could do
                        #                #!/bin/sh
                        #                say "Hello" &
                        # don't forget to do
                        #                # cd 
                        #                # chmod +x say.sh
                        #
                        # alternatively use "say $@ &" as command and send text strings along
                        # Voices:
                        #  -v Alex (male english)
                        #  -v Viki (female english)
                        #  -v Victoria (female english)
                        #  -v Yannick (male german)
                        #  -v Anna (female german)
                        #  -v Paolo (male italian)
                        #  -v Silvia (female italian)
                        aw.call_prog_with_args(fname)
                        res = True
                    if res:
                        aw.sendmessage(QApplication.translate("Message","Alarm is calling: {0}",None).format(fname))
                    else:
                        aw.qmc.adderror(QApplication.translate("Message","Calling alarm failed on {0}",None).format(f))
                elif self.alarmaction[alarmnumber] == 2:
                    # alarm event button
                    button_number = None
                    text = self.alarmstrings[alarmnumber].split('#')[0]
                    bnrs = text.split(',')
                    for bnr in bnrs:
                        try:
                            button_number = int(str(bnr.strip())) - 1 # the event buttons presented to the user are numbered from 1 on
                        except Exception:
                            aw.sendmessage(QApplication.translate("Message","Alarm trigger button error, description '{0}' not a number",None).format(u(self.alarmstrings[alarmnumber])))
                        if button_number is not None:
                            if button_number > -1 and button_number < len(aw.buttonlist):
                                aw.recordextraevent(button_number)
                elif self.alarmaction[alarmnumber] in [3,4,5,6]:
                    # alarm slider 1-4
                    slidernr = None
                    try:
                        text = self.alarmstrings[alarmnumber].split('#')[0].strip()
                        if self.alarmaction[alarmnumber] == 3:
                            slidernr = 0
                        elif self.alarmaction[alarmnumber] == 4:
                            slidernr = 1
                        elif self.alarmaction[alarmnumber] == 5:
                            slidernr = 2
                        elif self.alarmaction[alarmnumber] == 6:
                            slidernr = 3
                        if slidernr is not None:
                            slidervalue = max(aw.eventslidermin[slidernr],min(aw.eventslidermax[slidernr],int(str(text))))
                            aw.moveslider(slidernr,slidervalue)
                            # we set the last value to be used for relative +- button action as base
                            aw.extraeventsactionslastvalue[slidernr] = int(round(slidervalue))
                            if aw.qmc.flagstart:
                                value = aw.float2float((slidervalue + 10.0) / 10.0)
                                aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,eventdescription=str("A%d (S%d)"%(alarmnumber,slidernr)))
                            aw.fireslideraction(slidernr)
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " setalarm() {0}").format(str(e)),exc_tb.tb_lineno)
                        aw.sendmessage(QApplication.translate("Message","Alarm trigger slider error, description '{0}' not a valid number [0-100]",None).format(u(self.alarmstrings[alarmnumber])))
                        
                elif self.alarmaction[alarmnumber] == 7:
                    # START
                    if aw.button_2.isEnabled():
                        aw.qmc.ToggleRecorder()
                elif self.alarmaction[alarmnumber] == 8:
                    # DRY
                    #if aw.button_19.isEnabled():
                    #    aw.qmc.markDryEnd()
                    aw.qmc.autoDryIdx = len(aw.qmc.timex)
                elif self.alarmaction[alarmnumber] == 9:
                    # FCs
                    #if aw.button_3.isEnabled():
                    #    aw.qmc.mark1Cstart()
                    aw.qmc.autoFCsIdx = len(aw.qmc.timex)
                elif self.alarmaction[alarmnumber] == 10:
                    # FCe
                    if aw.button_4.isEnabled():
                        aw.qmc.mark1Cend()
                elif self.alarmaction[alarmnumber] == 11:
                    # SCs
                    if aw.button_5.isEnabled():
                        aw.qmc.mark2Cstart()
                elif self.alarmaction[alarmnumber] == 12:
                    # SCe
                    if aw.button_6.isEnabled():
                        aw.qmc.mark2Cend()
                elif self.alarmaction[alarmnumber] == 13:
                    # DROP
                    #if aw.button_9.isEnabled():
                    #    aw.qmc.markDrop()
                    aw.qmc.autoDropIdx = len(aw.qmc.timex)
                elif self.alarmaction[alarmnumber] == 14:
                    # COOL
                    if aw.button_20.isEnabled():
                        aw.qmc.markCoolEnd()
                elif self.alarmaction[alarmnumber] == 15:
                    # OFF
                    if aw.button_1.isEnabled():
                        aw.qmc.ToggleMonitor()
                elif self.alarmaction[alarmnumber] == 16:
                    # CHARGE
                    aw.qmc.autoChargeIdx = len(aw.qmc.timex)
                elif self.alarmaction[alarmnumber] == 17 and aw.qmc.Controlbuttonflag:
                    # RampSoak ON
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setrampsoak(1)
                    elif aw.pidcontrol: # internal or external MODBUS PID control
                        aw.pidcontrol.svMode = 1
                        aw.pidcontrol.pidOn()
                elif self.alarmaction[alarmnumber] == 18 and aw.qmc.Controlbuttonflag:
                    # RampSoak OFF
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setrampsoak(0)
                    elif aw.pidcontrol:  # internal or external MODBUS PID control
                        aw.pidcontrol.svMode = 0
                        aw.pidcontrol.pidOff()
                elif self.alarmaction[alarmnumber] == 19 and aw.qmc.Controlbuttonflag:
                    # PID ON
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setONOFFstandby(0)
                    elif aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        aw.pidcontrol.pidOn()
                elif self.alarmaction[alarmnumber] == 20 and aw.qmc.Controlbuttonflag:
                    # PID OFF
                    if aw.qmc.device == 0 and aw.fujipid: # FUJI PID
                        aw.fujipid.setONOFFstandby(1)
                    elif aw.pidcontrol: # internal or external MODBUS PID control or Arduino TC4 PID
                        aw.pidcontrol.pidOff()
                elif self.alarmaction[alarmnumber] == 21:
                    # SV slider alarm
                    try:
                        text = self.alarmstrings[alarmnumber].split('#')[0]
                        sv = float(str(text))
                        if aw.qmc.device == 0:
                            if sv is not None and sv != aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                #aw.qmc.temporarysetsv = sv
                                aw.fujipid.setsv(sv,silent=True)
                        elif aw.pidcontrol.pidActive:
                            if sv is not None and sv != aw.pidcontrol.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                #aw.qmc.temporarysetsv = sv
                                aw.pidcontrol.setSV(sv,init=False)
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " setalarm() {0}").format(str(e)),exc_tb.tb_lineno)
                        aw.sendmessage(QApplication.translate("Message","Alarm trigger SV slider error, description '{0}' not a valid number",None).format(u(self.alarmstrings[alarmnumber])))
                elif self.alarmaction[alarmnumber] == 22:
                    # Playback ON
                    aw.qmc.backgroundPlaybackEvents = True
                elif self.alarmaction[alarmnumber] == 23:
                    # Playback OFF
                    aw.qmc.backgroundPlaybackEvents = False
                elif self.alarmaction[alarmnumber] == 24:
                    # Set Canvas Color
                    c = self.alarmstrings[alarmnumber].strip()
                    try:
                        QColor(c) # test if color is valid
                        aw.qmc.palette["canvas_alt"] = aw.qmc.palette["canvas"]
                        aw.qmc.palette["canvas"] = c
                        aw.updateCanvasColors()
                        aw.qmc.redraw()
                        QApplication.processEvents() # needed to establish the change
                    except Exception:
                        pass
                elif self.alarmaction[alarmnumber] == 25:
                    # Reset Canvas Color
                    if "canvas_alt" in aw.qmc.palette:
                        aw.qmc.palette["canvas"] = aw.qmc.palette["canvas_alt"]
                        aw.updateCanvasColors()
                        aw.qmc.redraw()
                        QApplication.processEvents()
    
            except Exception as ex:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " setalarm() {0}").format(str(ex)),exc_tb.tb_lineno)

    # called only after CHARGE
    def playbackdrop(self):
        try:
            #needed when using device NONE
            if len(self.timex) and self.timeindexB[6] and not self.timeindex[6]:
                if ((aw.qmc.replayType == 0 and self.timeB[self.timeindexB[6]] - self.timeclock.elapsed()/1000. <= 0) or # by time
                    (aw.qmc.replayType == 1 and aw.qmc.TPalarmtimeindex and self.stemp2B[self.timeindexB[6]] - self.ctemp2[-1] <= 0) or # by BT
                    (aw.qmc.replayType == 2 and aw.qmc.TPalarmtimeindex and self.stemp21[self.timeindexB[6]] - self.ctemp1[-1] <= 0)): # by ET
                    aw.qmc.autoDropIdx = len(aw.qmc.timex) - 2
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " playbackdrop() {0}").format(str(ex)),exc_tb.tb_lineno)
        
    # called only after CHARGE
    def playbackevent(self):
        try:
            reproducing = None # index of the event that is currently replaying (surpress other replays in this round)
            #needed when using device NONE
            if len(self.timex):
                #find time or temp distances
                slider_events = {} # keep event type value pairs to move sliders (but only once per slider and per interval!)
                next_byTemp_checked = False # we take care to reply events by temperature in order!
                for i in range(len(self.backgroundEvents)):
                    if i not in aw.qmc.replayedBackgroundEvents: # never replay one event twice
                        timed = self.timeB[self.backgroundEvents[i]] - self.timeclock.elapsed()/1000.
                        if aw.qmc.replayType == 0: # replay by time
                            delta = timed
                        elif not next_byTemp_checked and aw.qmc.replayType == 1: # replay by BT (after TP)
                            if aw.qmc.TPalarmtimeindex:
                                delta = self.stemp2B[self.backgroundEvents[i]] - self.ctemp2[-1]
                            else: # before TP we switch back to time-based
                                delta = timed
                            next_byTemp_checked = True
                        elif not next_byTemp_checked and aw.qmc.replayType == 2: # replay by ET (after TP)
                            if aw.qmc.TPalarmtimeindex:
                                delta = self.stemp1B[self.backgroundEvents[i]] - self.ctemp1[-1]
                            else: # before TP we switch back to time-based
                                delta = timed
                            next_byTemp_checked = True
                        else:
                            delta = 1 # don't trigger this one
                        if reproducing is None and aw.qmc.backgroundReproduce and timed > 0 and timed < self.detectBackgroundEventTime:
                            if i not in aw.qmc.beepedBackgroundEvents and aw.qmc.backgroundReproduceBeep:
                                aw.qmc.beepedBackgroundEvents.append(i)
                                QApplication.beep()
                            #write text message
                            message = "> [{}] [{}] : <b>{}</b> : {}".format(
                                u(self.Betypesf(self.backgroundEtypes[i])),
                                self.eventsvalues(self.backgroundEvalues[i]),
                                self.stringfromseconds(timed),
                                self.backgroundEStrings[i])
                            #rotate colors to get attention
                            if int(round(timed))%2:
                                style = "background-color:'transparent';"
                            else:
                                style = "background-color:'yellow';"
                                
                            aw.sendmessage(message,style=style)
                            reproducing = i

                        if delta <= 0:
                            #for devices that support automatic roaster control
                            #if Fuji PID
                            if self.device == 0:

                                # COMMAND SET STRINGS
                                #  (adjust the SV PID to the float VALUE1)
                                # SETRS::VALUE1::VALUE2::VALUE3  (VALUE1 = target SV. float VALUE2 = time to reach int VALUE 1 (ramp) in minutes. int VALUE3 = hold (soak) time in minutes)

                                # IMPORTANT: VALUES are for controlling ET only (not BT). The PID should control ET not BT. The PID should be connected to ET only.
                                # Therefore, these values don't reflect a BT defined profile. They define an ET profile.
                                # They reflect the changes in ET, which indirectly define BT after some time lag
    
                                # There are two ways to record a roast. One is by changing Set Values (SV) during the roast,
                                # the other is by using ramp/soaks segments (RS). 
                                # Examples:
    
                                # SETSV::560.3           sets an SV value of 560.3F in the PID at the time of the recorded background event
    
                                # SETRS::440.2::2::0     starts Ramp Soak mode so that it reaches 440.2F in 2 minutes and holds (soaks) 440.2F for zero minutes
    
                                # SETRS::300.0::2::3::SETRS::540.0::6::0::SETRS::560.0::4::0::SETRS::560::0::0
                                #       this command has 4 comsecutive commands inside (4 segments)
                                #       1 SETRS::300.0::2::3 reach 300.0F in 2 minutes and hold it for 3 minutes (ie. total dry phase time = 5 minutes)
                                #       2 SETRS::540.0::6::0 then reach 540.0F in 6 minutes and hold it there 0 minutes (ie. total mid phase time = 6 minutes )
                                #       3 SETRS::560.0::4::0 then reach 560.0F in 4 minutes and hold it there 0 minutes (ie. total finish phase time = 4 minutes)
                                #       4 SETRS::560::0::0 then do nothing (because ramp time and soak time are both 0)
                                #       END ramp soak mode
    
                                if "::" in self.backgroundEStrings[i]:
                                    aw.fujipid.replay(self.backgroundEStrings[i])
                                    libtime.sleep(.5)  #avoid possible close times (rounding off)
                            
                            
                            # if playbackevents is active, we fire the event by moving the slider, but only if
                            # a event type is given (type!=4), the background event type is named exactly as the one of the foreground
                            # the event slider is active/visible and has an action defined
                            if aw.qmc.backgroundPlaybackEvents and self.backgroundEtypes[i] < 4 and \
                                (u(self.etypesf(self.backgroundEtypes[i]) == u(self.Betypesf(self.backgroundEtypes[i])))) and \
                                aw.eventslidervisibilities[self.backgroundEtypes[i]]: #  and aw.eventslideractions[self.backgroundEtypes[i]]
                                slider_events[self.backgroundEtypes[i]] = self.eventsInternal2ExternalValue(self.backgroundEvalues[i]) # add to dict (later overwrite earlier slider moves!)
                                # we move sliders only after processing all pending events (from the collected dict)
                                #aw.moveslider(self.backgroundEtypes[i],self.eventsInternal2ExternalValue(self.backgroundEvalues[i])) # move slider and update slider LCD
                                #aw.sliderReleased(self.backgroundEtypes[i],force=True) # record event

                            aw.qmc.replayedBackgroundEvents.append(i) # in any case we mark this event as processed

                # now move the sliders to the new values (if any)
                for k in slider_events.keys():
                    aw.moveslider(k,slider_events[k])
                    aw.sliderReleased(k,force=True)
                                
                #delete existing message
                if reproducing is None:
                    text = u(aw.messagelabel.text())
                    if len(text):
                        if text[0] == ">":
                            aw.clearMessageLine(style="background-color:'transparent';")
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " playbackevent() {0}").format(str(ex)),exc_tb.tb_lineno)

    #make a projection of change of rate of BT on the graph
    def updateProjection(self):
        try:
            if len(aw.qmc.ctemp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
                #self.resetlines()
                if self.timeindex[0] != -1:
                    starttime = self.timex[self.timeindex[0]]
                else:
                    starttime = 0
                if self.projectionmode == 0:
                    #calculate the temperature endpoint at endofx acording to the latest rate of change
                    if self.l_BTprojection is not None:
                        if aw.qmc.BTcurve and len(aw.qmc.delta2) > 0 and aw.qmc.delta2[-1] is not None and len(self.ctemp2) > 0:
                            BTprojection = self.ctemp2[-1] + aw.qmc.delta2[-1]*(self.endofx - self.timex[-1]+ starttime)/60.
                            #plot projections
                            self.l_BTprojection.set_data([self.timex[-1],self.endofx+starttime], [self.ctemp2[-1], BTprojection])
                        elif self.l_BTprojection:
                            self.l_BTprojection.set_data([],[])
                    if self.l_ETprojection is not None:
                        if aw.qmc.ETcurve and len(aw.qmc.delta1) > 0 and aw.qmc.delta1[-1] is not None and len(self.ctemp1) > 0:
                            ETprojection = self.ctemp1[-1] + aw.qmc.delta1[-1]*(self.endofx - self.timex[-1]+ starttime)/60.
                            self.l_ETprojection.set_data([self.timex[-1],self.endofx+starttime], [self.ctemp1[-1], ETprojection])
                        elif self.l_ETprojection:
                            self.l_ETprojection.set_data([],[])
                elif self.projectionmode == 1:
                    # Under Test. Newton's Law of Cooling
                    # This comes from the formula of heating (with ET) a cool (colder) object (BT).
                    # The difference equation (discrete with n elements) is: DeltaT = T(n+1) - T(n) = K*(ET - BT)
                    # The formula is a natural decay towards ET. The closer BT to ET, the smaller the change in DeltaT
                    # projectionconstant is a multiplier factor. It depends on
                    # 1 Damper or fan. Heating by convection is _faster_ than heat by conduction,
                    # 2 Mass of beans. The heavier the mass, the _slower_ the heating of BT
                    # 3 Gas or electric power: gas heats BT _faster_ because of hoter air.
                    # Every roaster will have a different constantN (self.projectionconstant).

                    den = self.ctemp1[-1] - self.ctemp2[-1]  #denominator ETn - BTn 
                    if den > 0 and len(aw.qmc.delta2)>0 and aw.qmc.delta2[-1]: # if ETn > BTn
                        #get x points
                        xpoints = list(numpy.arange(self.timex[-1],self.endofx + starttime, self.delay/1000.))  #do two minutes after endofx (+ 120 seconds); why? now +starttime
                        #get y points
                        ypoints = [self.ctemp2[-1]]                                  # start initializing with last BT
                        K =  self.projectionconstant*aw.qmc.delta2[-1]/den/60.                 # multiplier
                        for _ in range(len(xpoints)-1):                                     # create new points from previous points
                            DeltaT = K*(self.ctemp1[-1]- ypoints[-1])                        # DeltaT = K*(ET - BT)
                            ypoints.append(ypoints[-1]+ DeltaT)                             # add DeltaT to the next ypoint

                        #plot ET level (straight line) and BT curve
                        if self.l_ETprojection is not None:
                            self.l_ETprojection.set_data([self.timex[-1],self.endofx + starttime], [self.ctemp1[-1], self.ctemp1[-1]])
                        if self.l_BTprojection is not None:
                            self.l_BTprojection.set_data(xpoints, ypoints)
                    else:
                        if self.l_ETprojection:
                            self.l_ETprojection.set_data([],[])
                        if self.l_BTprojection:
                            self.l_BTprojection.set_data([],[])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " updateProjection() {0}").format(str(ex)),exc_tb.tb_lineno)

    # this function is called from the HUD DLg and reports the linear time (straight line) it would take to reach a temperature target
    # acording to the current rate of change
    def getTargetTime(self):

        if self.rateofchange1 > 0:
            ETreachTime = (self.ETtarget - self.temp1[-1])/(self.rateofchange1/60.)
            ET2reachTime = (self.ET2target - self.temp1[-1])/(self.rateofchange1/60.)
        else:
            ETreachTime = -1
            ET2reachTime = -1
            
        if self.rateofchange2 > 0:
            BTreachTime = (self.BTtarget - self.temp2[-1])/(self.rateofchange2/60.)
            BT2reachTime = (self.BT2target - self.temp2[-1])/(self.rateofchange2/60.)
        else:
            BTreachTime = -1
            BT2reachTime = -1

        return ETreachTime, BTreachTime, ET2reachTime, BT2reachTime

    # takes array with readings, the current index, the sign of the shift as character and the shift value
    # returns val, evalsign
    def shiftValueEvalsign(self,readings,index,sign,shiftval):
        if sign == "-": #  ie. original [1,2,3,4,5,6]; shift right 2 = [1,1,1,2,3,4]
            evalsign = "0"      # "-" becomes digit "0" for python eval compatibility
            shiftedindex = index - shiftval
        elif sign == "+": #"+" original [1,2,3,4,5,6]; shift left 2  = [3,4,5,6,6,6]
            evalsign = "1"      #digit 1 = "+"
            shiftedindex = index + shiftval
        if len(readings) > 0:
            if shiftedindex >= len(readings):
                shiftedindex = len(readings)- 1
            if shiftedindex < 0:
                shiftedindex = 0
            return readings[shiftedindex], evalsign
        else:
            return 0, evalsign

    # mathexpression = formula; t = a number to evaluate(usually time);
    # equeditnumber option = plotter edit window number; RTsname = option RealTime var name; RTsval = RealTime var val
    # The given mathexpression has to be a non-empty string!
    def eval_math_expression(self,mathexpression,t,equeditnumber=None, RTsname=None,RTsval=None,t_offset=0):
        if len(mathexpression):
            mathdictionary = {"min":min,"max":max,"sin":math.sin,"cos":math.cos,"tan":math.tan,"pow":math.pow,"exp":math.exp,"pi":math.pi,"e":math.e,
                              "abs":abs,"acos":math.acos,"asin":math.asin,"atan":math.atan,"log":math.log,"radians":math.radians,
                              "sqrt":math.sqrt,"degrees":math.degrees}
            #if sampling 
            if RTsname is not None and RTsname != "":
                if len(self.timex):
                    index = len(self.timex)-1
                else:
                    index = 0
                #load real time buffers acquired at sample() to the dictionary
                mathdictionary["Y1"] = self.RTtemp1 # ET
                mathdictionary["Y2"] = self.RTtemp2 # BT

                mathdictionary["R1"] = self.rateofchange1 # ET RoR
                mathdictionary["R2"] = self.rateofchange2 # BT RoR

                for d in range(len(self.RTextratemp1)):
                    mathdictionary["Y%i"%(d*2+3)] = self.RTextratemp1[d]
                    mathdictionary["Y%i"%(d*2+4)] = self.RTextratemp2[d]
                if str(RTsname) not in mathdictionary:
                    mathdictionary[str(RTsname)] = float(RTsval)

            else: # get index from the time.
                if len(self.timex):
                    index = self.time2index(t)  # If using the plotter with loaded profile. Background index done bellow at "B"
                else:
                    index = 0      #if plotting but nothing loaded.
            #if background
            if self.background and "B" in mathexpression:
                bindex = self.backgroundtime2index(t)         #use background time

            replacements = {'+':'p','-':'m','*':'m','/':'d','(':'o',')':'c'} # characters to be replaced from symb variable for substitution
            
            #symbolic variables holding the index of main events from self.timeindex to be used to retrieve time and temp data from the corresponding t and Y variables
            #using the absolute access symbolic variables t{<i>} and Y{<i>} defined below
            #those variable are set to the error item -1 if no index is yet available
            
            main_events = ["CHARGE","DRY","FCs","FCe","SCs","SCe","DROP", "COOL"]
            for i,v in enumerate(main_events):
                if (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0):
                    mathdictionary[v] = self.timeindex[i]
                else:
                    mathdictionary[v] = -1

            if self.background:
                background_main_events = ["bCHARGE","bDRY","bFCs","bFCe","bSCs","bSCe","bDROP", "bCOOL"]
                for i,v in enumerate(background_main_events):
                    if (i == 0 and self.timeindexB[i] > -1) or (self.timeindexB[i] > 0):
                        mathdictionary[v] = self.timeindexB[i]
                    else:
                        mathdictionary[v] = -1

            # time in seconds after those events. If an event was not issued yet this evaluates to 0
            delta_main_events = ["dCHARGE","dDRY","dFCs","dFCe","dSCs","dSCe","dDROP", "dCOOL"]
            try:
                for i,v in enumerate(delta_main_events):
                    if (i == 0 and self.timeindex[i] > -1) or (self.timeindex[i] > 0):
                        # we return the time after the event in seconds
                        mathdictionary[v] = self.timex[-1] - self.timex[self.timeindex[i]]
                    else:
                        # before the event we return 0
                        mathdictionary[v] = 0
            except:
                pass

            # prediction of the time to DRY and FCs before the event
            # this evaluates to None before TP and 0 after the event
            try:
                for v in ["pDRY","pFCs"]:
                    if len(self.delta2) > 0 and self.delta2[-1] and self.delta2[-1] > 0:
                        mathdictionary[v] = 0
                        if v == "pDRY":
                            if self.background and self.timeindexB[1] and not self.autoDRYflag: # with AutoDRY, we always use the set DRY phase temperature as target
                                drytarget = self.temp2B[self.timeindexB[1]] # Background DRY BT temperature
                            else:
                                drytarget = self.phases[1] # Drying max phases definition
                            if drytarget > self.temp2[-1]:
                                mathdictionary[v] = (drytarget - self.temp2[-1])/(self.delta2[-1]/60.)
                        elif v == "pFCs":
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.background and self.timeindexB[2]:
                                fcstarget = self.temp2B[self.timeindexB[2]] # Background FCs BT temperature
                            else:
                                fcstarget = self.phases[2] # FCs min phases definition
                            if fcstarget > self.temp2[-1]:
                                mathdictionary[v] = (fcstarget - self.temp2[-1])/(self.delta2[-1]/60.)
                    else:
                        # if a prediction is not possible (before TP), we return the error value -1
                        mathdictionary[v] = -1
            except:
                pass

            # add AUC variables (AUCbase, AUCtarget, AUCvalue)
            try:
                mathdictionary["AUCvalue"] = self.AUCvalue
                if self.AUCbaseFlag:
                    if self.AUCbegin == 0 and self.timeindex[0] > -1: # start after CHARGE
                        idx = self.timeindex[0]
                    elif self.AUCbegin == 1 and self.TPalarmtimeindex: # start ater TP
                        idx = self.TPalarmtimeindex
                    elif self.AUCbegin == 2 and self.timeindex[1] > 0: # DRY END
                        idx = self.timeindex[1]
                    elif self.AUCbegin == 3 and self.timeindex[2] > 0: # FC START
                        idx = self.timeindex[2]
                    else:
                        idx = -1
                    if idx > -1: # we passed the AUCbegin event
                        mathdictionary["AUCbase"] = self.temp2[idx]
                    else:
                        mathdictionary["AUCbase"] = None # Event not set yet, no AUCbase
                else:
                    mathdictionary["AUCbase"] = self.AUCbase
                if self.AUCtargetFlag and self.background and self.AUCbackground > 0:
                    mathdictionary["AUCtarget"] = self.AUCbackground
                else:
                    mathdictionary["AUCtarget"] = self.AUCtarget
            except:
                pass

            #timeshift working vars 
            timeshiftexpressions = []           #holds strings like "Y10040" as explained below
            timeshiftexpressionsvalues = []     #holds the evaluated values (float) for the above

            try:
                t = float(t)
                #extract Ys
                Yval = []                   #stores value number example Y9 = 9
                mlen = len(mathexpression)
                for i in range(mlen):
                    #Start symbolic assignment
                    #Y + one digit
                    if mathexpression[i] == "Y":
                        #find Y number for ET,BT,Extras (upto 9)
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                seconddigitstr = ""
                                if i+2 < mlen and mathexpression[i+2].isdigit():
                                    offset = 1
                                    nint = int(mathexpression[i+1]+mathexpression[i+2])  # two digits Ynumber int
                                else:
                                    offset = 0
                                    nint = int(mathexpression[i+1])                      # one digit Ynumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]" 
                                if i+5+offset < mlen and mathexpression[i+2+offset] == "[":
                                    Yshiftval = int(mathexpression[i+offset+4])
                                    sign = mathexpression[i+offset+3]

                                    #timeshift with two digits
                                    if mathexpression[i+offset+5].isdigit():
                                        seconddigitstr = mathexpression[i+offset+5]
                                        mathexpression = mathexpression[:i+offset+5]+mathexpression[i+offset+6:]
                                        Yshiftval = 10*Yshiftval + int(seconddigitstr)
                                    
                                    if nint == 1: #ET
                                        readings = self.temp1
                                    elif nint == 2: #BT
                                        readings = self.temp2
                                    elif nint > 2: 
                                        #map the extra device
                                        edindex = (nint-1)//2 - 1
                                        if nint%2:
                                            readings = self.extratemp1[edindex]
                                        else:
                                            readings = self.extratemp2[edindex]
                                    val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)

                                    #add expression and values found
                                    evaltimeexpression = "Y{}{}{}{}{}".format(mathexpression[i+1:i+2+offset],evalsign*2,mathexpression[i+offset+4],seconddigitstr,evalsign)
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    #convert "Y2[+9]" to Ynumber compatible for python eval() to add to dictionary
                                    #METHOD USED: replace all non digits chars with sign value.
                                    #Example1 "Y2[-7]" = "Y20070"   Example2 "Y2[+9]" = "Y21191"
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+offset+6:]))
                                #direct index access: e.g. "Y2{CHARGE}" or "Y2{12}"
                                elif i+5+offset < len(mathexpression) and mathexpression[i+offset+2] == "{" and mathexpression.find("}",i+offset+3) > -1:
                                    end_idx = mathexpression.index("}",i+offset+3)
                                    body = mathexpression[i+3:end_idx]
                                    val = -1
                                    try:
                                        absolute_index = eval(body,{"__builtins__":None},mathdictionary)
                                        if absolute_index > -1:
                                            if nint == 1: #ET
                                                val = self.temp1[absolute_index]
                                            elif nint == 2: #BT
                                                val = self.temp2[absolute_index]
                                            elif nint > 2: 
                                                #map the extra device
                                                edindex = (nint-1)//2 - 1
                                                if nint%2:
                                                    val = self.extratemp1[edindex][absolute_index]
                                                else:
                                                    val = self.extratemp2[edindex][absolute_index]
                                    except:
                                        pass
                                    #add expression and values found
                                    literal_body = body
                                    for k, v in replacements.items():
                                        literal_body = literal_body.replace(k,v)
                                    evaltimeexpression = "Y{}u{}u".format(mathexpression[i+1],literal_body) # curle brackets replaced by "u"
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                # Y + TWO digits. Y10-Y99 . 4+ extra devices. No timeshift
                                elif i+2 < mlen and mathexpression[i+2].isdigit():
                                    Yval.append(mathexpression[i+1]+mathexpression[i+2])
                                # No timeshift Y1,Y2,Y3,etc.
                                else:
                                    Yval.append(mathexpression[i+1])

                    #the actual value
                    elif mathexpression[i] == "x":
                        if "x" not in mathdictionary:
                            if RTsval is not None:                   # zero could be a valid value
                                mathdictionary['x'] = RTsval         # add x to the math dictionary
                            else:
                                mathdictionary['x'] = -1
                                
                    #the factor to plot C/min delta_ax values on the standard temperature axis
                    elif mathexpression[i] == "k":
                        if "k" not in mathdictionary:
                            try:
                                mathdictionary['k'] = (aw.qmc.ylimit - aw.qmc.ylimit_min) / float(aw.qmc.zlimit - aw.qmc.zlimit_min)
                            except Exception:
                                mathdictionary['k'] = 1
                                
                    #the offset to plot C/min delta_ax values on the standard temperature axis 
                    elif mathexpression[i] == "o":
                        if "o" not in mathdictionary:
                            try:
                                mathdictionary['o'] = aw.qmc.ylimit_min - (aw.qmc.zlimit_min * (aw.qmc.ylimit - aw.qmc.ylimit_min) / float(aw.qmc.zlimit - aw.qmc.zlimit_min))
                            except Exception:
                                mathdictionary['o'] = 0
                                
                    elif mathexpression[i] == "R":
                        try:
                            if i+1 < mlen:
                                seconddigitstr = ""
                                if mathexpression[i+1].isdigit():
                                    nint = int(mathexpression[i+1])              #Rnumber int
                                    #check for TIMESHIFT 0-9 (one digit). Example: "R1[-2]" 
                                    if i+5 < len(mathexpression) and mathexpression[i+2] == "[":
                                        Yshiftval = int(mathexpression[i+4])
                                        sign = mathexpression[i+3]

                                        # TWO digits shifting
                                        if mathexpression[i+5].isdigit():
                                            seconddigit = int(mathexpression[i+5])
                                            seconddigitstr = mathexpression[i+5]
                                            mathexpression = mathexpression[:i+5]+mathexpression[i+6:]
                                            Yshiftval = 10*Yshiftval + seconddigit
                                        if nint == 1: #DeltaET
                                            readings = self.delta1
                                        elif nint == 2: #DeltaBT
                                            readings = self.delta2
                                        val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)
                                        
                                        #add expression and values found
                                        evaltimeexpression = "".join(("R",mathexpression[i+1],evalsign*2,mathexpression[i+4],seconddigitstr,evalsign))
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        #convert "R2[+9]" to Rnumber compatible for python eval() to add to dictionary
                                        #METHOD USED: replace all non digits chars with sign value.
                                        #Example1 "R2[-7]" = "R20070"   Example2 "R2[+9]" = "R21191"
                                        mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                    
                                    #direct index access: e.g. "R2{CHARGE}" or "R2{12}"
                                    elif i+5 < len(mathexpression) and mathexpression[i+2] == "{" and mathexpression.find("}",i+3) > -1:
                                        end_idx = mathexpression.index("}",i+3)
                                        body = mathexpression[i+3:end_idx]
                                        val = -1
                                        try:
                                            absolute_index = eval(body,{"__builtins__":None},mathdictionary)
                                            if absolute_index > -1:
                                                if nint == 1: #DeltaET
                                                    val = self.delta1[absolute_index]
                                                else: # nint == 2: #DeltaBT
                                                    val = self.delta2[absolute_index]
                                        except:
                                            pass
                                        #add expression and values found
                                        literal_body = body
                                        for k, v in replacements.items():
                                            literal_body = literal_body.replace(k,v)
                                        evaltimeexpression = "".join(("R",mathexpression[i+1],"z",literal_body,"z")) # curle brackets replaced by "z"
                                        timeshiftexpressions.append(evaltimeexpression)
                                        timeshiftexpressionsvalues.append(val)
                                        mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                        
                                    #no shift
                                    else:
                                        if mathexpression[i+1] == "1":
                                            mathdictionary['R1'] = self.delta1[index]
                                        elif mathexpression[i+1] == "2":
                                            mathdictionary['R2'] = self.delta2[index]
                        except Exception:
                            pass

                    #Add to dict Event1-4 external value
                    elif mathexpression[i] == "E":
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])-1              #Enumber int 
                                #find right most occurrence before index of given event type
                                if nint in self.specialeventstype and nint < 4: 
                                    spevtylen = len(self.specialeventstype)-1
                                    for iii in range(spevtylen,-1,-1):
                                        if self.specialeventstype[iii] == nint and index >= self.specialevents[iii]:
                                            break  #index found
                                    val = self.eventsInternal2ExternalValue(self.specialeventsvalue[iii])
                                else:
                                    val = 0
                                if "E" + mathexpression[i+1] not in mathdictionary:
                                    mathdictionary["E"+mathexpression[i+1]] = val
                                    
                    # time timeshift of absolute time (not relative to CHARGE)
                    # t : to access the foreground profiles time (self.timex)
                    # b : to access the background profiles time (self.timeB)
                    elif mathexpression[i] in ["t","b"]:
                        if mathexpression[i] == "t":
                            timex = self.timex
                        else:
                            timex = self.timeB
                        seconddigitstr = ""
                        if i+4 < len(mathexpression) and mathexpression[i+1] == "[":
                            Yshiftval = int(mathexpression[i+3])
                            sign = mathexpression[i+2]

                            if mathexpression[i+4].isdigit():
                                seconddigit = int(mathexpression[i+4])
                                seconddigitstr = mathexpression[i+4]
                                mathexpression = mathexpression[:i+4]+mathexpression[i+5:]
                                Yshiftval = 10*Yshiftval + seconddigit

                            val, evalsign = self.shiftValueEvalsign(timex,index,sign,Yshiftval)
                            
                            val = val - t_offset
                            evaltimeexpression = "".join((mathexpression[i],evalsign*2,mathexpression[i+3],seconddigitstr,evalsign))
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+5:]))
                        #direct index access: e.g. "t{CHARGE}" or "t{12}"
                        elif i+3 < len(mathexpression) and mathexpression[i+1] == "{" and mathexpression.find("}",i+2) > -1:
                            end_idx = mathexpression.index("}",i+2)
                            body = mathexpression[i+2:end_idx]
                            val = -1
                            try:
                                absolute_index = eval(body,{"__builtins__":None},mathdictionary)
                                if absolute_index > -1:
                                    val = timex[absolute_index]
                            except:
                                pass
                            literal_body = body
                            for k, v in replacements.items():
                                literal_body = literal_body.replace(k,v)
                            evaltimeexpression = "".join((mathexpression[i],"q",literal_body,"q")) # curle brackets replaced by "q"
                            timeshiftexpressions.append(evaltimeexpression)
                            timeshiftexpressionsvalues.append(val)
                            mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                        #no timeshift
                        else:
                            if mathexpression[i] == "t" and "t" not in mathdictionary:
                                mathdictionary['t'] = t - t_offset         #add t to the math dictionary
                            # b is only valid with index
                                    
                    #Add to dict plotter Previous results (cascading) from plotter field windows (1-9)
                    elif mathexpression[i] == "P":
                        if i+1 < mlen:                          #check for out of range
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])              #Ynumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "Y1[-2]" 
                                if i+5 < len(mathexpression) and mathexpression[i+2] == "[" and mathexpression[i+5] == "]":
                                    Yshiftval = int(mathexpression[i+4])
                                    sign = mathexpression[i+3]
                                    evaltimeexpression = "".join(("P",mathexpression[i+1],evalsign*2,mathexpression[i+4],evalsign))
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                #no shift
                                else:
                                    if index < len(self.plotterequationresults[nint-1]):
                                        val = self.plotterequationresults[nint-1][index]
                                    else:
                                        val = -1000
                                    if "P" + mathexpression[i+1] not in mathdictionary:
                                        mathdictionary["P"+mathexpression[i+1]] = val

                    #Background B1 = ETbackground; B2 = BTbackground
                    elif mathexpression[i] == "B":
                        if i+1 < mlen:
                            seconddigitstr = ""
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])              #Bnumber int
                                #check for TIMESHIFT 0-9 (one digit). Example: "B1[-2]" 
                                if i+5 < len(mathexpression) and mathexpression[i+2] == "[":
                                    Yshiftval = int(mathexpression[i+4])
                                    sign = mathexpression[i+3]

                                    # TWO digits shifting
                                    if mathexpression[i+5].isdigit():
                                        seconddigit = int(mathexpression[i+5])
                                        seconddigitstr = mathexpression[i+5]
                                        mathexpression = mathexpression[:i+5]+mathexpression[i+6:]
                                        Yshiftval = 10*Yshiftval + seconddigit
                                    
                                    if not len(self.timeB):
                                        # no background, set to 0
                                        val = 0
                                        evalsign = "0"
                                    else:
                                        if nint == 1: #ETbackground
                                            readings = self.temp1B
                                        elif nint == 2: #BTbackground
                                            readings = self.temp2B
                                        #B3, B4, B5, ...
                                        elif nint > 2:
                                            idx3 = aw.qmc.xtcurveidx - 1
                                            n3 = idx3//2
                                            if aw.qmc.xtcurveidx%2:
                                                readings = self.temp1BX[n3]
                                            else:
                                                readings = self.temp2BX[n3]
                                        val, evalsign = self.shiftValueEvalsign(readings,index,sign,Yshiftval)
                                    evaltimeexpression = "".join(("B",mathexpression[i+1],evalsign*2,mathexpression[i+4],seconddigitstr,evalsign))
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[i+6:]))
                                #direct index access: e.g. "B2{CHARGE}" or "B2{12}"
                                elif i+5 < len(mathexpression) and mathexpression[i+2] == "{" and mathexpression.find("}",i+3) > -1:
                                    end_idx = mathexpression.index("}",i+3)
                                    body = mathexpression[i+3:end_idx]
                                    val = -1
                                    try:
                                        absolute_index = eval(body,{"__builtins__":None},mathdictionary)
                                        if absolute_index > -1:
                                            if nint == 1: #ET
                                                val = self.temp1B[absolute_index]
                                            elif nint == 2: #BT
                                                val = self.temp2B[absolute_index]
                                            else: 
                                                idx3 = aw.qmc.xtcurveidx - 1
                                                n3 = idx3//2
                                                #map the extra device
                                                b = [0,0,1,1,2,2,3]
                                                edindex = b[nint-3]
                                                if aw.qmc.xtcurveidx%2:
                                                    val = self.temp1BX[n3][absolute_index]
                                                else:
                                                    val = self.temp2BX[n3][absolute_index]
                                    except:
                                        pass
                                    #add expression and values found
                                    literal_body = body
                                    for k, v in replacements.items():
                                        literal_body = literal_body.replace(k,v)
                                    evaltimeexpression = "".join(("B",mathexpression[i+1],"z",literal_body,"z")) # curle brackets replaced by "z"
                                    timeshiftexpressions.append(evaltimeexpression)
                                    timeshiftexpressionsvalues.append(val)
                                    mathexpression = evaltimeexpression.join((mathexpression[:i],mathexpression[end_idx+1:]))
                                #no shift
                                else:
                                    if not len(self.timeB):
                                        # no background, set to 0
                                        mathdictionary["B"+mathexpression[i+1]] = 0
                                    else:
                                        if nint == 1:
                                            val = self.temp1B[bindex]
                                        elif nint == 2:
                                            val = self.temp2B[bindex]
                                        else:
                                            idx3 = aw.qmc.xtcurveidx - 1
                                            n3 = idx3//2
                                            if aw.qmc.xtcurveidx%2:
                                                val = self.temp1BX[n3][bindex]
                                            else:
                                                val = self.temp2BX[n3][bindex]
                                           
                                        mathdictionary["B"+mathexpression[i+1]] = val

                    # Feedback from previous result. Stack = [10,9,8,7,6,5,4,3,2,1]
                    # holds the ten previous formula results (same window) in order.
                    # F1 is the last result. F5 is the past 5th result 
                    elif mathexpression[i] == "F":
                        if i+1 < mlen:
                            if mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])
                                val = self.plotterstack[-1*nint]
                                if "F"+mathexpression[i+1] not in mathdictionary:
                                    mathdictionary["F"+mathexpression[i+1]] = val

                    # add channel tare values (T1 => ET, T2 => BT, T3 => E1c1, T4 => E1c2, T5 => E2c1,
                    # set by clicking on the corresponding LCD
                    elif mathexpression[i] == "T":
                        if i+1 < mlen:                          #check for out of range
                            nint = -1 #Enumber int 
                            if i+2 < mlen and mathexpression[i+2].isdigit():
                                nint = int(mathexpression[i+1]+mathexpression[i+2])-1
                                mexpr = "T"+mathexpression[i+1]+mathexpression[i+2]
                            elif mathexpression[i+1].isdigit():
                                nint = int(mathexpression[i+1])-1
                                mexpr = "T"+mathexpression[i+1]
                            if nint != -1:  
                                if len(aw.channel_tare_values) > nint:
                                    mathdictionary[mexpr] = aw.channel_tare_values[nint]
                                else:
                                    mathdictionary[mexpr] = 0.0

                    #############   end of mathexpression loop ##########################
                    
                #created Ys values 
                try:
                    if len(self.timex)>0:
                        if RTsname:
                            Y = [self.temp1[-1], self.temp2[-1]] # in realtime mode we take the last value
                        else:
                            Y = [self.temp1[index], self.temp2[index]]
                        if len(self.extratimex):
                            for i in range(len(self.extradevices)):
                                if len(self.extratimex[i]):
                                    if RTsname:
                                        Y.append(self.extratemp1[i][-1])
                                        Y.append(self.extratemp2[i][-1])
                                    else:
                                        Y.append(self.extratemp1[i][index])
                                        Y.append(self.extratemp2[i][index])

                        #add Ys and their value to math dictionary
                        for i in range(len(Yval)):
                            if "Y"+ Yval[i] not in mathdictionary:
                                mathdictionary["Y"+ Yval[i]] = Y[int(Yval[i])-1]

                        #add other timeshifted expressions to the math dictionary: shifted t and P
                        for i in range(len(timeshiftexpressions)):
                            if timeshiftexpressions[i] not in mathdictionary:
                                mathdictionary[timeshiftexpressions[i]] = timeshiftexpressionsvalues[i]
                except Exception:
                    pass

                #background symbols just in case there was no profile loaded but a background loaded.
                if len(self.timeB) > 0:
                    for i in range(len(timeshiftexpressions)):
                        if timeshiftexpressions[i] not in mathdictionary:   
                            mathdictionary[timeshiftexpressions[i]] = timeshiftexpressionsvalues[i]
                try:
                    # we exclude the main_events as they occur as substrings in others like CHARGE in dCHARGE
                    # the special case of a variable Y1 overlapping with a variable Y11,..,Y12 in this simple test has to be excluded to avoid
                    # that if mathexpression="Y11" and mathdictionary contains {"Y1":-1} -1 is returned instead of the correct value of Y11
                    # "x" occurs in "max" and has also to be excluded, as "t" and "b"
                    if any([((k in mathexpression) if k not in (["Y1","x","t","b"] if ("max" in mathexpression) else ["Y1","t","b"]) else False) for k,v in mathdictionary.items() if (v == -1 and not (k in main_events))]):
                        # if any variable is bound to the error value -1 we return -1 for the full formula
                        return -1
                    else:
                        res = float(eval(mathexpression,{"__builtins__":None},mathdictionary))
                except TypeError:
                    res = -1
                except ValueError:
                    res = -1
                except ZeroDivisionError:
                    res = -1
                except IndexError:
                    res = -1
                if res is None:
                    return -1
                else:
                    #stack (use in feedback "F" in same formula)
                    self.plotterstack.insert(10,res)
                    self.plotterstack.pop(0)
                    #Pnumber results storage
                    if equeditnumber:
                        self.plotterequationresults[equeditnumber-1].append(res)
                    return res

            except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                
                #if plotter
                if equeditnumber:
                    e = str(e)
                    e = "P" + str(equeditnumber) + ": " + e
                    self.plottermessage = e
                    return -1
                #if sample()
                else:
                    #virtual devices with symbolic may need 2 samples min.
                    if len(self.timex) > 2:
                        e = str(e)
                        _, _, exc_tb = sys.exc_info()
                        mathexpression = mathexpression.replace("{","(").replace("}",")") # avoid {x} leading to key arrows
                        self.adderror((QApplication.translate("Error Message", "Exception:",None) + " eval_curve_expression(): %s {0} "%mathexpression).format(e),exc_tb.tb_lineno)
                    return -1
        return -1


    #format X axis labels
    def xaxistosm(self,redraw=True):

        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        endtime = self.endofx + starttime
        self.ax.set_xlim(self.startofx,endtime)

        if not self.xgrid:
            self.xgrid = 60.

        mfactor1 =  round(float(2. + int(starttime)/int(self.xgrid)))
        mfactor2 =  round(float(2. + int(self.endofx)/int(self.xgrid)))

        majorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), self.xgrid)
        if self.xgrid == 60:
            minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 30)
        else:
            minorloc = numpy.arange(starttime-(self.xgrid*mfactor1),starttime+(self.xgrid*mfactor2), 60)

        majorlocator = ticker.FixedLocator(majorloc)
        minorlocator = ticker.FixedLocator(minorloc)

        self.ax.xaxis.set_major_locator(majorlocator)
        self.ax.xaxis.set_minor_locator(minorlocator)

        formatter = ticker.FuncFormatter(self.formtime)
        self.ax.xaxis.set_major_formatter(formatter)


        #adjust the length of the minor ticks
        for i in self.ax.xaxis.get_minorticklines() + self.ax.yaxis.get_minorticklines():
            i.set_markersize(4)

        #adjust the length of the major ticks
        for i in self.ax.get_xticklines() + self.ax.get_yticklines():
            i.set_markersize(6)
            #i.set_markeredgewidth(2)   #adjust the width

        # check x labels rotation
        if self.xrotation:     
            for label in self.ax.xaxis.get_ticklabels():
                label.set_rotation(self.xrotation)
                
        if not aw.qmc.LCDdecimalplaces:
            if self.ax:
                self.ax.minorticks_off()
            if self.delta_ax:
                self.delta_ax.minorticks_off()
                    
        # we have to update the canvas cache
        if redraw:
            self.updateBackground()
        else:
            self.ax_background = None

    def fmt_timedata(self,x):
        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0
        if x >=  starttime:
            sign = ""
        else:
            sign = "-"
        m,s = divmod(abs(x - round(starttime)), 60)
        s = int(round(s))
        m = int(m)
        return '%s%d:%02d'%(sign,m,s)
        
    def fmt_data(self,x):
        res = x
        if self.fmt_data_RoR and not aw.qmc.designerflag and self.delta_ax:
            try:
                # depending on the z-order of ax vs delta_ax the one or the other one is correct
                #res = (self.ax.transData.inverted().transform((0,self.delta_ax.transData.transform((0,x))[1]))[1])
                res = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,x))[1]))[1])
            except Exception:
                pass
        elif not self.fmt_data_RoR and aw.qmc.designerflag and self.delta_ax:
            try:
                res = (self.delta_ax.transData.inverted().transform((0,self.ax.transData.transform((0,x))[1]))[1])
            except Exception:
                pass
        if aw.qmc.LCDdecimalplaces:
            return aw.float2float(res)
        else:
            return int(round(res))

    #used by xaxistosm(). Provides also negative time
    def formtime(self,x,_):
        if self.timeindex[0] != -1 and self.timeindex[0] < len(self.timex):
            starttime = self.timex[self.timeindex[0]]
        else:
            starttime = 0

        if x >=  starttime:
            m,s = divmod((x - round(starttime)), 60)  #**NOTE**: divmod() returns here type numpy.float64, which could create problems
            #print type(m),type(s)                    #it is used in: formatter = ticker.FuncFormatter(self.formtime) in xaxistosm()
            s = int(round(s))
            m = int(m)

            if s >= 59:
                return '%d'%(m+1)
            elif abs(s - 30) < 1:
                return '%d.5'%m
            elif s > 1:
                return  '%d:%02d'%(m,s)
            else:
                return '%d'%m

        else:
            m,s = divmod(abs(x - round(starttime)), 60)
            s = int(round(s))
            m = int(m)
            
            if s >= 59:
                return '-%d'%(m+1)
            elif abs(s-30) < 1:
                return '-%d.5'%m
            elif s > 1:
                return  '-%d:%02d'%(m,s)
            else:
                if m == 0:
                    return '0'
                else:
                    return '-%d'%m

    # returns True if nothing to save, discard or save was selected and False if canceled by the user
    def checkSaved(self,allow_discard=True):
        #prevents deleting accidentally a finished roast
        if self.safesaveflag == True and len(aw.qmc.timex) > 3:
            if allow_discard:
                string = QApplication.translate("Message","Save the profile, Discard the profile (Reset), or Cancel?", None)
                buttons = QMessageBox.Discard|QMessageBox.Save|QMessageBox.Cancel
            else:
                string = QApplication.translate("Message","Save the profile or Cancel?", None)
                buttons = QMessageBox.Save|QMessageBox.Cancel
            reply = QMessageBox.warning(aw,QApplication.translate("Message","Profile unsaved", None),string,
                                buttons)
            if reply == QMessageBox.Save:
                return aw.fileSave(aw.curFile)  #if accepted, calls fileClean() and thus turns safesaveflag = False
            elif reply == QMessageBox.Discard:
                self.fileClean()
                return True
            elif reply == QMessageBox.Cancel:
                aw.sendmessage(QApplication.translate("Message","Action canceled",None))
                return False
        else:
            # nothing to be saved
            return True

    def clearLCDs(self):
        if self.LCDdecimalplaces:
            zz = "-.-"
        else:
            zz = "--"
        aw.lcd2.display(zz)
        aw.lcd3.display(zz)
        aw.lcd4.display(zz)
        aw.lcd5.display(zz)
        aw.lcd6.display(zz)
        aw.lcd7.display(zz)
        for i in range(aw.nLCDS):
            aw.extraLCD1[i].display(zz)
            aw.extraLCD2[i].display(zz)
        if aw.largeLCDs_dialog is not None:
            aw.largeLCDs_dialog.updateDecimals()
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.updateDecimals()
        if aw.largePIDLCDs_dialog is not None:
            aw.largePIDLCDs_dialog.updateDecimals()
        if aw.largeExtraLCDs_dialog is not None:
            aw.largeExtraLCDs_dialog.updateDecimals()
        if aw.largePhasesLCDs_dialog is not None:
            aw.largePhasesLCDs_dialog.updateDecimals()

    def clearMeasurements(self,andLCDs=True):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            self.fileClean()
            self.rateofchange1 = 0.0
            self.rateofchange2 = 0.0
            self.temp1, self.temp2, self.delta1, self.delta2, self.timex, self.stemp1, self.stemp2, self.ctimex1, self.ctimex2, self.ctemp1, self.ctemp2 = [],[],[],[],[],[],[],[],[],[],[]
            self.tstemp1,self.tstemp2 = [],[]
            self.unfiltereddelta1,self.unfiltereddelta2 = [],[]
            self.timeindex = [-1,0,0,0,0,0,0,0]
            #extra devices
            for i in range(min(len(self.extradevices),len(self.extratimex),len(self.extratemp1),len(self.extratemp2),len(self.extrastemp1),len(self.extrastemp2))):
                self.extratimex[i],self.extratemp1[i],self.extratemp2[i],self.extrastemp1[i],self.extrastemp2[i] = [],[],[],[],[]            #reset all variables that need to be reset (but for the actually measurements that will be treated separately at the end of this function)
                self.extractimex1[i],self.extractimex2[i],self.extractemp1[i],self.extractemp2[i] = [],[],[],[]
                
            self.replayedBackgroundEvents=[]
            self.beepedBackgroundEvents=[]
            self.specialevents=[]
            aw.lcd1.display("00:00")
            if aw.WebLCDs:
                self.updateWebLCDs(time="00:00")
            if aw.largeLCDs_dialog:
                self.updateLargeLCDsTimeSignal.emit("00:00")
            if andLCDs:
                self.clearLCDs()

        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " clearMeasurements() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
    
    @pyqtSlot(bool)
    def resetButtonAction(self,_=False):
        self.disconnectProbes() # release serial/S7/MODBUS connections
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            # detach IO Phidgets
            aw.qmc.closePhidgetOUTPUTs()
        self.reset()

    #Resets graph. Called from reset button. Deletes all data. Calls redraw() at the end
    # returns False if action was canceled, True otherwise
    # if keepProperties=True (a call from OnMonitor()), we keep all the pre-set roast properties
    def reset(self,redraw=True,soundOn=True,sampling=False,keepProperties=False):
        try:
            focused_widget = QApplication.focusWidget()
            if focused_widget:
                focused_widget.clearFocus()
        except Exception:
            pass
    
        if not self.checkSaved():
            return False
        else:
            if soundOn:
                aw.soundpop()
                
            try:
                # the RESET button action needs to be fired outside of the sempaphore to avoid lockups
                aw.eventactionx(aw.qmc.xextrabuttonactions[0],aw.qmc.xextrabuttonactionstrings[0])
            except:
                pass
            try:
                #### lock shared resources #####
                aw.qmc.samplingsemaphore.acquire(1)
                if self.flagon:
                    self.OffMonitor()
                #reset time
                aw.qmc.timeclock.start()
                
                self.roastUUID = None # reset UUID
                aw.qmc.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
                aw.qmc.roastbatchpos = 1 # initialized to 0, set to increased batchsequence on DROP
                aw.qmc.roastbatchprefix = aw.qmc.batchprefix

                if self.HUDflag:
                    self.toggleHUD()
                self.hudresizeflag = False

                aw.sendmessage(QApplication.translate("Message","Scope has been reset",None))
                aw.button_3.setDisabled(False)
                aw.button_4.setDisabled(False)
                aw.button_5.setDisabled(False)
                aw.button_6.setDisabled(False)
                aw.button_7.setDisabled(False)
                aw.button_8.setDisabled(False)
                aw.button_9.setDisabled(False)
                aw.button_19.setDisabled(False)
                aw.button_20.setDisabled(False)
                aw.button_3.setFlat(False)
                aw.button_4.setFlat(False)
                aw.button_5.setFlat(False)
                aw.button_6.setFlat(False)
                aw.button_7.setFlat(False)
                aw.button_8.setFlat(False)
                aw.button_9.setFlat(False)
                aw.button_19.setFlat(False)
                aw.button_20.setFlat(False)
                aw.button_1.setText(QApplication.translate("Button", "ON",None))
                if aw.simulator:
                    aw.button_1.setStyleSheet(aw.pushbuttonstyles_simulator["OFF"])
                else:
                    aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
                aw.button_2.setText(QApplication.translate("Button", "START",None))
                if aw.simulator:
                    aw.button_2.setStyleSheet(aw.pushbuttonstyles_simulator["STOP"])
                else:
                    aw.button_2.setStyleSheet(aw.pushbuttonstyles["STOP"])
                
                # quantification is blocked if lock_quantification_sampling_ticks is not 0
                # (eg. after a change of the event value by button or slider actions)
                aw.block_quantification_sampling_ticks = [0,0,0,0]
                aw.extraeventsactionslastvalue = [None,None,None,None] # used by +-% event buttons in ON mode when no event was registered yet

                if self.roastpropertiesflag and not keepProperties:
                    self.title = QApplication.translate("Scope Title", "Roaster Scope",None)
                    self.roastingnotes = ""
                    self.cuppingnotes = ""
                    self.beans = ""
                    self.plus_coffee = None
                    self.plus_blend_spec = None
                    self.weight = [0,0,self.weight[2]]
                    self.volume = [0,0,self.volume[2]]
                    self.density = [0,self.density[1],1,self.density[3]]
                    self.density_roasted = [0,self.density_roasted[1],1,self.density_roasted[3]]
                    self.ambientTemp = 0.
                    self.ambient_humidity = 0.
                    self.ambient_pressure = 0.
                    self.beansize = 0.
                    self.beansize_min = 0
                    self.beansize_max = 0
                    self.moisture_greens = 0.
                    self.greens_temp = 0.
                    self.volumeCalcWeightInStr = ""
                    self.volumeCalcWeightOutStr = ""
                else:
                    self.weight = [self.weight[0],0,self.weight[2]]
                    self.volume = [self.volume[0],0,self.volume[2]]
                self.whole_color = 0
                self.ground_color = 0
                self.moisture_roasted = 0.
                    
                # reset running AUC values
                self.AUCvalue = 0
                self.AUCsinceFCs = 0
                self.AUCguideTime = 0
                
                self.statisticstimes = [0,0,0,0,0]

                self.roastdate = QDateTime.currentDateTime()
                self.roastepoch = QDateTime.currentDateTime().toTime_t()
                self.roasttzoffset = libtime.timezone
                if not sampling: # just if the RESET button is manually pressed we clear the error log
                    self.errorlog = []
                    aw.seriallog = []

                aw.qmc.zoom_follow = False # reset the zoom follow feature
                
                self.specialevents = []
                self.specialeventstype = []
                self.specialeventsStrings = []
                self.specialeventsvalue = []
                
                self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                aw.eNumberSpinBox.setValue(0)
                aw.lineEvent.setText("")
                aw.etypeComboBox.setCurrentIndex(0)
                aw.valueEdit.setText("")
                #used to find length of arms in annotations
                self.ystep_down = 0
                self.ystep_up = 0

                # reset keyboard mode
                aw.keyboardmoveindex = 3
                aw.keyboardmoveflag = 0
                aw.resetKeyboardButtonMarks()
                
                if not (aw.qmc.autotimex and aw.qmc.background):
                    if self.locktimex:
                        self.startofx = self.locktimex_start
                        self.endofx = self.locktimex_end
                    else:
                        self.startofx = self.chargemintime
                        self.endofx = self.resetmaxtime
                if self.endofx < 1:
                    self.endofx = 60

                #clear PhasesLCDs
                aw.updatePhasesLCDs()
                #clear AUC LCD
                aw.updateAUCLCD()
                
                aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
                
                #roast flags
                aw.qmc.heavyFC_flag = False
                aw.qmc.lowFC_flag = False
                aw.qmc.lightCut_flag = False
                aw.qmc.darkCut_flag = False
                aw.qmc.drops_flag = False
                aw.qmc.oily_flag = False
                aw.qmc.uneven_flag = False
                aw.qmc.tipping_flag = False
                aw.qmc.scorching_flag = False
                aw.qmc.divots_flag = False
                
                # renable autoCHARGE/autoDRY/autoFCs/autoDROP; all of those get set to False on UNDO of the event for the current roast
                aw.qmc.autoCHARGEenabled = True
                aw.qmc.autoDRYenabled = True
                aw.qmc.autoFCsenabled = True
                aw.qmc.autoDROPenabled = True

                #Designer variables
                self.indexpoint = 0
                self.workingline = 2            #selects ET or BT
                self.currentx = 0               #used to add point when right click
                self.currenty = 0               #used to add point when right click
                self.designertemp1init = []
                self.designertemp2init = []
                if self.mode == "C":
        #                                     #CH, DE, Fcs,Fce,Scs,Sce,Drop
                    self.designertemp1init = [290,290,290,290,290,290,290]
                    self.designertemp2init = [200,150,200,210,220,225,240]
                elif self.mode == "F":
                    self.designertemp1init = [500,500,500,500,500,500,500]
                    self.designertemp2init = [380,300,390,395,410,412,420]
                self.disconnect_designer()  #sets designer flag false
                self.setCursor(Qt.ArrowCursor)

                #reset cupping flavor values
                self.flavors = [5.]*len(self.flavorlabels)

                try:
                    # reset color of last pressed button
                    if aw.lastbuttonpressed != -1:
                        normalstyle = "QPushButton {font-size: 10pt; font-weight: bold; color: %s; background-color: %s}"%(aw.extraeventbuttontextcolor[aw.lastbuttonpressed],aw.extraeventbuttoncolor[aw.lastbuttonpressed])
                        buttonstyle = "min-width:75px;border-style:solid; border-radius:3;border-color:grey; border-width:1;"
                        normalstyle = "QPushButton {" + buttonstyle + "font-size: 10pt; font-weight: bold; color: %s; background: %s}"%(aw.extraeventbuttontextcolor[aw.lastbuttonpressed],self.createGradient(aw.extraeventbuttoncolor[aw.lastbuttonpressed]))
                        aw.buttonlist[aw.lastbuttonpressed].setStyleSheet(normalstyle)
                    # reset lastbuttonpressed
                    aw.lastbuttonpressed = -1
                except Exception:
                    pass

#                if not keepProperties:
#                    # reset sliders
#                    aw.moveslider(0,aw.eventslidermin[0])
#                    aw.moveslider(1,aw.eventslidermin[1])
#                    aw.moveslider(2,aw.eventslidermin[2])
#                    aw.moveslider(3,aw.eventslidermin[3])
#                    # reset Arduino/TC4 PID SV
#                    aw.moveSVslider(aw.pidcontrol.svSliderMin)
                aw.pidcontrol.sv = None
                aw.fujipid.sv = None
                aw.qmc.dutycycle = -1
                aw.qmc.dutycycleTX = 0.
                aw.qmc.currentpidsv = 0.
                
                # we remove the filename to force writing a new file
                # and avoid accidential overwriting of existing data
                #current file name
                aw.curFile = None
                aw.setWindowTitle(aw.windowTitle)
                
                # if on turn mouse crosslines off
                if aw.qmc.crossmarker:
                    aw.qmc.togglecrosslines()
                
                #remove the analysis results annotation if it exists
                aw.qmc.analysisresultsstr = ""

                #autodetected CHARGE and DROP index
                self.autoChargeIdx = 0
                self.autoDropIdx = 0
                self.autoTPIdx = 0
                self.autoDryIdx = 0
                self.autoFCsIdx = 0
                
                self.l_annotations = [] # initiate the event annotations
                self.l_annotations_dict = {} # initiate the event id to temp/time annotation dict
                self.l_background_annotations = [] # initiate the event annotations

                aw.hideDefaultButtons()
                aw.updateExtraButtonsVisibility()
                aw.enableEditMenus()
                
                #reset alarms
                self.temporaryalarmflag = -3
                self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
                #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
                aw.qmc.TPalarmtimeindex = None

                
                aw.pidcontrol.pidActive = False

                self.wheelflag = False
                self.designerflag = False

                #check and turn off mouse cross marker
                if self.crossmarker:
                    self.togglecrosslines()

                if aw is not None:
                    aw.updatePlusStatus()
                    
            except Exception as ex:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " reset() {0}").format(str(ex)),exc_tb.tb_lineno)
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)
            # now clear all measurements and redraw
            self.clearMeasurements()
            ### REDRAW  ##
            if redraw:
                self.redraw(True,sampling=sampling,smooth=aw.qmc.optimalSmoothing) # we need to re-smooth with standard smoothing if ON and optimal-smoothing is ticked
            QApplication.processEvents() # this one seems to be needed for a proper redraw in fullscreen mode on OS X if a profile was loaded and NEW is pressed
            return True

    def medfilt(self, x, k):
        """Apply a length-k median filter to a 1D array x.
        Boundaries are extended by repeating endpoints.
        """
        assert k % 2 == 1, "Median filter length must be odd."
        assert x.ndim == 1, "Input must be one-dimensional."
        if len(x) == 0:
            return x
        else:
            k2 = (k - 1) // 2
            y = numpy.zeros ((len (x), k), dtype=x.dtype)
            y[:,k2] = x
            for i in range (k2):
                j = k2 - i
                y[j:,i] = x[:-j]
                y[:j,i] = x[0]
                y[:-j,-(i+1)] = x[j:]
                y[-j:,-(i+1)] = x[-1]
            return numpy.median(y, axis=1)

    # smoothes a list of values 'y' at taken at times indicated by the numbers in list 'x'
    # 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
    # 'flat' results in moving average
    # window_len should be odd
    # based on http://wiki.scipy.org/Cookbook/SignalSmooth
    def smooth(self, x, y, window_len=15, window='hanning'):
        try:
            if len(x) == len(y) and len(x) > 1:
                if window_len > 2:
                    # smooth curves
                    #s = numpy.r_[2*x[0]-y[window_len:1:-1],y,2*y[-1]-y[-1:-window_len:-1]]
                    #s=numpy.r_[y[window_len-1:0:-1],y,y[-2:-window_len-1:-1]]
                    #s = y
                    s=numpy.r_[y[window_len-1:0:-1],y,y[-1:-window_len:-1]]
                    if window == 'flat': #moving average
                        w = numpy.ones(window_len,'d')
                    else:
                        w = eval('numpy.'+window+'(window_len)')
                    try:
                        ys = numpy.convolve(w/w.sum(),s,mode='valid')
                    except:
                        return y
                    hwl = int((window_len/2))
                    res = ys[hwl:-hwl]
                    if len(res)+1 == len(y) and len(res) > 0:
                        try:
                            return ys[hwl-1:-hwl]
                        except:
                            return y
                    elif len(res) != len(y):
                        return y
                    else:
                        return res
                else:
                    return y
            else:
                return y
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " smooth() {0}").format(str(ex)),exc_tb.tb_lineno)
            return x


    # a: list of timestamps
    # b: list of readings
    # re_sample: if true re-sample readings to a linear spaced time before smoothing
    # back_sample: if true results are back-sampled to original timestamps given in "a" after smoothing
    # a_lin: pre-computed linear spaced timestamps of equal length than a
    def smooth_list(self, a, b, window_len=7, window='hanning',decay_weights=None,decay_smoothing=False,fromIndex=-1,toIndex=0,re_sample=True,back_sample=True,a_lin=None):  # default 'hanning'
        if len(a) > 1 and len(a) == len(b) and (aw.qmc.filterDropOuts or window_len>2):
            #pylint: disable=E1103
            # 1. truncate
            if fromIndex > -1: # if fromIndex is set, replace prefix up to fromIndex by None
                if toIndex==0: # no limit
                    toIndex=len(a)
            else: # smooth list on full length
                fromIndex = 0
                toIndex = len(a)
            a = numpy.array(a,dtype='float64')[fromIndex:toIndex]
            b = numpy.array(b,dtype='float64')[fromIndex:toIndex] 
            # 2. re-sample
            if re_sample:
                if a_lin is None or len(a_lin) != len(a):
                    a_mod = numpy.linspace(a[0],a[-1],len(a))
                else:
                    a_mod = a_lin
                b = numpy.interp(a_mod, a, b) # resample data in a to linear spaced time
            else:
                a_mod = a
            # 3. filter spikes
            if aw.qmc.filterDropOuts:
                try:
                    b = self.medfilt(numpy.array(b),5)  # k=3 seems not to catch all spikes in all cases; k must be odd!
                    res = b
                except:
                    pass
            # 4. smooth data
            if window_len>2:
                if decay_smoothing:
                    # decay smoothing
                    if decay_weights is None:
                        decay_weights = numpy.arange(1,window_len+1)
                    else:
                        window_len = len(decay_weights)
                    # invariant: window_len = len(decay_weights)
                    if decay_weights.sum() == 0:
                        res = b
                    else:
                        res = []
                        # ignore -1 readings in averaging and ensure a good ramp
                        for i in range(len(b)):
                            seq = b[max(0,i-window_len + 1):i+1] 
                            # we need to surpress -1 drop out values from this
                            seq = list(filter(lambda item: item != -1,seq))
                            w = decay_weights[max(0,window_len-len(seq)):]  # preCond: len(decay_weights)=window_len and len(seq) <= window_len; postCond: len(w)=len(seq)
                            if len(w) == 0:
                                res.append(b[i]) # we don't average if there is are no weights (e.g. if the original seq did only contain -1 values and got empty)
                            else:
                                res.append(numpy.average(seq,weights=w)) # works only if len(seq) = len(w) 
                        # postCond: len(res) = len(b)        
                else:
                    # optimal smoothing (the default)
                    win_len = max(0,window_len)
                    if win_len != 1: # at the lowest level we turn smoothing completely off
                        res = self.smooth(a_mod,b,win_len,window)
                    else:
                        res = b
            # 4. sample back
            if re_sample and back_sample:
                res = numpy.interp(a, a_mod, res) # re-sampled back to orginal timestamps
            return numpy.concatenate(([None]*(fromIndex),res.tolist(),[None]*(len(a)-toIndex))).tolist()
        else:
            return b
    
    # returns the position of the main event annotations as list of lists of the form
    #   [[id,temp_x,temp_y,time_x,time_y],...]
    # with id the main event id like -1 for TP, 0 for CHARGE, 1 for DRY,..
    def getAnnoPositions(self):
        res = []
        for k,v in self.l_annotations_dict.items():
            temp_anno = v[0].xyann
            time_anno = v[1].xyann
            res.append([k,temp_anno[0],temp_anno[1],time_anno[0],time_anno[1]])
        return res
        
    def setAnnoPositions(self,anno_positions):
        for ap in anno_positions:
            if len(ap) == 5:
                i = ap[0]
                temp_x = ap[1]
                temp_y = ap[2]
                time_x = ap[3]
                time_y = ap[4]
                self.l_annotations_pos_dict[i] = ((temp_x,temp_y),(time_x,time_y))
    
    # returns the position of the custom event flag annotations as list of lists of the form
    #   [[id,x,y],...]
    # with id the event id
    def getFlagPositions(self):
        res = []
        for k,v in self.l_event_flags_dict.items():
            flag_anno = v.xyann
            res.append([k,flag_anno[0],flag_anno[1]])
        return res
    
    def setFlagPositions(self,flag_positions):
        for fp in flag_positions:
            if len(fp) == 3:
                i = fp[0]
                x = fp[1]
                y = fp[2]
                self.l_event_flags_pos_dict[i] = (x,y)

    def annotate(self, temp, time_str, x, y, yup, ydown,e=0,a=1.,draggable=True,draggable_anno_key=None):
        fontprop_small = aw.mpl_fontproperties.copy()
        fontsize = "x-small"
        fontprop_small.set_size(fontsize)
        if aw.qmc.patheffects:
            rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette["background"])]
        else:
            rcParams['path.effects'] = []
        #annotate temp
        if aw.qmc.LCDdecimalplaces:
            fmtstr = "%.1f"
        else:
            fmtstr = "%.0f"
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file
            xytext = self.l_annotations_pos_dict[draggable_anno_key][0]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            # next we check the "live" dictionary
            xytext = self.l_annotations_dict[draggable_anno_key][0].xyann
        else:
            xytext = (x+e,y + yup)
        temp_anno = self.ax.annotate(fmtstr%(temp), xy=(x,y),xytext=xytext,
                            color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=a),
                            fontsize=fontsize,alpha=a,fontproperties=fontprop_small)
        try:
            temp_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            temp_anno.draggable(use_blit=True)
            temp_anno.set_picker(aw.draggable_text_box_picker)
        except: # mpl before v3.0 do not have this set_in_layout() function
            pass
        #anotate time
        if draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_pos_dict:
            # we first look into the position dictionary loaded from file
            xytext = self.l_annotations_pos_dict[draggable_anno_key][1]
        elif draggable and draggable_anno_key is not None and draggable_anno_key in self.l_annotations_dict:
            xytext = self.l_annotations_dict[draggable_anno_key][1].xyann
        else:
            xytext = (x+e,y - ydown)
        time_anno = self.ax.annotate(time_str,xy=(x,y),xytext=xytext,
                             color=self.palette["text"],arrowprops=dict(arrowstyle='-',color=self.palette["text"],alpha=a),
                             fontsize=fontsize,alpha=a,fontproperties=fontprop_small)
        try:
            time_anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
            if draggable:
                time_anno.draggable(use_blit=True)
                time_anno.set_picker(aw.draggable_text_box_picker)
        except: # mpl before v3.0 do not have this set_in_layout() function
            pass
        if aw.qmc.patheffects:
            rcParams['path.effects'] = []
        res = [temp_anno, time_anno]
        if draggable and draggable_anno_key is not None:
            aw.qmc.l_annotations_dict[draggable_anno_key] = [temp_anno, time_anno]
        return res

    def place_annotations(self,TP_index,d,timex,timeindex,temp,stemp,startB=None,time2=None,timeindex2=None,TP_time=-1,TP_time_loaded=-1,draggable=True):
        ystep_down = ystep_up = 0
        anno_artists = []
        #Add markers for CHARGE
        try: 
            if len(timex) > 0:
                if timeindex[0] != -1 and len(timex) > timeindex[0]:
                    t0idx = timeindex[0]
                    t0 = timex[t0idx]
                else:
                    t0idx = 0
                    t0 = 0
                if timeindex[0] != -1:
                    y = stemp[t0idx]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,y,y,d)
                    if startB is not None:
                        #st1 = str(self.stringfromseconds(t0 - startB))
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE", None))
                        e = 60
                        a = aw.qmc.backgroundalpha
                    else:
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE", None))
                        if aw.qmc.graphfont == 1:
                            st1 = toASCII(st1)
                        e = 15
                        a = 1.
                    time_temp_annos = self.annotate(temp[t0idx],st1,t0,y,ystep_up,ystep_down,e,a,draggable,0)
                    anno_artists += time_temp_annos
                
                #Add TP marker
                if self.markTPflag and TP_index and TP_index > 0:
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","TP {0}", None),u(self.stringfromseconds(timex[TP_index]-t0,False)))
                    a = 1.
                    e = -50
                    anno_artists += self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1)
                elif TP_time > -1:
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[TP_index],d)
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    e = -70
                    TP_index = self.backgroundtime2index(TP_time) + timeindex[0]
                    
                    TP_time = TP_time - t0
                    st1 = aw.arabicReshape("TP {0}",u(self.stringfromseconds(TP_time_loaded,False)))
                    anno_artists += self.annotate(temp[TP_index],st1,timex[TP_index],stemp[TP_index],ystep_up,ystep_down,e,a,draggable,-1)
                #Add Dry End markers
                if timeindex[1]:
                    tidx = timeindex[1]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[t0idx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DE {0}", None),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[1] and timex[timeindex[1]] < time2[timeindex2[1]]:
                        e = -80
                    else:
                        e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,1)
                
                #Add 1Cs markers
                if timeindex[2]:
                    tidx = timeindex[2]
                    if timeindex[1]: #if dryend
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[1]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCs {0}", None),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[2] and timex[timeindex[2]] > time2[timeindex2[2]]:
                        e = 0
                    else:
                        e = -80
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,2)
                #Add 1Ce markers
                if timeindex[3]:
                    tidx = timeindex[3]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[2]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCe {0}", None),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[3] and timex[timeindex[3]] < time2[timeindex2[3]]:
                        e = 0
                    else:
                        e = -80
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,3)
                    #add a water mark if FCs
                    if timeindex[2] and not timeindex2 and self.watermarksflag:
                        self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add 2Cs markers
                if timeindex[4]:
                    tidx = timeindex[4]
                    if timeindex[3]:
                        ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[3]],stemp[tidx],d)
                    else:
                        ystep_down,ystep_up = self.findtextgap(0,0,stemp[tidx],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCs {0}", None),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[4] and timex[timeindex[4]] < time2[timeindex2[4]]:
                        e = -80
                    else:
                        e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,4)
                #Add 2Ce markers
                if timeindex[5]:
                    tidx = timeindex[5]
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[timeindex[4]],stemp[tidx],d)
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCe {0}", None),u(self.stringfromseconds(timex[tidx]-t0,False)))
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[5] and timex[timeindex[5]] < time2[timeindex2[5]]:
                        e = -80
                    else:
                        e = 0
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,5)
                    #do water mark if SCs
                    if timeindex[4] and not timeindex2 and self.watermarksflag:
                        self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                #Add DROP markers
                if timeindex[6]:
                    tidx = timeindex[6]
                    if timeindex[5]:
                        tx = timeindex[5]
                    elif timeindex[4]:
                        tx = timeindex[4]
                    elif timeindex[3]:
                        tx = timeindex[3]
                    elif timeindex[2]:
                        tx = timeindex[2]
                    elif timeindex[1]:
                        tx = timeindex[1]
                    else:
                        tx = t0idx
                    ystep_down,ystep_up = self.findtextgap(ystep_down,ystep_up,stemp[tx],stemp[tidx],d)
                    ystep_down = ystep_down
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DROP {0}", None),str(self.stringfromseconds(timex[tidx]-t0,False)))
                    if aw.qmc.graphfont == 1:
                        st1 = toASCII(st1)
                    if timeindex2:
                        a = aw.qmc.backgroundalpha
                    else:
                        a = 1.
                    if timeindex2 and timeindex2[6] and timex[timeindex[6]] < time2[timeindex2[6]]:
                        e = -80
                    else:
                        e = 0
                    
                    anno_artists += self.annotate(temp[tidx],st1,timex[tidx],stemp[tidx],ystep_up,ystep_down,e,a,draggable,6)
                    
                    #do water mark if FCs, but no FCe nor SCs nor SCe
                    if timeindex[2] and not timeindex[3] and not timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        fc_artist = self.ax.axvspan(timex[timeindex[2]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                        try:
                            fc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except: # set_in_layout not available in mpl<3.x
                            pass
                    #do water mark if SCs, but no SCe
                    if timeindex[4] and not timeindex[5] and not timeindex2 and self.watermarksflag:
                        sc_artist = self.ax.axvspan(timex[timeindex[4]],timex[tidx], facecolor=self.palette["watermarks"], alpha=0.2)
                        try:
                            sc_artist.set_in_layout(False) # remove title from tight_layout calculation
                        except: # set_in_layout not available in mpl<3.x
                            pass
                # add COOL mark
                if timeindex[7] and not timeindex2:
                    tidx = timeindex[7]
                    # as the right most data value of the axis in self.ax.get_xlim()[1] is only correctly set after the initial draw,
                    # we simply set it to twice as wide and trust that the clipping will cut of the part not within the axis system
                    endidx = 2*max(aw.qmc.timex[-1],aw.qmc.endofx,self.ax.get_xlim()[0],self.ax.get_xlim()[1])
                    if timex[tidx] < endidx and self.watermarksflag:
                        cool_mark = self.ax.axvspan(timex[tidx],endidx, facecolor=self.palette["rect4"], ec='none', alpha=0.3, clip_on=True, lw=None)#,lod=False)                        
                        try:
                            cool_mark.set_in_layout(False) # remove title from tight_layout calculation
                        except: # set_in_layout not available in mpl<3.x
                            pass
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " place_annotations() {0}").format(str(e)),exc_tb.tb_lineno)
        return anno_artists
    
    def apply_symbolic_delta_formula(self,fct,deltas,timex,RTsname):
        try:
            if len(deltas) == len(timex):
                return [aw.qmc.eval_math_expression(fct,timex[i],RTsname=RTsname,RTsval=d) for i,d in enumerate(deltas)]
            else:
                return deltas
        except:
            return deltas
    
    # computes the RoR deltas and returns the smoothed versions for both temperature channels
    # if t1 or t2 is not given (None), its RoR signal is not computed and None is returned instead
    # timex_lin: a linear spaced version of timex
    def recomputeDeltas(self,timex,CHARGEidx,DROPidx,t1,t2,optimalSmoothing=True,timex_lin=None,deltaETsamples=None,deltaBTsamples=None):
        try:
            tx_roast = numpy.array(timex)
            lt = len(tx_roast)
            if CHARGEidx > -1:
                roast_start_idx = CHARGEidx
            else:
                roast_start_idx = 0
            if DROPidx > 0:
                roast_end_idx = DROPidx
            else:
                roast_end_idx = lt
            if deltaBTsamples is None:
                dsBT = aw.qmc.deltaBTsamples
            else:
                dsBT = deltaBTsamples
            if deltaETsamples is None:
                dsET = aw.qmc.deltaETsamples
            else:
                dsET = deltaETsamples
            if timex_lin is not None:
                if len(timex_lin) == len(timex):
                    timex_lin = numpy.array(timex_lin)
                else:
                    timex_lin = None
            if t1 is not None:
                with numpy.errstate(divide='ignore'):
                    nt1 = numpy.array([0 if x is None else x for x in t1]) # ERROR None Type object not scriptable! t==None on ON
                    z1 = (nt1[dsET:] - nt1[:-dsET]) / ((tx_roast[dsET:] - tx_roast[:-dsET])/60.)
                    ld1 = len(z1)
                # make lists equal in length
                if lt > ld1:
                    z1 = numpy.append([z1[0] if ld1 else 0.]*(lt - ld1),z1)
                # apply smybolic formula
                if aw.qmc.DeltaETfunction is not None and len(aw.qmc.DeltaETfunction):
                    z1 = self.apply_symbolic_delta_formula(aw.qmc.DeltaETfunction,z1,timex,RTsname="R1")
                # apply smoothing
                if optimalSmoothing:
                    user_filter = self.deltaETfilter
                else:
                    user_filter = int(round(self.deltaETfilter/2.))
                delta1 = self.smooth_list(tx_roast,z1,window_len=user_filter,decay_smoothing=(not optimalSmoothing),a_lin=timex_lin)
                delta1 = delta1[roast_start_idx:roast_end_idx]
                # add None for parts before and after CHARGE/DROP
                delta1 = numpy.concatenate(([None]*(roast_start_idx),delta1,[None]*(lt-roast_end_idx))) # ERROR: all input arrays must have the same number of dimensions
                # filter out values beyond the delta limits to cut out the part after DROP and before CHARGE
                if aw.qmc.RoRlimitFlag:
                    # remove values beyond the RoRlimit
                    delta1 = [d if d is not None and (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < d < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)) else None for d in delta1]
                if isinstance(delta1, (numpy.ndarray, numpy.generic)):
                    delta1 = delta1.tolist()
            else:
                delta1 = None
            if t2 is not None:
                with numpy.errstate(divide='ignore'):
                    nt2 = numpy.array([0 if x is None else x for x in t2])
                    z2 = (nt2[dsBT:] - nt2[:-dsBT]) / ((tx_roast[dsBT:] - tx_roast[:-dsBT])/60.)
                    ld2 = len(z2)
                # make lists equal in length
                if lt > ld2:
                    z2 = numpy.append([z2[0] if ld2 else 0.]*(lt - ld2),z2)
                # apply smybolic formula
                if aw.qmc.DeltaBTfunction is not None and len(aw.qmc.DeltaBTfunction):
                    z2 = self.apply_symbolic_delta_formula(aw.qmc.DeltaBTfunction,z2,timex,RTsname="R2")
                # apply smoothing
                if optimalSmoothing:
                    user_filter = self.deltaBTfilter
                else:
                    user_filter = int(round(self.deltaBTfilter/2.))
                delta2 = self.smooth_list(tx_roast,z2,window_len=user_filter,decay_smoothing=(not optimalSmoothing),a_lin=timex_lin)
                delta2 = delta2[roast_start_idx:roast_end_idx]
                # add None for parts before and after CHARGE/DROP
                delta2 = numpy.concatenate(([None]*(roast_start_idx),delta2,[None]*(lt-roast_end_idx)))
                # filter out values beyond the delta limits to cut out the part after DROP and before CHARGE
                if aw.qmc.RoRlimitFlag:
                    # remove values beyond the RoRlimit
                    delta2 = [d if d is not None and (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < d < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)) else None for d in delta2]
                if isinstance(delta2, (numpy.ndarray, numpy.generic)):
                    delta2 = delta2.tolist()
            else:
                delta2 = None
                    
            return delta1, delta2
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " recomputeDeltas() {0}").format(str(e)),exc_tb.tb_lineno)
            return [0]*len(timex),[0]*len(timex)

    # fills in intermediate interpolated values replacing -1 values based on surrounding values
    # [1, 2, 3, -1, -1, -1, 10, 11] => [1, 2, 3, 4.75, 6.5, 8.25, 11]
    # [1,2,3,-1,-1,-1,-1] => [1,2,3,-1,-1,-1,-1] # no final value to interpolate too, so trailing -1 are kept!
    # [-1,-1,2] => [2, 2.0, 2] # a prefix of -1 will be replaced by the first value in l that is not -1
    # INVARIANT: the resulting list has always the same lenght as l
    def fill_gaps(self,l):
        res = []
        last_val = -1
        skip = -1
        for i,e in enumerate(l):
            if i >= skip:
                if e == -1 and last_val == -1:            
                    # a prefix of -1 will be replaced by the first value in l that is not -1
                    s = -1
                    for e in l:
                        if e != -1:
                            s = e
                            break
                    res.append(s)
                    last_val = s
                elif e == -1 and last_val != -1:
                    next_val = None
                    next_idx = None # first index of an element beyond i of a value different to -1
                    for j in range(i+1,len(l)):
                        if l[j] != -1:
                            next_val = l[j]
                            next_idx = j
                            break
                    if next_val is None:
                        # no further valid values, we append the tail
                        res.extend(l[i:])
                        return res
                    else:
                        # compute intermediate values
                        step = (next_val - last_val) / (j-i+1.)
                        for _ in range(j-i):
                            last_val = last_val + step
                            res.append(last_val)
                        skip = next_idx
                else:
                    res.append(e)
                    last_val = e
        return res

    def bisection(self,array,value):
        #Algorithm presumes 'array' is monotonic increasing.  This is not guaranteed for profiles so there
        #may be results that are not strictly correct.
        n = len(array)
        if (value < array[0]):
            return -1
        elif (value > array[n-1]):
            return n
        elif (value == array[0]): # edge cases at bottom
            return 0
        elif (value == array[n-1]): # and top
            return n-1
        jl = 0   # Initialize lower
        ju = n-1 # and upper limits.
        while (ju-jl > 1):# If we are not yet done,
            jm=(ju+jl) >> 1 # compute a midpoint with a bitshift
            if (value >= array[jm]):
                jl=jm # and replace either the lower limit
            else:
                ju=jm # or the upper limit, as appropriate.
            # Repeat until the test condition is satisfied.
        if (abs(value - array[jl]) > abs(array[ju] - value)):
            return ju
        else:
            return jl

    def drawAUC(self):
        try:
            TP_Index = aw.findTP()
            if aw.qmc.AUCbaseFlag:
                _,_,_,idx = aw.ts()
                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],aw.qmc.stemp2[idx])
            else:
                idx = TP_Index + self.bisection(self.stemp2[TP_Index:self.timeindex[6]],aw.qmc.AUCbase)
            rtbt = aw.qmc.stemp2[idx]

            ix = self.timex[idx:self.timeindex[6]+1]
            iy = self.stemp2[idx:self.timeindex[6]+1]

            # Create the shaded region
            from matplotlib.patches import Polygon
            a = ix[0]
            b = ix[-1]
            verts = [ xy for xy in [(a, rtbt)] + list(zip(ix, iy)) + [(b, rtbt)] if xy[1] > 0 ]
            if verts:
                poly = Polygon(verts, facecolor=self.palette["aucarea"], edgecolor='0.5', alpha=0.3)
                self.ax.add_patch(poly)
        except:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass

    # if updatebackground is True, the samplingsemaphore is catched and updatebackground() is called
    @pyqtSlot(str,bool)
    def setProfileTitle(self,title,updatebackground=False):
        if self.flagon and self.batchcounter != -1:
            bnr = self.batchcounter + 1
        else:
            bnr = self.roastbatchnr
        
        if bnr != 0 and title != "":
            title = "{}{} {}".format(self.roastbatchprefix,u(bnr),title)

        if self.background and self.titleB and len(self.titleB) > 10:
            stl = 33
        else:
            stl = 38
        if aw.qmc.graphfont != 1: # Humor font runs very long!!
            stl = int(stl*1.5)
        if aw.qmc.graphfont == 1: # if selected font is Humor we translate the unicode title into pure ascii
            title = toASCII(title)
        title = aw.qmc.abbrevString(title,stl)
        fontprop_xlarge = aw.mpl_fontproperties.copy()
        fontprop_xlarge.set_size("x-large")
        t_artist = self.ax.set_title(aw.arabicReshape(title), color=self.palette["title"], loc='left',
                    fontproperties=fontprop_xlarge,horizontalalignment="left",x=0)
        try:
            t_artist.set_in_layout(False) # remove title from tight_layout calculation
        except: # set_in_layout not available in mpl<3.x
            pass
        if updatebackground:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            try:
                self.updateBackground()
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)

    # resize the given list to the length ln by cutting away elements or padding with trailing -1 items
    # used to resize temperature data to the length of the corresponding timex times
    def resizeList(self,lst,ln):
        if lst is None:
            return None
        else:
            return (lst + [-1]*(ln-len(lst)))[:ln]

    def drawET(self):
        if aw.qmc.ETcurve:
            self.l_temp1, = self.ax.plot(self.timex,self.stemp1,markersize=self.ETmarkersize,marker=self.ETmarker,
                sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETlinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
                linewidth=self.ETlinewidth,linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],label=aw.arabicReshape(QApplication.translate("Label", "ET", None)))
    
    def drawBT(self):
        self.l_temp2, = self.ax.plot(self.timex,self.stemp2,markersize=self.BTmarkersize,marker=self.BTmarker,
            sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTlinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
            linewidth=self.BTlinewidth,linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],label=aw.arabicReshape(QApplication.translate("Label", "BT", None)))
            
    def drawDeltaET(self,trans):
        if self.DeltaETflag:
            self.l_delta1, = self.ax.plot(self.timex, self.delta1,transform=trans,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
            sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
            linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],label=aw.arabicReshape(deltaLabelUTF8 + QApplication.translate("Label", "ET", None)))                    
    
    def drawDeltaBT(self,trans):
        if self.DeltaBTflag:
            self.l_delta2, = self.ax.plot(self.timex, self.delta2,transform=trans,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
            sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
            linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],label=aw.arabicReshape(deltaLabelUTF8 + QApplication.translate("Label", "BT", None)))    
    
    #Redraws data
    # if recomputeAllDeltas, the delta arrays; if smooth the smoothed line arrays are recomputed (incl. those of the background curves)
    def redraw(self, recomputeAllDeltas=True, smooth=True,sampling=False):
        if aw.qmc.designerflag:
            aw.qmc.redrawdesigner()
        else:
            try:
                #### lock shared resources   ####
                aw.qmc.samplingsemaphore.acquire(1)
                
                decay_smoothing_p = (not aw.qmc.optimalSmoothing) or sampling or aw.qmc.flagon

                rcParams['path.effects'] = []
                if aw.qmc.graphstyle == 1:
                    scale = 1
                else:
                    scale = 0
                length = 700 # 100 (128 the default)
                randomness = 12 # 2 (16 default)
                rcParams['path.sketch'] = (scale, length, randomness)

                rcParams['axes.linewidth'] = 0.8 # 1.5
                rcParams['xtick.major.size'] = 6 # 8
                rcParams['xtick.major.width'] = 1
#                rcParams['xtick.major.pad'] = 5
                rcParams['xtick.minor.width'] = 0.8
                
                rcParams['ytick.major.size'] = 4 # 8
                rcParams['ytick.major.width'] = 1
#                rcParams['ytick.major.pad'] = 5
                rcParams['ytick.minor.width'] = 1
                
                rcParams['xtick.color'] = self.palette["xlabel"]
                rcParams['ytick.color'] = self.palette["ylabel"]
                
                if self.ax is None:
                    self.ax = self.fig.add_subplot(111,facecolor=self.palette["background"])
                if self.delta_ax is None:
                    self.delta_ax = self.ax.twinx()

#                self.fig.clf()   #wipe out figure (remove all artists and axis). keep_observers=False
#                # first remove previous figure axis
#                if self.ax is not None:
#                    try:
#                        self.fig.delaxes(self.ax)
#                    except:
#                        pass
#                self.ax = self.fig.add_subplot(111,facecolor=self.palette["background"])
#                # reset crosslines to force redrawing on new axis object
#                self.l_horizontalcrossline = None
#                self.l_verticalcrossline = None

                # instead to remove and regenerate the axis object (as in the commented section above) we just clear and reuse it
                self.ax.clear()
                self.ax.set_facecolor(self.palette["background"])
                self.delta_ax.clear()
                self.ax.set_yticks([])
                self.ax.set_xticks([])
                self.delta_ax.set_yticks([])
                self.delta_ax.set_xticks([])


                self.ax.set_ylim(self.ylimit_min, self.ylimit)
                self.ax.set_autoscale_on(False)
                

                fontprop_small = aw.mpl_fontproperties.copy()
                fontprop_small.set_size("xx-small")
                fontprop_medium = aw.mpl_fontproperties.copy()
                fontprop_medium.set_size("medium")
                fontprop_large = aw.mpl_fontproperties.copy()
                fontprop_large.set_size("large")
                
                grid_axis = None
                if self.temp_grid and self.time_grid:
                    grid_axis = 'both'
                elif self.temp_grid:
                    grid_axis = 'y'
                elif self.time_grid:
                    grid_axis = 'x'
                if grid_axis is not None:
                    self.ax.grid(True,axis=grid_axis,color=self.palette["grid"],linestyle=self.gridstyles[self.gridlinestyle],linewidth = self.gridthickness,alpha = self.gridalpha,sketch_params=0,path_effects=[])

                if aw.qmc.flagstart and not aw.qmc.title_show_always:
                    self.setProfileTitle("")
                    st_artist = self.fig.suptitle("")
                    try:
                        st_artist.set_in_layout(False) # remove suptitle from tight_layout calculation
                    except: # set_in_layout not available in mpl<3.x
                        pass
                else:
                    self.setProfileTitle(self.title)

                # extra event names with substitution of event names applied
                extraname1_subst = aw.qmc.extraname1[:]
                extraname2_subst = aw.qmc.extraname2[:]
                for i in range(len(aw.qmc.extratimex)):
                    try:
                        extraname1_subst[i] = extraname1_subst[i].format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
                    except:
                        pass
                    try:
                        extraname2_subst[i] = extraname2_subst[i].format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
                    except:
                        pass
                    
                if aw.qmc.flagstart:
                    self.ax.set_ylabel("")
                    self.ax.set_xlabel("")
                else:
                    self.ax.set_ylabel(self.mode,color=self.palette["ylabel"],rotation=0,labelpad=10,fontproperties=fontprop_large)
                    self.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "min",None)),color = self.palette["xlabel"],fontproperties=fontprop_medium)

                two_ax_mode = (self.DeltaETflag or self.DeltaBTflag or
                    (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))or
                    any(aw.extraDelta1[:len(self.extratimex)]) or
                    any(aw.extraDelta2[:len(self.extratimex)]))

                if self.background:
                    if len(self.title) > 20:
                        stl = 25
                    else:
                        stl = 30
                    if two_ax_mode:
                        suptitleX = 0.93
                    else:
                        suptitleX = 1
                    if aw.qmc.flagstart and not aw.qmc.title_show_always:
                        st_artist = self.fig.suptitle("")
                    else:
                        if self.roastbatchnrB == 0:
                            titleB = self.titleB
                        else:
                            titleB = self.roastbatchprefixB + u(self.roastbatchnrB) + u(" ") + self.titleB
                        if aw.qmc.graphfont == 1: # if selected font is Humor we translate the unicode title into pure ascii
                            titleB = toASCII(titleB)
                        if self.title is None or u(self.title).strip() == "":
                            st_artist = self.fig.suptitle(aw.arabicReshape(aw.qmc.abbrevString(titleB,stl)),
                                horizontalalignment="right",fontproperties=fontprop_small,x=suptitleX,y=1,color=self.palette["title"])
                        else:
                            st_artist = self.fig.suptitle("\n" + aw.qmc.abbrevString(titleB,stl),
                                horizontalalignment="right",fontproperties=fontprop_small,x=suptitleX,y=1,color=self.palette["title"])
                    try:
                        st_artist.set_in_layout(False)  # remove title from tight_layout calculation
                    except:  # set_in_layout not available in mpl<3.x
                        pass

    #            self.fig.patch.set_facecolor(self.palette["background"]) # facecolor='lightgrey'
    #            self.ax.spines['top'].set_color('none')
                if aw.qmc.flagon or sampling:
                    tick_dir = 'in'
                else:
                    tick_dir = 'inout'
                self.ax.tick_params(\
                    axis='x',           # changes apply to the x-axis
                    which='both',       # both major and minor ticks are affected
                    bottom=True,        # ticks along the bottom edge are on
                    top=False,          # ticks along the top edge are off
                    direction=tick_dir,
                    labelbottom=True)   # labels along the bottom edge are on
                self.ax.tick_params(\
                    axis='y',           # changes apply to the y-axis
                    which='both',       # both major and minor ticks are affected
                    right=False,
                    bottom=True,        # ticks along the bottom edge are on
                    top=False,          # ticks along the top edge are off
                    direction=tick_dir,
                    labelbottom=True)   # labels along the bottom edge are on 
                prop = aw.mpl_fontproperties.copy()
                prop.set_size("small")
                for label in self.ax.get_xticklabels() :
                    label.set_fontproperties(prop)
                for label in self.ax.get_yticklabels() :
                    label.set_fontproperties(prop)

                # format temperature as int, not float in the cursor position coordinate indicator
                self.ax.fmt_ydata = self.fmt_data
                self.ax.fmt_xdata = self.fmt_timedata

                self.ax.set_zorder(self.delta_ax.get_zorder()+1) # put ax in front of delta_ax (which remains empty!)
                if two_ax_mode:
                    #create a second set of axes in the same position as self.ax
                    self.delta_ax.tick_params(\
                        axis='y',           # changes apply to the x-axis
                        which='both',       # both major and minor ticks are affected
                        left=False,         # ticks along the left edge are off
                        bottom=False,       # ticks along the bottom edge are off
                        top=False,          # ticks along the top edge are off
                        direction="inout", # tick_dir # this does not work as ticks are not drawn at all in ON mode with this!?
                        labelright=True,
                        labelleft=False,
                        labelbottom=False)   # labels along the bottom edge are on


                    self.ax.patch.set_visible(True)
                    if aw.qmc.flagstart:
                        self.delta_ax.set_ylabel("")
                    else:
                        self.delta_ax.set_ylabel(aw.qmc.mode + aw.arabicReshape(QApplication.translate("Label", "/min", None)),color = self.palette["ylabel"],fontproperties=fontprop_large)
                    self.delta_ax.set_ylim(self.zlimit_min,self.zlimit)
                    self.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.zgrid))
                    self.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                    for i in self.delta_ax.get_yticklines():
                        i.set_markersize(10)
                    for i in self.delta_ax.yaxis.get_minorticklines():
                        i.set_markersize(5)
                    for label in self.delta_ax.get_yticklabels() :
                        label.set_fontproperties(prop)

                    # translate y-coordinate from delta into temp range to ensure the cursor position display (x,y) coordinate in the temp axis
                    self.delta_ax.fmt_ydata = self.fmt_data
                    self.delta_ax.fmt_xdata = self.fmt_timedata
                #put a right tick on the graph
                else:
    #                if aw.qmc.graphstyle:
    #                    self.ax.spines['right'].set_color('none')
    #                    self.ax.spines['top'].set_color('none')
    ##                for tick in self.ax.yaxis.get_major_ticks():
    ##                    tick.label2On = True
                    self.ax.tick_params(\
                        axis='y', 
                        which='both',
                        right=False,
                        labelright=False)

                self.ax.spines['top'].set_color("0.40")
                self.ax.spines['bottom'].set_color("0.40")
                self.ax.spines['left'].set_color("0.40")
                self.ax.spines['right'].set_color("0.40")

                self.ax.yaxis.set_major_locator(ticker.MultipleLocator(self.ygrid))
                self.ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                for i in self.ax.get_yticklines():
                    i.set_markersize(10)
                for i in self.ax.yaxis.get_minorticklines():
                    i.set_markersize(5)

                #update X ticks, labels, and colors
                self.xaxistosm(redraw=False)

                rcParams['path.sketch'] = (0,0,0)
                trans = transforms.blended_transform_factory(self.ax.transAxes,self.ax.transData)

                #draw water marks for dry phase region, mid phase region, and finish phase region
                if aw.qmc.watermarksflag:
                    rect1 = patches.Rectangle((0,self.phases[0]), width=1, height=(self.phases[1]-self.phases[0]),
                                              transform=trans, color=self.palette["rect1"],alpha=0.15)
                    rect2 = patches.Rectangle((0,self.phases[1]), width=1, height=(self.phases[2]-self.phases[1]),
                                              transform=trans, color=self.palette["rect2"],alpha=0.15)
                    rect3 = patches.Rectangle((0,self.phases[2]), width=1, height=(self.phases[3] - self.phases[2]),
                                              transform=trans, color=self.palette["rect3"],alpha=0.15)
                    self.ax.add_patch(rect1)
                    self.ax.add_patch(rect2)
                    self.ax.add_patch(rect3)

                #if self.eventsGraphflag == 0 then that means don't plot event bars

                if self.eventsGraphflag == 1: #plot event bars by type
                    # make blended transformations to help identify EVENT types
                    if self.mode == "C":
                        step = 5
                        start = 20
                    else:
                        step = 10
                        start = 60
                    jump = 20
                    for i in range(4):
                        if aw.qmc.showEtypes[3-i]:
                            rectEvent = patches.Rectangle((0,self.phases[0]-start-jump), width=1, height = step, transform=trans, color=self.palette["rect5"],alpha=.15)
                            self.ax.add_patch(rectEvent)
                        if self.mode == "C":
                            jump -= 10
                        else:
                            jump -= 20

                #plot events bars by value
                elif self.eventsGraphflag in [2,3,4]:
                    # make blended transformations to help identify EVENT types
                    if self.clampEvents:
                        top = 100
                        bot = 0
                    else:
                        top = self.phases[0]
                        bot = self.ylimit_min
                    step = (top-bot)/10
                    start = top - bot
                    small_step = step/10 # as we have 100 items
                    jump = 0
                    
                    for j in range(110):
                        i = int(j/10)
                        barposition = top - start - jump
                        if i == j/10.:
                            c1 = "rect5"
                            c2 = "background"
                            if i == 0:
                                color = self.palette[c1] #self.palette["rect3"] # brown
                            elif i%2:
                                color = self.palette[c2] #self.palette["rect2"] # orange # the uneven ones
                            else:
                                color = self.palette[c1] #self.palette["rect1"] # green # the even ones
                            if (i != 10): # don't draw the first and the last bar in clamp mode
                                rectEvent = patches.Rectangle((0,barposition), width=1, height = step, transform=trans, color=color,alpha=.15)
                                self.ax.add_patch(rectEvent)
                        self.eventpositionbars[j] = barposition
                        jump -= small_step

                rcParams['path.sketch'] = (scale, length, randomness)
                
                #check BACKGROUND flag
                if self.background: 
                    if smooth:
                        # re-smooth background curves
                        tb = self.timeB
                        t1 = self.temp1B
                        t2 = self.temp2B
                        if tb is not None and tb:
                            tb_lin = numpy.linspace(tb[0],tb[-1],len(tb))
                        else:
                            tb_lin = None 
                        self.stemp1B = self.smooth_list(tb,self.fill_gaps(t1),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)
                        self.stemp2B = self.smooth_list(tb,self.fill_gaps(t2),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)

                    self.l_background_annotations = []
                    #check to see if there is both a profile loaded and a background loaded
                    if self.backmoveflag:
                        self.timealign(redraw=False,recompute=False)

                    #draw one extra device on background stemp1BX
                    if aw.qmc.xtcurveidx > 0:
                        idx3 = aw.qmc.xtcurveidx - 1
                        n3 = idx3 // 2
                        if len(self.stemp1BX) > n3 and len(self.stemp2BX) > n3 and len(self.extratimexB) > n3:
                            if smooth:
                                # re-smooth the extra background curve
                                tx = self.extratimexB[n3]
                                if tx is not None and tx:
                                    tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                                else:
                                    tx_lin = None
                            if aw.qmc.xtcurveidx % 2:
                                if smooth:
                                    stemp3B = self.smooth_list(tx,self.fill_gaps(self.temp1BX[n3]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                else:
                                    stemp3B = self.stemp1BX[n3]
                            else:
                                if smooth:
                                    stemp3B = self.smooth_list(tx,self.fill_gaps(self.temp2BX[n3]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin)
                                else:
                                    stemp3B = self.stemp2BX[n3]
                            self.l_back3, = self.ax.plot(self.extratimexB[n3], stemp3B, markersize=self.XTbackmarkersize,marker=self.XTbackmarker,
                                                        sketch_params=None,path_effects=[],
                                                        linewidth=self.XTbacklinewidth,linestyle=self.XTbacklinestyle,drawstyle=self.XTbackdrawstyle,color=self.backgroundxtcolor,
                                                        alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundXT", None)))
                    #draw background
                    if aw.qmc.backgroundETcurve:
                        temp_etb = self.stemp1B
                    else:
                        temp_etb = [None]*len(self.timeB)
                    self.l_back1, = self.ax.plot(self.timeB,temp_etb,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                sketch_params=None,path_effects=[],
                                                linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundET", None)))                        
                    if aw.qmc.backgroundBTcurve:
                        temp_btb = self.stemp2B
                    else:
                        temp_btb = [None]*len(self.timeB)
                    self.l_back2, = self.ax.plot(self.timeB, temp_btb,markersize=self.BTbackmarkersize,marker=self.BTbackmarker, 
                                                linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                sketch_params=None,path_effects=[],
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundBT", None)))

                    # we resample the temperatures to regular interval timestamps
                    if self.timeB is not None and self.timeB:
                        timeB_lin = numpy.linspace(self.timeB[0],self.timeB[-1],len(self.timeB))
                    else:
                        timeB_lin = None
                    
                    #populate background delta ET (self.delta1B) and delta BT (self.delta2B)
                    if self.DeltaETBflag or self.DeltaBTBflag:
                        if recomputeAllDeltas or (self.DeltaETBflag and self.delta1B == []) or (self.DeltaBTBflag and self.delta2B == []):
                            # we populate temporary smoothed ET/BT data arrays
                            cf = aw.qmc.curvefilter*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                            st1 = self.smooth_list(self.timeB,self.fill_gaps(self.temp1B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
                            st2 = self.smooth_list(self.timeB,self.fill_gaps(self.temp2B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
                            # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                            if aw.qmc.timeindexB[0]>-1:
                                RoRstart = min(aw.qmc.timeindexB[0]+10, len(self.timeB)-1)
                            else:
                                RoRstart = -1
                            if aw.qmc.background_profile_sampling_interval is None:
                                dsET = None
                            else:
                                dsET = int(max(1,aw.qmc.deltaETspan / aw.qmc.background_profile_sampling_interval))
                            if aw.qmc.background_profile_sampling_interval is None:
                                dsBT = None
                            else:
                                dsBT = int(max(1,aw.qmc.deltaBTspan / aw.qmc.background_profile_sampling_interval))
                            self.delta1B, self.delta2B = self.recomputeDeltas(self.timeB,RoRstart,aw.qmc.timeindexB[6],st1,st2,optimalSmoothing=not decay_smoothing_p,timex_lin=timeB_lin,deltaETsamples=dsET,deltaBTsamples=dsBT)

                        ##### DeltaETB,DeltaBTB curves
                        if self.delta_ax:
                            trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                            if self.DeltaETBflag and len(self.timeB) == len(self.delta1B):
                                self.l_delta1B, = self.ax.plot(self.timeB, self.delta1B,transform=trans,markersize=self.ETBdeltamarkersize,
                                sketch_params=None,path_effects=[],
                                marker=self.ETBdeltamarker,linewidth=self.ETBdeltalinewidth,linestyle=self.ETBdeltalinestyle,drawstyle=self.ETBdeltadrawstyle,color=self.backgrounddeltaetcolor,alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundDeltaET", None)))
                            if self.DeltaBTBflag and len(self.timeB) == len(self.delta2B):
                                self.l_delta2B, = self.ax.plot(self.timeB, self.delta2B,transform=trans,markersize=self.BTBdeltamarkersize,
                                sketch_params=None,path_effects=[],
                                marker=self.BTBdeltamarker,linewidth=self.BTBdeltalinewidth,linestyle=self.BTBdeltalinestyle,drawstyle=self.BTBdeltadrawstyle,color=self.backgrounddeltabtcolor,alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundDeltaBT", None)))
                    #check backgroundevents flag
                    if self.backgroundeventsflag:
                        if self.eventsGraphflag not in [2,4]:
                            if self.mode == "F":
                                height = 50
                            else:
                                height = 20

                            for p in range(len(self.backgroundEvents)):
                                if self.backgroundEtypes[p] < 4: 
                                    st1 = u(self.Betypesf(self.backgroundEtypes[p])[0] + self.eventsvaluesShort(self.backgroundEvalues[p])) 
                                else:
                                    st1 = u(self.backgroundEStrings[p].strip()[:4])
                                    if len(st1) == 0:
                                        st1 = u("E")
                                # plot events on BT when showeventsonbt is true
                                if not aw.qmc.showeventsonbt and self.temp1B[self.backgroundEvents[p]] > self.temp2B[self.backgroundEvents[p]]:
                                    temp = self.temp1B[self.backgroundEvents[p]]
                                else:
                                    temp = self.temp2B[self.backgroundEvents[p]]
                                if not aw.qmc.showEtypes[self.backgroundEtypes[p]]:
                                    continue
                                anno = self.ax.annotate(st1, xy=(self.timeB[self.backgroundEvents[p]], temp),path_effects=[],
                                                    xytext=(self.timeB[self.backgroundEvents[p]], temp+height),
                                                    va="center", ha="center",
                                                    fontsize="x-small",fontproperties=aw.mpl_fontproperties,color=self.palette["bgeventtext"],
                                                    arrowprops=dict(arrowstyle='wedge',color=self.palette["bgeventmarker"],
                                                                    alpha=self.backgroundalpha),#relpos=(0,0)),
                                                    alpha=min(self.backgroundalpha + 0.1, 1.0))
                                try:
                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                except: # mpl before v3.0 do not have this set_in_layout() function
                                    pass
                                self.l_background_annotations.append(anno)
                        #background events by value
                        if self.eventsGraphflag in [2,3,4]:
                            self.E1backgroundtimex,self.E2backgroundtimex,self.E3backgroundtimex,self.E4backgroundtimex = [],[],[],[]
                            self.E1backgroundvalues,self.E2backgroundvalues,self.E3backgroundvalues,self.E4backgroundvalues = [],[],[],[]
                            E1b_last = E2b_last = E3b_last = E4b_last = 0  #not really necessary but guarantees that Exb_last is defined
                            event_pos_offset = self.eventpositionbars[0]
                            event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                            #properties for the event annotation
                            eventannotationprop = aw.mpl_fontproperties.copy()
                            hoffset = 3  #relative to the event dot
                            voffset = 3  #relative to the event dot
                            eventannotationprop.set_size("x-small")
                            for i in range(len(self.backgroundEvents)):
                                pos = max(0,int(round((self.backgroundEvalues[i]-1)*10)))
                                if self.backgroundEtypes[i] == 0 and aw.qmc.showEtypes[0]:
                                    self.E1backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                    if self.clampEvents:
                                        self.E1backgroundvalues.append(pos)
                                    else:
                                        self.E1backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    E1b_last = i
                                    try:
                                        if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.timeindexB[6] and self.specialeventannovisibilities[0] and self.timeB[self.backgroundEvents[i]] < self.timeB[self.timeindexB[6]]:
                                            E1b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i, applyto="background")
                                            temp = self.E1backgroundvalues[-1]
                                            anno = self.ax.annotate(E1b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                        color=self.palette["text"],
                                                        va="bottom", ha="left",
                                                        fontproperties=eventannotationprop,
                                                        path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                        )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as ex:
#                                        import traceback
#                                        traceback.print_exc(file=sys.stdout)
                                        _, _, exc_tb = sys.exc_info()    
                                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                                elif self.backgroundEtypes[i] == 1 and aw.qmc.showEtypes[1]:
                                    self.E2backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                    if self.clampEvents:
                                        self.E2backgroundvalues.append(pos)
                                    else:
                                        self.E2backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    E2b_last = i
                                    try:
                                        if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.timeindexB[6] and self.specialeventannovisibilities[0] and self.timeB[self.backgroundEvents[i]] < self.timeB[self.timeindexB[6]]:
                                            E2b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i, applyto="background")
                                            temp = self.E2backgroundvalues[-1]
                                            anno = self.ax.annotate(E2b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                        color=self.palette["text"],
                                                        va="bottom", ha="left",
                                                        fontproperties=eventannotationprop,
                                                        path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                        )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as ex:
#                                        import traceback
#                                        traceback.print_exc(file=sys.stdout)
                                        _, _, exc_tb = sys.exc_info()    
                                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                                elif self.backgroundEtypes[i] == 2 and aw.qmc.showEtypes[2]:
                                    self.E3backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                    if self.clampEvents:
                                        self.E3backgroundvalues.append(pos)
                                    else:
                                        self.E3backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    E3b_last = i
                                    try:
                                        if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.timeindexB[6] and self.specialeventannovisibilities[0] and self.timeB[self.backgroundEvents[i]] < self.timeB[self.timeindexB[6]]:
                                            E3b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i, applyto="background")
                                            temp = self.E3backgroundvalues[-1]
                                            anno = self.ax.annotate(E3b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                        color=self.palette["text"],
                                                        va="bottom", ha="left",
                                                        fontproperties=eventannotationprop,
                                                        path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                        )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as ex:
#                                        import traceback
#                                        traceback.print_exc(file=sys.stdout)
                                        _, _, exc_tb = sys.exc_info()    
                                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                                elif self.backgroundEtypes[i] == 3 and aw.qmc.showEtypes[3]:
                                    self.E4backgroundtimex.append(self.timeB[self.backgroundEvents[i]])
                                    if self.clampEvents:
                                        self.E4backgroundvalues.append(pos)
                                    else:
                                        self.E4backgroundvalues.append((pos*event_pos_factor)+event_pos_offset)
                                    E4b_last = i
                                    try:
                                        if (len(self.timex)==0 or self.flagon) and self.eventsGraphflag!=4 and self.backgroundDetails and self.timeindexB[6] and self.specialeventannovisibilities[0] and self.timeB[self.backgroundEvents[i]] < self.timeB[self.timeindexB[6]]:
                                            E4b_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i, applyto="background")
                                            temp = self.E4backgroundvalues[-1]
                                            anno = self.ax.annotate(E4b_annotation, xy=(hoffset + self.timeB[int(self.backgroundEvents[i])], voffset + temp),
                                                        alpha=min(self.backgroundalpha + 0.1, 1.0),
                                                        color=self.palette["text"],
                                                        va="bottom", ha="left",
                                                        fontproperties=eventannotationprop,
                                                        path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                        )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                    except Exception as ex:
#                                        import traceback
#                                        traceback.print_exc(file=sys.stdout)
                                        _, _, exc_tb = sys.exc_info()    
                                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
#                            every = None
                            if len(self.E1backgroundtimex)>0 and len(self.E1backgroundtimex)==len(self.E1backgroundvalues):
                                if (self.timeindexB[7] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[7]] > self.timeB[self.backgroundEvents[E1b_last]]):   #if cool exists and last event was earlier
                                    self.E1backgroundtimex.append(self.timeB[self.timeindexB[7]]) #time of drop
                                    self.E1backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E1b_last]-1)*10))))]) #repeat last event value
                                elif (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E1b_last]]):   #if drop exists and last event was earlier
                                    self.E1backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                    self.E1backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E1b_last]-1)*10))))]) #repeat last event value
                                self.l_backgroundeventtype1dots, = self.ax.plot(self.E1backgroundtimex, self.E1backgroundvalues, color=self.EvalueColor[0], 
                                                                            marker=(self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                                            markersize = self.EvalueMarkerSize[0],
                                                                            picker=2,
                                                                            #markevery=every,
                                                                            linestyle="-",drawstyle="steps-post",linewidth = self.Evaluelinethickness[0],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(0,True))                            
                            if len(self.E2backgroundtimex)>0 and len(self.E2backgroundtimex)==len(self.E2backgroundvalues):
                                if (self.timeindexB[7] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[7]] > self.timeB[self.backgroundEvents[E2b_last]]):   #if cool exists and last event was earlier
                                    self.E2backgroundtimex.append(self.timeB[self.timeindexB[7]]) #time of drop
                                    self.E2backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E2b_last]-1)*10))))]) #repeat last event value
                                elif (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E2b_last]]):   #if drop exists and last event was earlier
                                    self.E2backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                    self.E2backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E2b_last]-1)*10))))]) #repeat last event value
                                self.l_backgroundeventtype2dots, = self.ax.plot(self.E2backgroundtimex, self.E2backgroundvalues, color=self.EvalueColor[1], 
                                                                            marker=(self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                                            markersize = self.EvalueMarkerSize[1],
                                                                            picker=2,
                                                                            #markevery=every,
                                                                            linestyle="-",drawstyle="steps-post",linewidth = self.Evaluelinethickness[1],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(1,True))
                            if len(self.E3backgroundtimex)>0 and len(self.E3backgroundtimex)==len(self.E3backgroundvalues):
                                if (self.timeindexB[7] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[7]] > self.timeB[self.backgroundEvents[E3b_last]]):   #if cool exists and last event was earlier
                                    self.E3backgroundtimex.append(self.timeB[self.timeindexB[7]]) #time of drop
                                    self.E3backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E3b_last]-1)*10))))]) #repeat last event value
                                elif (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E3b_last]]):   #if drop exists and last event was earlier
                                    self.E3backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                    self.E3backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E3b_last]-1)*10))))]) #repeat last event value
                                self.l_backgroundeventtype3dots, = self.ax.plot(self.E3backgroundtimex, self.E3backgroundvalues, color=self.EvalueColor[2], 
                                                                            marker=(self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                                            markersize = self.EvalueMarkerSize[2],
                                                                            picker=2,
                                                                            #markevery=every,
                                                                            linestyle="-",drawstyle="steps-post",linewidth = self.Evaluelinethickness[2],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(2,True))
                            if len(self.E4backgroundtimex)>0 and len(self.E4backgroundtimex)==len(self.E4backgroundvalues):
                                if (self.timeindexB[7] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[7]] > self.timeB[self.backgroundEvents[E4b_last]]):   #if cool exists and last event was earlier
                                    self.E4backgroundtimex.append(self.timeB[self.timeindexB[7]]) #time of drop
                                    self.E4backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E4b_last]-1)*10))))]) #repeat last event value
                                elif (self.timeindexB[6] > 0 and aw.qmc.extendevents and self.timeB[self.timeindexB[6]] > self.timeB[self.backgroundEvents[E4b_last]]):   #if drop exists and last event was earlier
                                    self.E4backgroundtimex.append(self.timeB[self.timeindexB[6]]) #time of drop
                                    self.E4backgroundvalues.append(self.eventpositionbars[min(110,max(0,int(round((self.backgroundEvalues[E4b_last]-1)*10))))]) #repeat last event value
                                self.l_backgroundeventtype4dots, = self.ax.plot(self.E4backgroundtimex, self.E4backgroundvalues, color=self.EvalueColor[3], 
                                                                            marker=(self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                                            markersize = self.EvalueMarkerSize[3],
                                                                            picker=2,
                                                                            #markevery=every,
                                                                            linestyle="-",drawstyle="steps-post",linewidth = self.Evaluelinethickness[3],alpha = min(self.backgroundalpha + 0.1, 1.0), label=self.Betypesf(3,True))

                        if len(self.backgroundEvents) > 0:
                            if self.eventsGraphflag == 4:
                                # we prepare copies of the background Evalues
                                Bevalues = [self.E1backgroundvalues[:],self.E2backgroundvalues[:],self.E3backgroundvalues[:],self.E4backgroundvalues[:]]
                            for i in range(len(self.backgroundEvents)):
                                if self.backgroundEtypes[i] == 4 or self.eventsGraphflag in [0,3,4]:
                                    if self.backgroundEtypes[i] < 4 and (not aw.qmc.renderEventsDescr or len(self.backgroundEStrings[i].strip()) == 0):
                                        Betype = self.Betypesf(self.backgroundEtypes[i])
                                        firstletter = u(Betype[0])
                                        secondletter = self.eventsvaluesShort(self.backgroundEvalues[i])
                                        thirdletter = aw.eventsliderunits[self.backgroundEtypes[i]] # postfix
                                    else:
                                        firstletter = self.backgroundEStrings[i].strip()[:aw.qmc.eventslabelschars]
                                        if firstletter == "":
                                            firstletter = "E"
                                        secondletter = ""
                                        thirdletter = ""
                                    if self.mode == "F":
                                        height = 50
                                    else:
                                        height = 20
                                        
                                    if self.eventsGraphflag == 4 and self.backgroundEtypes[i] < 4 and aw.qmc.showEtypes[self.backgroundEtypes[i]]:
                                        Btemp = Bevalues[self.backgroundEtypes[i]][0]
                                        Bevalues[self.backgroundEtypes[i]] = Bevalues[self.backgroundEtypes[i]][1:]
                                    else:
                                        Btemp = None 

                                    if Btemp != None and aw.qmc.showEtypes[self.backgroundEtypes[i]]:
                                        if self.backgroundEtypes[i] == 0:
                                            boxstyle = 'roundtooth,pad=0.4'
                                            boxcolor = self.EvalueColor[0]
                                            textcolor = self.EvalueTextColor[0]
                                        elif self.backgroundEtypes[i] == 1:
                                            boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                            boxcolor = self.EvalueColor[1]
                                            textcolor = self.EvalueTextColor[1]
                                        elif self.backgroundEtypes[i] == 2:
                                            boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                            boxcolor = self.EvalueColor[2]
                                            textcolor = self.EvalueTextColor[2]
                                        elif self.backgroundEtypes[i] == 3:
                                            boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                            boxcolor = self.EvalueColor[3]
                                            textcolor = self.EvalueTextColor[3]
                                        elif self.backgroundEtypes[i] == 4:
                                            boxstyle = 'square,pad=0.1'
                                            boxcolor = self.palette["specialeventbox"]
                                            textcolor = self.palette["specialeventtext"]
                                        if self.eventsGraphflag in [0,3] or self.backgroundEtypes[i] > 3:
                                            anno = self.ax.annotate(firstletter + secondletter, xy=(self.timeB[int(self.backgroundEvents[i])], Btemp),
                                                         xytext=(self.timeB[int(self.backgroundEvents[i])],Btemp+height),
                                                         alpha=min(aw.qmc.backgroundalpha + 0.1, 1.0),
                                                         color=aw.qmc.palette["bgeventtext"],
                                                         va="center", ha="center",
                                                         arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=aw.qmc.backgroundalpha), # ,relpos=(0,0)
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none', alpha=aw.qmc.backgroundalpha),
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                         )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                                        elif self.eventsGraphflag == 4:
                                            if thirdletter != "":
                                                firstletter = ""
                                            anno = self.ax.annotate(firstletter + secondletter + thirdletter, xy=(self.timeB[int(self.backgroundEvents[i])], Btemp),
                                                         xytext=(self.timeB[int(self.backgroundEvents[i])],Btemp),
                                                         alpha=min(aw.qmc.backgroundalpha + 0.3, 1.0),
                                                         color=aw.qmc.palette["bgeventtext"],
                                                         va="center", ha="center",
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none',
                                                            alpha=min(aw.qmc.backgroundalpha, 1.0)),
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                         )
                                            try:
                                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            except: # mpl before v3.0 do not have this set_in_layout() function
                                                pass
                    #check backgroundDetails flag
                    if self.backgroundDetails:
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min 
                        d = d - d/5
                        #if there is a profile loaded with CHARGE, then save time to get the relative time
                        if self.timeindex[0] != -1:   #verify it exists before loading it, otherwise the list could go out of index
                            startB = self.timex[self.timeindex[0]]
                        else:
                            if self.timeindexB[0] > 0:
                                startB = self.timeB[self.timeindexB[0]]
                            else:
                                startB = 0
                        try:
                            # background annotations are not draggable
                            aw.qmc.l_background_annotations.extend(self.place_annotations(-1,d,self.timeB,self.timeindexB,self.temp2B,self.stemp2B,startB,self.timex,self.timeindex,TP_time=self.TP_time_B,TP_time_loaded=self.TP_time_B_loaded, draggable=False))
                        except Exception:
                            pass
#                            import traceback
#                            traceback.print_exc(file=sys.stdout)

                    #show the analysis results if they exist
#                    if len(self.analysisresultsstr) > 0:
#                        aw.analysisShowResults(redraw=False)

                    #END of Background

                if aw.qmc.patheffects:
                    rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette["background"])]

                self.handles = []
                self.labels = []
                self.legend_lines = []

                # we resample the temperatures to regular interval timestamps
                if self.timex is not None and self.timex and len(self.timex)>1:
                    timex_lin = numpy.linspace(self.timex[0],self.timex[-1],len(self.timex))
                else:
                    timex_lin = None
                temp1_nogaps = self.fill_gaps(self.resizeList(self.temp1,len(self.timex)))
                temp2_nogaps = self.fill_gaps(self.resizeList(self.temp2,len(self.timex)))
                        
                if smooth or len(self.stemp1) != len(self.timex):
                    if not aw.qmc.smooth_curves_on_recording and aw.qmc.flagon: # we don't smooth, but remove the dropouts
                        self.stemp1 = temp1_nogaps
                    else:
                        self.stemp1 = self.smooth_list(self.timex,temp1_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
                if smooth or len(self.stemp2) != len(self.timex):
                    if not aw.qmc.smooth_curves_on_recording and aw.qmc.flagon:  # we don't smooth, but remove the dropouts
                        self.stemp2 = self.fill_gaps(self.temp2)
                    else:
                        self.stemp2 = self.smooth_list(self.timex,temp2_nogaps,window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)

                if self.eventsshowflag:
                    Nevents = len(self.specialevents)
                    #three modes of drawing events.
                    # the first mode just places annotations. They are text annotations.
                    # The second mode aligns the events types to a bar height so that they can be visually identified by type. They are text annotations
                    # the third mode plots the events by value. They are not annotations but actual lines.

                    if self.eventsGraphflag == 1 and Nevents:
                        
                        char1 = self.etypes[0][0]
                        char2 = self.etypes[1][0]
                        char3 = self.etypes[2][0]
                        char4 = self.etypes[3][0]

                        if self.mode == "F":
                            row = {char1:self.phases[0]-20,char2:self.phases[0]-40,char3:self.phases[0]-60,char4:self.phases[0]-80}
                        else:
                            row = {char1:self.phases[0]-10,char2:self.phases[0]-20,char3:self.phases[0]-30,char4:self.phases[0]-40}

                        #draw lines of color between events of the same type to help identify areas of events.
                        #count (as length of the list) and collect their times for each different type. Each type will have a different plot heigh
                        netypes=[[],[],[],[]]
                        for i in range(Nevents):
                            if self.specialeventstype[i] == 0 and aw.qmc.showEtypes[0]:
                                netypes[0].append(self.timex[self.specialevents[i]])
                            elif self.specialeventstype[i] == 1 and aw.qmc.showEtypes[1]:
                                netypes[1].append(self.timex[self.specialevents[i]])
                            elif self.specialeventstype[i] == 2 and aw.qmc.showEtypes[2]:
                                netypes[2].append(self.timex[self.specialevents[i]])
                            elif self.specialeventstype[i] == 3 and aw.qmc.showEtypes[3]:
                                netypes[3].append(self.timex[self.specialevents[i]])
                                
                        letters = "".join((char1,char2,char3,char4))   #"NPDF" first letter for each type (None, Power, Damper, Fan)
                        colors = [self.palette["rect2"],self.palette["rect3"]] #rotating colors
                        for p in range(len(letters)):
                            if len(netypes[p]) > 1:
                                for i in range(len(netypes[p])-1):
                                    #draw differentiating color bars between events and place then in a different height acording with type
                                    rect = patches.Rectangle((netypes[p][i], row[letters[p]]), width = (netypes[p][i+1]-netypes[p][i]), height = step, color = colors[i%2],alpha=0.5)
                                    self.ax.add_patch(rect)

                        # annotate event
                        for i in range(Nevents):
                            if self.specialeventstype[i] > 3:
                                # a special event of type "--"
                                pass
                            elif aw.qmc.showEtypes[self.specialeventstype[i]]:
                                firstletter = self.etypes[self.specialeventstype[i]][0]
                                secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                                
                                #some times ET is not drawn (ET = 0) when using device NONE
                                if aw.qmc.ETcurve or aw.qmc.BTcurve:
                                    # plot events on BT when showeventsonbt is true
                                    if aw.qmc.showeventsonbt and aw.qmc.BTcurve:
                                        col = self.palette["bt"]
                                        if aw.qmc.flagon:
                                            temps = self.temp2
                                        else:
                                            temps = self.stemp2
                                    elif (aw.qmc.ETcurve and self.temp1[int(self.specialevents[i])] >= self.temp2[int(self.specialevents[i])]) or (not aw.qmc.BTcurve):
                                        col = self.palette["et"]
                                        if aw.qmc.flagon:
                                            temps = self.temp1
                                        else:
                                            temps = self.stemp1
                                    else:
                                        col = self.palette["bt"]
                                        if aw.qmc.flagon:
                                            temps = self.temp2
                                        else:
                                            temps = self.stemp2
#                                    fcolor=self.EvalueColor[self.specialeventstype[i]]
                                    if platf == 'Windows':
                                        vert_offset = 5.0
                                    else:
                                        vert_offset = 2.5
                                    anno = self.ax.annotate(firstletter + secondletter,
                                                     xy=(self.timex[int(self.specialevents[i])],
                                                     temps[int(self.specialevents[i])]),
                                                     xytext=(self.timex[int(self.specialevents[i])],row[firstletter] + vert_offset),
                                                     alpha=1.,
                                                     va="center", ha="left",
                                                     bbox=dict(boxstyle='square,pad=0.1', fc=self.palette["specialeventbox"], ec='none'),
                                                     path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                     color=self.palette["specialeventtext"],
                                                     arrowprops=dict(arrowstyle='-',color=col,alpha=0.4,relpos=(0,0)),
                                                     fontsize="xx-small",
                                                     fontproperties=fontprop_small)
                                    try:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except: # mpl before v3.0 do not have this set_in_layout() function
                                        pass

                    elif self.eventsGraphflag in [2,3,4]: # in this mode we have to generate the plots even if Nevents=0 to avoid redraw issues resulting from an incorrect number of plot count
                        self.E1timex,self.E2timex,self.E3timex,self.E4timex = [],[],[],[]
                        self.E1values,self.E2values,self.E3values,self.E4values = [],[],[],[]
                        E1_nonempty = E2_nonempty = E3_nonempty = E4_nonempty = False
                        E1_last = E2_last = E3_last = E4_last = 0  #not really necessary but guarantees that Ex_last is defined
                        event_pos_offset = self.eventpositionbars[0]
                        event_pos_factor = self.eventpositionbars[1] - self.eventpositionbars[0]
                        #properties for the event annotations
                        eventannotationprop = aw.mpl_fontproperties.copy()
                        hoffset = 3  #relative to the event dot
                        voffset = 3  #relative to the event dot
                        eventannotationprop.set_size("x-small")
                        for i in range(Nevents):
                            pos = max(0,int(round((self.specialeventsvalue[i]-1)*10)))
                            if self.specialeventstype[i] == 0 and aw.qmc.showEtypes[0]:
                                self.E1timex.append(self.timex[self.specialevents[i]])
                                if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    self.E1values.append(pos)
                                else:
                                    self.E1values.append((pos*event_pos_factor)+event_pos_offset)
                                E1_nonempty = True
                                E1_last = i
                                try:
                                    if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.timeindex[6] and self.specialeventannovisibilities[0] and self.timex[self.specialevents[i]] < self.timex[self.timeindex[6]]:
                                        E1_annotation = self.parseSpecialeventannotation(self.specialeventannotations[0], i)
                                        temp = self.E1values[-1]
                                        anno = self.ax.annotate(E1_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                    alpha=.9,
                                                    color=self.palette["text"],
                                                    va="bottom", ha="left",
                                                    fontproperties=eventannotationprop,
                                                    path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                    )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                                except Exception as ex:
#                                    import traceback
#                                    traceback.print_exc(file=sys.stdout)
                                    _, _, exc_tb = sys.exc_info()    
                                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                            elif self.specialeventstype[i] == 1 and aw.qmc.showEtypes[1]:
                                self.E2timex.append(self.timex[self.specialevents[i]])
                                if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    self.E2values.append(pos)
                                else:
                                    self.E2values.append((pos*event_pos_factor)+event_pos_offset)
                                E2_nonempty = True
                                E2_last = i
                                try:
                                    if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.timeindex[6] and self.specialeventannovisibilities[1] and self.timex[self.specialevents[i]] < self.timex[self.timeindex[6]]:
                                        E2_annotation = self.parseSpecialeventannotation(self.specialeventannotations[1], i)
                                        temp = self.E2values[-1]
                                        anno = self.ax.annotate(E2_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                    alpha=.9,
                                                    color=self.palette["text"],
                                                    va="bottom", ha="left",
                                                    fontproperties=eventannotationprop,
                                                    path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                    )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                                except Exception as ex:
#                                    import traceback
#                                    traceback.print_exc(file=sys.stdout)
                                    _, _, exc_tb = sys.exc_info()    
                                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                            elif self.specialeventstype[i] == 2 and aw.qmc.showEtypes[2]:
                                self.E3timex.append(self.timex[self.specialevents[i]])
                                if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    self.E3values.append(pos)
                                else:
                                    self.E3values.append((pos*event_pos_factor)+event_pos_offset)
                                E3_nonempty = True
                                E3_last = i
                                try:
                                    if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.timeindex[6] and self.specialeventannovisibilities[2] and self.timex[self.specialevents[i]] < self.timex[self.timeindex[6]]:
                                        E3_annotation = self.parseSpecialeventannotation(self.specialeventannotations[2], i)
                                        temp = self.E3values[-1]
                                        anno = self.ax.annotate(E3_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                    alpha=.9,
                                                    color=self.palette["text"],
                                                    va="bottom", ha="left",
                                                    fontproperties=eventannotationprop,
                                                    path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                    )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                                except Exception as ex:
#                                    import traceback
#                                    traceback.print_exc(file=sys.stdout)
                                    _, _, exc_tb = sys.exc_info()    
                                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                            elif self.specialeventstype[i] == 3 and aw.qmc.showEtypes[3]:
                                self.E4timex.append(self.timex[self.specialevents[i]])
                                if self.clampEvents: # in clamp mode we render also event values higher than 100:
                                    self.E4values.append(pos)
                                else:
                                    self.E4values.append((pos*event_pos_factor)+event_pos_offset)
                                E4_nonempty = True
                                E4_last = i
                                try:
                                    if not sampling and not self.flagstart and self.eventsGraphflag!=4 and self.timeindex[6] and self.specialeventannovisibilities[3] and self.timex[self.specialevents[i]] < self.timex[self.timeindex[6]]:
                                        E4_annotation = self.parseSpecialeventannotation(self.specialeventannotations[3], i)
                                        temp = self.E4values[-1]
                                        anno = self.ax.annotate(E4_annotation, xy=(hoffset + self.timex[int(self.specialevents[i])], voffset + temp),
                                                    alpha=.9,
                                                    color=self.palette["text"],
                                                    va="bottom", ha="left",
                                                    fontproperties=eventannotationprop,
                                                    path_effects=[PathEffects.withStroke(linewidth=self.patheffects,foreground=self.palette["background"])],
                                                    )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                                except Exception as ex:
#                                    import traceback
#                                    traceback.print_exc(file=sys.stdout)
                                    _, _, exc_tb = sys.exc_info()    
                                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() anno {0}").format(str(ex)),exc_tb.tb_lineno)
                                
#                        every = None

                        if len(self.E1timex) > 0 and len(self.E1values) == len(self.E1timex):
                            if (self.timeindex[7] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E1_last]]):   #if cool exists and last event was earlier
                                self.E1timex.append(self.timex[self.timeindex[7]]) #time of cool
                                self.E1values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E1_last]-1)*10))))]) #repeat last event value
                            elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E1_last]]):   #if drop exists and last event was earlier
                                self.E1timex.append(self.timex[self.timeindex[6]]) #time of drop
                                self.E1values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E1_last]-1)*10))))]) #repeat last event value
                            E1x = self.E1timex
                            E1y = self.E1values
                            ds = "steps-post"
                        else:
                            E1x = [None]
                            E1y = [None]
                            ds = "steps-post"
                        self.l_eventtype1dots, = self.ax.plot(E1x, E1y, color=self.EvalueColor[0], 
                                                            marker = (self.EvalueMarker[0] if self.eventsGraphflag != 4 else None),
                                                            markersize = self.EvalueMarkerSize[0],
                                                            picker=2,
                                                            #markevery=every,
                                                            linestyle="-",drawstyle=ds,linewidth = self.Evaluelinethickness[0],alpha = self.Evaluealpha[0],label=self.etypesf(0))
                        if len(self.E2timex) > 0 and len(self.E2values) == len(self.E2timex): 
                            if (self.timeindex[7] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E2_last]]):   #if cool exists and last event was earlier
                                self.E2timex.append(self.timex[self.timeindex[7]]) #time of cool
                                self.E2values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E2_last]-1)*10))))]) #repeat last event value
                            elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E2_last]]):   #if drop exists and last event was earlier
                                self.E2timex.append(self.timex[self.timeindex[6]]) #time of drop
                                self.E2values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E2_last]-1)*10))))]) #repeat last event value
                            E2x = self.E2timex
                            E2y = self.E2values
                            ds = "steps-post"
                        else:
                            E2x = [None]
                            E2y = [None]
                            ds = "steps-post"
                        self.l_eventtype2dots, = self.ax.plot(E2x, E2y, color=self.EvalueColor[1],
                                                            marker = (self.EvalueMarker[1] if self.eventsGraphflag != 4 else None),
                                                            markersize = self.EvalueMarkerSize[1],
                                                            picker=2,
                                                            #markevery=every,
                                                            linestyle="-",drawstyle=ds,linewidth = self.Evaluelinethickness[1],alpha = self.Evaluealpha[1],label=self.etypesf(1))
                        if len(self.E3timex) > 0 and len(self.E3values) == len(self.E3timex):
                            if (self.timeindex[7] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E3_last]]):   #if cool exists and last event was earlier
                                self.E3timex.append(self.timex[self.timeindex[7]]) #time of cool
                                self.E3values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E3_last]-1)*10))))]) #repeat last event value
                            elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E3_last]]):   #if drop exists and last event was earlier
                                self.E3timex.append(self.timex[self.timeindex[6]]) #time of drop
                                self.E3values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E3_last]-1)*10))))]) #repeat last event value
                            E3x = self.E3timex
                            E3y = self.E3values
                            ds = "steps-post"
                        else:
                            E3x = [None]
                            E3y = [None]
                            ds = "steps-post"
                        self.l_eventtype3dots, = self.ax.plot(E3x, E3y, color=self.EvalueColor[2], 
                                                            marker = (self.EvalueMarker[2] if self.eventsGraphflag != 4 else None),
                                                            markersize = self.EvalueMarkerSize[2],
                                                            picker=2,
                                                            #markevery=every,
                                                            linestyle="-",drawstyle=ds,linewidth = self.Evaluelinethickness[2],alpha = self.Evaluealpha[2],label=self.etypesf(2))
                        if len(self.E4timex) > 0 and len(self.E4values) == len(self.E4timex):
                            if (self.timeindex[7] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[7]] > self.timex[self.specialevents[E4_last]]):   #if cool exists and last event was earlier
                                self.E4timex.append(self.timex[self.timeindex[7]]) #time of cool
                                self.E4values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E4_last]-1)*10))))]) #repeat last event value
                            elif (self.timeindex[6] > 0 and aw.qmc.extendevents and self.timex[self.timeindex[6]] > self.timex[self.specialevents[E4_last]]):   #if drop exists and last event was earlier
                                self.E4timex.append(self.timex[self.timeindex[6]]) #time of drop
                                self.E4values.append(self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[E4_last]-1)*10))))]) #repeat last event value
                            E4x = self.E4timex
                            E4y = self.E4values
                            ds = "steps-post"
                        else:
                            E4x = [None]
                            E4y = [None]
                            ds = "steps-post"
                        self.l_eventtype4dots, = self.ax.plot(E4x, E4y, color=self.EvalueColor[3],
                                                            marker = (self.EvalueMarker[3] if self.eventsGraphflag != 4 else None),
                                                            markersize = self.EvalueMarkerSize[3],
                                                            picker=2,#markevery=every,
                                                            linestyle="-",drawstyle=ds,linewidth = self.Evaluelinethickness[3],alpha = self.Evaluealpha[3],label=self.etypesf(3))
                    if Nevents:
                        if self.eventsGraphflag == 4:
                            # we prepare copies of the Evalues
                            evalues = [self.E1values[:],self.E2values[:],self.E3values[:],self.E4values[:]]
                        for i in range(Nevents):
                            if self.specialeventstype[i] == 4 or self.eventsGraphflag in [0,3,4]:
                                if self.specialeventstype[i] < 4 and (not aw.qmc.renderEventsDescr or len(self.specialeventsStrings[i].strip()) == 0):
                                    etype = self.etypesf(self.specialeventstype[i])
                                    firstletter = u(etype[0])
                                    secondletter = self.eventsvaluesShort(self.specialeventsvalue[i])
                                    thirdletter = aw.eventsliderunits[self.specialeventstype[i]] # postfix
                                else:
                                    firstletter = self.specialeventsStrings[i].strip()[:aw.qmc.eventslabelschars]
                                    if firstletter == "":
                                        firstletter = "E"
                                    secondletter = ""
                                    thirdletter = ""
                                if self.mode == "F":
                                    height = 50
                                else:
                                    height = 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if not aw.qmc.showeventsonbt and self.temp1[int(self.specialevents[i])] > self.temp2[int(self.specialevents[i])] and aw.qmc.ETcurve:
                                    if aw.qmc.flagon:
                                        temp = self.temp1[int(self.specialevents[i])]
                                    else:
                                        temp = self.stemp1[int(self.specialevents[i])]
                                elif aw.qmc.BTcurve:
                                    if aw.qmc.flagon:
                                        temp = self.temp2[int(self.specialevents[i])]
                                    else:
                                        temp = self.stemp2[int(self.specialevents[i])]
                                else:
                                    temp = None
                                    
                                # plot events on BT when showeventsonbt is true
                                if aw.qmc.showeventsonbt and temp != None and aw.qmc.BTcurve:
                                    if aw.qmc.flagon:
                                        temp = self.temp2[int(self.specialevents[i])]
                                    else:
                                        temp = self.stemp2[int(self.specialevents[i])]
                                    
                                if self.eventsGraphflag == 4 and self.specialeventstype[i] < 4 and aw.qmc.showEtypes[self.specialeventstype[i]]:
                                    temp = evalues[self.specialeventstype[i]][0]
                                    evalues[self.specialeventstype[i]] = evalues[self.specialeventstype[i]][1:]
                                                                  
                                if temp != None and aw.qmc.showEtypes[self.specialeventstype[i]]:
                                    if self.specialeventstype[i] == 0:
                                        boxstyle = 'roundtooth,pad=0.4'
                                        boxcolor = self.EvalueColor[0]
                                        textcolor = self.EvalueTextColor[0]
                                    elif self.specialeventstype[i] == 1:
                                        boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                        boxcolor = self.EvalueColor[1]
                                        textcolor = self.EvalueTextColor[1]
                                    elif self.specialeventstype[i] == 2:
                                        boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                        boxcolor = self.EvalueColor[2]
                                        textcolor = self.EvalueTextColor[2]
                                    elif self.specialeventstype[i] == 3:
                                        boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                        boxcolor = self.EvalueColor[3]
                                        textcolor = self.EvalueTextColor[3]
                                    elif self.specialeventstype[i] == 4:
                                        boxstyle = 'square,pad=0.1'
                                        boxcolor = self.palette["specialeventbox"]
                                        textcolor = self.palette["specialeventtext"]
                                    if self.eventsGraphflag in [0,3] or self.specialeventstype[i] > 3:
                                        if i in self.l_event_flags_pos_dict:
                                            xytext = self.l_event_flags_pos_dict[i]
                                        elif i in self.l_event_flags_dict:
                                            xytext = self.l_event_flags_dict[i].xyann
                                        else:
                                            xytext = (self.timex[int(self.specialevents[i])],temp+height)
                                        anno = self.ax.annotate(firstletter + secondletter, xy=(self.timex[int(self.specialevents[i])], temp),
                                                     xytext=xytext,
                                                     alpha=0.9,
                                                     color=textcolor,
                                                     va="center", ha="center",
                                                     arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=0.4), # ,relpos=(0,0)
                                                     bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                     fontproperties=fontprop_small,
                                                     path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                     )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                            anno.draggable(use_blit=True)
                                            anno.set_picker(aw.draggable_text_box_picker)
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                                        # register draggable flag annotation to be re-created after re-positioning on redraw
                                        self.l_event_flags_dict[i] = anno
                                    elif self.eventsGraphflag == 4:
                                        if thirdletter != "":
                                            firstletter = ""
                                        anno = self.ax.annotate(firstletter + secondletter + thirdletter, xy=(self.timex[int(self.specialevents[i])], temp),
                                                     xytext=(self.timex[int(self.specialevents[i])],temp),
                                                     alpha=0.9,
                                                     color=textcolor,
                                                     va="center", ha="center",
                                                     bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                     fontproperties=fontprop_small,
                                                     path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                     )
                                        try:
                                            anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                        except: # mpl before v3.0 do not have this set_in_layout() function
                                            pass
                            
                #populate delta ET (self.delta1) and delta BT (self.delta2)
                if self.DeltaETflag or self.DeltaBTflag:
                    if (recomputeAllDeltas or (self.DeltaETflag and self.delta1 == []) or (self.DeltaBTflag and self.delta2 == [])) and not self.flagstart: # during recording we don't recompute the deltas
                        cf = aw.qmc.curvefilter*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                        decay_smoothing_p = not aw.qmc.optimalSmoothing or sampling or aw.qmc.flagon
                        t1 = self.smooth_list(self.timex,temp1_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
                        t2 = self.smooth_list(self.timex,temp2_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
                        # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                        if aw.qmc.timeindex[0]>-1:
                            RoR_start = min(aw.qmc.timeindex[0]+10, len(self.timex)-1)
                        else:
                            RoR_start = -1
                        self.delta1, self.delta2 = self.recomputeDeltas(self.timex,RoR_start,aw.qmc.timeindex[6],t1,t2,optimalSmoothing=not decay_smoothing_p,timex_lin=timex_lin)
                        
## Output Idle Noise StdDev of BT RoR
#                        try:
#                            start = aw.qmc.timeindex[0]
#                            end = aw.qmc.timeindex[6]
#                            if start == -1:
#                                start = 0
#                            start = start + 30 # avoiding the empty begin of heavy smoothed data
#                            if end == 0:
#                                end = min(len(self.delta2) -1,100)
#                            print("BT RoR mean:",numpy.mean([x for x in self.delta2[start:end] if x is not None]))
#                            print("BT RoR std (old):",numpy.std([x for x in self.delta2[start:end] if x is not None]))
#                            print("BT RoR std (new):",numpy.std(self.delta2))
#                        except Exception as e:
#                            print(e)
                    ##### DeltaET,DeltaBT curves
                    if self.delta_ax:
                        if len(self.timex) == len(self.delta1) and len(self.timex)  == len(self.delta2):
                            trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
                            if aw.qmc.swapdeltalcds:
                                self.drawDeltaET(trans)
                                self.drawDeltaBT(trans)
                            else:
                                self.drawDeltaBT(trans)
                                self.drawDeltaET(trans)
                ##### Extra devices-curves
                self.extratemp1lines,self.extratemp2lines = [],[]
                for i in range(min(len(self.extratimex),len(self.extratemp1),len(self.extradevicecolor1),len(self.extraname1),len(self.extratemp2),len(self.extradevicecolor2),len(self.extraname2))):
                    if self.extratimex[i] is not None and self.extratimex[i] and len(self.extratimex[i])>1:
                        timexi_lin = numpy.linspace(self.extratimex[i][0],self.extratimex[i][-1],len(self.extratimex[i]))
                    else:
                        timexi_lin = None
                    try:
                        if aw.extraCurveVisibility1[i]:
                            if (not aw.qmc.flagon or aw.qmc.smooth_curves_on_recording) and (smooth or len(self.extrastemp1[i]) != len(self.extratimex[i])):
                                self.extrastemp1[i] = self.smooth_list(self.extratimex[i],self.fill_gaps(self.extratemp1[i]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timexi_lin)
                            else: # we don't smooth, but remove the dropouts
                                self.extrastemp1[i] = self.fill_gaps(self.extratemp1[i])
                            if aw.extraDelta1[i]:
                                trans = self.delta_ax.transData
                            else:
                                trans = self.ax.transData
                            # first draw the fill if any, but not during recording!
                            if not aw.qmc.flagstart and aw.extraFill1[i] > 0:
                                self.ax.fill_between(self.extratimex[i], 0, self.extrastemp1[i],transform=trans,color=self.extradevicecolor1[i],alpha=aw.extraFill1[i]/100.,sketch_params=None)
                            self.extratemp1lines.append(self.ax.plot(self.extratimex[i], self.extrastemp1[i],transform=trans,color=self.extradevicecolor1[i],
                                sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths1[i]+aw.qmc.patheffects,foreground=self.palette["background"])],
                                markersize=self.extramarkersizes1[i],marker=self.extramarkers1[i],linewidth=self.extralinewidths1[i],linestyle=self.extralinestyles1[i],
                                drawstyle=self.extradrawstyles1[i],label=extraname1_subst[i])[0])
                    except Exception as ex:
                        _, _, exc_tb = sys.exc_info() 
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() {0}").format(str(ex)),exc_tb.tb_lineno)
                    try:
                        if aw.extraCurveVisibility2[i]:
                            if (not aw.qmc.flagon or aw.qmc.smooth_curves_on_recording) and (smooth or len(self.extrastemp2[i]) != len(self.extratimex[i])):
                                self.extrastemp2[i] = self.smooth_list(self.extratimex[i],self.fill_gaps(self.extratemp2[i]),window_len=self.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timexi_lin)
                            else:
                                self.extrastemp2[i] = self.fill_gaps(self.extratemp2[i])
                            if aw.extraDelta2[i]:
                                trans = self.delta_ax.transData
                            else:
                                trans = self.ax.transData
                            # first draw the fill if any
                            if not aw.qmc.flagstart and aw.extraFill2[i] > 0:
                                self.ax.fill_between(self.extratimex[i], 0, self.extrastemp2[i],transform=trans,color=self.extradevicecolor2[i],alpha=aw.extraFill2[i]/100.,sketch_params=None)
                            self.extratemp2lines.append(self.ax.plot(self.extratimex[i],self.extrastemp2[i],transform=trans,color=self.extradevicecolor2[i],
                                sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.extralinewidths2[i]+aw.qmc.patheffects,foreground=self.palette["background"])],
                                markersize=self.extramarkersizes2[i],marker=self.extramarkers2[i],linewidth=self.extralinewidths2[i],linestyle=self.extralinestyles2[i],drawstyle=self.extradrawstyles2[i],label= extraname2_subst[i])[0])
                    except Exception as ex:
                        _, _, exc_tb = sys.exc_info() 
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() {0}").format(str(ex)),exc_tb.tb_lineno)
                ##### ET,BT curves
                if aw.qmc.swaplcds:
                    self.drawET()
                    self.drawBT()
                else:
                    self.drawBT()
                    self.drawET()
                
                if aw.qmc.ETcurve:
                    self.handles.append(self.l_temp1)
                    self.labels.append(aw.arabicReshape(aw.ETname))
                if aw.qmc.BTcurve:
                    self.handles.append(self.l_temp2)
                    self.labels.append(aw.arabicReshape(aw.BTname))

                if self.DeltaETflag: 
                    self.handles.append(self.l_delta1)
                    self.labels.append(aw.arabicReshape(deltaLabelMathPrefix + aw.ETname))
                if self.DeltaBTflag:
                    self.handles.append(self.l_delta2)
                    self.labels.append(aw.arabicReshape(deltaLabelMathPrefix + aw.BTname))

                nrdevices = len(self.extradevices)
                
                if nrdevices and not self.designerflag:
                    xtmpl1idx = 0
                    xtmpl2idx = 0
                    for i in range(nrdevices):
                        if aw.extraCurveVisibility1[i]:
                            idx1 = xtmpl1idx
                            xtmpl1idx = xtmpl1idx + 1
                            l1 = extraname1_subst[i]
                            if not l1.startswith("_"):
                                self.handles.append(self.extratemp1lines[idx1])
                                try:
                                    self.labels.append(aw.arabicReshape(l1.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3])))
                                except:
                                    # a key error can occure triggered by the format if curley braces are used without reference
                                    self.labels.append(aw.arabicReshape(l1))
                        if aw.extraCurveVisibility2[i]:
                            idx2 = xtmpl2idx
                            xtmpl2idx = xtmpl2idx + 1
                            l2 = extraname2_subst[i]
                            if not l2.startswith("_"):
                                self.handles.append(self.extratemp2lines[idx2])
                                try:
                                    self.labels.append(aw.arabicReshape(l2.format(self.etypes[0],self.etypes[1],self.etypes[2],self.etypes[3])))
                                except:
                                    # a key error can occure triggered by the format if curley braces are used without reference
                                    self.labels.append(aw.arabicReshape(l2))

                if self.eventsshowflag and self.eventsGraphflag in [2,3,4] and Nevents:
                    if E1_nonempty and aw.qmc.showEtypes[0]:
                        self.handles.append(self.l_eventtype1dots)
                        self.labels.append(aw.arabicReshape(self.etypesf(0)))
                    if E2_nonempty and aw.qmc.showEtypes[1]:
                        self.handles.append(self.l_eventtype2dots)
                        self.labels.append(aw.arabicReshape(self.etypesf(1)))
                    if E3_nonempty and aw.qmc.showEtypes[2]:
                        self.handles.append(self.l_eventtype3dots)
                        self.labels.append(aw.arabicReshape(self.etypesf(2)))
                    if E4_nonempty and aw.qmc.showEtypes[3]:
                        self.handles.append(self.l_eventtype4dots)
                        self.labels.append(aw.arabicReshape(self.etypesf(3)))
                            
                if not self.designerflag and aw.qmc.BTcurve:
                    if self.flagon: # no smoothed lines in this case, pass normal BT
                        aw.qmc.l_annotations = self.place_annotations(aw.qmc.TPalarmtimeindex,aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.temp2)
                    else:
                        TP_index = aw.findTP()
                        if aw.qmc.annotationsflag:
                            aw.qmc.l_annotations = self.place_annotations(TP_index,aw.qmc.ylimit - aw.qmc.ylimit_min,self.timex,self.timeindex,self.temp2,self.stemp2)
                        if self.timeindex[6]:
                            self.writestatistics(TP_index)
                
                if not sampling and not aw.qmc.flagon and self.timeindex[6] and aw.qmc.statssummary:
                    self.statsSummary()
                else:
                    self.stats_summary_rect = None

                if not sampling and not aw.qmc.flagon and self.timeindex[6] and aw.qmc.AUCshowFlag:
                    self.drawAUC()
# this seems to mess up the focus if sliders are shown, but mini editor not
#                    #if recorder on
#                    if self.flagon and self.eventsshowflag:
#                        #if not self.eventsshowflag:
#                        #    Nevents = len(self.specialevents)
#                        #update to last event
#                        if Nevents:
#                            aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
#                            aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
#                        else:
#                            aw.etypeComboBox.setCurrentIndex(0)
#                            aw.valueEdit.setText("")
#                        aw.eNumberSpinBox.setValue(Nevents)
    
                #update label colors
                for label in self.ax.xaxis.get_ticklabels():
                    label.set_color(self.palette["xlabel"])
                for label in self.ax.yaxis.get_ticklabels():
                    label.set_color(self.palette["ylabel"])
                if two_ax_mode and self.delta_ax:
                    for label in self.delta_ax.yaxis.get_ticklabels():
                        label.set_color(self.palette["ylabel"])
                
                #write legend
                if self.legendloc and not sampling and not aw.qmc.flagon and len(self.timex) > 2:
                    rcParams['path.effects'] = []
                    prop = aw.mpl_fontproperties.copy()
                    prop.set_size("x-small")
                    if len(self.handles) > 7:
                        ncol = int(math.ceil(len(self.handles)/4.))
                    elif len(self.handles) > 3:
                        ncol = int(math.ceil(len(self.handles)/2.))
                    else:
                        ncol = int(math.ceil(len(self.handles)))
                    if aw.qmc.graphfont == 1:
                        self.labels = [toASCII(l) for l in self.labels]
                    if self.legend is None:
                        if self.legendloc_pos is None:
                            loc = self.legendloc
                        else:
                            loc = self.legendloc_pos
                    else:
                        loc = self.legend._loc
                    leg = self.ax.legend(self.handles,self.labels,loc=loc,ncol=ncol,fancybox=True,prop=prop,shadow=False,frameon=True)
                    
                    try:
                        leg.set_in_layout(False) # remove legend from tight_layout calculation
                    except: # set_in_layout not available in mpl<3.x
                        pass
                    self.legend = leg
                    self.legend_lines = leg.get_lines()
                    for h in leg.legendHandles:
                        h.set_picker(False) # we disable the click to hide on the handles feature
                        #h.set_picker(aw.draggable_text_box_picker) # as setting this picker results in non-termination
                    for l in leg.texts:
                        #l.set_picker(5)
                        l.set_picker(aw.draggable_text_box_picker)
                    try:
                        leg.set_draggable(state=True,use_blit=True)  #,update='bbox')
                        leg.set_picker(aw.draggable_text_box_picker)
                    except: # not available in mpl<3.x
                        leg.draggable(state=True) # for mpl 2.x
                    frame = leg.get_frame()
                    frame.set_facecolor(self.palette["legendbg"])
#                    frame.set_alpha(self.legendbgalpha)
                    frame.set_alpha(self.alpha["legendbg"])
                    frame.set_edgecolor(self.palette["legendborder"])
                    frame.set_linewidth(0.5)
                    for line,text in zip(leg.get_lines(), leg.get_texts()):
                        text.set_color(line.get_color())
                    if aw.qmc.patheffects:
                        rcParams['path.effects'] = [PathEffects.withStroke(linewidth=aw.qmc.patheffects, foreground=self.palette["background"])]
                else:
                    self.legend = None

                # we create here the project line plots to have the accurate time axis after CHARGE
                dashes_setup = [0.4,0.8,0.1,0.8] # simulating matplotlib 1.5 default on 2.0  

                #watermark image
                self.placelogoimage()

                ############  ready to plot ############
#                self.fig.canvas.draw() # done also by updateBackground(), but the title on ON is not update if not called here too (might be a MPL bug in v3.1.2)!
                self.updateBackground() # update bitlblit backgrounds
                #######################################
                    
                # add projection and AUC guide lines last as those are removed by updategraphics for optimized redrawing and not cached
                if aw.qmc.projectFlag and aw.qmc.BTcurve:
                    self.l_BTprojection, = self.ax.plot([], [],color = self.palette["bt"],
                                                dashes=dashes_setup,
                                                label=aw.arabicReshape(QApplication.translate("Label", "BTprojection", None)),
                                                linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                if aw.qmc.projectFlag and aw.qmc.ETcurve:
                    self.l_ETprojection, = self.ax.plot([], [],color = self.palette["et"],
                                                dashes=dashes_setup,
                                                label=aw.arabicReshape(QApplication.translate("Label", "ETprojection", None)),
                                                linestyle = '-.', linewidth= 8, alpha = .3,sketch_params=None,path_effects=[])
                                                
                if aw.qmc.AUCguideFlag:
                    self.l_AUCguide, = self.ax.plot([], [],color = self.palette["aucguide"],
                                                label=aw.arabicReshape(QApplication.translate("Label", "AUCguide", None)),
                                                linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])

                if aw.qmc.showtimeguide or (aw.qmc.device == 18 and aw.simulator is None):
                    self.l_timeline, = self.ax.plot([], [],color = self.palette["timeguide"],
                                                label=aw.arabicReshape(QApplication.translate("Label", "TIMEguide", None)),
                                                linestyle = '-', linewidth= 1, alpha = .5,sketch_params=None,path_effects=[])

                # if designer ON
                if self.designerflag:
                    if self.background:
                        self.ax.lines = self.ax.lines[2:] # this might be wrong as the background can also have delta, 3rd curve and 4x event artists!!
                    if len(self.timex):
                        self.xaxistosm()
                        self.redrawdesigner()
                        
                if aw.qmc.patheffects:
                    rcParams['path.effects'] = []  
                                    
                # HACK
                # a bug in Qt/PyQt/mpl cause the canvas not to be repainted on load/switch/reset in fullscreen mode without this
                try:
                    if platf == 'Darwin' and app.allWindows()[0].visibility() == QWindow.FullScreen or aw.full_screen_mode_active or aw.isFullScreen():
                        aw.qmc.repaint()
                        QApplication.processEvents()
                except:
                    pass

            except Exception as ex:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()    
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " redraw() {0}").format(str(ex)),exc_tb.tb_lineno)
            finally:
                # we initialize at the end of the redraw the event and flag annotation custom position loaded from a profile as it should have been consumed
                self.l_annotations_pos_dict = {}
                self.l_event_flags_pos_dict = {}
                self.legendloc_pos = None
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)


    def parseSpecialeventannotation(self,eventanno, eventnum, applyto="foreground", postFCs=False):
        try:
            #background curve values
            if applyto == "background":
                e1 = self.backgroundEvalues[eventnum]
                e2 = self.backgroundEvalues[eventnum]
                e3 = self.backgroundEvalues[eventnum]
                e4 = self.backgroundEvalues[eventnum]
                y1 = self.temp1B[self.backgroundEvents[eventnum]]
                y2 = self.temp2B[self.backgroundEvents[eventnum]]

                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] > self.timeB[self.timeindexB[2]]:
                    postFCs = True
                    dtr = aw.float2float(100 * (self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]]) / (self.timeB[self.timeindexB[2]] - self.timeB[self.timeindexB[0]]),1)
                else:
                    postFCs = False
                    dtr = 0
                if self.timeindexB[2] > 0:
                    dfcs = aw.float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[2]],0)
                else:
                    dfcs = "*"
                if self.timeindexB[2] > 0 and self.timeB[self.backgroundEvents[eventnum]] < self.timeB[self.timeindexB[2]]:
                    prefcs = aw.float2float(self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]],0)
                else:
                    prefcs = '*'
                if self.timeindexB[0] > -1 and self.timeB[self.backgroundEvents[eventnum]] > self.timeB[self.timeindexB[0]]:
                    dcharge = aw.float2float(self.timeB[self.backgroundEvents[eventnum]] - self.timeB[self.timeindexB[0]],0)
                else:
                    dcharge = 0
                if not postFCs and (self.timeB[self.timeindexB[2]] - self.timeB[self.backgroundEvents[eventnum]]) < 90:
                    fcsWindow = True
                else:
                    fcsWindow = False

            # plug values for the previews
            elif applyto == "preview":
                e1 = 8.0  #70 
                e2 = 7.5  #65 
                e3 = 7.0  #60 
                e4 = 6.0  #50 
                y1 = 420
                y2 = 340
                dcharge = 340
                dfcs = 47
                prefcs = 50
                dtr = 12
                fcsWindow = True
                #postFCs supplied in the call

            # foreground curve values
            else:
                e1 = self.specialeventsvalue[eventnum]
                e2 = self.specialeventsvalue[eventnum]
                e3 = self.specialeventsvalue[eventnum]
                e4 = self.specialeventsvalue[eventnum]
                y1 = self.temp1[self.specialevents[eventnum]]
                y2 = self.temp2[self.specialevents[eventnum]]

                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] > self.timex[self.timeindex[2]]:
                    postFCs = True
                    dtr = aw.float2float(100 * (self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]]) / (self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]]),1)
                else:
                    postFCs = False
                    dtr = 0
                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] >= self.timex[self.timeindex[2]]:
                    dfcs = aw.float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[2]],0)
                else:
                    dfcs = "*"
                if self.timeindex[2] > 0 and self.timex[self.specialevents[eventnum]] < self.timex[self.timeindex[2]]:
                    prefcs = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]],0)
                else:
                    prefcs = '*'
                if self.timeindex[0] > -1 and self.timex[self.specialevents[eventnum]] > self.timex[self.timeindex[0]]:
                    dcharge = aw.float2float(self.timex[self.specialevents[eventnum]] - self.timex[self.timeindex[0]],0)
                else:
                    dcharge = 0
                if not postFCs and self.timex[self.timeindex[2]] - self.timex[self.specialevents[eventnum]] < 90:
                    fcsWindow = True
                else:
                    fcsWindow = False

            # Caution - the events E1,E2,E3,and E4 must be the first four entries in the fields list
            fields = [
                (QApplication.translate("AutosaveField", "E1",None), u(aw.qmc.eventsInternal2ExternalValue(e1))),
                (QApplication.translate("AutosaveField", "E2",None), u(aw.qmc.eventsInternal2ExternalValue(e2))),
                (QApplication.translate("AutosaveField", "E3",None), u(aw.qmc.eventsInternal2ExternalValue(e3))),
                (QApplication.translate("AutosaveField", "E4",None), u(aw.qmc.eventsInternal2ExternalValue(e4))),
                (QApplication.translate("AutosaveField", "Y1",None), u(aw.float2float(y1,0))),
                (QApplication.translate("AutosaveField", "Y2",None), u(aw.float2float(y2,0))),
                (QApplication.translate("AutosaveField", "dCHARGE",None), u(dcharge)),
                (QApplication.translate("AutosaveField", "dFCs",None), u(dfcs)),
                (QApplication.translate("AutosaveField", "preFCs",None), u(prefcs)),
                (QApplication.translate("AutosaveField", "DTR",None), u(dtr)),
                (QApplication.translate("AutosaveField", "mode",None), u(self.mode)),
                (QApplication.translate("AutosaveField", "degmode",None), u('\u00b0' + self.mode)),
                (QApplication.translate("AutosaveField", "deg",None), u('\u00b0')),
                (QApplication.translate("AutosaveField", "squot",None), u("'")),
                (QApplication.translate("AutosaveField", "quot",None), u('"')),
                ]

            #single, leading delimiter for the fields
            #replace with self.fieldDelim
            self.fieldDelim = '~'  #note this value is hard coded in autosavefieldsHelpDlg(). 
            #delimiter to show before FCs only
            preFCsDelim = "'"
            #delimiter to show after FCs only
            postFCsDelim = '"'
            #delimiter to show within a window before FCs only
            fcsWindowDelim = '`'
            #delimiter for explicit value substitutions
            nominalDelimopen = '{'
            nominalDelimclose = '}'
            nominalstringDelim = '|'

            #newlines can sneak in from cut and paste from help page 
            eventanno = eventanno.replace('\n', '')

            #text between single quotes ' will show only before FCs
            eventanno = re.sub(fr"{preFCsDelim}([^{preFCsDelim}]+){preFCsDelim}",r"\1",eventanno) if not postFCs else re.sub(fr"{preFCsDelim}([^{preFCsDelim}]+){preFCsDelim}",r"",eventanno)
            #text between double quotes " will show only after FCs
            eventanno = re.sub(fr'{postFCsDelim}([^{postFCsDelim}]+){postFCsDelim}',r'\1',eventanno) if postFCs else re.sub(fr'{postFCsDelim}([^{postFCsDelim}]+){postFCsDelim}',r'',eventanno)

            #text between back ticks ` will show only within 90 seconds before FCs
            eventanno = re.sub(fr'{fcsWindowDelim}([^{fcsWindowDelim}]+){fcsWindowDelim}',r'\1',eventanno) if (fcsWindow) else re.sub(fr'{fcsWindowDelim}([^{fcsWindowDelim}]+){fcsWindowDelim}',r'',eventanno)

            # substitute numeric to nominal values if in the annotationstring
            # Caution - the events E1,E2,E3,and E4 must be the first four entries in the fields list
            ##debug - things to watch out for in testing:  
            # does the matchedgroup(4) always persist after the pattern.sub() above?
            # does the pattern.split always result in the same list pattern?  ex:
            #     ['|', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '|', '100', 'A Point', '']
            for i in range(4):
                pattern = re.compile(fr".*{nominalDelimopen}{self.fieldDelim}{fields[i][0]}(?P<nominalstr>[^{nominalDelimclose}]+){nominalDelimclose}")
                matched = pattern.match(eventanno)
                if matched != None:
                    pattern = re.compile(fr"([0-9]+)([A-Za-z]+[A-Za-z 0-9]+)")
                    matches = pattern.split(matched.group('nominalstr'))
                    
                    replacestring = ""
                    j = 1
                    #example form of the matches list ['|', '20', 'Fresh Cut Grass', '|', '50', 'Hay', '|', '80', 'Baking Bread', '']
                    while (j < len(matches)):
                        if fields[i][1] == matches[j]:
                            replacestring = matches[j+1]
                            break
                        else:
                            j += 3
                    pattern = re.compile(fr"({nominalDelimopen}{self.fieldDelim}{fields[3][0]}[^{nominalDelimclose}]+{nominalDelimclose})")
                    eventanno = pattern.sub(replacestring,eventanno)
               
            # make all the remaining substitutions
            for i in range(len(fields)):
#                pattern = re.compile(fr"(.*{self.fieldDelim})({fields[i][0]})([/*+-][0-9]+)?")
                pattern = re.compile(fr"(.*{self.fieldDelim})({fields[i][0]})(?P<mathop>[/*+-][0-9]+)?(({nominalstringDelim}[0-9]+[A-Za-z]+[A-Za-z 0-9]+)+)?")
                matched = pattern.match(eventanno)
                if matched != None:

                    # get the value associated with the field
                    replacestring = str(fields[i][1])
                    # do simple math if in the string
                    if matched.group('mathop') != None:
                        replacestring += matched.group('mathop')
                        replacestring = str(eval(replacestring))

                    pattern = re.compile(fr"{self.fieldDelim}{fields[i][0]}([/*+-][0-9]+)?")
                    eventanno = pattern.sub(replacestring,eventanno)

        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " parseSpecialeventannotation() {0}").format(str(ex)),exc_tb.tb_lineno)
            eventanno = ""

        return eventanno

    #watermark image
    def placelogoimage(self):
        if self.flagon and aw.logoimgflag:  #if hide during roast
            return
        try:
            if len(aw.logofilename) == 0 or self.logoimg is None: 
                return
            img_height_pixels, img_width_pixels, _ = self.logoimg.shape
            img_aspect = img_height_pixels / img_width_pixels
            coord_axes_middle_Display = self.ax.transAxes.transform((.5,.5))
            coord_axes_upperright_Display = self.ax.transAxes.transform((1.,1.))
            coord_axes_lowerleft_Display = self.ax.transAxes.transform((0.,0.))
            coord_axes_height_pixels = coord_axes_upperright_Display[1] - coord_axes_lowerleft_Display[1]
            coord_axes_width_pixels = coord_axes_upperright_Display[0] - coord_axes_lowerleft_Display[0]
            coord_axes_aspect = coord_axes_height_pixels / coord_axes_width_pixels
            if img_aspect >= coord_axes_aspect:
                scale = min(1., coord_axes_height_pixels / img_height_pixels)
            else:
                scale = min(1., coord_axes_width_pixels / img_width_pixels)

            corner_pixels = [0.,0.,0.,0.]
            corner_pixels[0] = coord_axes_middle_Display[0] - (scale * img_width_pixels / 2) 
            corner_pixels[1] = coord_axes_middle_Display[1] - (scale * img_height_pixels / 2)
            corner_pixels[2] = corner_pixels[0] + scale * img_width_pixels
            corner_pixels[3] = corner_pixels[1] + scale * img_height_pixels
            ll_corner_axes = self.ax.transData.inverted().transform_point((corner_pixels[0],corner_pixels[1]))
            ur_corner_axes = self.ax.transData.inverted().transform_point((corner_pixels[2],corner_pixels[3]))
            extent = [ll_corner_axes[0], ur_corner_axes[0], ll_corner_axes[1], ur_corner_axes[1]]
            self.ai = self.ax.imshow(self.logoimg, zorder=0, extent=extent, alpha=aw.logoimgalpha/10, aspect='auto', resample=False)
            
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " placelogoimage() {0}").format(str(ex)),exc_tb.tb_lineno)

    #watermark image
    def logoloadfile(self,filename=None):
        try:
            if not filename:
                filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Image File",None),ext="*.png *.jpg")
            if len(u(filename)) == 0:
                return
            from matplotlib.pyplot import imread
            aw.qmc.logoimg = imread(filename)
            aw.logofilename = filename
            aw.sendmessage(QApplication.translate("Message","Loaded watermark image {0}", None).format(filename))
            QTimer.singleShot(500, lambda : self.redraw(recomputeAllDeltas=False)) #some time needed before the redraw on artisan start with no profile loaded.  processevents() does not work here.
        except Exception as ex:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " logoloadfile() {0}").format(str(ex)),exc_tb.tb_lineno)
            aw.logofilename = ""

    #add stats summmary to graph 
    def statsSummary(self):
        try:
            # build roast of the day string
            if aw.qmc.roastbatchnr != None and aw.qmc.roastbatchnr != 0 and aw.qmc.roastbatchpos != None and aw.qmc.roastbatchpos != 0:
                roastoftheday = '\n' + str(aw.qmc.roastbatchpos)
                if locale == "en":
                    if aw.qmc.roastbatchpos > 3:
                        roastoftheday += 'th'
                    elif aw.qmc.roastbatchpos == 3:
                        roastoftheday += 'rd'
                    elif aw.qmc.roastbatchpos == 2:
                        roastoftheday += 'nd'
                    elif aw.qmc.roastbatchpos == 1:
                        roastoftheday += 'st'
                else:
                    roastoftheday = '\n#' + str(aw.qmc.roastbatchpos)
                roastoftheday += ' ' + QApplication.translate("AddlInfo", "Roast of the Day",None)
            else:
                roastoftheday = ''

            cp = aw.computedProfileInformation()  # get all the computed profile information

            skipline = '\n'
            statstr = ''
            if self.statssummary:
                
                #Admin Info Section
                if aw.qmc.roastbatchnr > 0:
                    statstr += aw.qmc.roastbatchprefix + str(aw.qmc.roastbatchnr) 
                if aw.qmc.title != QApplication.translate("Scope Title", "Roaster Scope",None):
                    if statstr != "":
                        statstr += " "
                    statstr += aw.qmc.title
                statstr += skipline
                statstr += aw.qmc.roastdate.date().toString() + ' '
                statstr += aw.qmc.roastdate.time().toString()
                statstr += roastoftheday
                if aw.qmc.ambientTemp not in [None,0] or aw.qmc.ambient_humidity not in [None,0] or aw.qmc.ambient_pressure not in [None,0]:
                    statstr += skipline
                    if aw.qmc.ambientTemp not in [None,0]:
                        statstr += str(int(aw.qmc.ambientTemp)) + u'\u00b0' + aw.qmc.mode + '  '
                    if aw.qmc.ambient_humidity not in [None,0]:
                        statstr +=  str(int(aw.qmc.ambient_humidity)) + '%  '
                    if aw.qmc.ambient_pressure not in [None,0]:
                        statstr +=  str(aw.float2float(aw.qmc.ambient_pressure,2)) + 'hPa'
                if aw.qmc.roastertype or aw.qmc.drumspeed:
                    statstr += skipline
                    if aw.qmc.roastertype:
                        statstr += str(aw.qmc.roastertype) + " "
                    if aw.qmc.drumspeed:
                        statstr += "(" + str(aw.qmc.drumspeed) + QApplication.translate("Label", "RPM",None) + ')'
                    
                #Green Beans Info Section
                statstr += skipline
                if aw.qmc.beans is not None and len(aw.qmc.beans)>0:
                    statstr += skipline
                    beans_lines = textwrap.wrap(aw.qmc.beans, width=aw.qmc.statsmaxchrperline)
                    statstr += beans_lines[0]
                    if len(beans_lines)>1:
                        statstr += skipline
                        statstr += "  " + beans_lines[1]
                        if len(beans_lines)>2:
                            statstr += ".."
                if aw.qmc.beansize_min or aw.qmc.beansize_max:
                    screen = ""
                    if aw.qmc.beansize_min:
                        screen = str(int(round(aw.qmc.beansize_min)))
                    if aw.qmc.beansize_max:
                        if screen:
                            screen = screen + "/"
                        screen = screen + str(int(round(aw.qmc.beansize_max)))
                        statstr += '\n' + QApplication.translate("AddlInfo", "Screen Size", None) + ': '+ screen # + '18/64\u2033' # the unit makes it hard to read
                if aw.qmc.density[0] and aw.qmc.density[2] != 0:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Density Green", None) + ': '+ str(aw.float2float(aw.qmc.density[0]/aw.qmc.density[2],2)) + ' ' + encodeLocal(aw.qmc.density[1]) + "/" + encodeLocal(aw.qmc.density[3]) 
                if aw.qmc.moisture_greens:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Moisture Green", None) + ': '+ str(aw.float2float(aw.qmc.moisture_greens,1)) + "%"
                if aw.qmc.weight[0]:
                    if aw.qmc.weight[2] == "g":
                        w =str(aw.float2float(aw.qmc.weight[0],0))
                    else:
                        w = str(aw.float2float(aw.qmc.weight[0],2))
                    statstr += '\n' + QApplication.translate("AddlInfo", "Batch Size", None) + ': '+ w + aw.qmc.weight[2] + " "
                    if aw.qmc.weight[1]:
                        statstr += '(-' + str(aw.float2float(aw.weight_loss(aw.qmc.weight[0],aw.qmc.weight[1]),1)) + "%)"

                # Roast Info Section
                statstr += skipline
                if "roasted_density" in cp:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Density Roasted", None) + ': '+ str(cp["roasted_density"]) + ' ' + encodeLocal(aw.qmc.density[1]) + "/" + encodeLocal(aw.qmc.density[3]) 
                if aw.qmc.moisture_roasted:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Moisture Roasted", None) + ': '+ str(aw.float2float(aw.qmc.moisture_roasted,1)) + "%"
                if aw.qmc.whole_color > 0:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Whole Color", None) + ': #' + str(aw.qmc.whole_color) + " " + str(aw.qmc.color_systems[aw.qmc.color_system_idx])
                if aw.qmc.ground_color > 0:
                    statstr += '\n' + QApplication.translate("AddlInfo", "Ground Color", None) + ': #' + str(aw.qmc.ground_color) + " " + str(aw.qmc.color_systems[aw.qmc.color_system_idx])
                if cp["AUC"]:
                    statstr += '\n' + QApplication.translate("AddlInfo", "AUC", None) + ': ' + str(cp["AUC"]) + 'C*min [' + str(cp["AUCbase"]) + aw.qmc.mode + "]"

                if aw.qmc.roastingnotes is not None and len(aw.qmc.roastingnotes)>0:
                    statstr += skipline
                    roasting_notes_lines = textwrap.wrap(aw.qmc.roastingnotes, width=aw.qmc.statsmaxchrperline)
                    statstr += roasting_notes_lines[0]
                    if len(roasting_notes_lines)>1:
                        statstr += skipline
                        statstr += "  " + roasting_notes_lines[1]
                        if len(roasting_notes_lines)>2:
                            statstr += ".."

                if aw.qmc.cuppingnotes is not None and len(aw.qmc.cuppingnotes)>0:
                    statstr += skipline
                    cupping_notes_lines = textwrap.wrap(aw.qmc.cuppingnotes, width=aw.qmc.statsmaxchrperline)
                    statstr += cupping_notes_lines[0]
                    if len(cupping_notes_lines)>1:
                        statstr += skipline
                        statstr += "  " + cupping_notes_lines[1]
                        if len(cupping_notes_lines)>2:
                            statstr += ".."

                # Trim the long lines
                trimmedstatstr = ""
                lines = statstr.split('\n')
                for l in lines:
                    if trimmedstatstr != "":
                        trimmedstatstr += '\n' 
                    trimmedstatstr += l[:aw.qmc.statsmaxchrperline]
                    if len(l) > aw.qmc.statsmaxchrperline:
                        trimmedstatstr += ".."
                statstr = trimmedstatstr

                #defaults appropriate for default font
                prop = aw.mpl_fontproperties.copy()
                prop.set_size("small")
                fc = aw.qmc.palette["statsanalysisbkgnd"]  #fill color
                tc = aw.labelBorW(fc)                   #text color
                a = aw.qmc.alpha["statsanalysisbkgnd"]     #alpha
                ls = 1.7                     #linespacing
                border = 10                  #space around outside of text box (in seconds)
                margin = 4                   #text to edge of text box
                
                #adjust for other fonts
                if aw.qmc.graphfont == 1:   #Humor
                    prop.set_size("x-small")
                if aw.qmc.graphfont == 2:   #Comic
                    ls = 1.2

                if aw.qmc.legendloc != 1:
                    # legend not in upper right
                    statsheight = aw.qmc.ylimit - (0.08 * (aw.qmc.ylimit - aw.qmc.ylimit_min)) # standard positioning
                else:
                    # legend in upper right
                    statsheight = aw.qmc.ylimit - (0.13 * (aw.qmc.ylimit - aw.qmc.ylimit_min))

                if aw.qmc.timeindex[0] != -1:
                    start = aw.qmc.timex[aw.qmc.timeindex[0]]
                else:
                    start = 0
                    
                # position the stats summary relative to the right hand edge of the graph                
                drop_label = QApplication.translate("Scope Annotation","DROP {0}", None).replace(" {0}","")
                _,_,droptext_end = self.droptextBounds(drop_label,start,statsheight,ls,prop,fc)
                stats_textbox_bounds = self.statstextboxBounds(self.ax.get_xlim()[1]+border,statsheight,statstr,ls,prop,fc)
                stats_textbox_width = stats_textbox_bounds[2]
                stats_textbox_height = stats_textbox_bounds[3]
                pos_x = self.ax.get_xlim()[1]-stats_textbox_width-border

                if (aw.qmc.autotimex):
                    aw.qmc.endofx = droptext_end + stats_textbox_width + 2*border # provide room for the stats
                    self.xaxistosm(redraw=False)  # recalculate the x axis

                    prev_stats_textbox_width = 0
                    #set the maximum number of iterations
                    for _ in range(2, 20):
                        _,_,droptext_end = self.droptextBounds(drop_label,start,statsheight,ls,prop,fc)
                        stats_textbox_bounds = self.statstextboxBounds(self.ax.get_xlim()[1]+border,statsheight,statstr,ls,prop,fc)
                        stats_textbox_width = stats_textbox_bounds[2]
                        stats_textbox_height = stats_textbox_bounds[3]

                        # position the stats summary relative to the right edge of the drop text
                        aw.qmc.endofx = droptext_end + stats_textbox_width + 2*border #provide room for the stats
                        self.xaxistosm(redraw=False)
                        #break the loop if it looks like stats_textbox_width has converged
                        if abs(prev_stats_textbox_width - stats_textbox_width) < .2:
                            break
                        else:
                            prev_stats_textbox_width = stats_textbox_width

                    pos_x = droptext_end + border + start
                
                pos_y = statsheight
#               self.stats_summary_rect = patches.Rectangle((pos_x-margin,pos_y+margin),stats_textbox_width+2*margin,-stats_textbox_height-2*margin,linewidth=0.5,edgecolor=aw.qmc.palette["grid"],facecolor=fc,fill=True,alpha=a,zorder=10)
                self.stats_summary_rect = patches.Rectangle((pos_x-margin,pos_y - (stats_textbox_height + 2*margin)),stats_textbox_width+2*margin,stats_textbox_height+3*margin,linewidth=0.5,edgecolor=aw.qmc.palette["grid"],facecolor=fc,fill=True,alpha=a,zorder=10)
                self.ax.add_patch(self.stats_summary_rect)

                text = self.ax.text(pos_x, pos_y, statstr, verticalalignment='top',linespacing=ls,fontproperties=prop,color=tc,zorder=11,path_effects=[])
                text.set_in_layout(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " statsSummary() {0}").format(str(e)),exc_tb.tb_lineno)

    def statstextboxBounds(self,x_pos,y_pos,textstr,ls,prop,fc):
        from matplotlib.transforms import Bbox
        t = self.ax.text(x_pos, y_pos, textstr, verticalalignment='top',linespacing=ls,fontproperties=prop,color=fc,path_effects=[])
        f = self.ax.get_figure()
        r = f.canvas.get_renderer()
        t.update_bbox_position_size(renderer=r)
        bb = t.get_window_extent(renderer=r) # bounding box in display space
        bbox_data = aw.qmc.ax.transData.inverted().transform(bb)
        bbox = Bbox(bbox_data)
        t.remove()
        return bbox.bounds


    def droptextBounds(self,drop_label,x_pos,y_pos,ls,prop,fc):
        droptext_width = 0
        droptextstart = 0
        droptext_end = aw.qmc.timex[-1] - x_pos #default for when Events Annotations is unchecked 
        for child in self.ax.get_children():
            if isinstance(child, mpl.text.Annotation):
                droptext = re.search(r'.*\((.*?),.*({0} [0-9:]*)'.format(drop_label),str(child))
                if droptext:
                    droptextstart = int(float(droptext.group(1))) - x_pos
                    droptext_width = self.statstextboxBounds(x_pos,y_pos,droptext.group(2),ls,prop,fc)[2]
                    droptext_end = droptextstart + droptext_width
        return droptext_width,droptextstart,droptext_end

    # adjusts height of annotations
    #supporting function for self.redraw() used to find best height of annotations in graph to avoid annotating over previous annotations (unreadable) when close to each other
    def findtextgap(self,ystep_down,ystep_up,height1,height2,dd=0):
        if dd <= 0:
            d = aw.qmc.ylimit - aw.qmc.ylimit_min
        else:
            d = dd
        init = int(d/12.0)
        gap = int(d/20.0)
        maxx = int(d/3.6)
        for i in range(init,maxx):
            if abs((height1 + ystep_up) - (height2+i)) > gap:
                break      
        for j in range(init,maxx):
            if abs((height1 - ystep_down) - (height2 - j)) > gap:
                break
        return j,i  #return height of arm

    # used to convert time from int seconds to string (like in the LCD clock timer). input int, output string xx:xx
    def stringfromseconds(self, seconds_raw, leadingzero=True):
        seconds = int(round(seconds_raw))
        if seconds >= 0:
            if leadingzero:
                return "%02d:%02d"% divmod(seconds, 60)
            else:
                return ("%2d:%02d"% divmod(seconds, 60)).strip()
        else:
            #usually the timex[timeindex[0]] is alreday taken away in seconds before calling stringfromseconds()
            negtime = abs(seconds)
            return "-%02d:%02d"% divmod(negtime, 60)

    #Converts a string into a seconds integer. Use for example to interpret times from Roaster Properties Dlg inputs
    #acepted formats: "00:00","-00:00"
    def stringtoseconds(self, string,errormsg=False):
        timeparts = string.split(":")
        if len(timeparts) != 2:
            if errormsg:
                aw.sendmessage(QApplication.translate("Message","Time format error encountered", None))
            return -1
        else:
            if timeparts[0][0] != "-":  #if number is positive
                seconds = int(timeparts[1])
                seconds += int(timeparts[0])*60
                return seconds
            else:
                seconds = int(timeparts[0])*60
                seconds -= int(timeparts[1])
                return seconds    #return negative number

    def fromFtoC(self,Ffloat):
        if Ffloat in [-1,None]:
            return Ffloat
        else:
            return (Ffloat-32.0)*(5.0/9.0)

    def fromCtoF(self,Cfloat):
        if Cfloat in [-1,None]:
            return Cfloat
        else:
            return (Cfloat*9.0/5.0)+32.0
            
    def RoRfromCtoF(self,CRoR):
        if CRoR in [-1,None]:
            return CRoR
        else:
            return (CRoR*9.0/5.0)
    
    def RoRfromFtoC(self,FRoR):
        if FRoR in [-1,None]:
            return FRoR
        else:
            return FRoR*(5.0/9.0)
    
    def convertRoR(self,r,source_unit,target_unit):
        if source_unit == "C":
            if target_unit == "C":
                return r
            else:
                return self.RoRfromCtoF(r)
        elif source_unit == "F":
            if target_unit == "F":
                return r
            else:
                return self.RoRfromFtoC(r)
        else:
            return r
            
    def convertTemp(self,t,source_unit,target_unit):
        if source_unit == "C":
            if target_unit == "C":
                return t
            else:
                return self.fromCtoF(t)
        elif source_unit == "F":
            if target_unit == "F":
                return t
            else:
                return self.fromFtoC(t)
        else:
            return t
            
    # adjust min/max limits of temperature sliders to the actual temperature mode
    def adjustTempSliders(self):
        if self.mode != self.mode_tempsliders:
            for i in range(4):
                if aw.eventslidertemp[i]:
                    if self.mode == "C":
                        aw.eventslidermin[i] = int(round(self.fromFtoC(aw.eventslidermin[i])))
                        aw.eventslidermax[i] = int(round(self.fromFtoC(aw.eventslidermax[i])))
                    else:
                        aw.eventslidermin[i] = int(round(self.fromCtoF(aw.eventslidermin[i])))
                        aw.eventslidermax[i] = int(round(self.fromCtoF(aw.eventslidermax[i])))
            aw.updateSliderMinMax()
            self.mode_tempsliders = self.mode    
            
    #sets the graph display in Fahrenheit mode
    def fahrenheitMode(self,setdefaultaxes=True):
        if setdefaultaxes:
            # just set it to the defaults to avoid strange conversion issues
            self.ylimit = self.ylimit_F_default
            self.ylimit_min = self.ylimit_min_F_default
            self.ygrid = self.ygrid_F_default
            self.zlimit = self.zlimit_F_default
            self.zlimit_min = self.zlimit_min_F_default
            self.zgrid = self.zgrid_F_default
        if self.mode == "C":
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(self.fromCtoF(self.phases[i])))
            self.ETtarget = int(round(self.fromCtoF(self.ETtarget)))
            self.ET2target = int(round(self.fromCtoF(self.ET2target)))
            self.BTtarget = int(round(self.fromCtoF(self.BTtarget)))
            self.BT2target = int(round(self.fromCtoF(self.BT2target)))
            self.AUCbase = int(round(self.fromCtoF(self.AUCbase)))
# this is wrong            
#            self.RoRlimit = int(round(self.fromCtoF(self.RoRlimit)))
#            self.RoRlimitm = int(round(self.fromCtoF(self.RoRlimitm)))
            self.alarmtemperature = [(self.fromCtoF(t) if t != 500 else t) for t in self.alarmtemperature]
            # conv Arduino mode
            if aw:
                aw.pidcontrol.conv2fahrenheit()
        self.ax.set_ylabel("F",size=16,color = self.palette["ylabel"]) #Write "F" on Y axis
        self.mode = "F"
        if aw: # during initialization aw is still None!
            aw.FahrenheitAction.setDisabled(True)
            aw.CelsiusAction.setEnabled(True)
            aw.ConvertToFahrenheitAction.setDisabled(True)
            aw.ConvertToCelsiusAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_F_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_F_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_F_default
            self.adjustTempSliders()

    #sets the graph display in Celsius mode
    def celsiusMode(self,setdefaultaxes=True):
        if setdefaultaxes:
            self.ylimit = self.ylimit_C_default
            self.ylimit_min = self.ylimit_min_C_default
            self.ygrid = self.ygrid_C_default
            self.zlimit = self.zlimit_C_default
            self.zlimit_min = self.zlimit_min_C_default
            self.zgrid = self.zgrid_C_default
        if self.mode == "F":
            #change watermarks limits. dryphase1, dryphase2, midphase, and finish phase Y limits
            for i in range(4):
                self.phases[i] = int(round(self.fromFtoC(self.phases[i])))
            self.ETtarget = int(round(self.fromFtoC(self.ETtarget)))
            self.ET2target = int(round(self.fromFtoC(self.ET2target)))
            self.BTtarget = int(round(self.fromFtoC(self.BTtarget)))
            self.BT2target = int(round(self.fromFtoC(self.BT2target)))
            self.AUCbase = int(round(self.fromFtoC(self.AUCbase)))
# This translates a limit (0F/min,30F/min) to (-18C/min, -1C/min) which is wrong
#            self.RoRlimit = int(round(self.fromFtoC(self.RoRlimit)))
#            self.RoRlimitm = int(round(self.fromFtoC(self.RoRlimitm)))
            self.alarmtemperature = [(self.fromFtoC(t) if t != 500 else t) for t in self.alarmtemperature]
            # conv Arduino mode
            if aw:
                aw.pidcontrol.conv2celsius()
        self.ax.set_ylabel("C",size=16,color = self.palette["ylabel"]) #Write "C" on Y axis
        self.mode = "C"
        if aw: # during initialization aw is still None
            aw.CelsiusAction.setDisabled(True)
            aw.FahrenheitAction.setEnabled(True)
            aw.ConvertToCelsiusAction.setDisabled(True)
            aw.ConvertToFahrenheitAction.setEnabled(True)
            # configure dropfilter
            aw.qmc.filterDropOut_tmin = aw.qmc.filterDropOut_tmin_C_default
            aw.qmc.filterDropOut_tmax = aw.qmc.filterDropOut_tmax_C_default
            aw.qmc.filterDropOut_spikeRoR_dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit_C_default
            self.adjustTempSliders()

    @pyqtSlot()
    @pyqtSlot(bool)
    def fahrenheitModeRedraw(self,_=False):
        self.fahrenheitMode()
        self.redraw()

    @pyqtSlot()
    @pyqtSlot(bool)
    def celsiusModeRedraw(self,_=False):
        self.celsiusMode()
        self.redraw()
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureF(self,_=False):
        self.convertTemperature("F")

    @pyqtSlot()
    @pyqtSlot(bool)
    def convertTemperatureC(self,_=False):
        self.convertTemperature("C")

    #converts a loaded profile to a different temperature scale. t input is the requested mode (F or C).
    def convertTemperature(self,t,silent=False,setdefaultaxes=True):
        #verify there is a loaded profile
        profilelength = len(self.timex)
        if profilelength > 0 or self.background:
            if t == "F":
                if silent:
                    reply = QMessageBox.Yes
                else:
                    string = QApplication.translate("Message", "Convert profile data to Fahrenheit?",None)
                    reply = QMessageBox.question(aw,QApplication.translate("Message", "Convert Profile Temperature",None),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "C":
                        aw.CelsiusAction.setDisabled(True)
                        aw.FahrenheitAction.setEnabled(True)
                        aw.ConvertToCelsiusAction.setDisabled(True)
                        aw.ConvertToFahrenheitAction.setEnabled(True)
                        aw.qmc.l_annotations_dict = {}
                        aw.qmc.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = self.fromCtoF(self.temp1[i])    #ET
                            self.temp2[i] = self.fromCtoF(self.temp2[i])    #BT
                            if len(self.delta1):
                                self.delta1[i] = self.fromCtoF(self.delta1[i])  #Delta ET
                            if len(self.delta2):
                                self.delta2[i] = self.fromCtoF(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)   
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                                            aw.qmc.extratemp1[e][i] = self.fromCtoF(aw.qmc.extratemp1[e][i])
                                        if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                                            aw.qmc.extratemp2[e][i] = self.fromCtoF(aw.qmc.extratemp2[e][i])
                                    except Exception:
                                        pass
                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = self.fromCtoF(self.ambientTemp)  #ambient temperature

                        #prevents accidentally deleting a modified profile. 
                        self.fileDirty()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromCtoF(self.temp1B[i])
                            self.temp2B[i] = self.fromCtoF(self.temp2B[i])
                            self.stemp1B[i] = self.fromCtoF(self.stemp1B[i])
                            self.stemp2B[i] = self.fromCtoF(self.stemp2B[i])

                        self.fahrenheitMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            aw.sendmessage(QApplication.translate("Message","Profile changed to Fahrenheit", None))

                    elif not silent:
                        QMessageBox.information(aw,QApplication.translate("Message", "Convert Profile Temperature",None),
                                                QApplication.translate("Message", "Unable to comply. You already are in Fahrenheit", None))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None))
                        return

            elif t == "C":
                if silent:
                    reply = QMessageBox.Yes
                else:
                    string = QApplication.translate("Message", "Convert profile data to Celsius?",None)
                    reply = QMessageBox.question(aw,QApplication.translate("Message", "Convert Profile Temperature",None),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                elif reply == QMessageBox.Yes:
                    if self.mode == "F":    
                        aw.ConvertToFahrenheitAction.setDisabled(True)
                        aw.ConvertToCelsiusAction.setEnabled(True) 
                        aw.FahrenheitAction.setDisabled(True)
                        aw.CelsiusAction.setEnabled(True)
                        aw.qmc.l_annotations_dict = {}
                        aw.qmc.l_event_flags_dict = {}
                        for i in range(profilelength):
                            self.temp1[i] = self.fromFtoC(self.temp1[i])    #ET
                            self.temp2[i] = self.fromFtoC(self.temp2[i])    #BT
                            if self.device != 18 or aw.simulator is not None:
                                if len(self.delta1):
                                    self.delta1[i] = self.fromFtoC(self.delta1[i])  #Delta ET
                                if len(self.delta2):
                                    self.delta2[i] = self.fromFtoC(self.delta2[i])  #Delta BT
                            #extra devices curves
                            nextra = len(aw.qmc.extratemp1)
                            if nextra:
                                for e in range(nextra):
                                    try:
                                        if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                                            aw.qmc.extratemp1[e][i] = self.fromFtoC(aw.qmc.extratemp1[e][i])
                                        if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                                            aw.qmc.extratemp2[e][i] = self.fromFtoC(aw.qmc.extratemp2[e][i])
                                    except Exception:
                                        pass

                        if self.ambientTemp is not None and self.ambientTemp != 0:
                            self.ambientTemp = self.fromFtoC(self.ambientTemp)  #ambient temperature

                        #prevents accidentally deleting a modified profile. 
                        self.fileDirty()

                        #background
                        for i in range(len(self.timeB)):
                            self.temp1B[i] = self.fromFtoC(self.temp1B[i]) #ET B
                            self.temp2B[i] = self.fromFtoC(self.temp2B[i]) #BT B
                            self.stemp1B[i] = self.fromFtoC(self.stemp1B[i])
                            self.stemp2B[i] = self.fromFtoC(self.stemp2B[i])

                        self.celsiusMode(setdefaultaxes=setdefaultaxes)
                        if not silent:
                            aw.sendmessage(QApplication.translate("Message","Profile changed to Celsius", None))

                    elif not silent:
                        QMessageBox.information(aw,QApplication.translate("Message", "Convert Profile Temperature",None),
                                                QApplication.translate("Message", "Unable to comply. You already are in Celsius",None))
                        aw.sendmessage(QApplication.translate("Message","Profile not changed", None))
                        return

            if not silent:
                self.redraw(recomputeAllDeltas=True,smooth=True)

        elif not silent:
            QMessageBox.information(aw,QApplication.translate("Message", "Convert Profile Scale",None),
                                          QApplication.translate("Message", "No profile data found",None))

    @pyqtSlot()
    @pyqtSlot(bool)
    def changeGColor3(self,_=False):
        self.changeGColor(3)

    #selects color mode: input 1=color mode; input 2=black and white mode (printing); input 3 = customize colors
    def changeGColor(self,color):
        #load selected dictionary
        if color == 1:
            aw.sendmessage(QApplication.translate("Message","Colors set to defaults", None))
            fname = os.path.join(aw.getResourcePath(),"Themes","Artisan","Default.athm")
            if os.path.isfile(fname) and not self.flagon:
                aw.loadSettings(fn=fname,remember=False,reset=False)
                aw.sendmessage(QApplication.translate("Message","Colors set to Default Theme", None))
            else:
                for key in list(self.palette1.keys()):
                    self.palette[key] = self.palette1[key]
                self.backgroundmetcolor     = self.palette["et"]
                self.backgroundbtcolor      = self.palette["bt"]
                self.backgrounddeltaetcolor = self.palette["deltaet"]
                self.backgrounddeltabtcolor = self.palette["deltabt"]
                self.backgroundxtcolor      = self.palette["xt"]
                self.EvalueColor = self.EvalueColor_default.copy()
                self.EvalueTextColor = self.EvalueTextColor_default.copy()
                aw.sendmessage(QApplication.translate("Message","Colors set to defaults", None))
                
            
        if color == 2:
            aw.sendmessage(QApplication.translate("Message","Colors set to grey", None))
            for key in list(aw.qmc.palette.keys()):
                c = aw.qmc.palette[key]
                nc = aw.convertToGreyscale(c)
                self.palette[key] = nc
            for i in range(len(aw.qmc.extradevices)):
                c = aw.qmc.extradevicecolor1[i]
                aw.qmc.extradevicecolor1[i] = aw.convertToGreyscale(c)
                c = aw.qmc.extradevicecolor2[i]
                aw.qmc.extradevicecolor2[i] = aw.convertToGreyscale(c)       
            for i in range(len(aw.qmc.EvalueColor)):
                c = aw.qmc.EvalueColor[i]
                aw.qmc.EvalueColor[i] = aw.convertToGreyscale(c)
            aw.qmc.backgroundmetcolor     = aw.convertToGreyscale(aw.qmc.backgroundmetcolor)
            aw.qmc.backgroundbtcolor      = aw.convertToGreyscale(aw.qmc.backgroundbtcolor)
            aw.qmc.backgrounddeltaetcolor = aw.convertToGreyscale(aw.qmc.backgrounddeltaetcolor)
            aw.qmc.backgrounddeltabtcolor = aw.convertToGreyscale(aw.qmc.backgrounddeltabtcolor)
            aw.qmc.backgroundxtcolor      = aw.convertToGreyscale(aw.qmc.backgroundxtcolor)
            aw.setLCDsBW()
              
        if color == 3:
            dialog = graphColorDlg(aw)
            if dialog.exec_():
                self.palette["background"] = str(dialog.backgroundButton.text())
                self.palette["grid"] = str(dialog.gridButton.text())
                self.palette["ylabel"] = str(dialog.yButton.text())
                self.palette["xlabel"] = str(dialog.xButton.text())
                self.palette["title"] = str(dialog.titleButton.text())
                self.palette["rect1"] = str(dialog.rect1Button.text())
                self.palette["rect2"] = str(dialog.rect2Button.text())
                self.palette["rect3"] = str(dialog.rect3Button.text())
                self.palette["rect4"] = str(dialog.rect4Button.text())
                self.palette["rect5"] = str(dialog.rect5Button.text())
                self.palette["et"] = str(dialog.metButton.text())
                self.palette["bt"] = str(dialog.btButton.text())
                self.palette["deltaet"] = str(dialog.deltametButton.text())
                self.palette["deltabt"] = str(dialog.deltabtButton.text())
                self.palette["markers"] = str(dialog.markersButton.text())
                self.palette["text"] = str(dialog.textButton.text())
                self.palette["watermarks"] = str(dialog.watermarksButton.text())
                self.palette["timeguide"] = str(dialog.timeguideButton.text())
                self.palette["aucguide"] = str(dialog.aucguideButton.text())
                self.palette["aucarea"] = str(dialog.aucareaButton.text())
                self.palette["canvas"] = str(dialog.canvasButton.text())
                self.palette["legendbg"] = str(dialog.legendbgButton.text())
#                self.palette["legendbgalpha"] = str(dialog.legendbgalphaButton.text())
                self.palette["legendborder"] = str(dialog.legendborderButton.text())
                self.palette["specialeventbox"] = str(dialog.specialeventboxButton.text())
                self.palette["specialeventtext"] = str(dialog.specialeventtextButton.text())
                self.palette["bgeventmarker"] = str(dialog.bgeventmarkerButton.text())
                self.palette["bgeventtext"] = str(dialog.bgeventtextButton.text())
                self.palette["mettext"] = str(dialog.mettextButton.text())
                self.palette["metbox"] = str(dialog.metboxButton.text())
                self.backgroundmetcolor = str(dialog.bgmetButton.text())
                self.backgroundbtcolor  = str(dialog.bgbtButton.text())
                self.backgrounddeltaetcolor = str(dialog.bgdeltametButton.text())
                self.backgrounddeltabtcolor = str(dialog.bgdeltabtButton.text())
                self.backgroundxtcolor = str(dialog.bgextraButton.text())
                #deleteLater() will not work here as the dialog is still bound via the parent
                #dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
                # the following will immedately release the memory dispite this parent link
                QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                try: # sip not supported on older PyQt versions (RPi!)
                    sip.delete(dialog)
                    #print(sip.isdeleted(dialog))
                except:
                    pass

        #update screen with new colors
        aw.updateCanvasColors()
        aw.applyStandardButtonVisibility()
        aw.update_extraeventbuttons_visibility()
        self.fig.canvas.redraw()

    def clearFlavorChart(self):
        self.flavorchart_plotf = None
        self.flavorchart_angles = None
        self.flavorchart_plot = None
        self.flavorchart_fill = None
        self.flavorchart_labels = None
        self.flavorchart_total = None
        
    #draws a polar star graph to score cupping. It does not delete any profile data.
    def flavorchart(self):
        try:
            pi = math.pi
            
            # to trigger a recreation of the standard axis in redraw() we remove them completely
            self.ax = None
            self.delta_ax = None

            self.fig.clf()
            
            #create a new name ax1 instead of ax (ax is used when plotting profiles)
            
            if self.ax1 is not None:
                try:
                    self.fig.delaxes(self.ax1)
                except:
                    pass
            self.ax1 = self.fig.add_subplot(111,projection='polar',facecolor='None') #) radar green facecolor='#d5de9c'
            self.ax1.set_aspect(self.flavoraspect)
            
            aw.setFonts(redraw=False)
    
            #find number of divisions
            nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])
            
    
            sa = self.flavorstartangle % (360./nflavors)
            g_angle = numpy.arange(sa,(360.+sa),(360./nflavors))  #angles in degree
            self.ax1.set_thetagrids(g_angle)
            self.ax1.set_rmax(1.)
            self.ax1.set_autoscale_on(False)
            self.ax1.grid(True,linewidth=1.,color='#212121', linestyle = "-",alpha=.3)
            # hack to make flavor labels visible also on top and bottom
            self.ax1.set_xlabel(" -\n ", alpha=0.0)
            self.ax1.set_title(" -\n ", alpha=0.0)
    
            #create water marks 6-7 anf 8-9
            self.ax1.bar(.1, .1, width=2.*pi, bottom=.6,color="#0c6aa6",linewidth=0.,alpha = .1)
            self.ax1.bar(.1, .1, width=2.*pi, bottom=.8,color="#0c6aa6",linewidth=0.,alpha = .1)
    
            #delete degrees ticks to anotate flavor characteristics 
            for tick in self.ax1.xaxis.get_major_ticks():
                #tick.label1On = False
                tick.label1.set_visible(False)
            
            fontprop_small = aw.mpl_fontproperties.copy()
            fontprop_small.set_size("x-small")
    
            #rename yaxis 
            locs = self.ax1.get_yticks()
            labels = []
            for i in range(len(locs)):
                stringlabel = str(int(locs[i]*10))
                labels.append(stringlabel)
            self.ax1.set_yticklabels(labels,color=self.palette["xlabel"],fontproperties=fontprop_small)

            self.updateFlavorChartData()
            
            #anotate labels
            self.flavorchart_labels = []
            for i in range(len(self.flavorlabels)):
                if self.flavorchart_angles[i] > 2.*pi or self.flavorchart_angles[i] < 0.:
                    _,self.flavorchart_angles[i] = divmod(self.flavorchart_angles[i],(2.*pi))
                if self.flavorchart_angles[i] <= (pi/2.) or self.flavorchart_angles[i] >= (1.5*pi): #if < 90 or smaller than 270 degress
                    ha = "left"
                else:
                    ha = "right"
                anno = self.ax1.annotate(self.flavorChartLabelText(i),xy =(self.flavorchart_angles[i],.9),
                                    fontproperties=fontprop_small,
                                    xytext=(self.flavorchart_angles[i],1.1),horizontalalignment=ha,verticalalignment='center')
                try:
                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                except: # mpl before v3.0 do not have this set_in_layout() function
                    pass
                self.flavorchart_labels.append(anno)
    
            # total score
            score = self.calcFlavorChartScore()
            txt = "%.2f" %score
            self.flavorchart_total = self.ax1.text(0.,0.,txt,fontsize="x-large",fontproperties=aw.mpl_fontproperties,color="#FFFFFF",horizontalalignment="center",bbox={"facecolor":"#212121", "alpha":0.5, "pad":10})
    
            #add background to plot if found
            if self.background:
                if self.flavorbackgroundflag:
                    if len(aw.qmc.backgroundFlavors) != len(aw.qmc.flavors):
                        message = QApplication.translate("Message","Background does not match number of labels", None)
                        aw.sendmessage(message)
                        self.flavorbackgroundflag = False
                    else:
                        backgroundplotf = self.backgroundFlavors[:]
                        backgroundplotf.append(self.backgroundFlavors[0])
                        #normalize flavor values to 0-1 range
                        for i in range(len(backgroundplotf)):
                            backgroundplotf[i] /= 10.
        
                        self.ax1.plot(self.flavorchart_angles,backgroundplotf,color="#cc0f50",marker="o",alpha=.5)
                        #needs matplotlib 1.0.0+
                        self.ax1.fill_between(self.flavorchart_angles,0,backgroundplotf, facecolor="#ff5871", alpha=0.1, interpolate=True)
    
            #add to plot
            self.flavorchart_plot, = self.ax1.plot(self.flavorchart_angles,self.flavorchart_plotf,color="#0c6aa6",marker="o")
            
            self.flavorchart_fill = self.ax1.fill_between(self.flavorchart_angles,0,self.flavorchart_plotf, facecolor='#1985ba', alpha=0.1, interpolate=True)
    
            #self.fig.canvas.draw()
            self.fig.canvas.draw_idle()
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass
            
    def flavorChartLabelText(self,i):
        return aw.arabicReshape(self.flavorlabels[i]) + "\n" + str("%.2f"%self.flavors[i])
            
    #To close circle we need one more element. angle and values need same dimension in order to plot.
    def updateFlavorChartData(self):
        # update angles
        nflavors = len(self.flavors)      #last value of nflavors is used to close circle (same as flavors[0])
        step = 2.*math.pi/nflavors
        startradian = math.radians(self.flavorstartangle)
        self.flavorchart_angles = [startradian]   #angles in radians
        for i in range(nflavors-1): self.flavorchart_angles.append(self.flavorchart_angles[-1] + step)
        self.flavorchart_angles.append(self.flavorchart_angles[-1]+step)
        # update values
        self.flavorchart_plotf = self.flavors[:]
        self.flavorchart_plotf.append(self.flavors[0])
        #normalize flavor values to 0-1 range
        for i in range(len(self.flavorchart_plotf)):
            self.flavorchart_plotf[i] /= 10.
    
    def calcFlavorChartScore(self):
        score = 0.
        nflavors = len(self.flavors)
        for i in range(nflavors):
            score += self.flavors[i]
        score /= (nflavors)
        score *= 10.    
        return score
    
    # an incremental redraw of the existing flavorchart
    def updateFlavorchartValues(self):
        # update data
        self.updateFlavorChartData()
        self.flavorchart_plot.set_xdata(self.flavorchart_angles)
        self.flavorchart_plot.set_ydata(self.flavorchart_plotf)
        
        # collections need to be redrawn completely
        self.flavorchart_fill.remove()
        self.flavorchart_fill = self.ax1.fill_between(self.flavorchart_angles,0,self.flavorchart_plotf, facecolor='#1985ba', alpha=0.1, interpolate=True)
        
        # total score
        score = self.calcFlavorChartScore()
        txt = "%.2f" %score
        self.flavorchart_total.set_text(txt)
        
        # update canvas
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()
        
    def updateFlavorchartLabel(self,i):
        label_anno = self.flavorchart_labels[i]
        label_anno.set_text(self.flavorChartLabelText(i))
        
        # update canvas
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()
        
    def samplingAction(self):
        try:
            ###  lock resources ##
            aw.qmc.samplingsemaphore.acquire(1)
            if aw.qmc.extra_event_sampling_delay != 0:
                aw.eventactionx(aw.qmc.extrabuttonactions[2],aw.qmc.extrabuttonactionstrings[2])
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
    
    def AsyncSamplingActionTrigger(self):
        if aw.AsyncSamplingAction and aw.qmc.extra_event_sampling_delay and aw.qmc.extrabuttonactions[2]:
            self.samplingAction()
            QTimer.singleShot(aw.qmc.extra_event_sampling_delay,self.AsyncSamplingActionTrigger)
        
    def StartAsyncSamplingAction(self):
        if aw.qmc.flagon and aw.qmc.extra_event_sampling_delay != 0:
            aw.AsyncSamplingAction = True
            self.AsyncSamplingActionTrigger()
            
    def StopAsyncSamplingAction(self):
        aw.AsyncSamplingAction = False
    
    # fill the self.extraNoneTempHint1 and self.extraNoneTempHint2 lists
    # indicating which curves should not be temperature converted
    def generateNoneTempHints(self):
        self.extraNoneTempHint1 = []
        self.extraNoneTempHint2 = []
        for d in self.extradevices:
            if d in self.nonTempDevices:
                self.extraNoneTempHint1.append(True)
                self.extraNoneTempHint2.append(True)
            elif d == 29: # MODBUS
                self.extraNoneTempHint1.append(aw.modbus.inputModes[0] == "")
                self.extraNoneTempHint2.append(aw.modbus.inputModes[1] == "")
            elif d == 33: # +MODBUS 34
                self.extraNoneTempHint1.append(aw.modbus.inputModes[2] == "")
                self.extraNoneTempHint2.append(aw.modbus.inputModes[3] == "")
            elif d == 55: # +MODBUS 56
                self.extraNoneTempHint1.append(aw.modbus.inputModes[4] == "")
                self.extraNoneTempHint2.append(aw.modbus.inputModes[5] == "")
            elif d == 109: # +MODBUS 78
                self.extraNoneTempHint1.append(aw.modbus.inputModes[6] == "")
                self.extraNoneTempHint2.append(aw.modbus.inputModes[7] == "")
            elif d == 79: # S7
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[0]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[1]))
            elif d == 80: # +S7 34
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[2]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[3]))
            elif d == 81: # +S7 56
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[4]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[5]))
            elif d == 82: # +S7 78
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[6]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[7]))
            elif d == 110: # +S7 910
                self.extraNoneTempHint1.append(not bool(aw.s7.mode[8]))
                self.extraNoneTempHint2.append(not bool(aw.s7.mode[9]))
            else:
                self.extraNoneTempHint1.append(False)
                self.extraNoneTempHint2.append(False)


    def addPhidgetServer(self):
        if not self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            if self.phidgetServerID == "" and not self.phidgetServiceDiscoveryStarted:
                try:
                    # we enable the automatic service discovery if no server host is given
                    from Phidget22.PhidgetServerType import PhidgetServerType
                    PhidgetNetwork.enableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = True
                    aw.sendmessage(QApplication.translate("Message","Phidget service discovery started...", None))
                except Exception:
                    pass
            else:
                PhidgetNetwork.addServer("PhidgetServer",self.phidgetServerID,self.phidgetPort,self.phidgetPassword,0)
                self.phidgetServerAdded = True

    def removePhidgetServer(self):
        if self.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            try:
                PhidgetNetwork.removeServer("PhidgetServer")
            except:
                pass
            self.phidgetServerAdded = False
            if self.phidgetServiceDiscoveryStarted:
                try:
                    from Phidget22.PhidgetServerType import PhidgetServerType
                    PhidgetNetwork.disableServerDiscovery(PhidgetServerType.PHIDGETSERVER_DEVICEREMOTE)
                    self.phidgetServiceDiscoveryStarted = False
                except:
                    pass
            
    def startPhidgetManager(self):
        # this is needed to surpress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/surpress_error.py fails to surpress this)
        _stderr = sys.stderr
        sys.stderr = object
        try:
            if self.phidgetRemoteFlag:
                try:
                    self.addPhidgetServer()
                except:
                    if aw.qmc.device in aw.qmc.phidgetDevices:
                        aw.qmc.adderror(QApplication.translate("Error Message","Exception: PhidgetManager couldn't be started. Verify that the Phidget driver is correctly installed!",None))
#                        _, _, exc_tb = sys.exc_info()
#                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " addPhidgetServer() {0}").format(str(e)),exc_tb.tb_lineno)
            if self.phidgetManager is None:
                try:
                    self.phidgetManager = PhidgetManager()
# as the PhidgetManager is now started at app start we do not need to wait anymore for attaches
#                    if self.phidgetRemoteFlag:
#                        libtime.sleep(1.3)
#                    else:
#                        libtime.sleep(0.5)
                except Exception:
                    if aw.qmc.device in aw.qmc.phidgetDevices:
                        aw.qmc.adderror(QApplication.translate("Error Message","Exception: PhidgetManager couldn't be started. Verify that the Phidget driver is correctly installed!",None))
#                        _, _, exc_tb = sys.exc_info()
#                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " startPhidgetManager() {0}").format(str(e)),exc_tb.tb_lineno)
        finally:
            sys.stderr = _stderr
    
    def stopPhidgetManager(self):
        if self.phidgetManager is not None:
            self.phidgetManager.close()
            self.phidgetManager = None
        self.removePhidgetServer()
        
    def restartPhidgetManager(self):
        self.stopPhidgetManager()
        self.startPhidgetManager()
            
    def OnMonitor(self):
        try:
            self.startPhidgetManager()
            # collect ambient data if any
            if self.ambient_pressure_device or self.ambient_humidity_device or self.ambient_temperature_device:
                self.ambiThread = AmbientThread()
                self.ambiThread.start()
            
            self.generateNoneTempHints()
            self.block_update = True # block the updating of the bitblit canvas (unblocked at the end of this function to avoid multiple redraws)
            res = aw.qmc.reset(False,False,sampling=True,keepProperties=True)
            if not res: # reset canceled
                self.OffMonitor()
                return

            if not bool(aw.simulator) and aw.qmc.device == 53:
                from artisanlib.hottop import startHottop
                startHottop(0.6,aw.ser.comport,aw.ser.baudrate,aw.ser.bytesize,aw.ser.parity,aw.ser.stopbits,aw.ser.timeout)
            try:
                aw.eventactionx(aw.qmc.extrabuttonactions[0],aw.qmc.extrabuttonactionstrings[0])
            except Exception:
                pass
            
            #reset alarms
            self.temporaryalarmflag = -3
            self.alarmstate = [-1]*len(self.alarmflag)  #1- = not triggered; any other value = triggered; value indicates the index in self.timex at which the alarm was triggered
            #reset TPalarmtimeindex to trigger a new TP recognition during alarm processing
            aw.qmc.TPalarmtimeindex = None
            
            self.timeclock.start()   #set time to the current computer time
            self.flagon = True
            aw.qmc.redraw(True,sampling=True,smooth=aw.qmc.optimalSmoothing) # we need to re-smooth with standard smoothing if ON and optimal-smoothing is ticked
            
            if self.designerflag: return
            aw.sendmessage(QApplication.translate("Message","Scope monitoring...", None))
            #disable RESET button:
            aw.button_7.setEnabled(False)
            aw.button_7.setVisible(False)
            QApplication.processEvents()
            if aw.simulator:
                aw.button_1.setStyleSheet(aw.pushbuttonstyles_simulator["ON"])
            else:
                aw.button_1.setStyleSheet(aw.pushbuttonstyles["ON"])
            QApplication.processEvents()
            aw.button_1.setText(QApplication.translate("Button", "OFF",None)) # text means click to turn OFF (it is ON)
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop monitoring", None))
            aw.button_2.setEnabled(True) # ensure that the START button is enabled
            aw.disableEditMenus()
            aw.update_extraeventbuttons_visibility()
            aw.updateExtraButtonsVisibility()
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.pidcontrol.activateONOFFeasySV(aw.pidcontrol.svButtons and aw.button_10.isVisible())
            aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider and aw.button_10.isVisible())
            self.block_update = False # unblock the updating of the bitblit canvas            
            aw.updateReadingsLCDsVisibility() # this one triggers the resize and the recreation of the bitblit canvas
            self.threadserver.createSampleThread()
#            QApplication.processEvents()
            if not bool(aw.simulator):
                self.StartAsyncSamplingAction()
#            QApplication.processEvents()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " OnMonitor() {0}").format(str(ex)),exc_tb.tb_lineno)

    def OffMonitor(self):
        try:
            # first activate "Stopping Mode" to ensure that sample() is not reseting the timer now (independent of the flagstart state)
            if self.HUDflag:
                self.toggleHUD()
            # stop Recorder if still running
            recording = self.flagstart
            if recording:
                self.OffRecorder(autosave=False) # we autosave after the monitor is turned off to get all the data in the generated PDF!
            self.flagon = False
            # now wait until the current sampling round is done
            while self.flagsampling:
                libtime.sleep(0.05)
                QApplication.processEvents()
            if len(self.timex) < 3:
                # clear data from monitoring-only mode
                aw.qmc.clearMeasurements()
            else:
                # we only reset the LCDs, but keep the readings
                aw.qmc.clearLCDs()

            aw.pidcontrol.pidOff()
#            if aw.qmc.device == 53:
#                aw.HottopControlOff()
            # at OFF we stop the follow-background on FujiPIDs and set the SV to 0
            if aw.qmc.device == 0 and aw.fujipid.followBackground:
                if aw.fujipid.sv and aw.fujipid.sv > 0:
                    try:
                        aw.fujipid.setsv(0,silent=True)
                    except:
                        pass
                    aw.fujipid.sv = 0
            QTimer.singleShot(5,self.disconnectProbes)
#            QApplication.processEvents()
            # reset the canvas color when it was set by an alarm but never reset
            if "canvas_alt" in aw.qmc.palette:
                aw.qmc.palette["canvas"] = aw.qmc.palette["canvas_alt"]
                aw.updateCanvasColors()
            #enable RESET button:
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"])
            aw.button_7.setEnabled(True)
            aw.button_7.setVisible(True)
            aw.keyboardmoveflag = 0  #disable keyboard navigation
            if aw.simulator:
                aw.button_1.setStyleSheet(aw.pushbuttonstyles_simulator["OFF"])
            else:
                aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None))
            aw.sendmessage(QApplication.translate("Message","Scope stopped", None))
            aw.button_1.setText(QApplication.translate("Button", "ON",None)) # text means click to turn OFF (it is ON)
            # reset time LCD color to the default (might have been changed to red due to long cooling!)
            aw.updateReadingsLCDsVisibility()
            # reset WebLCDs	
            if aw.qmc.LCDdecimalplaces:
                resLCD = "-.-"
            else:	
                resLCD = "--"
            if aw.WebLCDs: 	
                self.updateWebLCDs(bt=resLCD,et=resLCD)
            if not aw.HottopControlActive:
                aw.hideExtraButtons(changeDefault=False)
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.updateExtraButtonsVisibility()
            aw.pidcontrol.activateONOFFeasySV(False)
            self.StopAsyncSamplingAction()
            aw.enableEditMenus()
#            QApplication.processEvents()
            aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
            if len(self.timex) > 2:
                # we autosave after full redraw after OFF to have the optional generated PDF containing all information
                if aw.qmc.autosaveflag and aw.qmc.autosavepath:
                    try:
                        aw.automaticsave()
                    except:
                        pass
            #appnope.nap()
            aw.eventactionx(aw.qmc.extrabuttonactions[1],aw.qmc.extrabuttonactionstrings[1])
#            QApplication.processEvents()
            if recording and self.flagKeepON:
                self.OnMonitor()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " OffMonitor() {0}").format(str(ex)),exc_tb.tb_lineno)

    def getAmbientData(self):
        # this is needed to surpress the message on the ignored Exception
        #                            # Phidget that is raised on starting the PhidgetManager without installed
        #                            # Phidget driver (artisanlib/surpress_error.py fails to surpress this)
        _stderr = sys.stderr
        sys.stderr = object
        try:
            humidity = None
            temp = None # assumed to be gathered in C (not F!)
            pressure = None 
    
            #--- humidity
            if self.ambient_humidity_device == 1: # Phidget HUM1000
                humidity = aw.ser.PhidgetHUM1000humidity()
            elif self.ambient_humidity_device == 2: # Yocto Meteo
                humidity = aw.ser.YoctoMeteoHUM()
    
            #--- temperature
            if self.ambient_temperature_device == 1: # Phidget HUM1000
                temp = aw.ser.PhidgetHUM1000temperature()
            elif self.ambient_temperature_device == 2: # Yocto Meteo
                temp = aw.ser.YoctoMeteoTEMP()
    
            #--- pressure
            if self.ambient_pressure_device == 1: # Phidget PRE1000
                pressure = aw.ser.PhidgetPRE1000pressure()
                if pressure is not None:
                    pressure = pressure * 10 # convert to hPa/mbar
            elif self.ambient_pressure_device == 2: # Yocto Meteo
                pressure = aw.ser.YoctoMeteoPRESS()
                
            # calc final values
            if pressure is not None:
                if temp is None:
                    t = 23 # we just assume 23C room temperature if no ambient temperature is given
                else:
                    t = temp
                pressure = self.barometricPressure(pressure,t,self.elevation)
                
            # set and report
            if humidity is not None:
                self.ambient_humidity = aw.float2float(humidity,1)
                aw.sendmessage(QApplication.translate("Message","Humidity: {}%", None).format(self.ambient_humidity))
                
            if temp is not None:
                if self.mode == "F":
                    temp = self.fromCtoF(temp)
                self.ambientTemp = aw.float2float(temp,1)
                aw.sendmessage(QApplication.translate("Message","Temperature: {}{}", None).format(self.ambientTemp,self.mode))
                
            if pressure is not None:
                self.ambient_pressure = aw.float2float(pressure,1)
                aw.sendmessage(QApplication.translate("Message","Pressure: {}hPa", None).format(self.ambient_pressure))
        finally:
            sys.stderr = _stderr
      
    # computes the barometric pressure from 
    #   aap:  atmospheric pressure in hPa
    #   atc:  temperature in Celsius
    #   hasl: height above sea level in m
    # see https://www.wmo.int/pages/prog/www/IMOP/meetings/SI/ET-Stand-1/Doc-10_Pressure-red.pdf
    def barometricPressure(self, aap, atc, hasl):
        return aap * pow((1 - ((0.0065*hasl) / (atc + (0.0065*hasl) + 273.15))),-5.257)

    # close serial port, Phidgets and Yocto ports
    def disconnectProbesFromSerialDevice(self,ser):
        # close main serial port
        try:
            ser.closeport()
        except Exception:
            pass
        # disconnect phidgets
        if ser.PhidgetTemperatureSensor is not None:
            try:
                if ser.PhidgetTemperatureSensor[0].getAttached():
                    serial = ser.PhidgetTemperatureSensor[0].getDeviceSerialNumber()
                    port = ser.PhidgetTemperatureSensor[0].getHubPort()  # returns 0 for USB Phidgets!
                    deviceType = ser.PhidgetTemperatureSensor[0].getDeviceID()
                    ser.PhidgetTemperatureSensor[0].close()
                    ser.phidget1048detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
            except Exception:
                pass
            try:
                if len(ser.PhidgetTemperatureSensor) > 1 and ser.PhidgetTemperatureSensor[1].getAttached():
                    serial = ser.PhidgetTemperatureSensor[1].getDeviceSerialNumber()
                    port = ser.PhidgetTemperatureSensor[1].getHubPort()  # returns 0 for USB Phidgets!
                    deviceType = ser.PhidgetTemperatureSensor[1].getDeviceID()
                    ser.PhidgetTemperatureSensor[1].close()
                    ser.phidget1048detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
            except Exception:
                pass
            ser.Phidget1048values = [[],[],[],[]]
            ser.Phidget1048lastvalues = [-1]*4
            ser.PhidgetTemperatureSensor = None
        if ser.PhidgetIRSensor is not None:
            try:
                if ser.PhidgetIRSensor.getAttached():
                    serial = ser.PhidgetIRSensor.getDeviceSerialNumber()
                    port = ser.PhidgetIRSensor.getHubPort() # returns 0 for USB Phidgets!
                    deviceType = ser.PhidgetIRSensor.getDeviceID()
                    ser.PhidgetIRSensor.close()
                    ser.phidget1045detached(serial,port,deviceType) # call detach handler to release from PhidgetManager
            except Exception:
                pass
            try:
                if ser.PhidgetIRSensorIC is not None and ser.PhidgetIRSensorIC.getAttached():
                    ser.PhidgetIRSensorIC.close()
            except Exception:
                pass
            ser.PhidgetIRSensor = None
            ser.Phidget1045values = [] # async values of the one channel
            ser.Phidget1045lastvalue = -1
            ser.Phidget1045tempIRavg = None
            ser.PhidgetIRSensorIC = None
        if ser.PhidgetBridgeSensor is not None:
            try:
                if ser.PhidgetBridgeSensor[0].getAttached():
                    serial = ser.PhidgetBridgeSensor[0].getDeviceSerialNumber()
                    port = ser.PhidgetBridgeSensor[0].getHubPort()   # returns 0 for USB Phidgets!
                    deviceType = ser.PhidgetBridgeSensor[0].getDeviceID()
                    ser.PhidgetBridgeSensor[0].close()
                    ser.phidget1046detached(serial,port,deviceType,0) # call detach handler to release from PhidgetManager
            except Exception:
                pass
            try:
                if len(ser.PhidgetBridgeSensor) > 1 and ser.PhidgetBridgeSensor[1].getAttached():
                    serial = ser.PhidgetBridgeSensor[1].getDeviceSerialNumber()
                    port = ser.PhidgetBridgeSensor[1].getHubPort()   # returns 0 for USB Phidgets!
                    deviceType = ser.PhidgetBridgeSensor[1].getDeviceID()
                    ser.PhidgetBridgeSensor[1].close()
                    ser.phidget1046detached(serial,port,deviceType,1) # call detach handler to release from PhidgetManager
            except Exception:
                pass
            ser.Phidget1046values = [[],[],[],[]]
            ser.Phidget1046lastvalues = [-1]*4
            ser.PhidgetBridgeSensor = None
        if ser.PhidgetIO is not None:
            try:
                if ser.PhidgetIO[0].getAttached():
                    serial = ser.PhidgetIO[0].getDeviceSerialNumber()
                    port = ser.PhidgetIO[0].getHubPort()   # returns 0 for USB Phidgets!
                    className = ser.PhidgetIO[0].getChannelClassName()
                    deviceType = ser.PhidgetIO[0].getDeviceID()
                    ser.PhidgetIO[0].close()
                    ser.phidget1018detached(serial,port,className,deviceType,0)
            except Exception:
                pass
            try:
                if len(ser.PhidgetIO) > 1 and ser.PhidgetIO[1].getAttached():
                    serial = ser.PhidgetIO[1].getDeviceSerialNumber()
                    port = ser.PhidgetIO[1].getHubPort()   # returns 0 for USB Phidgets!
                    className = ser.PhidgetIO[1].getChannelClassName()
                    deviceType = ser.PhidgetIO[1].getDeviceID()
                    ser.PhidgetIO[1].close()
                    ser.phidget1018detached(serial,port,className,deviceType,1)
            except Exception:
                pass
            ser.PhidgetIO = None
            ser.PhidgetIOvalues = [[],[],[],[],[],[],[],[]]
            ser.PhidgetIOlastvalues = [-1]*8
        if ser.YOCTOsensor is not None:
            try:
                ser.YOCTOsensor = None
                ser.YOCTOchan1 = None
                ser.YOCTOchan2 = None
                ser.YOCTOtempIRavg = None
                if ser.YOCTOthread is not None:
                    ser.YOCTOthread.join()
                    ser.YOCTOthread = None
                ser.YOCTOvalues = [[],[]]
                ser.YOCTOlastvalues = [-1]*2
                YAPI.FreeAPI()
            except:
                pass

    # close Phidget and and Yocto outputs
    def closePhidgetOUTPUTs(self):
        # close Phidget Digital Outputs
        aw.ser.phidgetOUTclose()
        # close Phidget Digital Outputs on Hub
        aw.ser.phidgetOUTcloseHub()
        # close Phidget IO Outputs
        aw.ser.phidgetBinaryOUTclose()
        # close Phidget Analog Outputs
        aw.ser.phidgetVOUTclose()
        # close Phidget DCMotors
        aw.ser.phidgetDCMotorClose()
        # close Phidget RC Servos
        aw.ser.phidgetRCclose()
        # close Yocto Voltage Outputs
        aw.ser.yoctoVOUTclose()
        # close Yocto Current Outputs
        aw.ser.yoctoCOUTclose()
        # close Yocto Relay Outputs
        aw.ser.yoctoRELclose()
        # close Yocto Servo Outputs
        aw.ser.yoctoSRERVOclose()
        # close Yocto PWM Outputs
        aw.ser.yoctoPWMclose()
        
        
    def disconnectProbes(self):
        # close ports of main device
        self.disconnectProbesFromSerialDevice(aw.ser)
        # close (serial) port of Modbus device
        aw.modbus.disconnect()
        # close port of S7 device
        aw.s7.disconnect()
        # close ports of extra devices
        for i in range(len(aw.extraser)):
            self.disconnectProbesFromSerialDevice(aw.extraser[i])

    #Turns ON/OFF flag self.flagon to read and print values. Called from push button_1.
    @pyqtSlot(bool)
    def ToggleMonitor(self,_=False):
        #turn ON
        if not self.flagon:
            QApplication.processEvents()
            # the sample thread might still run, but should terminate soon. We do nothing and ignore this click on ON
            if not aw.qmc.flagsamplingthreadrunning:
                if not self.checkSaved():
                    return False
                else:
                    aw.soundpop()
                    self.OnMonitor()
        #turn OFF
        else:
            try:
                aw.soundpop()
            except:
                pass
            self.OffMonitor()

    def OnRecorder(self):
        try:
            # if on turn mouse crosslines off
            if aw.qmc.crossmarker:
                aw.qmc.togglecrosslines()
            aw.qmc.ax.set_xlabel("")
            aw.qmc.ax.set_ylabel("")
            if not aw.qmc.title_show_always:
                aw.qmc.setProfileTitle("")
            if aw.qmc.delta_ax:
                aw.qmc.delta_ax.set_ylabel("")
            
            self.flagstart = True
            # start Monitor if not yet running
            if not self.flagon:
                self.OnMonitor()
            try:
                aw.eventactionx(aw.qmc.xextrabuttonactions[1],aw.qmc.xextrabuttonactionstrings[1])
            except Exception:
                pass
                    
            aw.qmc.roastbatchnr = 0 # initialized to 0, set to increased batchcounter on DROP
            aw.qmc.roastbatchpos = 1 # initialized to 1, set to increased batchsequence on DROP
            if not aw.qmc.title_show_always:
                aw.qmc.fig.suptitle("")
            aw.qmc.profile_sampling_interval = self.delay / 1000.
            aw.qmc.updateDeltaSamples()
            aw.disableSaveActions()
            aw.sendmessage(QApplication.translate("Message","Scope recording...", None))
            aw.button_2.setEnabled(False)
            aw.button_2.setGraphicsEffect(None)
            aw.button_1.setToolTip(QApplication.translate("Tooltip", "Stop recording", None))
            aw.button_1.setEnabled(True) # ensure that the OFF button is enabled
            #disable RESET button:
            aw.button_7.setEnabled(False)
            aw.button_18.setEnabled(True)
            aw.button_18.setStyleSheet(aw.pushbuttonstyles["HUD_OFF"])
            aw.shadow_18 = QGraphicsDropShadowEffect(self)
            aw.shadow_18.setBlurRadius(20)
            aw.shadow_18.setOffset(0,1)
            aw.button_18.setGraphicsEffect(aw.shadow_18)
            self.updateLCDtime()
            aw.lowerbuttondialog.setVisible(True)
            aw.applyStandardButtonVisibility()

            aw.update_extraeventbuttons_visibility()
            aw.updateExtraButtonsVisibility()
                       
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.updateReadingsLCDsVisibility() # update visiblity of reading LCDs based on the user preference
            if aw.qmc.phasesLCDflag:
                aw.phasesLCDs.show()
                aw.TP2DRYlabel.setStyleSheet("background-color:'transparent'; color: " + aw.qmc.palette["messages"] + ";")
                aw.DRY2FCslabel.setStyleSheet("background-color:'transparent'; color: " + aw.qmc.palette["messages"] + ";")
            if aw.qmc.AUClcdFlag:
                aw.AUCLCD.show()
                
            aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[0]

            aw.update_minieventline_visibility()
            
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " OffMonitor() {0}").format(str(ex)),exc_tb.tb_lineno)

    def OffRecorder(self, autosave=True):
        try:
            aw.enableSaveActions()
            self.flagstart = False
            if aw.simulator:
                aw.button_2.setStyleSheet(aw.pushbuttonstyles_simulator["STOP"])
            else:
                aw.button_2.setStyleSheet(aw.pushbuttonstyles["STOP"])
            aw.button_2.setEnabled(True)   
            self.shadow_2 = QGraphicsDropShadowEffect(self)
            self.shadow_2.setBlurRadius(20)
            self.shadow_2.setOffset(0,1)
            aw.button_2.setGraphicsEffect(self.shadow_2)
            #enable RESET button:
            aw.button_7.setStyleSheet(aw.pushbuttonstyles["RESET"]) 
            aw.button_7.setEnabled(True)
            aw.button_18.setEnabled(False)
            aw.button_18.setGraphicsEffect(None)
            self.updateLCDtime()
            #prevents accidentally deleting a modified profile:
            if len(self.timex) > 2:
                self.fileDirty()
                aw.autoAdjustAxis() # automatic adjust axis after roast if auto axis is enabled
            try:
                if aw.clusterEventsFlag:
                    aw.clusterEvents()
            except:
                pass
            if autosave and aw.qmc.autosaveflag and aw.qmc.autosavepath:
                try:
                    aw.automaticsave()
                except:
                    pass
            aw.sendmessage(QApplication.translate("Message","Scope recording stopped", None))
            aw.button_2.setText(QApplication.translate("Button", "START",None))
            aw.lowerbuttondialog.setVisible(False)
            aw.messagelabel.setVisible(True)
            aw.phasesLCDs.hide()
            aw.AUCLCD.hide()
            aw.hideEventsMinieditor()
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " OffRecorder() {0}").format(str(ex)),exc_tb.tb_lineno)

    #Turns START/STOP flag self.flagon to read and plot. Called from push button_2.
    @pyqtSlot(bool)
    def ToggleRecorder(self,_=False):
        #turn START
        if not self.flagstart:
            if not self.checkSaved():
                return False
            else:
                aw.soundpop()
                if self.flagon and len(self.timex) == 1:
                    # we are already in monitoring mode, we just clear this first measurement and go
                    aw.qmc.clearMeasurements(andLCDs=False)
                elif self.timex != []: # there is a profile loaded, we have to reset
                    aw.qmc.reset(True,False)
                self.OnRecorder()
        #turn STOP
        else:
            aw.soundpop()
            self.OffRecorder()

    #Records charge (put beans in) marker. called from push button 'Charge'
    @pyqtSlot(bool)
    def markCharge(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                try:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    if aw.button_8.isFlat() and self.timeindex[0] > -1:
                        # undo wrongly set CHARGE
                        # deactivate autoCHARGE
                        aw.qmc.autoCHARGEenabled = False
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE", None))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            try:
                                self.l_annotations[-1].remove()
                            except:
                                pass
                            try:
                                self.l_annotations[-2].remove()
                            except:
                                pass
                            self.l_annotations = self.l_annotations[:-2]
                            if 0 in self.l_annotations_dict:
                                del self.l_annotations_dict[0]
                            self.timeindex[0] = -1
                            removed = True
                            self.xaxistosm(redraw=False)
                    elif not aw.button_8.isFlat():
                        if self.device == 18 and aw.simulator is None: #manual mode
                            tx,et,bt = aw.ser.NONE()
                            if bt != 1 and et != -1:  #cancel
                                self.drawmanual(et,bt,tx)
                                self.timeindex[0] = len(self.timex)-1
                            else:
                                return
                        else:
                            if self.autoChargeIdx:
                                self.timeindex[0] = self.autoChargeIdx
                            else:
                                if len(self.timex) > 0:
                                    self.timeindex[0] = len(self.timex)-1
                                else:
                                    message = QApplication.translate("Message","Not enough data collected yet. Try again in a few seconds", None)
                            if aw.pidcontrol.pidOnCHARGE and not aw.pidcontrol.pidActive: # Arduino/TC4, Hottop, MODBUS
                                aw.pidcontrol.pidOn()
                        try:
                            if not aw.qmc.locktimex:
                                aw.qmc.startofx = aw.qmc.chargemintime + self.timex[self.timeindex[0]] # we set the min x-axis limit to the CHARGE Min time
                        except Exception:
                            pass

                        self.xaxistosm(redraw=False) # need to fix uneven x-axis labels like -0:13
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation", "CHARGE", None))
                        t2 = self.temp2[self.timeindex[0]]
                        tx = self.timex[self.timeindex[0]]
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,t2,t2,d)
                        self.l_annotations += self.annotate(t2,st1,tx,t2,self.ystep_up,self.ystep_down,draggable_anno_key=0)
                        # mark active slider values that are not zero 

                        for slidernr in range(4):
                            if aw.eventslidervisibilities[slidernr]:
                                # we record also for inactive sliders as some button press actions might have changed the event values also for those
                                if slidernr == 0:
                                    slidervalue = aw.slider1.value()
                                elif slidernr == 1:
                                    slidervalue = aw.slider2.value()
                                elif slidernr == 2:
                                    slidervalue = aw.slider3.value()
                                elif slidernr == 3:
                                    slidervalue = aw.slider4.value()
                                if slidervalue != 0:
                                    value = aw.float2float((slidervalue + 10.0) / 10.0)
                                    # note that EventRecordAction avoids to generate events were type and value matches to the previously recorded one
                                    aw.qmc.EventRecordAction(extraevent = 1,eventtype=slidernr,eventvalue=value,takeLock=False,doupdategraphics=False)
                                    # we don't take another lock in EventRecordAction as we already hold that lock!
                except Exception:
                    pass
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " markCharge() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            aw.qmc.timealign(redraw=True,recompute=False,force=True) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            if aw.button_8.isFlat():
                if removed:
                    aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.eventactionx(aw.qmc.buttonactions[0],aw.qmc.buttonactionstrings[0])
                aw.button_8.setFlat(True)
                try:
                    if aw.qmc.LCDdecimalplaces:
                        fmt = "%.1f"
                    else:
                        fmt = "%.0f"
                    bt = fmt%self.temp2[self.timeindex[0]] + aw.qmc.mode
                    message = QApplication.translate("Message","Roast time starts now 00:00 BT = {0}",None).format(bt)
                    aw.sendmessage(message) 
                except Exception:
                    pass
                if aw.qmc.roastpropertiesAutoOpenFlag:
                    aw.openPropertiesSignal.emit()
                aw.onMarkMoveToNext(aw.button_8)
                if not(self.autoChargeIdx and aw.qmc.timeindex[0] < 0):
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately


    # called from sample() and marks the autodetected TP visually on the graph
    def markTP(self):
        try:
            self.samplingsemaphore.acquire(1)
            if self.flagstart and self.markTPflag:
                if aw.qmc.TPalarmtimeindex and self.timeindex[0] != -1 and len(self.timex) > aw.qmc.TPalarmtimeindex:
                    st = self.stringfromseconds(self.timex[aw.qmc.TPalarmtimeindex]-self.timex[self.timeindex[0]])
                    st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","TP {0}", None).format(st))
                    #anotate temperature
                    d = aw.qmc.ylimit - aw.qmc.ylimit_min
                    self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[aw.qmc.TPalarmtimeindex],d)
                    self.l_annotations += self.annotate(self.temp2[aw.qmc.TPalarmtimeindex],st1,self.timex[aw.qmc.TPalarmtimeindex],self.temp2[aw.qmc.TPalarmtimeindex],self.ystep_up,self.ystep_down,-50,1.,draggable_anno_key=-1)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need to update the background cache with the new annotation
                    st2 = "%.1f "%self.temp2[aw.qmc.TPalarmtimeindex] + self.mode
                    message = QApplication.translate("Message","[TP] recorded at {0} BT = {1}", None).format(st,st2)
                    #set message at bottom
                    aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " markTP() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if self.samplingsemaphore.available() < 1:
                self.samplingsemaphore.release(1)
        self.autoTPIdx = 0 # avoid a loop on auto marking

    @pyqtSlot(bool)
    def markDryEnd(self,_=False):
        try:
            self.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_19.isFlat() and self.timeindex[1] > 0:
                        # undo wrongly set DRY
                        # deactivate autoDRY
                        aw.qmc.autoDRYenabled = False
                        st = self.stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                        DE_str = aw.arabicReshape(QApplication.translate("Scope Annotation","DE {0}", None).format(st))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == DE_str:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 1 in self.l_annotations_dict:
                                del self.l_annotations_dict[1]
                            self.timeindex[1] = 0
                            removed = True
                    elif not aw.button_19.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[1] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[1] = len(self.timex)-1
                            else:
                                return
                        if aw.qmc.phasesbuttonflag:
                            self.phases[1] = int(round(self.temp2[self.timeindex[1]]))
                        #calculate time elapsed since charge time
                        st = self.stringfromseconds(self.timex[self.timeindex[1]]-start,False)
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DE {0}", None).format(st))
                        #anotate temperature
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[1]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[1]],st1,self.timex[self.timeindex[1]],self.temp2[self.timeindex[1]],self.ystep_up,self.ystep_down,draggable_anno_key=1)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
                        aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[1]

            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " markDryEnd() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [1,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.button_19.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_19.setFlat(False)
                    if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                        aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit()
            else:
                aw.button_19.setFlat(True) # deactivate DRY button
                aw.button_8.setFlat(True) # also deactivate CHARGE button
                try:
                    aw.eventactionx(aw.qmc.buttonactions[1],aw.qmc.buttonactionstrings[1])
                    st = self.stringfromseconds(self.timex[self.timeindex[1]]-self.timex[self.timeindex[0]])
                    st2 = "%.1f "%self.temp2[self.timeindex[1]] + self.mode
                    message = QApplication.translate("Message","[DRY END] recorded at {0} BT = {1}", None).format(st,st2)
                    #set message at bottom
                    aw.sendmessage(message)
                except Exception:
                    pass
                aw.onMarkMoveToNext(aw.button_19)
                if self.autoDryIdx == 0:
                    # only if markDryEnd() is not anyhow triggered within updategraphics()
                    self.updategraphicsSignal.emit()

    #record 1C start markers of BT. called from push button_3 of application window
    @pyqtSlot(bool)
    def mark1Cstart(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_3.isFlat() and self.timeindex[2] > 0:
                        # undo wrongly set FCs
                        # deactivate autoFCs
                        aw.qmc.autoFCsenabled = False
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCs {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 2 in self.l_annotations_dict:
                                del self.l_annotations_dict[2]
                            self.timeindex[2] = 0
                            removed = True
                    elif not aw.button_3.isFlat():
                        # record 1Cs only if Charge mark has been done
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[2] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[2] = len(self.timex)-1
                            else:
                                return
                        if aw.qmc.phasesbuttonflag:
                            self.phases[2] = int(round(self.temp2[self.timeindex[2]]))
                        #calculate time elapsed since charge time
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCs {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[2]]-start,False)))
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min
                        if self.timeindex[1]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[2]],d)
                        else:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[0]],self.temp2[self.timeindex[2]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[2]],st1,self.timex[self.timeindex[2]],self.temp2[self.timeindex[2]],self.ystep_up,self.ystep_down,draggable_anno_key=2)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
                        aw.qmc.phasesLCDmode = aw.qmc.phasesLCDmode_l[2]
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " mark1Cstart() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [2,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that acquires a lock, so release it here
            if aw.button_3.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_3.setFlat(False)
                    if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                        aw.button_19.setFlat(False)
                        if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                            aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.button_3.setFlat(True)
                aw.button_8.setFlat(True)
                aw.button_19.setFlat(True)
                aw.eventactionx(aw.qmc.buttonactions[2],aw.qmc.buttonactionstrings[2])
                st1 = self.stringfromseconds(self.timex[self.timeindex[2]]-self.timex[self.timeindex[0]])
                st2 = "%.1f "%self.temp2[self.timeindex[2]] + self.mode
                message = QApplication.translate("Message","[FC START] recorded at {0} BT = {1}", None).format(st1,st2)
                aw.sendmessage(message)
                aw.onMarkMoveToNext(aw.button_3)
                if self.autoFCsIdx == 0:
                    # only if mark1Cstart() is not triggered from within updategraphics() and the canvas is anyhow updated
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #record 1C end markers of BT. called from button_4 of application window
    @pyqtSlot(bool)
    def mark1Cend(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_4.isFlat() and self.timeindex[3] > 0:
                        # undo wrongly set FCe
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCe {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 3 in self.l_annotations_dict:
                                del self.l_annotations_dict[3]
                            self.timeindex[3] = 0
                            removed = True
                    elif not aw.button_4.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[3] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[3] = len(self.timex)-1
                            else:
                                return
                        #calculate time elapsed since charge time
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","FCe {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[3]]-start,False)))
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[3]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[3]],st1,self.timex[self.timeindex[3]],self.temp2[self.timeindex[3]],self.ystep_up,self.ystep_down,draggable_anno_key=3)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " mark1Cend() {0}").format(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [3,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.button_4.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_4.setFlat(False)
                    if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                        aw.button_3.setFlat(False)
                        if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                            aw.button_19.setFlat(False)                        
                            if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.button_4.setFlat(True)
                aw.button_8.setFlat(True)
                aw.button_19.setFlat(True)
                aw.button_3.setFlat(True)
                aw.eventactionx(aw.qmc.buttonactions[3],aw.qmc.buttonactionstrings[3])
                st1 = self.stringfromseconds(self.timex[self.timeindex[3]]-self.timex[self.timeindex[0]])
                st2 = "%.1f "%self.temp2[self.timeindex[3]] + self.mode
                message = QApplication.translate("Message","[FC END] recorded at {0} BT = {1}", None).format(st1,st2)
                aw.sendmessage(message)
                aw.onMarkMoveToNext(aw.button_4)
                self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                

    #record 2C start markers of BT. Called from button_5 of application window
    @pyqtSlot(bool)
    def mark2Cstart(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile. 
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_5.isFlat() and self.timeindex[4] > 0:
                        # undo wrongly set FCs
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCs {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 4 in self.l_annotations_dict:
                                del self.l_annotations_dict[4]
                            self.timeindex[4] = 0
                            removed = True
                    elif not aw.button_5.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[4] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[4] = len(self.timex)-1
                            else:
                                return
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCs {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[4]]-start,False)))
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min
                        if self.timeindex[3]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[4]],d)
                        else:
                            self.ystep_down,self.ystep_up = self.findtextgap(0,0,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[4]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[4]],st1,self.timex[self.timeindex[4]],self.temp2[self.timeindex[4]],self.ystep_up,self.ystep_down,draggable_anno_key=4)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " mark2Cstart() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [4,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.button_5.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_5.setFlat(False)
                    if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                        aw.button_4.setFlat(False)
                        if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                            aw.button_3.setFlat(False)
                            if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                aw.button_19.setFlat(False)
                                if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                    aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.button_5.setFlat(True)
                aw.button_8.setFlat(True)
                aw.button_19.setFlat(True)
                aw.button_3.setFlat(True)
                aw.button_4.setFlat(True)
                aw.eventactionx(aw.qmc.buttonactions[4],aw.qmc.buttonactionstrings[4])
                st1 = self.stringfromseconds(self.timex[self.timeindex[4]]-self.timex[self.timeindex[0]])
                st2 = "%.1f "%self.temp2[self.timeindex[4]] + self.mode
                message = QApplication.translate("Message","[SC START] recorded at {0} BT = {1}", None).format(st1,st2)
                aw.sendmessage(message)
                aw.onMarkMoveToNext(aw.button_5)
                self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #record 2C end markers of BT. Called from button_6  of application window
    @pyqtSlot(bool)
    def mark2Cend(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_6.isFlat() and self.timeindex[5] > 0:
                        # undo wrongly set FCs
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCe {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 5 in self.l_annotations_dict:
                                del self.l_annotations_dict[5]
                            self.timeindex[5] = 0
                            removed = True
                    elif not aw.button_6.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[5] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[5] = len(self.timex)-1
                            else:
                                return
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","SCe {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[5]]-start,False)))
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[5]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[5]],st1,self.timex[self.timeindex[5]],self.temp2[self.timeindex[5]],self.ystep_up,self.ystep_down,draggable_anno_key=5)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " mark2Cend() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)  
        if self.flagstart:                      
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [5,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.button_6.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_6.setFlat(False)
                    if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                        aw.button_5.setFlat(False)
                        if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                            aw.button_4.setFlat(False)
                            if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                aw.button_3.setFlat(False)
                                if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                    aw.button_19.setFlat(False)                        
                                    if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                        aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.button_6.setFlat(True)
                aw.button_8.setFlat(True)
                aw.button_19.setFlat(True)
                aw.button_3.setFlat(True)
                aw.button_4.setFlat(True)
                aw.button_5.setFlat(True)
                aw.eventactionx(aw.qmc.buttonactions[5],aw.qmc.buttonactionstrings[5])
                st1 = self.stringfromseconds(self.timex[self.timeindex[5]]-self.timex[self.timeindex[0]])
                st2 = "%.1f "%self.temp2[self.timeindex[5]] + self.mode
                message = QApplication.translate("Message","[SC END] recorded at {0} BT = {1}", None).format(st1,st2)
                aw.sendmessage(message)
                aw.onMarkMoveToNext(aw.button_6)
                self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #record end of roast (drop of beans). Called from push button 'Drop'
    @pyqtSlot(bool)
    def markDrop(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    # we check if this is the first DROP mark on this roast
                    firstDROP = self.timeindex[6] == 0
                    if aw.button_9.isFlat() and self.timeindex[6] > 0:
                        # undo wrongly set FCs
                        # deactivate autoDROP
                        aw.qmc.autoDROPenabled = False
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DROP {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 6 in self.l_annotations_dict:
                                del self.l_annotations_dict[6]
                            self.timeindex[6] = 0
                            #decrease BatchCounter again
                            self.decBatchCounter()
                            removed = True
                    elif not aw.button_9.isFlat():
                        self.incBatchCounter()
                        # generate UUID
                        if self.roastUUID is None: # there might be already one assigned by undo and redo the markDROP!
                            self.roastUUID = uuid.uuid4().hex
                        if self.device != 18 or aw.simulator is not None:
                            if self.autoDropIdx:
                                self.timeindex[6] = self.autoDropIdx
                            else:
                                self.timeindex[6] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[6] = len(self.timex)-1
                            else:
                                return
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","DROP {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[6]]-start,False)))
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                        if self.timeindex[5]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[5]],self.temp2[self.timeindex[6]],d)
                        elif self.timeindex[4]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[4]],self.temp2[self.timeindex[6]],d)
                        elif self.timeindex[3]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[3]],self.temp2[self.timeindex[6]],d)
                        elif self.timeindex[2]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[2]],self.temp2[self.timeindex[6]],d)
                        elif self.timeindex[1]:
                            self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[1]],self.temp2[self.timeindex[6]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[6]],st1,self.timex[self.timeindex[6]],self.temp2[self.timeindex[6]],self.ystep_up,self.ystep_down,draggable_anno_key=6)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
                        
                        try:
                            # update ambient temperature if a ambient temperature source is configured and no value yet established
                            aw.qmc.updateAmbientTempFromPhidgetModulesOrCurve()
                        except Exception:
                            pass

#PLUS
                        # only on first setting the DROP event (not set yet and no previous DROP undone) and if not in simulator modus, we upload to PLUS
                        if firstDROP and aw.qmc.autoDROPenabled and aw.plus_account is not None and not bool(aw.simulator):
                            try:
                                aw.updatePlusStatus()
                            except:
                                pass
                                # add to out-queue
                            try:
                                plus.queue.addRoast()
                            except:
                                pass

            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " markDrop() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # redraw (within timealign) should not be called if semaphore is hold!
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.qmc.alignEvent in [6,7]:
                aw.qmc.timealign(redraw=True,recompute=False) # redraws at least the canvas if redraw=True, so no need here for doing another canvas.draw()
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            try:
                if aw.button_9.isFlat():
                    if removed:
                        self.updateBackground()
                        aw.button_9.setFlat(False)
                        if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                            aw.button_6.setFlat(False)
                            if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                aw.button_5.setFlat(False)
                                if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                    aw.button_4.setFlat(False)
                                    if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                        aw.button_3.setFlat(False)
                                        if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                            aw.button_19.setFlat(False)
                                            if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                aw.button_8.setFlat(False)
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
                else:            
                    aw.button_9.setFlat(True)
                    aw.button_8.setFlat(True)
                    aw.button_19.setFlat(True)
                    aw.button_3.setFlat(True)
                    aw.button_4.setFlat(True)
                    aw.button_5.setFlat(True)
                    aw.button_6.setFlat(True)
                    
                    try:
                        aw.eventactionx(aw.qmc.buttonactions[6],aw.qmc.buttonactionstrings[6])
                        st1 = self.stringfromseconds(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]])
                        st2 = "%.1f "%self.temp2[self.timeindex[6]] + self.mode
                        message = QApplication.translate("Message","Roast ended at {0} BT = {1}", None).format(st1,st2)
                        aw.sendmessage(message)
                    except:
                        pass
                    # at DROP we stop the follow background on FujiPIDs and set the SV to 0
                    if aw.qmc.device == 0 and aw.fujipid.followBackground:
                        if aw.fujipid.sv and aw.fujipid.sv > 0:
                            try:
                                aw.fujipid.setsv(0,silent=True)
                                aw.fujipid.sv = 0
                            except:
                                pass
                    aw.onMarkMoveToNext(aw.button_9)
                    if not (self.autoDropIdx > 0 and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6]):
                        # only if not anyhow markDrop() is triggered from within updategraphic() which guarantees an immedate redraw
                        self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            except Exception:
                pass

    def decBatchCounter(self):
        if aw.qmc.batchcounter > -1 and not bool(aw.simulator):
            aw.qmc.batchcounter -= 1 # we decrease the batch counter
            # set the batchcounter of the current profile
            aw.qmc.roastbatchnr = 0
            if aw.qmc.lastroastepoch + 5400 < aw.qmc.roastepoch:
                # reset the sequence counter
                aw.qmc.batchsequence = 1
            elif aw.qmc.batchsequence > 1:
                aw.qmc.batchsequence -= 1
            aw.qmc.roastbatchpos = 0
            # decr. the batchcounter of the loaded app settings
            if aw.settingspath and aw.settingspath != "":
                try:
                    settings = QSettings(aw.settingspath,QSettings.IniFormat)
                    settings.beginGroup("Batch")
                    if settings.contains("batchcounter"):
                        bc = toInt(settings.value("batchcounter",aw.qmc.batchcounter))
                        bprefix = toString(settings.value("batchprefix",aw.qmc.batchprefix))
                        if bc > -1 and bc == aw.qmc.batchcounter+1 and aw.qmc.batchprefix == bprefix:
                            settings.setValue("batchcounter",bc - 1)
                    settings.endGroup()
                except Exception:
                    aw.settingspath = ""
        
    def incBatchCounter(self):
        if aw.qmc.batchcounter > -1 and not bool(aw.simulator):
            aw.qmc.batchcounter += 1 # we increase the batch counter
            # set the batchcounter of the current profile
            aw.qmc.roastbatchnr = aw.qmc.batchcounter
            # set the batchprefix of the current profile
            aw.qmc.roastbatchprefix = aw.qmc.batchprefix
            # incr. the batchcounter of the loaded app settings
            if aw.settingspath and aw.settingspath != "":
                try:
                    settings = QSettings(aw.settingspath,QSettings.IniFormat)
                    settings.beginGroup("Batch")
                    if settings.contains("batchcounter"):
                        bc = toInt(settings.value("batchcounter",aw.qmc.batchcounter))
                        bprefix = toString(settings.value("batchprefix",aw.qmc.batchprefix))
                        if bc > -1 and aw.qmc.batchprefix == bprefix:
                            settings.setValue("batchcounter",aw.qmc.batchcounter)
                    settings.endGroup()
                except Exception:
                    aw.settingspath = ""
            # update batchsequence by estimating batch sequence (roastbatchpos) from lastroastepoch and roastepoch
            # if this roasts DROP is more than 1.5h after the last registered DROP, we assume a new session starts
            if aw.qmc.lastroastepoch + 5400 < aw.qmc.roastepoch:
                # reset the sequence counter
                aw.qmc.batchsequence = 1
            else:
                aw.qmc.batchsequence += 1
            # set roastbatchpos
            aw.qmc.roastbatchpos = aw.qmc.batchsequence
        else: # batch counter system inactive
            # set the batchcounter of the current profile
            aw.qmc.batchsequence = 1
            aw.qmc.roastbatchnr = 0
            aw.qmc.roastbatchpos = 1
        # update lastroastepoch to time of roastdate
        aw.qmc.lastroastepoch = aw.qmc.roastepoch
    
    @pyqtSlot(bool)
    def markCoolEnd(self,_=False):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                removed = False
                if len(self.timex) > 0:
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    
                    if self.timeindex[0] > -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    if aw.button_20.isFlat() and self.timeindex[7] > 0:
                        # undo wrongly set COOL
                        
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","CE {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[7]] - start)))
                        
                        if len(self.l_annotations) > 1 and self.l_annotations[-1].get_text() == st1:
                            self.l_annotations[-1].remove()
                            self.l_annotations[-2].remove()
                            self.l_annotations = self.l_annotations[:-2]
                            if 7 in self.l_annotations_dict:
                                del self.l_annotations_dict[7]
                            self.timeindex[7] = 0
                            removed = True
                        
                    elif not aw.button_20.isFlat():
                        if self.device != 18 or aw.simulator is not None:
                            self.timeindex[7] = len(self.timex)-1
                        else:
                            tx,et,bt = aw.ser.NONE()
                            if et != -1 and bt != -1:
                                self.drawmanual(et,bt,tx)
                                self.timeindex[7] = len(self.timex)-1
                            else:
                                return
                        #calculate time elapsed since charge time
                        st1 = aw.arabicReshape(QApplication.translate("Scope Annotation","CE {0}", None).format(self.stringfromseconds(self.timex[self.timeindex[7]] - start)))
                        #anotate temperature
                        d = aw.qmc.ylimit - aw.qmc.ylimit_min  
                        self.ystep_down,self.ystep_up = self.findtextgap(self.ystep_down,self.ystep_up,self.temp2[self.timeindex[6]],self.temp2[self.timeindex[7]],d)
                        self.l_annotations += self.annotate(self.temp2[self.timeindex[7]],st1,self.timex[self.timeindex[7]],self.temp2[self.timeindex[7]],self.ystep_up,self.ystep_down,draggable_anno_key=7)
                        #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                        self.updateBackground() # but we need
            else:
                message = QApplication.translate("Message","Scope is OFF", None)
                aw.sendmessage(message)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " markCoolEnd() {0}").format(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart:
            # NOTE: the following aw.eventaction might do serial communication that accires a lock, so release it here
            if aw.button_20.isFlat():
                if removed:
                    self.updateBackground()
                    aw.button_20.setFlat(False)
                    if self.timeindex[6] == 0: # reactivate the DROP button if not yet set
                        aw.button_9.setFlat(False)
                        if self.timeindex[5] == 0: # reactivate the SCe button if not yet set
                            aw.button_6.setFlat(False)
                            if self.timeindex[4] == 0: # reactivate the SCs button if not yet set
                                aw.button_5.setFlat(False)
                                if self.timeindex[3] == 0: # reactivate the FCe button if not yet set
                                    aw.button_4.setFlat(False)
                                    if self.timeindex[2] == 0: # reactivate the FCs button if not yet set
                                        aw.button_3.setFlat(False)
                                        if self.timeindex[1] == 0: # reactivate the DRY button if not yet set
                                            aw.button_19.setFlat(False)
                                            if self.timeindex[0] == -1: # reactivate the CHARGE button if not yet set
                                                aw.button_8.setFlat(False)
                    self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately
            else:
                aw.button_20.setFlat(True)
                aw.button_8.setFlat(True)
                aw.button_19.setFlat(True)
                aw.button_3.setFlat(True)
                aw.button_4.setFlat(True)
                aw.button_5.setFlat(True)
                aw.button_6.setFlat(True)
                aw.button_9.setFlat(True)
                aw.eventactionx(aw.qmc.buttonactions[7],aw.qmc.buttonactionstrings[7])
                st1 = self.stringfromseconds(self.timex[self.timeindex[7]]-self.timex[self.timeindex[0]])
                st2 = "%.1f "%self.temp2[self.timeindex[7]] + self.mode
                message = QApplication.translate("Message","[COOL END] recorded at {0} BT = {1}", None).format(st1,st2)
                #set message at bottom
                aw.sendmessage(message)
                self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    # action of the EVENT button
    @pyqtSlot(bool)
    def EventRecord_action(self,_=False):
        self.EventRecord()

    def EventRecord(self,extraevent=None,takeLock=True):
        try:
            if extraevent!=None:
                if aw.extraeventstypes[extraevent] <= 4:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=aw.extraeventstypes[extraevent],
                        eventvalue=aw.extraeventsvalues[extraevent],
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock)
                elif aw.extraeventstypes[extraevent] == 9:
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=4,  # we map back to the untyped event type
                        eventvalue=aw.extraeventsvalues[extraevent],
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock)
                else: # on "relative" event values, we take the last value set per event via the recordextraevent call before
                    self.EventRecordAction(
                        extraevent=extraevent,
                        eventtype=aw.extraeventstypes[extraevent]-5,
                        eventvalue=aw.qmc.eventsExternal2InternalValue(aw.extraeventsactionslastvalue[aw.extraeventstypes[extraevent]-5]),
                        eventdescription=aw.extraeventsdescriptions[extraevent],takeLock=takeLock)
            else:
                self.EventRecordAction(extraevent=extraevent,takeLock=takeLock)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " EventRecord() {0}").format(str(e)),exc_tb.tb_lineno)

    #Marks location in graph of special events. For example change a fan setting.
    #Uses the position of the time index (variable self.timex) as location in time
    # extraevent is given when called from aw.recordextraevent() from an extra Event Button
    def EventRecordAction(self,extraevent=None,eventtype=None,eventvalue=None,eventdescription="",takeLock=True,doupdategraphics=True):
        try:
            if takeLock:
                aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                if len(self.timex) > 0 or (self.device == 18 and aw.simulator is None):
                    aw.soundpop()
                    #prevents accidentally deleting a modified profile.
                    self.fileDirty()
                    Nevents = len(self.specialevents)
                    #if in manual mode record first the last point in self.timex[]
                    if self.device == 18 and aw.simulator is None:
                        tx,et,bt = aw.ser.NONE()
                        if bt != -1 or et != -1:
                            self.drawmanual(et,bt,tx)
                        else:
                            return
                    #i = index number of the event (current length of the time list)
                    i = len(self.timex)-1
                    # if Desciption, Type and Value of the new event equals the last recorded one, we do not record this again!
                    if not(self.specialeventstype) or not(self.specialeventsvalue) or not(self.specialeventsStrings) or not(eventtype != 4 and self.specialeventstype[-1] == eventtype and self.specialeventsvalue[-1] == eventvalue and self.specialeventsStrings[-1] == eventdescription):
                        fontprop_small = aw.mpl_fontproperties.copy()
                        fontsize = "xx-small"
                        fontprop_small.set_size(fontsize)
                        self.specialevents.append(i)
                        self.specialeventstype.append(4)
                        self.specialeventsStrings.append(str(Nevents+1))
                        self.specialeventsvalue.append(0)
                        #if event was initiated by an Extra Event Button then change the type,value,and string 
                        if extraevent is not None:
                            self.specialeventstype[-1] = eventtype
                            self.specialeventsvalue[-1] = eventvalue
                            self.specialeventsStrings[-1] = eventdescription
                        etype = self.specialeventstype[-1]
                        tx = self.timex[self.specialevents[-1]]
                        if self.clampEvents: # in clamp mode we render also event values higher than 100:
                            val = int(round((self.specialeventsvalue[-1]-1)*10))
                        else:
                            val = self.eventpositionbars[min(110,max(0,int(round((self.specialeventsvalue[-1]-1)*10))))]
                        if etype == 0:
                            self.E1timex.append(tx)
                            self.E1values.append(val)
                        elif etype == 1:
                            self.E2timex.append(tx)
                            self.E2values.append(val)
                        elif etype == 2:
                            self.E3timex.append(tx)
                            self.E3values.append(val)
                        elif etype == 3:
                            self.E4timex.append(tx)
                            self.E4values.append(val)
                        #if Event show flag
                        if self.eventsshowflag and aw.qmc.showEtypes[etype]:
                            index = self.specialevents[-1]
                            if etype < 4  and (not aw.qmc.renderEventsDescr or len(self.specialeventsStrings[-1].strip()) == 0):
                                firstletter = self.etypesf(self.specialeventstype[-1])[0]
                                secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                                thirdletter = aw.eventsliderunits[self.specialeventstype[-1]] # postfix
                            else:
                                firstletter = self.specialeventsStrings[-1].strip()[:aw.qmc.eventslabelschars]
                                if firstletter == "":
                                    firstletter = "E"
                                secondletter = ""
                                thirdletter = ""
                            #if Event Type-Bars flag
                            if self.eventsGraphflag == 1 and etype < 4:
                                if self.mode == "F":
                                    row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                                else:
                                    row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] >= self.temp2[index]:
                                    anno = self.ax.annotate(firstletter + secondletter, 
                                        xy=(self.timex[index], 
                                        self.temp1[index]),
                                        xytext=(self.timex[index],row[etype]),
                                        alpha=1.,
                                        bbox=dict(boxstyle='square,pad=0.1', fc=self.EvalueColor[etype], ec='none'),
                                        path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                        color=self.EvalueTextColor[etype],
                                        arrowprops=dict(arrowstyle='-',color=self.palette["et"],alpha=0.4,relpos=(0,0)),
                                        fontsize=fontsize,
                                        fontproperties=fontprop_small)
                                elif aw.qmc.BTcurve:
                                    anno = self.ax.annotate(firstletter + secondletter, 
                                            xy=(self.timex[index], 
                                            self.temp2[index]),
                                            xytext=(self.timex[index],row[etype]),
                                            alpha=1.,
                                            bbox=dict(boxstyle='square,pad=0.1', fc=self.EvalueColor[etype], ec='none'),
                                            path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                            color=self.EvalueTextColor[etype],
                                            arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),
                                            fontsize=fontsize,
                                            fontproperties=fontprop_small)
                                try:
                                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                except: # mpl before v3.0 do not have this set_in_layout() function
                                    pass
                            elif self.eventsGraphflag in [2,3,4] and etype < 4:
                                # update lines data using the lists with new data
                                if etype == 0 and aw.qmc.showEtypes[0]:
                                    self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                                elif etype == 1 and aw.qmc.showEtypes[1]:
                                    self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                                elif etype == 2 and aw.qmc.showEtypes[2]:
                                    self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                                elif etype == 3 and aw.qmc.showEtypes[3]:
                                    self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                            if self.specialeventstype[-1] == 4 or ( self.eventsGraphflag in [0,3,4] and aw.qmc.showEtypes[self.specialeventstype[-1]] ): 
                                if self.mode == "F":
                                    height = 50
                                else:
                                    height = 20
                                #some times ET is not drawn (ET = 0) when using device NONE
                                # plot events on BT when showeventsonbt is true
                                if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] > self.temp2[index]:
                                    temp = self.temp1[index]
                                elif aw.qmc.BTcurve:
                                    temp = self.temp2[index]
                                else:
                                    temp = None
                                    
                                if self.eventsGraphflag == 4:
                                    if self.specialeventstype[-1] == 0:
                                        temp = self.E1values[-1]
                                    elif self.specialeventstype[-1] == 1:
                                        temp = self.E2values[-1]
                                    elif self.specialeventstype[-1] == 2:
                                        temp = self.E3values[-1]
                                    elif self.specialeventstype[-1] == 3:
                                        temp = self.E4values[-1]
                                    
                                if temp != None:
                                    if self.specialeventstype[-1] == 0:
                                        boxstyle = 'roundtooth,pad=0.4'
                                        boxcolor = self.EvalueColor[0]
                                        textcolor = self.EvalueTextColor[0]
                                    elif self.specialeventstype[-1] == 1:
                                        boxstyle = 'round,pad=0.3,rounding_size=0.8'
                                        boxcolor = self.EvalueColor[1]
                                        textcolor = self.EvalueTextColor[1]
                                    elif self.specialeventstype[-1] == 2:
                                        boxstyle = 'sawtooth,pad=0.3,tooth_size=0.2'
                                        boxcolor = self.EvalueColor[2]
                                        textcolor = self.EvalueTextColor[2]
                                    elif self.specialeventstype[-1] == 3:
                                        boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                                        boxcolor = self.EvalueColor[3]
                                        textcolor = self.EvalueTextColor[3]
                                    else: # self.specialeventstype[-1] == 4:
                                        boxstyle = 'square,pad=0.1'
                                        boxcolor = self.palette["specialeventbox"]
                                        textcolor = self.palette["specialeventtext"]
                                    if self.eventsGraphflag in [0,3] or self.specialeventstype[-1] > 3:
                                        anno = self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                                         color=textcolor,
                                                         va="center", ha="center",
                                                         arrowprops=dict(arrowstyle='-',color=boxcolor,alpha=0.4,relpos=(0,0)),
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                         backgroundcolor=boxcolor)
                                    elif self.eventsGraphflag == 4:
                                        if thirdletter != "":
                                            firstletter = ""
                                        anno = self.ax.annotate(firstletter + secondletter + thirdletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp),alpha=0.9,
                                                         color=textcolor,
                                                         va="center", ha="center",
                                                         bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                                         fontsize=fontsize,
                                                         fontproperties=fontprop_small,
                                                         path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                                         backgroundcolor=boxcolor)

                                    try:
                                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                                    except: # mpl before v3.0 do not have this set_in_layout() function
                                        pass

                        self.updateBackground() # call to canvas.draw() not needed as self.annotate does the (partial) redraw, but updateBacground() needed
                        temp = "%.1f "%self.temp2[i]
                        if aw.qmc.timeindex[0] != -1:
                            start = aw.qmc.timex[aw.qmc.timeindex[0]]
                        else:
                            start = 0
                        timed = self.stringfromseconds(self.timex[i] - start)
                        message = QApplication.translate("Message","Event # {0} recorded at BT = {1} Time = {2}", None).format(str(Nevents+1),temp,timed)
                        aw.sendmessage(message)
                        #write label in mini recorder if flag checked
                        if aw.minieventsflag:
                            aw.eventlabel.setText(QApplication.translate("Label", "Event #<b>{0} </b>",None).format(Nevents+1))
                            aw.eNumberSpinBox.blockSignals(True)
                            try:
                                aw.eNumberSpinBox.setValue(Nevents+1)
                            except Exception:
                                pass
                            aw.eNumberSpinBox.blockSignals(False)
                            if aw.qmc.timeindex[0] > -1:
                                timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[Nevents]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
                                aw.etimeline.setText(timez)
                            aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents])
                            aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents]))
                            aw.lineEvent.setText(self.specialeventsStrings[Nevents])
            else:
                aw.sendmessage(QApplication.translate("Message","Timer is OFF", None))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " EventRecordAction() {0}").format(str(e)),exc_tb.tb_lineno)
        finally:
            if takeLock and aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        if self.flagstart and doupdategraphics:
            self.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    #called from controlling devices when roasting to record steps (commands) and produce a profile later
    def DeviceEventRecord(self,command):
        try:
            aw.qmc.samplingsemaphore.acquire(1)
            if self.flagstart:
                #prevents accidentally deleting a modified profile.
                self.fileDirty()
                #number of events
                Nevents = len(self.specialevents)
                #index number            
                i = len(self.timex)-1
                if i > 0:
                    self.specialevents.append(i)                                     # store absolute time index
                    self.specialeventstype.append(0)                                 # set type (to the first index 0)
                    self.specialeventsStrings.append(command)                        # store the command in the string section of events (not a binary string)
                    self.specialeventsvalue.append(0)                                # empty
                    temp = str(self.temp2[i])
                    if self.timeindex[0] != -1:
                        start = self.timex[self.timeindex[0]]
                    else:
                        start = 0
                    timed = self.stringfromseconds(self.timex[i]-start)
                    message = QApplication.translate("Message","Computer Event # {0} recorded at BT = {1} Time = {2}", None).format(str(Nevents+1),temp,timed)
                    aw.sendmessage(message)
                    #write label in mini recorder if flag checked
                    if aw.minieventsflag:
                        aw.eNumberSpinBox.setValue(Nevents+1)
                        aw.etypeComboBox.setCurrentIndex(self.specialeventstype[Nevents-1])
                        aw.valueEdit.setText(aw.qmc.eventsvalues(self.specialeventsvalue[Nevents-1]))
                        aw.lineEvent.setText(self.specialeventsStrings[Nevents])
                #if Event show flag
                if self.eventsshowflag:
                    index = self.specialevents[-1]
                    if self.specialeventstype[-1] < 4 and aw.qmc.showEtypes[self.specialeventstype[-1]]:
                        fontprop_small = aw.mpl_fontproperties.copy()
                        fontsize = "xx-small"
                        fontprop_small.set_size(fontsize)
                        firstletter = self.etypesf(self.specialeventstype[-1])[0]
                        secondletter = self.eventsvaluesShort(self.specialeventsvalue[-1])
                        if self.eventsGraphflag == 0:
                            if self.mode == "F":
                                height = 50
                            else:
                                height = 20
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] > self.temp2[index]:
                                temp = self.temp1[index]
                            else:
                                temp = self.temp2[index]
                            anno = self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], temp),xytext=(self.timex[index],temp+height),alpha=0.9,
                                             color=self.palette["specialeventtext"],arrowprops=dict(arrowstyle='-',color=self.palette["bt"],alpha=0.4,relpos=(0,0)),
                                             fontsize=fontsize,fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette["specialeventbox"])
                            try:
                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except: # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        #if Event Type-Bars flag
                        if self.eventsGraphflag == 1:
                            if self.mode == "F":
                                row = {0:self.phases[0]-20,1:self.phases[0]-40,2:self.phases[0]-60,3:self.phases[0]-80}
                            else:
                                row = {0:self.phases[0]-10,1:self.phases[0]-20,2:self.phases[0]-30,3:self.phases[0]-40}
                            #some times ET is not drawn (ET = 0) when using device NONE
                            # plot events on BT when showeventsonbt is true
                            if aw.qmc.ETcurve and not aw.qmc.showeventsonbt and self.temp1[index] >= self.temp2[index]:
                                anno = self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp1[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette["specialeventtext"],arrowprops=dict(arrowstyle='-',
                                                 color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette["specialeventbox"])
                            elif aw.qmc.BTcurve:
                                anno = self.ax.annotate(firstletter + secondletter, xy=(self.timex[index], self.temp2[index]),xytext=(self.timex[index],row[self.specialeventstype[-1]]),alpha=1.,
                                                 color=self.palette["specialeventtext"],arrowprops=dict(arrowstyle='-',
                                                 color=self.palette["et"],alpha=0.4,relpos=(0,0)),fontsize=fontsize,
                                                 fontproperties=fontprop_small,backgroundcolor=aw.qmc.palette["specialeventbox"])
                            try:
                                anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                            except: # mpl before v3.0 do not have this set_in_layout() function
                                pass
                        if self.eventsGraphflag in [2,3,4]:
                            # update lines data using the lists with new data
                            etype = self.specialeventstype[-1]
                            if etype == 0:
                                self.l_eventtype1dots.set_data(self.E1timex, self.E1values)
                            elif etype == 1:
                                self.l_eventtype2dots.set_data(self.E2timex, self.E2values)
                            elif etype == 2:
                                self.l_eventtype3dots.set_data(self.E3timex, self.E3values)
                            elif etype == 3:
                                self.l_eventtype4dots.set_data(self.E4timex, self.E4values)
                    #self.fig.canvas.draw() # not needed as self.annotate does the (partial) redraw
                    self.updateBackground() # but we need
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " DeviceEventRecord() {0}").format(str(e)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    def writecharacteristics(self,TP_index=None,LP=None):
        try:            
            # Display MET marker
            if self.showmet and aw.qmc.ETcurve and self.timeindex[0] > -1 and self.timeindex[6] > 0:
                if TP_index is None:
                    TP_index = aw.findTP()
                met_temp = max(self.temp1[TP_index:self.timeindex[6]])
                self.idx_met = TP_index + self.temp1[TP_index:self.timeindex[6]].index(met_temp)
                if self.idx_met and self.timeindex[2]:
                    # time between MET and FCs
                    met_delta = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.idx_met],0)
                else:
                    met_delta = None    
                self.met_timex_temp1_delta = [(self.timex[self.idx_met]-self.timex[self.timeindex[0]]), met_temp, met_delta ] #used in onpick() to display the MET temp and time
                # plot a MET marker
                if self.showmet and aw.qmc.ETcurve:
                    if self.mode == "F":
                        height = 0
                    else:
                        height = 0
                    boxstyle = 'round4,pad=0.3,rounding_size=0.15'
                    boxcolor = aw.qmc.palette["metbox"] #match the ET color
                    textcolor = self.palette["mettext"]
                    fontprop_small = aw.mpl_fontproperties.copy()
                    fontprop_small.set_size("xx-small")
                    self.met_annotate = self.ax.annotate("MET", xy=(self.timex[self.idx_met], met_temp),
                                 xytext=(self.timex[self.idx_met], met_temp + height),
                                 ha = "center",
                                 alpha=0.9,
                                 color=textcolor,
                                 bbox=dict(boxstyle=boxstyle, fc=boxcolor, ec='none'),
                                 fontproperties=fontprop_small,
                                 path_effects=[PathEffects.withStroke(linewidth=0.5,foreground=self.palette["background"])],
                                 picker=True,
                                 zorder=2,
                                 )
                    try:
                        self.met_annotate.set_in_layout(False) # remove suptitle from tight_layout calculation
                    except: # set_in_layout not available in mpl<3.x
                        pass

            if self.statisticsflags[3] and self.timeindex[0]>-1:
                statsprop = aw.mpl_fontproperties.copy()
                statsprop.set_size("small")
                if aw.qmc.statisticsmode == 0:
                    if TP_index is None:
                        TP_index = aw.findTP()
                    if LP is None:
                        #find Lowest Point in BT
                        LP = 1000 
                        if TP_index >= 0:
                            LP = self.temp2[TP_index]
                    # compute max ET between TP and DROP
                    if TP_index is not None:
                        temp1_values = self.temp1[TP_index:self.timeindex[6]]
                        if self.LCDdecimalplaces:
                            lcdformat = "%.1f"
                        else:
                            lcdformat = "%.0f"
                        temp1_values_max = max(temp1_values)
                        ETmax = lcdformat%temp1_values_max + aw.qmc.mode
                    else:
                        ETmax = "--"

                    FCperiod = None
                    try:
                        if self.timeindex[2] > 0 and self.timeindex[3] > 0:
                            FCperiod = self.stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[2]])[1:]
                        elif self.timeindex[2] > 0 and self.timeindex[6] > 0:
                            FCperiod = self.stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])[1:]
                    except:
                        pass

                    ror = "%.1f"%(((self.temp2[self.timeindex[6]]-LP)/(self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]))*60.)
                    _,_,tsb,_ = aw.ts(tp=TP_index)
                    
                    #curveSimilarity
                    det,dbt = aw.curveSimilarity(aw.qmc.phases[1]) # we analyze from DRY-END as specified in the phases dialog to DROP

                    #end temperature
                    if locale == "ar":
                        strline = u("C*min{2}=" + aw.arabicReshape(QApplication.translate("Label", "AUC", None)) \
                                    + " " + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min", None)) \
                                    + "{1}=" + aw.arabicReshape(QApplication.translate("Label", "RoR", None)) \
                                    + " {0}=" + aw.arabicReshape(QApplication.translate("Label", "MET", None))) \
                                    .format(u(ETmax), \
                                    u(ror), \
                                    u(int(tsb)))
                        if det is not None:
                            strline = u(("%.1f/%.1f" % (det,dbt)) + self.mode + "=" + QApplication.translate("Label", "CM", None) + " ") + strline
                        if FCperiod is not None:
                            strline = u("min%s=" % FCperiod + QApplication.translate("Label", "FC", None) + "   ") + strline
                    else:
                        strline = ""
                        if temp1_values_max and temp1_values_max > 0:
                            strline = u(QApplication.translate("Label", "MET", None) + "={0}   ").format(u(ETmax))
                        strline += u(QApplication.translate("Label", "RoR", None) + "={0}" \
                                    + aw.qmc.mode + QApplication.translate("Label", "/min", None) + "   " \
                                    + QApplication.translate("Label", "AUC", None) + "={1}C*min") \
                                    .format(u(ror), \
                                    u(int(tsb)))
                        if det is not None:
                            strline = strline + u("   " + QApplication.translate("Label", "CM", None) + ("=%.1f/%.1f" % (det,dbt)) + self.mode)
                        if FCperiod is not None:
                            strline = strline + u("   " + QApplication.translate("Label", "FC", None) + "=%smin" % FCperiod)
                    self.ax.set_xlabel(strline,color = aw.qmc.palette["xlabel"],fontproperties=statsprop)
                else:
                    sep = u"   "
                    msg = aw.qmc.roastdate.date().toString(Qt.SystemLocaleShortDate)
                    tm = u(aw.qmc.roastdate.time().toString()[:-3])
                    if tm != "00:00":
                        msg += ", " + tm
                    if aw.qmc.beans and aw.qmc.beans != "":
                        msg += sep + aw.qmc.abbrevString(u(aw.qmc.beans),25)
                    if aw.qmc.weight[0]:
                        if aw.qmc.weight[2] in ["g","oz"]:
                            msg += sep + str(aw.float2float(aw.qmc.weight[0],0)) + aw.qmc.weight[2]
                        else:
                            msg += sep + str(aw.float2float(aw.qmc.weight[0],1)) + aw.qmc.weight[2]
                        if aw.qmc.weight[1]:
                            msg += sep + str(-aw.float2float(aw.weight_loss(aw.qmc.weight[0],aw.qmc.weight[1]),1)) + "%"
                    if aw.qmc.volume[0] and aw.qmc.volume[1]:
                            msg += sep + str(aw.float2float(aw.volume_increase(aw.qmc.volume[0],aw.qmc.volume[1]),1)) + "%"
                    if aw.qmc.whole_color and aw.qmc.ground_color:
                        msg += sep + u"#" + str(aw.qmc.whole_color) + u"/" +  str(aw.qmc.ground_color)
                    elif aw.qmc.ground_color:
                        msg += sep + u"#" + str(aw.qmc.ground_color)
                    self.ax.set_xlabel(msg,color = aw.qmc.palette["xlabel"],fontproperties=statsprop)
            else:
                fontprop_medium = aw.mpl_fontproperties.copy()
                fontprop_medium.set_size("medium")
                self.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "min",None)),color = self.palette["xlabel"],fontproperties=fontprop_medium)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " writecharacteristics() {0}").format(str(ex)),exc_tb.tb_lineno)
    
    # calculates self.statisticstimes values and returns dryEndIndex as well as the calcuated statisticstimes array of length 5
    def calcStatistics(self,TP_index):
        statisticstimes = [0,0,0,0,0]
        try:
            if self.timeindex[1] and self.phasesbuttonflag:
                #manual dryend available
                dryEndIndex = self.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            dryEndTime = self.timex[dryEndIndex]

            #if DROP
            if self.timeindex[6] and self.timeindex[2]:
                totaltime = self.timex[self.timeindex[6]]-self.timex[self.timeindex[0]]
                if totaltime == 0:
                    return dryEndIndex, statisticstimes

                statisticstimes[0] = totaltime
                dryphasetime = dryEndTime - self.timex[self.timeindex[0]] # aw.float2float(dryEndTime - self.timex[self.timeindex[0]])
                midphasetime = self.timex[self.timeindex[2]] - dryEndTime # aw.float2float(self.timex[self.timeindex[2]] - dryEndTime)
                finishphasetime = self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]] # aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                if self.timeindex[7]:
                    coolphasetime = self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]] # int(round(self.timex[self.timeindex[7]] - self.timex[self.timeindex[6]]))
                else:
                    coolphasetime = 0

                statisticstimes[1] = dryphasetime
                statisticstimes[2] = midphasetime
                statisticstimes[3] = finishphasetime
                statisticstimes[4] = coolphasetime
            return dryEndIndex, statisticstimes
        except:
            return self.timeindex[1], statisticstimes

    # Writes information about the finished profile in the graph
    # TP_index is the TP index calculated by findTP and might be -1 if no TP could be detected
    def writestatistics(self,TP_index):
        try:
            LP = None

            dryEndIndex, statisticstimes = self.calcStatistics(TP_index)

            if statisticstimes[0] == 0:
# not sure we want this warning message to display on each redraw of a profile without proper events, maybe better to just silently don't render the statistics
#                aw.sendmessage(QApplication.translate("Message","Statistics cancelled: need complete profile [CHARGE] + [FCs] + [DROP]", None))
                return
            else:
                self.statisticstimes = statisticstimes

            #if DROP
            if self.timeindex[6] and self.timeindex[2]:

                #dry time string
                st1 = self.stringfromseconds(self.statisticstimes[1],False)

                #mid time string
                st2 = self.stringfromseconds(self.statisticstimes[2],False)

                #finish time string
                st3 = self.stringfromseconds(self.statisticstimes[3],False)
                
                if self.statisticstimes[4]:
                    st4 = self.stringfromseconds(self.statisticstimes[4],False)
                else:
                    st4 = ""

                #calculate the positions for the statistics elements
                ydist = self.ylimit - self.ylimit_min
                statisticsbarheight = ydist/70

                if aw.qmc.legendloc in [1,2,9]:
                    # legend on top
                    statisticsheight = self.ylimit - (0.13 * ydist) # standard positioning
                else:
                    # legend not on top
                    statisticsheight = self.ylimit - (0.08 * ydist)

                if aw.qmc.mode == "C":
                    statisticsupper = statisticsheight + statisticsbarheight + 4
                    statisticslower = statisticsheight - 3.5*statisticsbarheight
                else:
                    statisticsupper = statisticsheight + statisticsbarheight + 10
                    statisticslower = statisticsheight - 2.5*statisticsbarheight

                if self.statisticsflags[1]:

                    #Draw cool phase rectangle
                    if self.timeindex[7]:
                        rect = patches.Rectangle((self.timex[self.timeindex[6]], statisticsheight), width = self.statisticstimes[4], height = statisticsbarheight,
                                                color = self.palette["rect4"],alpha=0.5)
                        self.ax.add_patch(rect)

                    if self.timeindex[2]: # only if FCs exists
                        #Draw finish phase rectangle
                        #check to see if end of 1C exists. If so, use half between start of 1C and end of 1C. Otherwise use only the start of 1C
                        rect = patches.Rectangle((self.timex[self.timeindex[2]], statisticsheight), width = self.statisticstimes[3], height = statisticsbarheight,
                                                color = self.palette["rect3"],alpha=0.5)
                        self.ax.add_patch(rect)

                        # Draw mid phase rectangle
                        rect = patches.Rectangle((self.timex[self.timeindex[0]]+self.statisticstimes[1], statisticsheight), width = self.statisticstimes[2], height = statisticsbarheight,
                                              color = self.palette["rect2"],alpha=0.5)
                        self.ax.add_patch(rect)

                    # Draw dry phase rectangle
                    rect = patches.Rectangle((self.timex[self.timeindex[0]], statisticsheight), width = self.statisticstimes[1], height = statisticsbarheight,
                                              color = self.palette["rect1"],alpha=0.5)
                    self.ax.add_patch(rect)

                if aw.qmc.LCDdecimalplaces:
                    fmtstr = "%.1f"
                else:
                    fmtstr = "%.0f" 
                if self.statisticstimes[0]:
                    dryphaseP = fmtstr%(self.statisticstimes[1]*100./self.statisticstimes[0])
                    midphaseP = fmtstr%(self.statisticstimes[2]*100./self.statisticstimes[0])
                    finishphaseP = fmtstr%(self.statisticstimes[3]*100./self.statisticstimes[0])
                else:
                    dryphaseP = " --- "
                    midphaseP = " --- "
                    finishphaseP = " --- "
                            
                #find Lowest Point in BT
                LP = 1000 
                if TP_index >= 0:
                    LP = self.temp2[TP_index]

                if self.statisticsflags[0]:
                    statsprop = aw.mpl_fontproperties.copy()
                    statsprop.set_size(11)
                    text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]/2.,statisticsupper,st1 + "  "+ dryphaseP+"%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                    try:
                        text.set_in_layout(False)
                    except:
                        pass
                    if self.timeindex[2]: # only if FCs exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticsupper,st2+ "  " + midphaseP+"%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticsupper,st3 + "  " + finishphaseP+ "%",color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+self.statisticstimes[4]/2.,statisticsupper,st4,color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass

                st1 = st2 = st3 = st4 = ""

                if self.statisticsflags[4] or self.statisticsflags[5]:
                    rates_of_changes = aw.RoR(TP_index,dryEndIndex)
                    if self.statisticsflags[4]:
                        st1 = st1 + "%.1f"%rates_of_changes[0] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None))
                        st2 = st2 + "%.1f"%rates_of_changes[1] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None))
                        st3 = st3 + "%.1f"%rates_of_changes[2] + aw.arabicReshape(aw.qmc.mode + QApplication.translate("Label", "/min",None))
                    if self.statisticsflags[5]:
                        if self.statisticsflags[4]:
                            st1 += u("  ")
                            st2 += u("  ")
                            st3 += u("  ")
                        _,_,ts1b,_ = aw.ts(self.timeindex[0],dryEndIndex,TP_index)
                        _,_,ts2b,_ = aw.ts(dryEndIndex,self.timeindex[2],TP_index)
                        _,_,ts3b,_ = aw.ts(self.timeindex[2],self.timeindex[6],TP_index)
                        st1 += u(ts1b) + u("C*min")
                        st2 += u(ts2b) + u("C*min")
                        st3 += u(ts3b) + u("C*min")

                if self.statisticsflags[4] or self.statisticsflags[5]:
                    #Write flavor estimation
                    statsprop = aw.mpl_fontproperties.copy()
                    statsprop.set_size(11)
                    text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]/2.,statisticslower,st1,color=self.palette["text"],ha="center",fontproperties=statsprop)
                    try:
                        text.set_in_layout(False)
                    except:
                        pass
                    if self.timeindex[2]: # only if FCs exists
                        text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]+self.statisticstimes[2]/2.,statisticslower,st2,color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass
                        text = self.ax.text(self.timex[self.timeindex[0]] + self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]/2.,statisticslower,st3,color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass
                    if self.timeindex[7]: # only if COOL exists
                        text = self.ax.text(self.timex[self.timeindex[0]]+ self.statisticstimes[1]+self.statisticstimes[2]+self.statisticstimes[3]+max(self.statisticstimes[4]/2.,self.statisticstimes[4]/3.),statisticslower,st4,color=self.palette["text"],ha="center",fontproperties=statsprop)
                        try:
                            text.set_in_layout(False)
                        except:
                            pass
            self.writecharacteristics(TP_index,LP)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " writestatistics() {0}").format(str(ex)),exc_tb.tb_lineno)

    #used in EventRecord()
    def restorebutton_11(self):
        aw.button_11.setDisabled(False)
        aw.button_11.setFlat(False)

    #called from markdryen(), markcharge(), mark1Cstart(), etc when using device 18 (manual mode)
    def drawmanual(self,et,bt,tx):
        self.timex.append(tx)
        self.temp1.append(et)
        if aw.qmc.ETcurve:
            self.l_temp1.set_data(self.timex, self.temp1)
        self.temp2.append(bt)
        if aw.qmc.BTcurve:
            self.l_temp2.set_data(self.timex, self.temp2)

    def movebackground(self,direction,step):
        lt = len(self.timeB)
        le = len(self.temp1B)
        lb = len(self.temp2B)
        #all background curves must have same dimension in order to plot. Check just in case.
        if lt > 1 and lt == le and lb == le:
            if  direction == "up":
                for i in range(lt):
                    self.temp1B[i] += step
                    self.temp2B[i] += step
                    self.stemp1B[i] += step
                    self.stemp2B[i] += step
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.stemp1BX[i][j] += step
                        self.stemp2BX[i][j] += step

            elif direction == "left":
                for i in range(lt):
                    self.timeB[i] -= step                    
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.extratimexB[i][j] -= step
                if self.TP_time_B > -1:
                    self.TP_time_B -= step
                                   
            elif direction == "right":
                for i in range(lt):
                    self.timeB[i] += step             
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.extratimexB[i][j] += step
                if self.TP_time_B > -1:
                    self.TP_time_B += step

            elif direction == "down":
                for i in range(lt):
                    self.temp1B[i] -= step
                    self.temp2B[i] -= step
                    self.stemp1B[i] -= step
                    self.stemp2B[i] -= step
                    
                for i in range(len(self.extratimexB)):
                    for j in range(len(self.extratimexB[i])):
                        self.stemp1BX[i][j] -= step
                        self.stemp2BX[i][j] -= step
        else:
            aw.sendmessage(QApplication.translate("Message","Unable to move background", None))
            return

    #points are used to draw interpolation
    def findpoints(self):
        #if profile found
        if self.timeindex[0] != -1:
            Xpoints = []                        #make temporary lists to hold the values to return
            Ypoints = []

            #start point from begining of time
            Xpoints.append(self.timex[0])
            Ypoints.append(self.temp2[0])
            #input beans (CHARGE)
            Xpoints.append(self.timex[self.timeindex[0]])
            Ypoints.append(self.temp2[self.timeindex[0]])

            #find indexes of lowest point and dryend
            LPind = aw.findTP()
            DE = aw.findDryEnd()

            if LPind < DE:
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
            else:
                Xpoints.append(self.timex[DE])
                Ypoints.append(self.temp2[DE])
                Xpoints.append(self.timex[LPind])
                Ypoints.append(self.temp2[LPind])
                
            if self.temp2[self.timeindex[1]] > self.timex[DE] and self.temp2[self.timeindex[1]] > self.timex[LPind]:
                Xpoints.append(self.timex[self.timeindex[1]])
                Ypoints.append(self.temp2[self.timeindex[1]])
            if self.timeindex[2]:
                Xpoints.append(self.timex[self.timeindex[2]])
                Ypoints.append(self.temp2[self.timeindex[2]])
            if self.timeindex[3]:
                Xpoints.append(self.timex[self.timeindex[3]])
                Ypoints.append(self.temp2[self.timeindex[3]])
            if self.timeindex[4]:
                Xpoints.append(self.timex[self.timeindex[4]])
                Ypoints.append(self.temp2[self.timeindex[4]])
            if self.timeindex[5]:
                Xpoints.append(self.timex[self.timeindex[5]])
                Ypoints.append(self.temp2[self.timeindex[5]])
            if self.timeindex[6]:
                Xpoints.append(self.timex[self.timeindex[6]])
                Ypoints.append(self.temp2[self.timeindex[6]])

            #end point
            if self.timex[self.timeindex[6]] != self.timex[-1]:
                Xpoints.append(self.timex[-1])
                Ypoints.append(self.temp2[-1])

            return Xpoints,Ypoints

        else:
            aw.sendmessage(QApplication.translate("Message","No finished profile found", None))
            return [],[]

    #collects info about the univariate interpolation
    def univariateinfo(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()  #from lowest point to avoid many coeficients
            equ = UnivariateSpline(Xpoints, Ypoints)
            coeffs = equ.get_coeffs().tolist()
            knots = equ.get_knots().tolist()
            resid = equ.get_residual()
            roots = equ.roots().tolist()

            #interpretation of coefficients: http://www.sagenb.org/home/pub/1708/
            #spline=[ans[0,i]+(x-xi)*(ans[1,i]+(x-xi)*(ans[2,i]+(x-xi)*ans[3,i]/3)/2) for i,xi in enumerate(a[:-1])]
            
            string = "<b>" + u(QApplication.translate("Message","Polynomial coefficients (Horner form):",
                                                    None)) + "</b><br><br>"
            string += str(coeffs) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Knots:",
                                                     None)) + "</b><br><br>"
            string += str(knots) + "<br><br>"
            string += "<b>" + u(QApplication.translate("Message","Residual:",
                                                     None)) + "</b><br><br>"
            string += str(resid) + "<br><br>"      
            string += "<b>" + u(QApplication.translate("Message","Roots:",
                                                     None)) + "</b><br><br>"
            string += str(roots)

            QMessageBox.information(aw,QApplication.translate("Message","Profile information",None),string)

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None) + " univariateinfo() {0}").format(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " univariateinfo() {0}").format(str(e)),exc_tb.tb_lineno)
            return

    def polyfit(self,xarray,yarray,deg,startindex,endindex,_=False):
        xa = xarray[startindex:endindex]
        ya = yarray[startindex:endindex]
        if len(xa) > 0 and len(xa) == len(ya) and not all(x == 0 for x in xa) and not all(x == 0 for x in ya):
            try:
                z = numpy.polyfit(xa,ya,deg)
                p = numpy.poly1d(z)
                x = p(xarray[startindex:endindex])
                pad = max(0,len(self.timex) - startindex - len(x))
                xx = numpy.append(numpy.append([None]*max(0,startindex), x), [None]*pad)
                if False: # deltacurvep and self.delta_ax:
                    self.delta_ax.plot(self.timex, xx, linestyle = '--', linewidth=3)
                else:
                    self.ax.plot(self.timex, xx, linestyle = '--', linewidth=3)
                self.fig.canvas.draw()
                return z
            except Exception:
                return None
        else:
            return None
    
    #ln() regression. ln() will be used when power does not equal 2 (quadratic) or 3 (cubic).
    def lnRegression(self,power=0, curvefit_starttime=0, curvefit_endtime=0, plot=True):
        res = ""
        try:
            from scipy.optimize import curve_fit
            if self.timeindex[0] > -1 and self.timeindex[6] > -1:  #CHARGE and DROP events exist
                charge = self.timex[self.timeindex[0]]
                if curvefit_starttime != None and curvefit_starttime > charge:
                    begin = aw.time2index(curvefit_starttime)
                    time_l = []
                    temp_l = []
                else:
                    #a = [charge] # not used!?
                    # find the DRY END point
                    if self.timeindex[1]: # take DRY if available
                        begin = self.timeindex[1]
                    else: # take DRY as specificed in phases
                        pi = aw.findDryEnd(phasesindex=1)
                        begin = aw.time2index(self.timex[pi])
                    # intial bean temp set to ambient
                    if aw.qmc.ambientTemp != None and aw.qmc.ambientTemp > 0:
                        time_l = [charge]
                        temp_l = [aw.qmc.ambientTemp]
                    else:
                        time_l = [charge]
                        if aw.qmc.mode == "F":
                            roomTemp = 70.0
                        else:
                            roomTemp = 21.0
                        temp_l = [roomTemp]
                if curvefit_endtime > 0:
                    end = aw.time2index(curvefit_endtime)
                else:
                    end = self.timeindex[6]
                time_l = time_l + self.timex[begin:end]
                temp_l = temp_l + self.temp2[begin:end]
                    
                xa = numpy.array(time_l) - charge
                yn = numpy.array(temp_l)
                if power == 2:
                    func = lambda x,a,b,c: a*x*x + b*x + c
                elif power == 3:
                    func = lambda x,a,b,c,d: a*x*x*x + b*x*x + c*x + d
                else:
                    func = lambda x,a,b,c: a * numpy.log(b*x+c)
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    popt,_ = curve_fit(func, xa, yn)
                #perr = numpy.sqrt(numpy.diag(pcov))
                if plot:
                    xb = numpy.array(self.timex)
                    xxb = xb + charge
                    xxa = xa + charge                                    
                    self.ax.plot(xxb, func(xb, *popt),  color="black", linestyle = '-.', linewidth=3)
                    self.ax.plot(xxa, yn, "ro")
                    self.fig.canvas.draw()
                if len(popt)>2:
                    if power == 2:
                        res = "%.8f * t*t %s %.8f * t %s %.8f" % (popt[0],("+" if popt[1] > 0 else ""),popt[1],("+" if popt[2] > 0 else ""),popt[2])
                    elif power ==3:
                        res = "%.8f * t*t*t %s %.8f * t*t %s %.8f * t %s %.8f" % (popt[0],("+" if popt[1] > 0 else ""),popt[1],("+" if popt[2] > 0 else ""),popt[2],("+" if popt[3] > 0 else ""),popt[3])
                    else:
                        res = "%.8f * log(%.8f * t %s %.8f, e)" % (popt[0],popt[1],("+" if popt[2] > 0 else ""),popt[2])
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message","Error in lnRegression:",None) + " lnRegression() " + str(e),exc_tb.tb_lineno)
            if power == 2:
                fit = QApplication.translate("Label","x",None) +"\u00b2"
            elif power == 3:
                fit = QApplication.translate("Label","x",None) +"\u00b3"
            else:
                fit = QApplication.translate("Label","ln()",None)
            QMessageBox.warning(aw,QApplication.translate("Message","Curve fit problem", None),
                    QApplication.translate("Message","Cannot fit this curve to " + fit, None))
        return res

    #interpolation type
    def univariate(self):
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            Xpoints,Ypoints = self.findpoints()

            func = UnivariateSpline(Xpoints, Ypoints)

            xa = numpy.array(self.timex)
            newX = func(xa).tolist()

            self.ax.plot(self.timex, newX, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError:
            aw.qmc.adderror(QApplication.translate("Error Message","Value Error:",None) + " univariate()")

        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None) + " univariate() " + str(e),exc_tb.tb_lineno)
            return

    def drawinterp(self,mode):
        try:
            #pylint: disable=E1101
            from scipy import interpolate as inter
            Xpoints,Ypoints = self.findpoints() #from 0 origin
            func = inter.interp1d(Xpoints, Ypoints, kind=mode)
            newY = func(self.timex)
            self.ax.plot(self.timex, newY, color="black", linestyle = '-.', linewidth=3)
            self.ax.plot(Xpoints, Ypoints, "ro")

            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:",None) + " drawinterp() {0}").format(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " drawinterp() {0}").format(str(e)),exc_tb.tb_lineno)
            return

    # calculates the (interpolated) temperature from the given time/temp arrays at timepoint "seconds"
    def timetemparray2temp(self,timearray,temparray,seconds):
        if timearray and temparray and len(timearray) and len(temparray) and len(timearray) == len(temparray):
            if seconds > timearray[-1] or seconds < timearray[0]:
                # requested timepoint out of bonds
                return -1
            else:
                # compute the closest index (left sided)
                i = numpy.searchsorted(timearray,seconds,side='left')
                ti = timearray[i]
                tempi = temparray[i]
                if i < len(timearray) - 1:
                    j = i - 1
                    tj = timearray[j]
                    tempj = temparray[j]
                    s = (tempi - tempj) / (ti - tj)
                    return tempj + s*(seconds - tj)
                else:
                    # should not be reached (guarded by the outer if)
                    return tempi
        else:
            return -1
            
    # if smoothed=True, the smoothed data is taken if available
    # if relative=True, the given time in seconds is interpreted relative to CHARGE, otherwise absolute from the first mesasurement
    def BTat(self,seconds,smoothed=True,relative=False):
        if smoothed and self.stemp2 and self.stemp2 != []:
            temp = self.stemp2
        else:
            temp = self.temp2
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)
        
    def ETat(self,seconds,smoothed=True,relative=False):
        if smoothed and self.stemp1 and self.stemp1 != []:
            temp = self.stemp1
        else:
            temp = self.temp1
        if self.timeindex[0] > -1 and relative:
            offset = self.timex[self.timeindex[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timex,temp,seconds + offset)
        
    def backgroundBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp2B,seconds + offset)
        
    def backgroundSmoothedBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.stemp2B,seconds + offset)
        
    def backgroundETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.temp1B,seconds + offset)
        
    def backgroundSmoothedETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.stemp1B,seconds + offset)

    def backgroundDBTat(self,seconds, relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta2B,seconds + offset)
        
    def backgroundDETat(self,seconds,relative=False):
        if self.timeindexB[0] > -1 and relative:
            offset = self.timeB[self.timeindexB[0]]
        else:
            offset = 0
        return self.timetemparray2temp(self.timeB,self.delta1B,seconds + offset)

    def timearray2index(self,timearray,seconds):
        #find where given seconds crosses timearray
        if len(timearray):                           #check that timearray is not empty just in case
            #if input seconds longer than available time return last index
            if  seconds > timearray[-1]:
                return int(len(timearray)-1)
            #if given input seconds smaller than first time return first index
            if seconds < timearray[0]:
                return 0
            i = numpy.searchsorted(timearray,seconds,side='left')
            if i < len(timearray) - 1:
                #look around (check if the value of the next index is closer
                choice1 = abs(timearray[i] - seconds)
                choice2 = abs(timearray[i-1] - seconds)
                #return closest (smallest) index
                if choice2 < choice1:
                    i = i - 1
            return int(i)
        else:
            return -1

    #selects closest time INDEX in self.timex from a given input float seconds
    def time2index(self,seconds):
        #find where given seconds crosses self.timex
        return self.timearray2index(self.timex,seconds)

    #selects closest time INDEX in self.timeB from a given input float seconds
    def backgroundtime2index(self,seconds):
        #find where given seconds crosses self.timeB
        return self.timearray2index(self.timeB,seconds)

    #updates list self.timeindex when found an _OLD_ profile without self.timeindex (new version)
    def timeindexupdate(self,times):
##        #          START            DRYEND          FCs             FCe         SCs         SCe         DROP
##        times = [self.startend[0],self.dryend[0],self.varC[0],self.varC[2],self.varC[4],self.varC[6],self.startend[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindex[i] = self.time2index(times[i])
            else:
                self.timeindex[i] = 0

    #updates list self.timeindexB when found an _OLD_ profile without self.timeindexB 
    def timebackgroundindexupdate(self,times):
##        #          STARTB            DRYENDB          FCsB       FCeB         SCsB         SCeB               DROPB
##        times = [self.startendB[0],self.dryendB[0],self.varCB[0],self.varCB[2],self.varCB[4],self.varCB[6],self.startendB[2]]
        for i in range(len(times)):               
            if times[i]:
                self.timeindexB[i] = self.backgroundtime2index(times[i])
            else:
                self.timeindexB[i] = 0

    
    #adds errors (can be called also outside the GUI thread, eg. from the sampling thread as actuall message is written by updategraphics in the GUI thread)
    def adderror(self,error,line=None):
        try:
            #### lock shared resources #####
            aw.qmc.errorsemaphore.acquire(1)
            timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
            #keep a max of 500 errors
            if len(self.errorlog) > 499:
                self.errorlog = self.errorlog[1:]
            if line:
                error = error + "@line " + str(line)
            self.errorlog.append(timez + " " + error)
            # truncate to first line for window message line
            try:
                # only show first line in 
                error = error.splitlines()[0]
            except:
                pass
            if self.flagon: # don't send message here, but cache it and send it from updategraphics from within the GUI thread
                self.temporary_error = error
            else:
                aw.sendmessage(error) 
        except Exception:
            pass
        finally:
            if aw.qmc.errorsemaphore.available() < 1:
                aw.qmc.errorsemaphore.release(1)

    ####################  PROFILE DESIGNER   ###################################################################################
    #launches designer
    def designer(self):
        #disconnect mouse cross if ON
        if self.crossmarker:
            self.togglecrosslines()
        #clear background if it came from analysis
        if len(aw.qmc.analysisresultsstr) > 0:
            aw.deleteBackground()

        if len(self.timex):
            reply = QMessageBox.question(aw,QApplication.translate("Message","Designer Start",None),
                                         QApplication.translate("Message","Importing a profile in to Designer will decimate all data except the main [points].\nContinue?",None),
                                         QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Yes:
                res = self.initfromprofile()
                if res:
                    self.connect_designer()
                    aw.disableEditMenus(designer=True)
                    self.redraw(True)
                else:
                    aw.designerAction.setChecked(False)
            elif reply == QMessageBox.Cancel:
                aw.designerAction.setChecked(False)
        else:
            #if no profile found
            #                
            # reset also the special event copy held for the designer
            self.eventtimecopy = []
            self.specialeventsStringscopy = []
            self.specialeventsvaluecopy = []
            self.specialeventstypecopy = []
            #
            self.reset(redraw=False,soundOn=False)
            self.connect_designer()
            self.designerinit()
            aw.disableEditMenus(designer=True)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def savepoints(self,_=False):
        try:
            filename = aw.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Points",None),ext="*.adsg")
            if filename:
                obj = {}
                obj["timex"] = self.timex
                obj["temp1"] = self.temp1
                obj["temp2"] = self.temp2
                obj["timeindex"] = self.timeindex
                f = codecs.open(u(filename), 'w+', encoding='utf-8')
                f.write(repr(obj))
                f.close()
                aw.sendmessage(QApplication.translate("Message","Points saved", None))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " savepoints() {0}").format(str(e)),exc_tb.tb_lineno)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def loadpoints(self,_=False):
        try:
            filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message", "Load Points",None),ext="*.adsg")
            obj = None
            if os.path.exists(u(filename)):
                f = codecs.open(u(filename), 'rb', encoding='utf-8')
                obj=ast.literal_eval(f.read())
                f.close()
            if obj and "timex" in obj and "temp1" in obj and "temp2" in obj:
                self.timex = obj["timex"]
                self.temp1 = obj["temp1"]
                self.temp2 = obj["temp2"]
                self.timeindex = obj["timeindex"]
                self.xaxistosm(redraw=False)
                self.redrawdesigner()
                aw.sendmessage(QApplication.translate("Message","Points loaded", None))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " loadpoints() {0}").format(str(e)),exc_tb.tb_lineno)
            

    #used to start designer from scratch (not from a loaded profile)
    def designerinit(self):
        #init start vars        #CH, DE,      Fcs,      Fce,       Scs,         Sce,         Drop,      COOL
        self.designertimeinit = [0,(5*60),(8*60),(10*60),(10.5*60),(11.5*60),(12*60),(16*60)]
        if self.mode == "C":
            self.designertemp1init = [290.,290.,290.,290.,290.,290.,290.,290.]   #CHARGE,DE,FCs,FCe,SCs,SCe,Drop
            self.designertemp2init = [230.,150.,190.,210.,220.,225.,230.,230.]   #CHARGE,DE,FCs,FCe,SCs,SCe,DROP
        elif self.mode == "F":
            self.designertemp1init = [500.,500.,500.,500.,500.,500.,500.,500.]
            self.designertemp2init = [440.,300.,385.,410.,430.,445.,460.,460.]
        
        #check x limits
        #if self.endofx < 960:
        #    self.endofx = 960
        #    self.redraw()
    
        self.timex,self.temp1,self.temp2 = [],[],[]
        for i in range(len(self.timeindex)):
            self.timex.append(self.designertimeinit[i])
            self.temp1.append(self.designertemp1init[i])
            self.temp2.append(self.designertemp2init[i])
            self.timeindex[i] = i
    
        self.xaxistosm(redraw=False)
        self.redrawdesigner()

    #loads main points from a profile so that they can be edited
    def initfromprofile(self):
        if self.timeindex[0] == -1 or self.timeindex[6] == 0:
            QMessageBox.information(aw,QApplication.translate("Message","Designer Init",None),
                                    QApplication.translate("Message","Unable to start designer.\nProfile missing [CHARGE] or [DROP]",None))
            self.disconnect_designer()
            return False

        #save events. They will be deleted on qmc.reset()
        self.specialeventsStringscopy = self.specialeventsStrings[:]
        self.specialeventsvaluecopy = self.specialeventsvalue[:]
        self.specialeventstypecopy = self.specialeventstype[:]
        self.eventtimecopy = []
        for i in range(len(self.specialevents)):
            #save relative time of events
            self.eventtimecopy.append(self.timex[self.specialevents[i]]-self.timex[self.timeindex[0]])

        #find lowest point from profile to be converted
        lpindex = aw.findTP()
        if lpindex != -1 and not lpindex in self.timeindex:
            lptime = self.timex[lpindex]
            lptemp2 = self.temp2[lpindex]
            # we only consider TP if its BT is at least 20 degrees lower than the CHARGE temperature
            if self.temp2[self.timeindex[0]] < (lptemp2 + 20):
                lpindex = -1
        else:
            lpindex = -1

        timeindexhold = [self.timex[self.timeindex[0]],0,0,0,0,0,0,0]
        timez,t1,t2 = [self.timex[self.timeindex[0]]],[self.temp1[self.timeindex[0]]],[self.temp2[self.timeindex[0]]]    #first CHARGE point
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:                           # fill up empty lists with main points (FCs, etc). match from timeindex
                timez.append(self.timex[self.timeindex[i]])  #add time
                t1.append(self.temp1[self.timeindex[i]])    #add temp1
                t2.append(self.temp2[self.timeindex[i]])    #add temp2
                timeindexhold[i] =  self.timex[self.timeindex[i]]

        self.reset()                                            #erase screen

        self.timex,self.temp1,self.temp2 = timez[:],t1[:],t2[:]  #copy lists back after reset() with the main points

        self.timeindexupdate(timeindexhold) #create new timeindex[]

        #add lowest point as extra point
        if lpindex != -1:
            self.currentx = lptime
            self.currenty = lptemp2
            self.addpoint(manual=False)

        self.xaxistosm(redraw=False)
        self.redrawdesigner()                                   #redraw the designer screen
        return True

    #redraws designer
    def redrawdesigner(self):
        if aw.qmc.designerflag:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #reset (clear) plot
            if self.delta_ax is not None:
                self.delta_ax.lines = []
            self.ax.lines = []
            
            fontprop_medium = aw.mpl_fontproperties.copy()
            fontprop_medium.set_size("medium")
            self.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "Designer",None)),color = self.palette["xlabel"],fontproperties=fontprop_medium)
            
            #draw background
            if self.background: 
                self.ax.plot(self.timeB, self.stemp1B,markersize=self.ETbackmarkersize,marker=self.ETbackmarker,
                                                sketch_params=None,path_effects=[],
                                                linewidth=self.ETbacklinewidth,linestyle=self.ETbacklinestyle,drawstyle=self.ETbackdrawstyle,color=self.backgroundmetcolor,
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundET", None)))
                self.ax.plot(self.timeB, self.stemp2B,markersize=self.BTbackmarkersize,marker=self.BTbackmarker, 
                                                linewidth=self.BTbacklinewidth,linestyle=self.BTbacklinestyle,drawstyle=self.BTbackdrawstyle,color=self.backgroundbtcolor,
                                                sketch_params=None,path_effects=[],
                                                alpha=self.backgroundalpha,label=aw.arabicReshape(QApplication.translate("Label", "BackgroundBT", None)))
            
            #create statistics bar
            #calculate the positions for the statistics elements
            ydist = self.ylimit - self.ylimit_min
            statisticsheight = self.ylimit - (0.13 * ydist)

            #add statistics bar
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[1]]],[statisticsheight,statisticsheight],color = self.palette["rect1"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[2]]],[statisticsheight,statisticsheight],color = self.palette["rect2"],alpha=.5,linewidth=5)
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[6]]],[statisticsheight,statisticsheight],color = self.palette["rect3"],alpha=.5,linewidth=5)

            #add phase division lines
            ylist = [self.ylimit,0]
            self.ax.plot([self.timex[self.timeindex[0]],self.timex[self.timeindex[0]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[1]],self.timex[self.timeindex[1]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[2]],self.timex[self.timeindex[2]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")
            self.ax.plot([self.timex[self.timeindex[6]],self.timex[self.timeindex[6]]],ylist,color = self.palette["grid"],alpha=.3,linewidth=3,linestyle="--")

            if self.timex[-1] > self.endofx:
                self.endofx = self.timex[-1] + 120
                self.xaxistosm()

            if self.BTsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.BTsplinedegree = len(self.timex)-1

            if self.ETsplinedegree >= len(self.timex):  #max 5 or less. Cannot biger than points
                self.ETsplinedegree = len(self.timex)-1

            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            func = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            btvals = func(timez).tolist()
            func2 = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)
            etvals = func2(timez).tolist()
            #convert all time values to temperature


            rcParams['path.sketch'] = (0,0,0)
            
            if (self.DeltaBTflag or self.DeltaETflag) and self.delta_ax is not None:
                trans = self.delta_ax.transData #=self.delta_ax.transScale + (self.delta_ax.transLimits + self.delta_ax.transAxes)
            if self.DeltaBTflag:
                funcDelta = func.derivative()
                deltabtvals = [x*60 for x in funcDelta(timez).tolist()]
                self.ax.plot(timez,deltabtvals,transform=trans,markersize=self.BTdeltamarkersize,marker=self.BTdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.BTdeltalinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
                    linewidth=self.BTdeltalinewidth,linestyle=self.BTdeltalinestyle,drawstyle=self.BTdeltadrawstyle,color=self.palette["deltabt"],
                    label=aw.arabicReshape(deltaLabelPrefix + QApplication.translate("Label", "BT", None)))
                    
            if self.DeltaETflag:
                funcDelta2 = func2.derivative()
                deltaetvals = [x*60 for x in funcDelta2(timez).tolist()]
                self.ax.plot(timez,deltaetvals,transform=trans,markersize=self.ETdeltamarkersize,marker=self.ETdeltamarker,
                    sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.ETdeltalinewidth+aw.qmc.patheffects,foreground=self.palette["background"])],
                    linewidth=self.ETdeltalinewidth,linestyle=self.ETdeltalinestyle,drawstyle=self.ETdeltadrawstyle,color=self.palette["deltaet"],
                    label=aw.arabicReshape(deltaLabelPrefix + QApplication.translate("Label", "ET", None)))                          
            
            #add curves
            if self.ETcurve:
                self.ax.plot(timez, etvals,markersize=self.ETmarkersize,marker=self.ETmarker,linewidth=self.ETlinewidth,
                    linestyle=self.ETlinestyle,drawstyle=self.ETdrawstyle,color=self.palette["et"],
                        label=u(QApplication.translate("Label", "ET", None)))
            if self.BTcurve:
                self.ax.plot(timez, btvals, markersize=self.BTmarkersize,marker=self.BTmarker,linewidth=self.BTlinewidth,
                    linestyle=self.BTlinestyle,drawstyle=self.BTdrawstyle,color=self.palette["bt"],
                        label=u(QApplication.translate("Label", "BT", None)))

            #add markers (big circles) '0'
            if self.ETcurve:
                self.ax.plot(self.timex,self.temp1,color = self.palette["et"],marker = "o",picker=10,linestyle='',markersize=8)
            if self.BTcurve:
                self.ax.plot(self.timex,self.temp2,color = self.palette["bt"],marker = "o",picker=10,linestyle='',markersize=8)     #picker = 10 means 10 points tolerance

        
            #plot
            self.fig.canvas.draw()

    #CONTEXT MENU  = Right click
    def on_press(self,event):
        
        if event.inaxes != self.ax: return
        if event.button != 3: return   #select right click only
        

        self.releaseMouse()
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

        self.currentx = event.xdata
        self.currenty = event.ydata

        designermenu = QMenu(aw)  # if we bind this to self, we inherit the background-color: transparent from self.fig

        designermenu.addSeparator()

        addpointAction = QAction(QApplication.translate("Contextual Menu", "Add point",None),self)
        addpointAction.triggered.connect(self.addpoint_action)
        designermenu.addAction(addpointAction)

        removepointAction = QAction(QApplication.translate("Contextual Menu", "Remove point",None),self)
        removepointAction.triggered.connect(self.removepoint)
        designermenu.addAction(removepointAction)

        designermenu.addSeparator()

        loadpointsAction = QAction(QApplication.translate("Contextual Menu", "Load points",None),self)
        loadpointsAction.triggered.connect(self.loadpoints)
        designermenu.addAction(loadpointsAction)
        
        savepointsAction = QAction(QApplication.translate("Contextual Menu", "Save points",None),self)
        savepointsAction.triggered.connect(self.savepoints)
        designermenu.addAction(savepointsAction)
        
        designermenu.addSeparator()

        resetAction = QAction(QApplication.translate("Contextual Menu", "Reset Designer",None),self)
        resetAction.triggered.connect(self.reset_designer)
        designermenu.addAction(resetAction)

        configAction = QAction(QApplication.translate("Contextual Menu", "Config...",None),self)
        configAction.triggered.connect(self.desconfig)
        designermenu.addAction(configAction)

        designermenu.exec_(QCursor.pos())

    def on_pick(self,event):
        if self.currentx or self.currenty:
            self.currentx = 0
            self.currenty = 0
            return
        
        self.setCursor(Qt.ClosedHandCursor)

        if isinstance(event.ind, (int)):
            self.indexpoint = event.ind
        else:
            N = len(event.ind)
            if not N: return
            self.indexpoint = event.ind[0]
        
        self.mousepress = True

        line = event.artist
        #identify which line is being edited
        ydata = line.get_ydata()
        if ydata[1] == self.temp1[1]:
            self.workingline = 1
        else:
            self.workingline = 2

    #handles when releasing mouse
    def on_release(self,_):
        self.mousepress = False
        self.setCursor(Qt.OpenHandCursor)

    #handler for moving point
    def on_motion(self,event):
        if not event.inaxes: return
        
        ydata = event.ydata
        
        try:
            if self.mousepress:                                 #if mouse clicked
                
                self.timex[self.indexpoint] = event.xdata
                if self.workingline == 1:
                    self.temp1[self.indexpoint] = ydata
                else:
                    self.temp2[self.indexpoint] = ydata

                #check point going over point
                #check to the left    
                if self.indexpoint > 0:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint - 1]) < 10.:
                        self.unrarefy_designer()
                        return
                #check to the right
                if self.indexpoint <= len(self.timex)-2:
                    if abs(self.timex[self.indexpoint] - self.timex[self.indexpoint + 1]) < 10.:
                        self.unrarefy_designer()
                        return

                #check for possible CHARGE time moving
                if self.indexpoint == self.timeindex[0]:
                    self.xaxistosm(redraw=False)

                #redraw
                self.redrawdesigner()
                return

            if type(event.xdata):                       #outside graph type is None
                for i in range(len(self.timex)):
                    if abs(event.xdata - self.timex[i]) < 7.:
                        if i in self.timeindex:
                            if abs(self.temp2[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "orange",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            index = self.timeindex.index(i)
                            if index == 0:
                                timez = self.stringfromseconds(0)
                                aw.sendmessage(u(QApplication.translate("Message", "[ CHARGE ]",None)) + " " + timez, style="background-color:'#f07800';")
                            elif index == 1:
                                timez = self.stringfromseconds(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ DRY END ]",None)) + " " + timez, style="background-color:'orange';")
                            elif index == 2:
                                timez = self.stringfromseconds(self.timex[self.timeindex[2]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ FC START ]",None)) + " " + timez, style="background-color:'orange';")
                            elif index == 3:
                                timez = self.stringfromseconds(self.timex[self.timeindex[3]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ FC END ]",None)) + " " + timez, style="background-color:'orange';")
                            elif index == 4:
                                timez = self.stringfromseconds(self.timex[self.timeindex[4]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ SC START ]",None)) + " " + timez, style="background-color:'orange';")
                            elif index == 5:
                                timez = self.stringfromseconds(self.timex[self.timeindex[5]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ SC END ]",None)) + " " + timez, style="background-color:'orange';")
                            elif index == 6:
                                timez = self.stringfromseconds(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                                aw.sendmessage(u(QApplication.translate("Message", "[ DROP ]",None)) + " " + timez, style="background-color:'#f07800';")
                            break
                        else:
                            if abs(self.temp2[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp2[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            elif abs(self.temp1[i] - ydata) < 10:
                                self.ax.plot(self.timex[i],self.temp1[i],color = "blue",marker = "o",alpha = .3,markersize=30)
                                self.fig.canvas.draw()
                                QTimer.singleShot(600, self.redrawdesigner)
                            timez = self.stringfromseconds(self.timex[i] - self.timex[self.timeindex[0]])
                            aw.sendmessage(timez,style="background-color:'lightblue';")
                            break
                    else:
                        totaltime = aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[0]])
                        dryphasetime = aw.float2float(self.timex[self.timeindex[1]] - self.timex[self.timeindex[0]])
                        midphasetime = aw.float2float(self.timex[self.timeindex[2]] - self.timex[self.timeindex[1]])
                        finishphasetime = aw.float2float(self.timex[self.timeindex[6]] - self.timex[self.timeindex[2]])

                        if totaltime:
                            dryphaseP = int(round(dryphasetime*100./totaltime))
                            midphaseP = int(round(midphasetime*100./totaltime))
                            finishphaseP = int(round(finishphasetime*100./totaltime))
                        else:
                            return

#                        dryramp = self.temp2[self.timeindex[1]] - self.temp2[self.timeindex[0]] # ML: unused
                        midramp = self.temp2[self.timeindex[2]] - self.temp2[self.timeindex[1]]
                        finishramp = self.temp2[self.timeindex[6]] - self.temp2[self.timeindex[2]]

                        ts1,_,_,_ = aw.ts(self.timeindex[0],self.timeindex[1])
                        ts2,_,_,_ = aw.ts(self.timeindex[1],self.timeindex[2])
                        ts3,_,_,_ = aw.ts(self.timeindex[2],self.timeindex[6])
                        etbt1 = "%i"%(ts1)
                        etbt2 = "%i"%(ts2)
                        etbt3 = "%i"%(ts3)

                        min_bt,time_min_bt = self.findTPdes()
                        dryrampTP = self.temp2[self.timeindex[1]] - min_bt
                        dryphasetimeTP = self.timex[self.timeindex[1]] - time_min_bt

                        if dryphasetimeTP:
                            dryroc = (" %.1f " + aw.qmc.mode + "/min")%((dryrampTP/dryphasetimeTP)*60.)
                        else:
                            dryroc = " 0 " + aw.qmc.mode + "/min"

                        if midphasetime:
                            midroc = (" %.1f " + aw.qmc.mode + "/min")%((midramp/midphasetime)*60.)
                        else:
                            midroc = " 0 " + aw.qmc.mode + "/min"

                        if finishphasetime:
                            finishroc = (" %.1f " + aw.qmc.mode + "/min")%((finishramp/finishphasetime)*60.)
                        else:
                            finishroc = 0

                        margin = "&nbsp;&nbsp;&nbsp;"
                        string1 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect1"],
                                  margin,self.stringfromseconds(dryphasetime),margin, dryphaseP, margin,dryroc,margin,etbt1,margin)
                        string2 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect2"],
                                  margin,self.stringfromseconds(midphasetime),margin,midphaseP,margin,midroc,margin,etbt2,margin)
                        string3 = " <font color = \"white\" style=\"BACKGROUND-COLOR: %s\">%s %s %s %i%% %s %s %s %s %s</font>"%(self.palette["rect3"],
                                  margin,self.stringfromseconds(finishphasetime),margin,finishphaseP,margin,finishroc,margin,etbt3,margin)
                        aw.sendmessage(string1+string2+string3)

        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " on_motion() {0}").format(str(e)),exc_tb.tb_lineno)
            self.unrarefy_designer()
            return

    def findTPdes(self):
        try:
            from scipy.interpolate import UnivariateSpline
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()
            btvals = funcBT(timez).tolist()
            min_bt = min(btvals)
            idx_min_bt = btvals.index(min_bt)
            time_min_bt = timez[idx_min_bt]
            return min_bt, time_min_bt

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " findTPdes() {0}").format(str(e)),exc_tb.tb_lineno)
            return 

    #this is used in on_motion() to try to prevent points crossing over points
    def unrarefy_designer(self):
        for i in range(len(self.timex)-1):
            if abs(self.timex[i]-self.timex[i+1]) < 20:
                self.timex[i+1] = self.timex[i] + 20
            self.disconnect_designer()
            self.connect_designer()

    @pyqtSlot()
    @pyqtSlot(bool)
    def addpoint_action(self,_=False):
        self.addpoint()

    def addpoint(self,manual=True):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            if manual:
                # open a dialog to let the user correct the input
                offset = 0
                if self.timeindex[0] > -1:
                    offset = self.timex[self.timeindex[0]]
                values = [self.currentx-offset, self.currenty]
                dlg = pointDlg(parent=aw,values = values)
                if dlg.exec_():
                    self.currentx = values[0] + offset
                    self.currenty = values[1]
                else:
                    return


            if self.currentx > self.timex[-1]:       #if point is beyond max timex (all the way to the right)
            
                #find closest line
                d1 = abs(self.temp1[-1] - self.currenty)
                d2 = abs(self.temp2[-1] - self.currenty)
                if d2 < d1:
                    self.temp2.append(self.currenty)
                    self.temp1.append(self.temp1[-1])
                else:
                    self.temp2.append(self.temp2[-1])
                    self.temp1.append(self.currenty)
                    
                self.timex.append(self.currentx)
                #no need to update time index

                self.redrawdesigner()
                return 0

            elif self.currentx < self.timex[0]:         #if point is bellow min timex (all the way to the left)
                #find closest line
                d1 = abs(self.temp1[0] - self.currenty)
                d2 = abs(self.temp2[0] - self.currenty)
                if d2 < d1:
                    self.temp2.insert(0,self.currenty)
                    self.temp1.insert(0,self.temp1[0])
                else:
                    self.temp2.insert(0,self.temp2[0])
                    self.temp1.insert(0,self.currenty)

                self.timex.insert(0,self.currentx)

                #update timeindex
                if self.timeindex[0] != -1:   #we update timeindex[0] different
                    self.timeindex[0] += 1
                for u in range(1,len(self.timeindex)):
                    if self.timeindex[u]:
                        self.timeindex[u] += 1

                self.redrawdesigner()
                return len(self.timex)-1   #return index received from Designer Dialog Config to asign index to timeindex)

            else:                                           #mid range
                #find index
                for i in range(len(self.timex)):
                    if self.timex[i] > self.currentx:
                        break
                #find closest line
                d1 = abs(self.temp1[i] - self.currenty)
                d2 = abs(self.temp2[i] - self.currenty)
                if (d2 < d1 or self.temp1[i] == -1) and self.temp2[i] != -1:
                    self.temp2.insert(i,self.currenty)
                    self.temp1.insert(i,self.temp1[i])
                elif self.temp1[i] != -1:
                    self.temp2.insert(i,self.temp2[i])
                    self.temp1.insert(i,self.currenty)
                if not (self.temp1[i] == -1 and self.temp2[i] == -1):
                    self.timex.insert(i,self.currentx)

                    #update timeindex
                    for x in range(len(self.timeindex)):
                        if self.timeindex[x] >= i:
                            self.timeindex[x] += 1

                self.redrawdesigner()
                return i
                

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " addpoint() {0}").format(str(e)),exc_tb.tb_lineno)
            return 

    #removes point
    @pyqtSlot()
    @pyqtSlot(bool)
    def removepoint(self,_=False):
        try:
            #current x, and y is obtained when doing right click in mouse: on_press()
            #find index
            for i in range(len(self.timex)):
                if self.timex[i] > self.currentx:
                    break
            #find closest point
            if abs(self.timex[i]- self.currentx) < abs(self.timex[i-1] - self.currentx):
                index = i
            else:
                index = i-1

            #check if if it is a landmark point
            if index in self.timeindex:
                whichone = self.timeindex.index(index)
                if whichone == 0 or whichone == 6:  #if charge or drop
                    return
                self.timeindex[whichone] = 0

            self.timex.pop(index)
            self.temp1.pop(index)
            self.temp2.pop(index)

            for x in range(len(self.timeindex)):
                if self.timeindex[x] > index: #decrease time index by one when above the index taken out
                    self.timeindex[x] -= 1

            self.redrawdesigner()

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " removepoint() {0}").format(str(e)),exc_tb.tb_lineno)
            return

    #finds a proper index location for a time that does not exists yet.
    def designerfindindex(self,time):
        if time < aw.qmc.timex[0]:
            return 0
        elif time > aw.qmc.timex[-1]:
            return len(aw.qmc.timex)-1
        else:
            for i in range(len(aw.qmc.timex)):
                if time == aw.qmc.timex[i]:
                    return i
                if aw.qmc.timex[i] > time:
                    return i-1

    #converts from a designer profile to a normal profile
    def convert_designer(self): 
        try:
            #pylint: disable=E0611
            from scipy.interpolate import UnivariateSpline
            #prevents accidentally deleting a modified profile.
            self.fileDirty()
            #create functions
            funcBT = UnivariateSpline(self.timex,self.temp2, k = self.BTsplinedegree)
            funcET = UnivariateSpline(self.timex,self.temp1, k = self.ETsplinedegree)

            #create longer list of time values
            timez = numpy.arange(self.timex[0],self.timex[-1],1).tolist()

            #convert all time values to temperature
            btvals = funcBT(timez).tolist()
            etvals = funcET(timez).tolist()

            #find new indexes for events
            for i in range(len(self.specialevents)):
                for p in range(len(timez)):
                    if timez[p] > self.timex[self.specialevents[i]]:
                        self.specialevents[i] = p
                        break

            #save landmarks
            maintimes = []
            for i in range(len(self.timeindex)):
                maintimes.append(self.timex[self.timeindex[i]])

            self.timex = timez[:]
            self.temp1 = etvals[:]
            self.temp2 = btvals[:]

            self.timeindexupdate(maintimes)

            #check and restore carried over events
            if len(self.eventtimecopy):
                for i in range(len(self.eventtimecopy)):
                    self.specialevents.append(self.time2index(self.eventtimecopy[i] + self.timex[self.timeindex[0]]))
                self.specialeventsStrings = self.specialeventsStringscopy[:]
                self.specialeventsvalue = self.specialeventsvaluecopy[:]
                self.specialeventstype = self.specialeventstypecopy[:]

            #check for extra devices
            num = len(self.timex)
            for i in range(len(self.extradevices)):
                self.extratemp1[i] = [-1.]*num
                self.extratemp2[i] = [-1.]*num
                self.extratimex[i] = self.timex[:]
                
            if self.profile_sampling_interval is None:
                self.profile_sampling_interval = self.delay / 1000.

            self.disconnect_designer()

            #create playback events
            if self.reproducedesigner:
                functioncall = [0,
                                self.designer_create_BT_rateofchange,
                                self.designer_create_ET_rateofchange,
                                self.designer_create_sv_command,
                                self.designer_create_ramp_command]

                functioncall[self.reproducedesigner]()

            self.redraw()
            aw.sendmessage(QApplication.translate("Message", "New profile created",None))

        except ValueError:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(QApplication.translate("Error Message", "Value Error:",None) + " createFromDesigner()",exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " createFromDesigner() {0}").format(str(e)),exc_tb.tb_lineno)
            return

    #activates mouse events
    def connect_designer(self):
        if not self.designerflag:
            self.designerflag = True
            aw.designerAction.setChecked(True)
            self.setCursor(Qt.OpenHandCursor)
            self.mousepress = None
            #create mouse events. Note: keeping the ids inside a list helps protect against extrange python behaviour.
            self.designerconnections = [None,None,None,None]
            self.designerconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.on_pick) 
            self.designerconnections[1] = self.fig.canvas.mpl_connect('button_release_event', self.on_release)
            self.designerconnections[2] = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
            self.designerconnections[3] = self.fig.canvas.mpl_connect('button_press_event', self.on_press) #right click
            #this is needed to prevent complaints from UnivariateSpline() -used in redraw()- in extreme cases of difficulty
            warnings.simplefilter('ignore', UserWarning)

    #deactivates mouse events
    def disconnect_designer(self):
        self.designerflag = False
        aw.designerAction.setChecked(False)
        for i in range(len(self.designerconnections)):
            if self.designerconnections[i] is not None:
                self.fig.canvas.mpl_disconnect(self.designerconnections[i])
        self.setCursor(Qt.ArrowCursor)
        warnings.simplefilter('default', UserWarning)

    #launches designer config Window
    @pyqtSlot()
    @pyqtSlot(bool)
    def desconfig(self,_=False):
        dialog = designerconfigDlg(aw)
        dialog.show()
        dialog.setFixedSize(dialog.size())

    @pyqtSlot()
    @pyqtSlot(bool)
    def reset_designer(self,_=False):
        self.reset()
        self.disconnect_designer()
        self.connect_designer()
        self.designerinit()

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_BT_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp2[self.timeindex[i]] - self.temp2[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "BT {0} {1}/min for {2}",None).format("%.1f"%(difftemp/difftime),aw.qmc.mode,self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    #saves next BT rate of change till next landmark as an event (example idea for arduino TC4)
    def designer_create_ET_rateofchange(self):
        self.deleteEvents()
        lastindexused = 0
        for i in range(1,len(self.timeindex)):
            if self.timeindex[i]:
                difftemp = self.temp1[self.timeindex[i]] - self.temp1[self.timeindex[lastindexused]]
                difftime = (self.timex[self.timeindex[i]] - self.timex[self.timeindex[lastindexused]])/60.
                if difftime:
                    string = u(QApplication.translate("Label", "ET {0} {1}/min for {2}",None).format("%.1f"%(difftemp/difftime),aw.qmc.mode,self.stringfromseconds(self.timex[self.timeindex[i]]-self.timex[self.timeindex[lastindexused]])))
                    self.specialevents.append(self.timeindex[lastindexused])
                    self.specialeventstype.append(0)
                    self.specialeventsStrings.append(string)
                    self.specialeventsvalue.append(0)
                    lastindexused = i

    def deleteEvents(self):
        self.specialevents = []
        self.specialeventstype = []
        self.specialeventsStrings = []
        self.specialeventsvalue = []

    #this is used to create a string in pid language to reproduce the profile from Designer
    #NOTE: pid runs ET (temp1)    
    def designer_create_ramp_command(self):
        tempinits = []
        minutes_segments = []

        #ramp times in minutes
        minsDryPhase = str(int(abs(self.timex[self.timeindex[0]] - self.timex[self.timeindex[1]])/60))
        minsMidPhase = str(int(abs(self.timex[self.timeindex[1]] - self.timex[self.timeindex[2]])/60)) 
        minsFinishPhase = str(int(abs(self.timex[self.timeindex[2]] - self.timex[self.timeindex[6]])/60))

        #target temps for ET
        tempinits.append("%.1f"%self.temp1[self.timeindex[1]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[2]])
        tempinits.append("%.1f"%self.temp1[self.timeindex[6]])

        minutes_segments.append(minsDryPhase)
        minutes_segments.append(minsMidPhase)
        minutes_segments.append(minsFinishPhase)

        command = ""
        for i in range(3):
            command += "SETRS::" + tempinits[i] + "::" + minutes_segments[i] + "::0::"
        command += "SETRS::" + tempinits[-1] + "::0::0"

        self.clean_old_pid_commands()

        #do only one event but with all segments
        self.specialevents.append(0)
        self.specialeventstype.append(0)
        self.specialeventsStrings.append(command)
        self.specialeventsvalue.append(0)

    #this is used to create a string in ET temp language to reproduce the profile from Designer
    def designer_create_sv_command(self):
        self.clean_old_pid_commands()
        for i in range(len(self.timeindex)-1):
            command = "SETSV::%.1f"%self.temp1[self.timeindex[i+1]]
            if i > 0 and self.timeindex[i]:
                self.specialevents.append(self.timeindex[i])
                self.specialeventstype.append(0)
                self.specialeventsStrings.append(command)
                self.specialeventsvalue.append(0)

    #verifies there are no previos machine commands on events
    def clean_old_pid_commands(self):
        #check for possible preloaded machine commands
        target = 0
        if len(self.specialevents):
            for i in range(len(self.specialevents)):
                if "::" in self.specialeventsStrings[i]:
                    self.specialevents.pop(i)
                    self.specialeventstype.pop(i)
                    self.specialeventsStrings.pop(i)
                    self.specialeventsvalue.pop(i)
                    target = 1
                    break     #break or the index i can become larger than the new shorted length of specialevents
        if target:
            self.clean_old_pid_commands()

    ###################################      WHEEL GRAPH  ####################################################

    def findCenterWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)
        if t == 360. or t == 0.:
            return 270.
        #check cuadrants
        elif t < 90. and t > 0. or t > 360.:        #quadrant 1
            return 270.+t
        elif t <= 180. and t >= 90.:                #quadrant 2
            return t-90.
        elif t < 270. and t > 180.:                 #quadrant 3
            return t+90.
        else:                                       #quadrant 4
            return t-270.

    def findRadialWheelTextAngle(self,t):
        if t > 360. or t < 0.:
            _,t = divmod(t,360.)  
        if t <= 90. and t > 0. or t > 270.:
            return t
        else:
            return 180.+t

    def loadselectorwheel(self,path):
        string = "Wheels" + "\\" + path
        direct = QDir()
        pathDir = direct.toNativeSeparators(u(string))
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None),path=pathDir,ext="*.wg")
        if filename:
            self.connectWheel()
            aw.loadWheel(filename)
            self.drawWheel()
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def addTocuppingnotes(self,_=False):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) 
        if self.cuppingnotes == "":
            self.cuppingnotes = descriptor
        else:    
            self.cuppingnotes += "\n" + descriptor 
        string = u(QApplication.translate("Message", " added to cupping notes",None))
        aw.sendmessage(descriptor + string)

    @pyqtSlot()
    @pyqtSlot(bool)
    def addToroastingnotes(self,_=False):
        descriptor =  u(self.wheelnames[self.wheelx][self.wheelz]) + " "
        if self.roastingnotes == "":
            self.roastingnotes = descriptor
        else:
            self.roastingnotes +=  "\n" + descriptor
        string = u(QApplication.translate("Message", " added to roasting notes",None))
        aw.sendmessage(descriptor + string)

    def wheel_pick(self,event):
        rect =  event.artist
        loc = rect.get_url().split("-")
        x = int(loc[0])
        z = int(loc[1])
        aw.sendmessage(self.wheelnames[x][z])
        self.wheelx = x
        self.wheelz = z

    def wheel_release(self,event):
        newlocz = event.xdata
        if newlocz:
            if newlocz != self.wheellocationz:
                diff = math.degrees(self.wheellocationx - newlocz)
                for i in range(len(self.startangle)):
                    self.startangle[i] -= diff
                self.drawWheel()

    def wheel_menu(self,event):
        if str(event.inaxes) != str(self.ax2): return
        if event.button == 1:
            self.wheellocationx = event.xdata
            self.wheellocationz = event.ydata

        elif event.button == 3:
            designermenu = QMenu(aw) # if we bind this to self, we inherit the background-color: transparent from self.fig
            cuppingAction = QAction(QApplication.translate("Contextual Menu", "Add to Cupping Notes",None),self)
            cuppingAction.triggered.connect(self.addTocuppingnotes)
            designermenu.addAction(cuppingAction)

            roastingAction = QAction(QApplication.translate("Contextual Menu", "Add to Roasting Notes",None),self)
            roastingAction.triggered.connect(self.addToroastingnotes)
            designermenu.addAction(roastingAction)

            designermenu.addSeparator()
            
            editAction = QAction(QApplication.translate("Contextual Menu", "Edit",None),self)
            editAction.triggered.connect(self.editmode)
            designermenu.addAction(editAction)

            designermenu.exec_(QCursor.pos())

    @pyqtSlot()
    @pyqtSlot(bool)
    def editmode(self,_=False):
        self.disconnectWheel()
        aw.wheeldialog.show()

    def exitviewmode(self):
        self.disconnectWheel()
        if self.ax2 is not None:
            try:
                self.fig.delaxes(self.ax2)
            except:
                pass
        self.redraw(recomputeAllDeltas=False)

    def connectWheel(self):
        self.wheelflag = True
        self.setCursor(Qt.PointingHandCursor)
        self.wheelconnections[0] = self.fig.canvas.mpl_connect('pick_event', self.wheel_pick)
        self.wheelconnections[1] = self.fig.canvas.mpl_connect('button_press_event', self.wheel_menu)           #right click menu context
        self.wheelconnections[2] = self.fig.canvas.mpl_connect('button_release_event', self.wheel_release)

    def disconnectWheel(self):
        self.wheelflag = False
        self.setCursor(Qt.ArrowCursor)
        self.fig.canvas.mpl_disconnect(self.wheelconnections[0])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[1])
        self.fig.canvas.mpl_disconnect(self.wheelconnections[2])

    def drawWheel(self):
        try:
            ### var constants  #####
            pi = numpy.pi
            threesixty = 2.*pi
            div = threesixty/100.
            rad = 360./threesixty
            ########################
            # same as redraw but using different axes
            self.fig.clf()
            #create a new name ax1 instead of ax
            if self.ax2 is not None:
                try:
                    self.fig.delaxes(self.ax2)
                except:
                    pass
            self.ax2 = self.fig.add_subplot(111, projection='polar',facecolor='None')
            self.ax2.set_rmax(1.)
            self.ax2.set_aspect(self.wheelaspect)
            self.ax2.grid(False)

            #delete degrees ticks 
            for tick in self.ax2.xaxis.get_major_ticks():
                #tick.label1On = False
                tick.label1.set_visible(False)
            #delete yaxis 
            locs = self.ax2.get_yticks()
            labels = [""]*len(locs)
            self.ax2.set_yticklabels(labels)

            names = self.wheelnames[:]
            Wradii = self.wradii[:]
            startangle = self.startangle[:]
            projection = self.projection[:]

            #calculate text orientation
            wheels = len(names)

            if not wheels:
                self.fig.canvas.draw()
                return

            n,textangles,textloc = [],[],[] # nr of names, text angles, text locations
            for i in range(wheels):
                l,tloc = [],[]
                count = self.startangle[i]
                #calculate text orientation
                for p in range(len(names[i])):
                    if projection[i] == 0:
                        l.append(0)
                    elif projection[i] == 1:
                        l.append(self.findCenterWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    elif projection[i] == 2:
                        l.append(self.findRadialWheelTextAngle(3.6*self.segmentlengths[i][p]/2. + count))
                    tloc.append((3.6*self.segmentlengths[i][p]/2. + count)/rad)
                    count += self.segmentlengths[i][p]*3.6

                textloc.append(tloc)
                textangles.append(l)
                Wradii[i] = float(Wradii[i])/100.                   #convert radii to float between 0-1 range
                startangle[i] = startangle[i]/rad                   #convert angles to radians
                n.append(len(names[i]))                             #store the number of names for each wheel

            #store the absolute len-radius origin of each circle
            lbottom = [0.]
            count = 0.
            for i in range(wheels-1):
                count += Wradii[i]
                lbottom.append(count)

            Wradiitext = [Wradii[0]/2.]
            for i in range(wheels-1):
                Wradiitext.append(lbottom[i+1] + Wradii[i+1]/2.)     #store absolute len-radius for text in each circle
                Wradii[i] += self.wheeledge                          #create extra color edge between wheels by overlaping wheels
            #Generate Wheel graph
            bar = []                                                 #holds bar-graphs (wheels)
            for z in range(len(n)):
                #create wheel
                theta,segmentwidth,radii = [],[],[]
                count = startangle[z] 
                for i in range(n[z]):
                    #negative number affect eventpicker
                    if count > threesixty:
                        count %= threesixty
                    elif count < 0.:
                        count += threesixty
                    theta.append(count + div*self.segmentlengths[z][i] / 2.)
                    count += div*self.segmentlengths[z][i]
                    segmentwidth.append(div*self.segmentlengths[z][i])
                    radii.append(Wradii[z])
                
                bar.append(self.ax2.bar(theta, radii, width=segmentwidth, bottom=lbottom[z],edgecolor=self.wheellinecolor,
                                        linewidth=self.wheellinewidth,picker=3))
                count = 0
                #set color, alpha, and text
                for _,bar[z] in zip(radii, bar[z]):
                    bar[z].set_facecolor(self.wheelcolor[z][count])
                    bar[z].set_alpha(max(min(self.segmentsalpha[z][count],1),0))
                    bar[z].set_url(str(z) + "-" + str(count))
                    fontprop = aw.mpl_fontproperties.copy()
                    fontprop.set_size(self.wheeltextsize[z])
                    anno = self.ax2.annotate(names[z][count],xy=(textloc[z][count],Wradiitext[z]),xytext=(textloc[z][count],Wradiitext[z]),
                        rotation=textangles[z][count],
                        horizontalalignment='center',
                        verticalalignment="center",
                        color=aw.qmc.wheeltextcolor,
                        fontproperties=fontprop)
                    try:
                        anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                    except: # mpl before v3.0 do not have this set_in_layout() function
                        pass
                    count += 1
            self.fig.canvas.draw()

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None) + " drawWheel() {0}").format(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " drawWheel() {0}").format(str(e)),exc_tb.tb_lineno)
            return

    def makewheelcolorpattern(self):
        for x in range(len(self.wheelcolor)):
            wlen = len(self.wheelcolor[x])
            for i in range(wlen):
                color = QColor()
                color.setHsv((360/wlen)*i*self.wheelcolorpattern,255,255,255)
                self.wheelcolor[x][i] = str(color.name())

    # sets parent and corrects segment lengths so that child fits inside parent (multiple children can be set to same parent)
    # input: z = index of parent in previus wheel    # x = wheel number    # i = index of element in wheel x
    def setwheelchild(self,z,x,i):
        #set same start angle
        self.startangle[x] = self.startangle[x-1]
        self.wheellabelparent[x][i] = z

        #adjust lengths
        for x in range(1,len(self.segmentlengths)):
            nsegments = len(self.segmentlengths[x])
            parentanglecount = 0
            for i in range(nsegments):
                if self.wheellabelparent[x][i]:                                                   #if parent selected (otherwise 0) 
                    parentindex = self.wheellabelparent[x][i]                                     #parent index
                    if self.wheellabelparent[x][i] == parentindex:                                #if match
                        parentangle = self.segmentlengths[x-1][self.wheellabelparent[x][i]-1]     #find parent angle (in %)
                        #find number of labels with same parent
                        count = self.wheellabelparent[x].count(parentindex)                       #count number of labels with same parent
                        self.segmentlengths[x][i] = parentangle/count                             #divide parent angle between children

                        #calculate last total angle
                        if i < nsegments-1:
                            parentanglecount += self.segmentlengths[x][i]

                        #adjust rest of angles to get 100 % coverage
                        for a in range(i+1,nsegments):
                            self.segmentlengths[x][a] = (100-parentanglecount)/(nsegments-(i+1))

    #adjusts size of all segements of the graph based on child parent relation
    #expects all segments to have a parent except in the first wheel
    @pyqtSlot(bool)
    def setWheelHierarchy(self,_):
        #check for not stablished relashionships (will cause graph plotting problems) and give warning
        for x in range(1,len(self.wheellabelparent)):
            for i in range(len(self.wheellabelparent[x])):
                if self.wheellabelparent[x][i] == 0:
                    QMessageBox.information(aw,"Wheel Hierarchy Problem",
                    "Please assign a parent to wheel #%i element#%i: \n\n%s"%(x+1,i+1,self.wheelnames[x][i]))
                    return

        #adjust top wheel and make all segments equal
        for i in range(len(self.segmentlengths[-1])):
            self.segmentlengths[-1][i] = 100./len(self.segmentlengths[-1])

        #adjust lower wheels based on previous wheels
        for p in range(len(self.wheellabelparent)-1,0,-1):
            nsegments = len(self.wheellabelparent[p])
            nparentsegments = len(self.wheellabelparent[p-1])
            angles = [0]*nparentsegments
            for x in range(nparentsegments):
                for i in range(nsegments):
                    if self.wheellabelparent[p][i]-1 == x:
                        angles[x] += self.segmentlengths[p][i]

            #adjust angle length of parents proportionaly
            for i in range(nparentsegments):
                self.segmentlengths[p-1][i] = angles[i]

        self.drawWheel()

#############################     MOUSE CROSS     #############################

    def togglecrosslines(self):
        if self.crossmarker == False and not self.designerflag and not self.flagstart:  #if not projection flag
            #turn ON
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None
            self.updateBackground() # update bitlblit backgrounds
            self.crossmarker = True
            message = QApplication.translate("Message", "Mouse Cross ON: move mouse around",None)
            aw.sendmessage(message)
            self.crossmouseid = self.fig.canvas.mpl_connect('motion_notify_event', self.drawcross)
            self.onreleaseid = self.fig.canvas.mpl_connect('button_release_event', self.onrelease)  #mouse cross lines measurement
        else:
            #turn OFF
            self.crossmarker = False
            if (self.DeltaETflag or self.DeltaBTflag or (aw.qmc.background and (self.DeltaETBflag or self.DeltaBTBflag))) and not self.designerflag:
                self.resetdeltalines()
            else:
                self.resetlines()
            self.updateBackground() # update bitlblit backgrounds
            message = QApplication.translate("Message", "Mouse cross OFF",None)
            aw.sendmessage(message)
            self.fig.canvas.mpl_disconnect(self.crossmouseid)
            self.l_horizontalcrossline = None
            self.l_verticalcrossline = None
            self.fig.canvas.mpl_disconnect(self.onreleaseid)  #mouse cross lines measurement

    def drawcross(self,event):
        # do not interleave with redraw()
        gotlock = aw.qmc.samplingsemaphore.tryAcquire(1,0)
        if gotlock:
            try:
                if event.inaxes == self.ax:
                    x = event.xdata 
                    y = event.ydata
                    if self.baseX and self.baseY:
                        deltaX = aw.qmc.stringfromseconds(event.xdata - self.baseX)
                        deltaY = str(aw.float2float(event.ydata - self.baseY,1))
                        RoR = str(aw.float2float(60 * (event.ydata - self.baseY) / (event.xdata - self.baseX),1))
                        message = "delta Time= {},    delta Temp= {} {},    RoR= {} {}/min".format(deltaX,deltaY,aw.qmc.mode,RoR,aw.qmc.mode)
                        aw.sendmessage(message)
                        self.base_messagevisible = True
                    elif self.base_messagevisible:
                        aw.clearMessageLine()
                        self.base_messagevisible = False
                    if x and y:
                        if self.l_horizontalcrossline is None:
                            self.l_horizontalcrossline, = self.ax.plot([self.startofx,self.endofx*2], [y,y],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_horizontalcrossline.set_data([self.startofx,self.endofx*2], [y,y])
                        if self.l_verticalcrossline is None:
                            self.l_verticalcrossline, = self.ax.plot([x,x], [self.ylimit_min,self.ylimit],color = self.palette["text"], linestyle = '-', linewidth= .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_verticalcrossline.set_data([x,x], [self.ylimit_min,self.ylimit])
                        if self.ax_background:
                            self.fig.canvas.restore_region(self.ax_background)
                            aw.qmc.ax.draw_artist(self.l_horizontalcrossline)
                            aw.qmc.ax.draw_artist(self.l_verticalcrossline)
                            if self.base_horizontalcrossline and self.base_verticalcrossline:
                                aw.qmc.ax.draw_artist(self.base_horizontalcrossline)
                                aw.qmc.ax.draw_artist(self.base_verticalcrossline)
                            self.fig.canvas.blit(aw.qmc.ax.get_tightbbox(self.fig.canvas.get_renderer()))
                        else:
                            self.updateBackground()
                elif event.inaxes == self.delta_ax:
                    x = event.xdata 
                    y = event.ydata
                    if x and y and self.delta_ax:
                        if self.l_horizontalcrossline is None:
                            self.l_horizontalcrossline, = self.delta_ax.plot([self.startofx,self.endofx*2], [y,y], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_horizontalcrossline.set_data([self.startofx,self.endofx*2], [y,y])
                        if self.l_verticalcrossline is None:
                            self.l_verticalcrossline, = self.delta_ax.plot([x,x], [self.zlimit_min,self.zlimit], color = self.palette["text"], linestyle = '-', linewidth = .5, alpha = 1.0,sketch_params=None,path_effects=[])
                        else:
                            self.l_verticalcrossline.set_data([x,x], [self.zlimit_min,self.zlimit])
                        if self.ax_background:
                            self.fig.canvas.restore_region(self.ax_background)
                            aw.qmc.delta_ax.draw_artist(self.l_horizontalcrossline)
                            aw.qmc.delta_ax.draw_artist(self.l_verticalcrossline)
                            self.fig.canvas.blit(aw.qmc.delta_ax.bbox)
                        else:
                            self.updateBackground()
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)

#######################################################################################
#######################  END OF MAIN APPLICATION   ####################################
#######################################################################################

#######################################################################################
#####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
#######################################################################################


def my_get_icon(name):
    basedir = os.path.join(mpl.rcParams['datapath'], 'images')
    p = os.path.join(basedir, name.replace('.svg','.png'))
    if os.path.exists(p):
        return QIcon(p)
    else:
        None
        
class VMToolbar(NavigationToolbar):
    def __init__(self, plotCanvas, parent,white_icons=False):
        self.toolitems = (
                ('Plus', QApplication.translate("Tooltip", 'Connect to plus service', None), 'plus', 'plus'),
                ('', QApplication.translate("Tooltip", 'Subscription', None), 'plus-pro', 'subscription'),
                ('Home', QApplication.translate("Tooltip", 'Reset original view', None), 'home', 'home'),
                ('Back', QApplication.translate("Tooltip", 'Back to  previous view', None), 'back', 'back'),
                ('Forward', QApplication.translate("Tooltip", 'Forward to next view', None), 'forward', 'forward'),
                (None, None, None, None),
                ('Pan', QApplication.translate("Tooltip", 'Pan axes with left mouse, zoom with right', None), 'move', 'pan'),
                ('Zoom', QApplication.translate("Tooltip", 'Zoom to rectangle', None), 'zoom_to_rect', 'zoom'),
        )
        
        # if true, we render Artisan-specific white versions of the icons
        self.white_icons = white_icons
        
        self.axis_ranges = [] # holds the ranges of all axis to detect if it is zoomed in

        NavigationToolbar.__init__(self, plotCanvas, parent)
        

# add green flag menu on matplotlib v2.0 and later
        if len(self.actions()) > 0:
            # insert the "Green Flag" menu item before the last one (which is the x/y coordinate display)
            a = QAction(self._icon("qt4_editor_options.png"),'Customize',self)
            a.triggered.connect(self.edit_parameters)   
            a.setToolTip(QApplication.translate("Tooltip", 'Edit axis and curve parameters', None))
            self.insertAction(self.actions()[-1],a) 

        # adjust for dark or light canvas and set hover/selection style
        for a in self.actions():
            if aw is not None: 
                if aw.qmc.palette["canvas"] is None or aw.qmc.palette["canvas"] == "None":
                    canvas_color = QColor("#ECECEC")
                else:           
                    canvas_color = QColor(aw.qmc.palette["canvas"])
                if canvas_color.name() == "#000000": # on black we start with (1,1,1) for lighter
                    canvas_color = QColor("#222222")
                
                if self.white_icons:
                    selected_canvas_color = canvas_color.lighter(250)
                    border_color = "white"
                else:
                    selected_canvas_color = canvas_color.darker(120)
                    border_color = "black"           
                self.widgetForAction(a).setStyleSheet(" \
                        QToolButton:checked {border:1px solid transparent; margin: 1px; padding: 2px; background-color:" + selected_canvas_color.name() + ";border-radius: 3px;} \
                        QToolButton:hover {border:1px solid " + border_color + "; margin: 2px; padding: 2px; background-color:transparent;border-radius: 3px;} \
                        QToolButton:checked:hover {border:1px solid " + border_color + "; margin: 2px; padding: 2px; background-color:" + selected_canvas_color.name() + ";border-radius: 3px;} \
                        QToolButton {border:1px solid transparent; margin: 2px; padding: 2px; background-color: transparent;border-radius: 3px;}")

        if aw is not None:
            aw.updatePlusStatus(self)


        self.update_view_org = self._update_view
        self._update_view = self.update_view_new
        self.draw_org = self.draw
        self.draw = self.draw_new

        # monkey patch matplotlib figureoptions that links to svg icon by default (crashes Windows Qt4 builds!)
        if not svgsupport:
            figureoptions.get_icon = my_get_icon
            
                
    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def draw_new(self):
        self.draw_org()
        aw.qmc.updateBackground()
        
    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def update_view_new(self):
        self.update_view_org()
        aw.qmc.updateBackground()

    def getAxisRanges(self):
        res = []
        for ax in self.canvas.figure.axes:
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            res.append(xlim[1]-xlim[0])
            res.append(ylim[1]-ylim[0])
        return res
        
    def press_pan(self, event):
        if aw.qmc.ai is not None:
            # we remember the axis ranges before the pan-zoom to detect if it was zoomed
            self.axis_ranges = self.getAxisRanges()
        super(VMToolbar, self).press_pan(event)
    
    def release_pan(self, event):
        if aw.qmc.ai is not None and [round(r) for r in self.axis_ranges] != [round(r) for r in self.getAxisRanges()]:
            # only hide the background image if the axis ratio changed
            aw.qmc.ai.set_visible(False)
        super(VMToolbar, self).release_pan(event)

    def release_zoom(self, event):
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(False)
        super(VMToolbar, self).release_zoom(event)

    def forward(self, *args):
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(False)  # whenever forward is pressed the image will be hidden
        super(VMToolbar, self).forward(*args) 
        
    def back(self, *args):
        if aw.qmc.ai is not None:
            if self._nav_stack._pos == 1:
                aw.qmc.ai.set_visible(True)
        super(VMToolbar, self).back(*args) 
        
    def home(self, *args):
        """Restore the original view"""
        # show the background image again that was hidden on zoom-in
        if aw.qmc.ai is not None:
            aw.qmc.ai.set_visible(True)
        super(VMToolbar, self).home(*args) 
                
        # toggle zoom_follow if recording
        if aw.qmc.flagstart:
            aw.qmc.zoom_follow = not aw.qmc.zoom_follow
            if aw.qmc.zoom_follow:
                aw.sendmessage(QApplication.translate("Message","follow on", None))
            else:
                aw.sendmessage(QApplication.translate("Message","follow off", None))
        else:
            aw.qmc.zoom_follow = False
        if aw.qmc.zoom_follow:
            self.push_current()

    def _icon(self, name, _=None):
        if aw is not None and name.startswith("plus"):
            basedir = os.path.join(aw.getResourcePath(),"Icons")
        else:
            basedir = self.basedir
        if name.startswith("plus") and not self.white_icons:
            name = 'white_' + name
        #dirty hack to prefer .svg over .png Toolbar icons
        if not svgsupport:
            name = name.replace('.svg','.png')
        else:
            name = name.replace('.png','.svg')
        # large png icons introduced in MPL 2.1 for Qt5
        name = name.replace('.png', '_large.png')
        p = os.path.join(basedir, name)
        pm = QPixmap(p)
        if not name.startswith("plus") and not name.startswith("white_plus"):
            if self.white_icons:
                pm = self.recolorIcon(pm,QColor("#dfdfdf"))
            else:
                pm = self.recolorIcon(pm,QColor("#424242"))
        if hasattr(pm, 'setDevicePixelRatio'):
            pm.setDevicePixelRatio(self.canvas._dpi_ratio)
        return QIcon(pm)
        
    def recolorIcon(self, pixmap, color):
        tmp = pixmap.toImage()
        for y in range(tmp.height()):
            for x in range(tmp.width()):
                color.setAlpha(tmp.pixelColor(x,y).alpha())
                tmp.setPixelColor(x,y,color)
        return QPixmap.fromImage(tmp)

#PLUS
    def plus(self):
        plus.controller.toggle(aw)
        
    def subscription(self):
        remaining_days = max(0,(aw.plus_paidUntil.date() - datetime.datetime.now().date()).days)
        if remaining_days == 1:
            days = QApplication.translate("Plus","1 day",None)
        else:
            days = str(remaining_days) + ' ' + QApplication.translate("Plus","days",None)
        pu = aw.plus_paidUntil.date()
        message = QApplication.translate("Plus","Paid until",None) + ' ' + QDate(pu.year,pu.month,pu.day).toString(Qt.SystemLocaleShortDate)
        if remaining_days <31:
            if remaining_days <=3:
                style = "background-color:#cc0f50;color:white;"
            else:
                style = ""
            message += '<blockquote><b><span style="' + style + '">&nbsp; ' + days + ' left &nbsp;</span></b></blockquote>'
        else:
            message += '<br><br>'
        message += 'Please visit our <a href="' + plus.config.shop_base_url + '">shop</a> to extend your subscription'
        #
        # if less then 31 days:
        # n days left <= rot if <=3
        #  3 days, 2 days, 1 day, 0 days left
        #
        subscription_message_box = ArtisanMessageBox(aw,QApplication.translate("Message", "Subscription",None),message)
        subscription_message_box.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def edit_parameters(self,_=False):
        try:
            if not aw.qmc.designerflag: # deactivate figure_options in designer mode due to all kind of side effects
                allaxes = self.canvas.figure.get_axes()
                if len(allaxes) == 1:
                    pass
                else:
                    if aw.qmc.flagstart:
                        # temporary set the axis to get proper menu items (same code as in redraw)
                        aw.qmc.ax.set_ylabel(aw.qmc.mode)
                        aw.qmc.ax.set_xlabel(aw.arabicReshape(QApplication.translate("Label", "Time",None)))
                        two_ax_mode = (aw.qmc.DeltaETflag or aw.qmc.DeltaBTflag or (aw.qmc.background and (aw.qmc.DeltaETBflag or aw.qmc.DeltaBTBflag))) and not aw.qmc.designerflag
                        if two_ax_mode and aw.qmc.delta_ax:
                            aw.qmc.delta_ax.set_ylabel(aw.qmc.mode + aw.arabicReshape(QApplication.translate("Label", "/min", None)))

                axes = allaxes[0]
                
                try:
                    # hack to work around an inconsistency in mpl (1.5.1, 2.0b3) that throws an index error on "steps-post" in figureoptions
                    steps_post_lines = []
                    for line in aw.qmc.ax.lines:
                        if line.get_drawstyle() == "steps-post":
                            steps_post_lines.append(line)
                            line.set_drawstyle("steps")
                    figureoptions.figure_edit(axes)
                    for line in steps_post_lines:
                        line.set_drawstyle("steps-post")
                except Exception as e:
    #                import traceback
    #                traceback.print_exc(file=sys.stdout)
                    pass
                aw.fetchCurveStyles()
#                aw.fetchAxisLimits() # DON'T
                # the redraw is mostly necessary to force a redraw of the legend to reflect the changed colors/styles/labels
                aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " edit_parameters() {0}").format(str(e)),exc_tb.tb_lineno)
#            import traceback
#            traceback.print_exc(file=sys.stdout)
    

########################################################################################
###     Sample thread
########################################################################################

class SampleThread(QThread):
    updategraphics = pyqtSignal()
    
    def __init__(self,parent = None):
        super(SampleThread,self).__init__(parent)
        self.afterTP = False

    # input filter
    # if temp (the actual reading) is outside of the interval [tmin,tmax] or
    # a spike is detected, the previous value is repeated or if that happend already before, -1 is returned
    # note that here we assume that the actual measured temperature time/temp was not already added to the list of previous measurements timex/tempx
    def inputFilter(self,timex,tempx,time,temp,BT=False):
        try:
            #########################
            # a) detect overflows
            wrong_reading = 0
            if aw.qmc.minmaxLimits and (temp < aw.qmc.filterDropOut_tmin or temp > aw.qmc.filterDropOut_tmax):
                wrong_reading = 1
            #########################
            # b) detect spikes (on BT only after CHARGE if autoChargeFlag=True not to have a conflict here)
            n = aw.qmc.filterDropOut_spikeRoR_period
            dRoR_limit = aw.qmc.filterDropOut_spikeRoR_dRoR_limit # the limit of additional RoR in temp/sec (4C for C / 7F for F) compared to previous readings
            if aw.qmc.dropSpikes and ((not aw.qmc.autoChargeFlag) or (not BT) or (aw.qmc.timeindex[0] != -1 and (aw.qmc.timeindex[0] + n) < len(timex))) and not wrong_reading and len(tempx) >= n:
                # no min/max overflow detected
                # check if RoR caused by actual measurement is way higher then the previous one
                # calc previous RoR (pRoR) taking the last n samples into account
                pdtemp = tempx[-1] - tempx[-n]
                pdtime = timex[-1] - timex[-n]
                if pdtime > 0:
                    pRoR = abs(pdtemp/pdtime)
                    dtemp = tempx[-1] - temp
                    dtime = timex[-1] - time
                    if dtime > 0:
                        RoR = abs(dtemp/dtime)
                        if RoR > (pRoR + dRoR_limit):
                            wrong_reading = 2
            #########################
            # c) handle outliers if it could be detected
            if wrong_reading:
                if len(tempx) > 0 and tempx[-1] != -1:
                    # repeate last correct reading if not done before in the last two fixes (min/max violation are always filtered)
                    if len(tempx) == 1 or (len(tempx) > 3 and (tempx[-1] != tempx[-2] or tempx[-2] != tempx[-3])):
                        return tempx[-1]
                    else:
                        if wrong_reading == 1:
                            return -1
                        else:
                            # no way to correct this
                            return temp
                else:
                    if wrong_reading == 1:
                        return -1
                    else:
                        # no way to correct this
                        return temp
            else:
                # try to improve a previously corrected reading timex/temp[-1] based on the current reading time/temp (just in this case the actual reading is not a drop)                
                if (aw.qmc.minmaxLimits or aw.qmc.dropSpikes) and len(tempx) > 2 and tempx[-1] == tempx[-2] and tempx[-1] != -1 and tempx[-1] != temp: # previous reading was a drop and replaced by reading[-2]
                    tempx[-1] = (tempx[-2] + temp) / 2.0
                return temp
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " filterDropOuts() {0}").format(str(e)),exc_tb.tb_lineno)            
            return temp

    def sample_main_device(self):
        #read time, ET (t1) and BT (t2) TEMPERATURE
        try:
            if aw.simulator is None:
                if aw.qmc.swapETBT:
                    tx,t2,t1 = aw.ser.devicefunctionlist[aw.qmc.device]()  #use a list of functions (a different one for each device) with index aw.qmc.device
                else:
                    tx,t1,t2 = aw.ser.devicefunctionlist[aw.qmc.device]()  #use a list of functions (a different one for each device) with index aw.qmc.device
            else:
                tx = aw.qmc.timeclock.elapsed()/1000.
                t1,t2 = aw.simulator.read((tx if aw.qmc.flagstart else 0))
            return tx,float(t1),float(t2)
        except:
            tx = aw.qmc.timeclock.elapsed()/1000.
            return tx,-1.0,-1.0
    
    def sample_extra_device(self,i):
        try:
            if aw.simulator is None:
                tx,t1,t2 = aw.extraser[i].devicefunctionlist[aw.qmc.extradevices[i]]()
            else:
                tx = aw.qmc.timeclock.elapsed()/1000.
                t1,t2 = aw.simulator.readextra(i,(tx if aw.qmc.flagstart else 0))
            return tx,float(t1),float(t2)
        except:
            tx = aw.qmc.timeclock.elapsed()/1000.
            return tx,-1.0,-1.0

    # the temp get's averaged using the given decay weights after resampling
    # to linear time based on tx and the current sampling interval
    def decay_average(self,tx,temp,decay_weights):
        if len(tx) != len(temp):
            return temp
        else:
            # we take one more reading, if availble, for the re-sampling to make it more likely to have all readings re-sampled
            l = min(len(decay_weights)+1,len(temp))
            d = aw.qmc.delay / 1000.
            tx_org = tx[-l:] # as len(tx)=len(temp) here, it is guranteed that len(tx_org)=l
            # we create a linearly spaced time array starting from the newest timestamp in sampling interval distance
            tx_lin = numpy.flip(numpy.arange(tx_org[-1],tx_org[-1]-l*d,-d), axis=0) # by contruction, len(tx_lin)=len(tx_org)=l
            temp_trail = temp[-l:] # by construction, len(temp_trail)=len(tx_lin)=len(tx_org)=l
            temp_trail_re = numpy.interp(tx_lin, tx_org, temp_trail) # resample data into that linear spaced time
            return numpy.average(temp_trail_re[-len(decay_weights):],weights=decay_weights[-l:])  # len(decay_weights)>len(temp_trail_re)=l is possible

    # sample devices at interval self.delay miliseconds.
    # we can assume within the processing of sample() that flagon=True
    def sample(self):
        ##### (try to) lock resources  #########
#        gotlock = aw.qmc.samplingsemaphore.tryAcquire(1,100) # we try to catch a lock for 100ms, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        gotlock = aw.qmc.samplingsemaphore.tryAcquire(1,0) # we try to catch a lock if available but we do not wait, if we fail we just skip this sampling round (prevents stacking of waiting calls)
        if gotlock:
            try:
                # duplicate system state flag flagstart locally and only refer to this copy within this function to make it behaving uniquely (either append or overwrite mode)
                local_flagstart = aw.qmc.flagstart
                
                # if we are not yet recording, but sampling we keep on reseting the timer (only if not already a profile was recorded)
                if not local_flagstart and len(aw.qmc.timex) < 2:
                    aw.qmc.timeclock.start()
                    
                # send sampling action if any interval is set to "sync" (extra_event_sampling_delay = 0)
                try:
                    if aw.qmc.extra_event_sampling_delay == 0 and aw.qmc.extrabuttonactions[2]:
                        aw.eventactionx(aw.qmc.extrabuttonactions[2],aw.qmc.extrabuttonactionstrings[2])
                except Exception:
                    pass
                    
                #if using a meter (thermocouple device)
                if aw.qmc.device != 18 or aw.simulator is not None: # not NONE device
                
                    #### first retrieve readings from the main device
                    timeBeforeETBT = libtime.perf_counter() # the time before sending the request to the main device
                    #read time, ET (t1) and BT (t2) TEMPERATURE
                    tx_org,t1,t2 = self.sample_main_device()
                    timeAfterETBT = libtime.perf_counter() # the time the data of the main device was received
                    etbt_time = timeAfterETBT - timeBeforeETBT
                    tx = tx_org + (etbt_time / 2.0) # we take the average between before and after
                    aw.qmc.RTtemp1 = t1 # store readings for real-time symbolic evaluation
                    aw.qmc.RTtemp2 = t2
                    ##############  if using Extra devices
                    nxdevices = len(aw.qmc.extradevices)
                    if nxdevices:
                        les,led,let =  len(aw.extraser),len(aw.qmc.extradevices),len(aw.qmc.extratemp1)
                        if les == led == let:
                            xtra_dev_lines1 = 0
                            xtra_dev_lines2 = 0
                            #1 clear extra device buffers
                            aw.qmc.RTextratemp1,aw.qmc.RTextratemp2,aw.qmc.RTextratx = [],[],[]
                            #2 load RT buffers
                            for i in range(nxdevices):
                                extratx,extrat2,extrat1 = self.sample_extra_device(i)
                                aw.qmc.RTextratemp1.append(extrat1)
                                aw.qmc.RTextratemp2.append(extrat2)
                                aw.qmc.RTextratx.append(extratx)
                            #3 evaluate symbolic expressions
                            for i in range(nxdevices):
                                extrat1 = aw.qmc.RTextratemp1[i]
                                extrat2 = aw.qmc.RTextratemp2[i]
                                if len(aw.qmc.extramathexpression1) > i and aw.qmc.extramathexpression1[i] is not None and len(aw.qmc.extramathexpression1[i]):
                                    try:
                                        extrat1 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression1[i],aw.qmc.RTextratx[i],RTsname="Y"+str(2*i+3),RTsval=aw.qmc.RTextratemp1[i])
                                        aw.qmc.RTextratemp1[i] = extrat1
                                    except:
                                        pass
                                if len(aw.qmc.extramathexpression2) > i and aw.qmc.extramathexpression2[i] is not None and len(aw.qmc.extramathexpression2[i]):
                                    try:
                                        extrat2 = aw.qmc.eval_math_expression(aw.qmc.extramathexpression2[i],aw.qmc.RTextratx[i],RTsname="Y"+str(2*i+4),RTsval=aw.qmc.RTextratemp2[i])
                                        aw.qmc.RTextratemp2[i] = extrat2
                                    except:
                                        pass
                                if aw.qmc.extradevices[i] != 25: # don't apply input filters to virtual devices
                                    extrat1 = self.inputFilter(aw.qmc.extratimex[i],aw.qmc.extratemp1[i],extratx,extrat1)
                                    extrat2 = self.inputFilter(aw.qmc.extratimex[i],aw.qmc.extratemp2[i],extratx,extrat2)
                                if local_flagstart:
                                    aw.qmc.extratemp1[i].append(float(extrat1))
                                    aw.qmc.extratemp2[i].append(float(extrat2))
                                    aw.qmc.extratimex[i].append(extratx)
                                    if extrat1 != -1:
                                        aw.qmc.extractimex1[i].append(float(extratx))
                                        aw.qmc.extractemp1[i].append(float(extrat1))
                                    if extrat2 != -1:
                                        aw.qmc.extractimex2[i].append(float(extratx))
                                        aw.qmc.extractemp2[i].append(float(extrat2))
                                    # update extra lines
                                    
                                    if aw.extraCurveVisibility1[i] and len(aw.qmc.extratemp1lines) > xtra_dev_lines1:
                                        aw.qmc.extratemp1lines[xtra_dev_lines1].set_data(aw.qmc.extractimex1[i], aw.qmc.extractemp1[i])
                                        xtra_dev_lines1 = xtra_dev_lines1 + 1
                                    if aw.extraCurveVisibility2[i] and len(aw.qmc.extratemp2lines) > xtra_dev_lines2:
                                        aw.qmc.extratemp2lines[xtra_dev_lines2].set_data(aw.qmc.extractimex2[i], aw.qmc.extractemp2[i])
                                        xtra_dev_lines2 = xtra_dev_lines2 + 1
                                else:
                                    # we do not record, so we just replace the old last value
                                    if len(aw.qmc.extratemp1[i]) > 0:
                                        aw.qmc.extratemp1[i][-1] = float(extrat1)
                                    else:
                                        aw.qmc.extratemp1[i].append(float(extrat1))
                                    if len(aw.qmc.extratemp2[i]) > 0:
                                        aw.qmc.extratemp2[i][-1] = float(extrat2)
                                    else:
                                        aw.qmc.extratemp2[i].append(float(extrat2))
                                    if len(aw.qmc.extratimex[i]) > 0:
                                        aw.qmc.extratimex[i][-1] = extratx
                                    else:
                                        aw.qmc.extratimex[i].append(extratx)
                        #ERROR FOUND
                        else:
                            lengths = [les,led,let]
                            location = ["Extra-Serial","Extra-Devices","Extra-Temp"]
                            #find error
                            if (nxdevices-1) in lengths:
                                indexerror =  lengths.index(nxdevices-1)
                            elif (nxdevices+1) in lengths:
                                indexerror =  lengths.index(nxdevices+1)
                            else:
                                indexerror = 1000
                            if indexerror != 1000:
                                errormessage = "ERROR: length of %s (=%i) does not have the necessary length (=%i)"%(location[indexerror],lengths[indexerror],nxdevices)
                                errormessage += "\nPlease Reset: Extra devices"
                            else:
                                string = location[0] + "= " + str(lengths[0]) + " " + location[1] + "= " + str(lengths[1]) + " "
                                string += location[2] + "= " + str(lengths[2])
                                errormessage = "ERROR: extra devices lengths don't match: %s"%string
                                errormessage += "\nPlease Reset: Extra devices"
                            raise Exception(errormessage)
                    timeAfterExtra = libtime.perf_counter() # the time the data of all extra devices was received
                    if aw.qmc.oversampling and aw.qmc.delay >= aw.qmc.oversampling_min_delay:
                        # let's do the oversampling thing and take a second reading from the main device
                        sampling_interval = aw.qmc.delay/1000.
                        gone = timeAfterExtra - timeBeforeETBT
                        # only do it if there is enough time to do the ET/BT sampling (which takes etbt_time) 
                        # and only half of the sampling interval is gone
                        if (sampling_interval - gone) > etbt_time and gone < (sampling_interval / 2.0):
                            # place the second ET/BT sampling in the middle of the sampling interval
                            stime = max(0.3,(sampling_interval / 4.0) - gone) # placing the second sample in the middle blocks too long!
#                            stime = max(0,0.3 - gone) # we want the second main sample minimally 100ms after the first
                            libtime.sleep(stime)
                            timeBeforeETBT2 = libtime.perf_counter() # the time before sending the 2nd request to the main device
                            tx_2,t1_2,t2_2 = self.sample_main_device()
                            timeAfterETBT2 = libtime.perf_counter() # the time after sending the 2nd request to the main device
                            if t1 != -1 and t2 != -1 and t1_2 != -1 and t2_2 != -1:
                                t2 = (t2 + t2_2) / 2.0
                                t1 = (t1 + t1_2) / 2.0
                                etbt_time_total = timeAfterETBT2 - timeBeforeETBT
                                tx = tx_org + (etbt_time_total / 2.0) # we take the average between before and after
                            elif t1 == -1 and t2 == -1 and t1_2 != -1 and t2_2 != -1: # only the second pair is valid, take that one
                                t2 = t2_2
                                t1 = t1_2
                                etbt_time_2nd = timeAfterETBT2 - timeBeforeETBT2
                                tx = tx_2 + (etbt_time_2nd / 2.0) # we take the average between before and after
                            else: # use new values only to fix reading errors of the initial set of values
                                if t1 == -1:
                                    t1 = t1_2
                                elif t1_2 != -1:
                                    t1 = (t1 + t1_2) / 2.0
                                if t2 == -1:
                                    t2 = t2_2
                                elif t2_2 != -1:
                                    t2 = (t2 + t2_2) / 2.0

                    ####### all values retrieved

                    if aw.qmc.ETfunction is not None and len(aw.qmc.ETfunction):
                        try:
                            t1 = aw.qmc.eval_math_expression(aw.qmc.ETfunction,tx,RTsname="Y1",RTsval=t1)
                            aw.qmc.RTtemp1 = t1
                        except:
                            pass
                    if aw.qmc.BTfunction is not None and len(aw.qmc.BTfunction):
                        try:
                            t2 = aw.qmc.eval_math_expression(aw.qmc.BTfunction,tx,RTsname="Y2",RTsval=t2)
                            aw.qmc.RTtemp2 = t2
                        except:
                            pass
                    # if modbus device do the C/F conversion if needed (done after mathexpression, not to mess up with x/10 formulas)
                    # modbus channel 1+2, respect input temperature scale setting
                    t1 = self.inputFilter(aw.qmc.timex,aw.qmc.temp1,tx,t1)
                    t2 = self.inputFilter(aw.qmc.timex,aw.qmc.temp2,tx,t2,True)
                    
                    length_of_qmc_timex = len(aw.qmc.timex)
                    t1_final = t1
                    t2_final = t2
                    if local_flagstart:
                        aw.qmc.temp2.append(t2_final)
                        aw.qmc.temp1.append(t1_final)
                        aw.qmc.timex.append(tx)
                        length_of_qmc_timex += 1
                        if t1_final != -1:
                            aw.qmc.ctimex1.append(tx)
                            aw.qmc.ctemp1.append(t1_final)
                        if t2_final != -1:
                            aw.qmc.ctimex2.append(tx)
                            aw.qmc.ctemp2.append(t2_final)
                    else:
                        if len(aw.qmc.temp2) > 0:
                            aw.qmc.temp2[-1] = t2_final
                        else:
                            aw.qmc.temp2.append(t2_final)
                        if len(aw.qmc.temp1) > 0:
                            aw.qmc.temp1[-1] = t1_final
                        else:
                            aw.qmc.temp1.append(t1_final)
                        if length_of_qmc_timex <= 0:
                            aw.qmc.timex.append(tx)
                            length_of_qmc_timex += 1
                        else:
                            aw.qmc.timex[-1] = tx
                            
                        if len(aw.qmc.ctemp2) > 0:
                            aw.qmc.ctemp2[-1] = t2_final
                        else:
                            aw.qmc.ctemp2.append(t2_final)
                        if len(aw.qmc.ctemp1) > 0:
                            aw.qmc.ctemp1[-1] = t1_final
                        else:
                            aw.qmc.ctemp1.append(t1_final)
                        if len(aw.qmc.ctimex2) > 0:
                            aw.qmc.ctimex2[-1] = tx
                        else:
                            aw.qmc.ctimex2.append(tx)
                        if len(aw.qmc.ctimex1) > 0:
                            aw.qmc.ctimex1[-1] = tx
                        else:
                            aw.qmc.ctimex1.append(tx)
                            
                    #we populate the temporary smoothed ET/BT data arrays (with readings cleansed from -1 dropouts)
                    cf = aw.qmc.curvefilter*2 - 1 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                    if self.temp_decay_weights is None or len(self.temp_decay_weights) != cf: # recompute only on changes
                        self.temp_decay_weights = numpy.arange(1,cf+1)
                    # we don't smooth st'x if last, or butlast temperature value were a drop-out not to confuse the RoR calculation
                    if -1 in aw.qmc.temp1[-(cf+1):]: 
                        dw1 = [1]
                    else:
                        dw1 = self.temp_decay_weights
                    if -1 in aw.qmc.temp2[-(cf+1):]:
                        dw2 = [1]
                    else:
                        dw2 = self.temp_decay_weights
                    # average smoothing
                    d = aw.qmc.delay / 1000.
                    if len(aw.qmc.ctemp1) > 0:
                        st1 = self.decay_average(aw.qmc.ctimex1,aw.qmc.ctemp1,dw1)
                    else:
                        st1 = -1
                    if len(aw.qmc.ctemp2) > 0:
                        st2 = self.decay_average(aw.qmc.ctimex2,aw.qmc.ctemp2,dw2)
                    else:
                        st2 = -1
                    # register smoothed values
                    aw.qmc.tstemp1.append(st1)
                    aw.qmc.tstemp2.append(st2)

                    if aw.qmc.smooth_curves_on_recording:
                        cf = aw.qmc.curvefilter 
                        if self.temp_decay_weights is None or len(self.temp_decay_weights) != cf: # recompute only on changes
                            self.temp_decay_weights = numpy.arange(1,cf+1)
                        # we don't smooth st'x if last, or butlast temperature value were a drop-out not to confuse the RoR calculation
                        if -1 in aw.qmc.temp1[-(cf+1):]: 
                            dw1 = [1]
                        else:
                            dw1 = self.temp_decay_weights
                        if -1 in aw.qmc.temp2[-(cf+1):]:
                            dw2 = [1]
                        else:
                            dw2 = self.temp_decay_weights
                        # average smoothing
                        d = aw.qmc.delay / 1000.
                        if len(aw.qmc.ctemp1) > 0:
                            sst1 = self.decay_average(aw.qmc.ctimex1,aw.qmc.ctemp1,dw1)
                        else:
                            sst1 = -1
                        if len(aw.qmc.ctemp2) > 0:
                            sst2 = self.decay_average(aw.qmc.ctimex2,aw.qmc.ctemp2,dw2)
                        else:
                            sst2 = -1
                        # register smoothed values
                        aw.qmc.stemp1.append(sst1)
                        aw.qmc.stemp2.append(sst2)
                    
                    if local_flagstart:
                        if aw.qmc.ETcurve:
                            if aw.qmc.smooth_curves_on_recording:
                                aw.qmc.l_temp1.set_data(aw.qmc.ctimex1, aw.qmc.stemp1)
                            else:
                                aw.qmc.l_temp1.set_data(aw.qmc.ctimex1, aw.qmc.ctemp1)
                        if aw.qmc.BTcurve:
                            if aw.qmc.smooth_curves_on_recording:
                                aw.qmc.l_temp2.set_data(aw.qmc.ctimex2, aw.qmc.stemp2)
                            else:             
                                aw.qmc.l_temp2.set_data(aw.qmc.ctimex2, aw.qmc.ctemp2)

                    if (aw.qmc.Controlbuttonflag and aw.pidcontrol.pidActive and \
                            not aw.pidcontrol.externalPIDControl()): # any device and + Artisan Software PID lib
                        if aw.pidcontrol.pidSource == 1:
                            aw.qmc.pid.update(st2) # smoothed BT
                        else:
                            aw.qmc.pid.update(st1) # smoothed ET
                            
                    #we need a minimum of two readings to calculate rate of change
                    if local_flagstart and length_of_qmc_timex > 1:
                        # compute T1 RoR
                        if t1_final == -1:  # we repeat the last RoR if underlying temperature dropped
                            if aw.qmc.unfiltereddelta1:
                                aw.qmc.rateofchange1 = aw.qmc.unfiltereddelta1[-1]
                            else:
                                aw.qmc.rateofchange1 = 0.
                        else: # normal data received
                            #   Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
                            left_index = min(len(aw.qmc.ctimex1),max(2,(aw.qmc.deltaETsamples + 1)))
                            timed = aw.qmc.ctimex1[-1] - aw.qmc.ctimex1[-left_index]   #time difference between last aw.qmc.deltaETsamples readings
                            aw.qmc.rateofchange1 = ((aw.qmc.tstemp1[-1] - aw.qmc.tstemp1[-left_index])/timed)*60.  #delta ET (degress/minute)
                            if aw.qmc.DeltaETfunction is not None and len(aw.qmc.DeltaETfunction):
                                try:
                                    aw.qmc.rateofchange1 = aw.qmc.eval_math_expression(aw.qmc.DeltaETfunction,tx,RTsname="R1",RTsval=aw.qmc.rateofchange1)
                                except:
                                    pass
                        # compute T2 RoR
                        if t2_final == -1:  # we repeat the last RoR if underlying temperature dropped
                            if aw.qmc.unfiltereddelta2:
                                aw.qmc.rateofchange2 = aw.qmc.unfiltereddelta2[-1]
                            else:
                                aw.qmc.rateofchange2 = 0.
                        else: # normal data received
                            #   Delta T = (changeTemp/ChangeTime)*60. =  degress per minute;
                            left_index = min(len(aw.qmc.ctimex2),max(2,(aw.qmc.deltaBTsamples + 1)))
                            timed = aw.qmc.ctimex2[-1] - aw.qmc.ctimex2[-left_index]   #time difference between last aw.qmc.deltaBTsamples readings
                            aw.qmc.rateofchange2 = ((aw.qmc.tstemp2[-1] - aw.qmc.tstemp2[-left_index])/timed)*60.  #delta BT (degress/minute)
                            if aw.qmc.DeltaBTfunction is not None and len(aw.qmc.DeltaBTfunction):
                                try:
                                    aw.qmc.rateofchange2 = aw.qmc.eval_math_expression(aw.qmc.DeltaBTfunction,tx,RTsname="R2",RTsval=aw.qmc.rateofchange2)
                                except:
                                    pass

                        aw.qmc.unfiltereddelta1.append(aw.qmc.rateofchange1)
                        aw.qmc.unfiltereddelta2.append(aw.qmc.rateofchange2)
                        
                        #######   filter deltaBT deltaET
                        # decay smoothing
                        if aw.qmc.deltaETfilter:
                            user_filter = int(round(aw.qmc.deltaETfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(aw.qmc.unfiltereddelta1) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = numpy.arange(1,user_filter+1)
                                aw.qmc.rateofchange1 = self.decay_average(aw.qmc.timex,aw.qmc.unfiltereddelta1,self.decay_weights)
                        if aw.qmc.deltaBTfilter:
                            user_filter = int(round(aw.qmc.deltaBTfilter/2.))
                            if user_filter and length_of_qmc_timex > user_filter and (len(aw.qmc.unfiltereddelta2) > user_filter):
                                if self.decay_weights is None or len(self.decay_weights) != user_filter: # recompute only on changes
                                    self.decay_weights = numpy.arange(1,user_filter+1)
                                aw.qmc.rateofchange2 = self.decay_average(aw.qmc.timex,aw.qmc.unfiltereddelta2,self.decay_weights)
                        if aw.qmc.timeindex[6]:
                            rateofchange1plot = None
                            rateofchange2plot = None
                        else:
                            rateofchange1plot = aw.qmc.rateofchange1
                            rateofchange2plot = aw.qmc.rateofchange2
                    else:
                        if local_flagstart: # recording started, but not yet enough readings to calc a RoR
                            aw.qmc.unfiltereddelta1.append(0.)
                            aw.qmc.unfiltereddelta2.append(0.)
                        else:
                            if len(aw.qmc.unfiltereddelta1) > 0:
                                aw.qmc.unfiltereddelta1[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta1.append(0.)
                            if len(aw.qmc.unfiltereddelta2) > 0:
                                aw.qmc.unfiltereddelta2[-1] = 0.
                            else:
                                aw.qmc.unfiltereddelta2.append(0.)
                        aw.qmc.rateofchange1,aw.qmc.rateofchange2,rateofchange1plot,rateofchange2plot = 0.,0.,0.,0.
                        
                        
                    # show RoR only 10 readings after CHARGE
                    if aw.qmc.timeindex[0] == -1 or (aw.qmc.timeindex[0]>-1 and len(aw.qmc.timex) < aw.qmc.timeindex[0] + 10):
                        rateofchange1plot = None
                        rateofchange2plot = None
                    # limit displayed RoR (only before TP is recognized) # WHY?
                    elif aw.qmc.RoRlimitFlag: # not aw.qmc.TPalarmtimeindex and aw.qmc.RoRlimitFlag:
                        if rateofchange1plot is not None and not (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < rateofchange1plot < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)):
                            rateofchange1plot = None
                        if rateofchange2plot is not None and not (max(-aw.qmc.maxRoRlimit,aw.qmc.RoRlimitm) < rateofchange2plot < min(aw.qmc.maxRoRlimit,aw.qmc.RoRlimit)):
                            rateofchange2plot = None
                            
                    # append new data to the rateofchange arrays
                    if local_flagstart:
                        # only after CHARGE and we have enough readings to fully apply the delta_span and delta_smoothing, we draw the resulting lines
                        # and only 7 readings after CHARGE
                        if aw.qmc.timeindex[0] > -1 and length_of_qmc_timex>9+aw.qmc.timeindex[0] and length_of_qmc_timex > int(round(aw.qmc.deltaETfilter/2.)) + max(2,(aw.qmc.deltaETsamples + 1)):
                            aw.qmc.delta1.append(rateofchange1plot)
                        else:
                            aw.qmc.delta1.append(None)
                        if aw.qmc.timeindex[0] > -1 and length_of_qmc_timex>9+aw.qmc.timeindex[0] and length_of_qmc_timex > int(round(aw.qmc.deltaBTfilter/2.)) + max(2,(aw.qmc.deltaBTsamples + 1)):
                            aw.qmc.delta2.append(rateofchange2plot)
                        else:
                            aw.qmc.delta2.append(None)
                    else:
                        if len(aw.qmc.delta1) > 0:
                            aw.qmc.delta1[-1] = rateofchange1plot
                        else:
                            aw.qmc.delta1.append(rateofchange1plot)
                        if len(aw.qmc.delta2) > 0:
                            aw.qmc.delta2[-1] = rateofchange2plot
                        else:
                            aw.qmc.delta2.append(rateofchange2plot)
                    
                    if local_flagstart:
                        if aw.qmc.DeltaETflag:
                            aw.qmc.l_delta1.set_data(aw.qmc.timex, aw.qmc.delta1)
                        if aw.qmc.DeltaBTflag:
                            aw.qmc.l_delta2.set_data(aw.qmc.timex, aw.qmc.delta2)
                        #readjust xlimit of plot if needed
                        if  not aw.qmc.fixmaxtime and not aw.qmc.locktimex and aw.qmc.timex[-1] > (aw.qmc.endofx - 45):            # if difference is smaller than 30 seconds
                            aw.qmc.endofx = int(aw.qmc.timex[-1] + 180.)         # increase x limit by 3 minutes
                            aw.qmc.xaxistosm(redraw=False) # don't redraw within the sampling process!!
                            aw.qmc.tempory_sample_trigger_redraw = True # we enfore a full redraw within updategraphics
                        if aw.qmc.projectFlag:
                            aw.qmc.updateProjection()
                        
                        # autodetect CHARGE event
                        # only if BT > 77C/170F
                        if not aw.qmc.autoChargeIdx and aw.qmc.autoChargeFlag and aw.qmc.autoCHARGEenabled and aw.qmc.timeindex[0] < 0 and length_of_qmc_timex >= 5 and \
                            ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 77) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 170)):
                            if aw.qmc.mode == "C":
                                o = 0.5
                            else:
                                o = 0.5 * 1.8
                            b = aw.BTbreak(length_of_qmc_timex - 1,o)
                            if b > 0:
                                # we found a BT break at the current index minus b
                                aw.qmc.autoChargeIdx = length_of_qmc_timex - b
                        # check for TP event if already CHARGEed and not yet recognized (earliest in the next call to sample())
                        elif not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and aw.qmc.timeindex[0]+8 < len(aw.qmc.temp2) and self.checkTPalarmtime():                            
                            try:
                                tp = aw.findTP()
                                if ((aw.qmc.mode == "C" and aw.qmc.temp2[tp] > 50 and aw.qmc.temp2[tp] < 150) or \
                                    (aw.qmc.mode == "F" and aw.qmc.temp2[tp] > 100 and aw.qmc.temp2[tp] < 300)): # only mark TP if not an error value!
                                    aw.qmc.autoTPIdx = 1
                                    aw.qmc.TPalarmtimeindex = tp
                            except:
                                pass
                            try:
                                # if 2:30min into the roast and TPalarmtimeindex alarmindex not yet set,
                                # we place the TPalarmtimeindex at the current index to enable in airoasters without TP the autoDRY and autoFCs functions and activate the TP Phases LCDs
                                if aw.qmc.TPalarmtimeindex is None and ((aw.qmc.timex[-1] - aw.qmc.timex[aw.qmc.timeindex[0]]) > 150):
                                    aw.qmc.TPalarmtimeindex = length_of_qmc_timex - 1
                            except:
                                pass
                        # autodetect DROP event
                        # only if 8min into roast and BT>160C/320F
                        if not aw.qmc.autoDropIdx and aw.qmc.autoDropFlag and aw.qmc.autoDROPenabled and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[6] and \
                            length_of_qmc_timex >= 5 and ((aw.qmc.mode == "C" and aw.qmc.temp2[-1] > 160) or (aw.qmc.mode == "F" and aw.qmc.temp2[-1] > 320)) and\
                            ((aw.qmc.timex[-1] - aw.qmc.timex[aw.qmc.timeindex[0]]) > 420):
                            if aw.qmc.mode == "C":
                                o = 0.2
                            else:
                                o = 0.2 * 1.8                            
                            b = aw.BTbreak(length_of_qmc_timex - 1,o)
                            if b > 0:
                                # we found a BT break at the current index minus b
                                aw.qmc.autoDropIdx = length_of_qmc_timex - b
                        #check for autoDRY: # only after CHARGE and TP and before FCs if not yet set
                        if aw.qmc.autoDRYflag and aw.qmc.autoDRYenabled and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[1] and not aw.qmc.timeindex[2]:
                            # if DRY event not yet set check for BT exceeding Dry-max as specified in the phases dialog
                            if aw.qmc.temp2[-1] >= aw.qmc.phases[1]:
                                aw.qmc.autoDryIdx = 1
                        #check for autoFCs: # only after CHARGE and TP and before FCe if not yet set
                        if aw.qmc.autoFCsFlag and aw.qmc.autoFCsenabled and aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and not aw.qmc.timeindex[2] and not aw.qmc.timeindex[3]:
                            # after DRY (if FCs event not yet set) check for BT exceeding FC-min as specified in the phases dialog
                            if aw.qmc.temp2[-1] >= aw.qmc.phases[2]:
                                aw.qmc.autoFCsIdx = 1

                    #process active quantifiers
                    try:
                        aw.process_active_quantifiers()
                    except Exception:
                        pass
                        
                    #update SV on Arduino/TC4, Hottop, or MODBUS if in Ramp/Soak or Background Follow mode and PID is active
                    if aw.qmc.flagon: # only during sampling
                        #update SV on FujiPIDs
                        if aw.qmc.device == 0 and aw.fujipid.followBackground:
                            # calculate actual SV
                            sv = aw.fujipid.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != aw.fujipid.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.qmc.temporarysetsv = sv
                                # aw.fujipid.setsv(sv,silent=True) # this is called in updategraphics() within the GUI thread to move the sliders
                        elif aw.pidcontrol.pidActive and aw.pidcontrol.svMode in [1,2]:
                            # calculate actual SV
                            sv = aw.pidcontrol.calcSV(tx)
                            # update SV (if needed)
                            if sv is not None and sv != aw.pidcontrol.sv:
                                sv = max(0,sv) # we don't send SV < 0
                                aw.qmc.temporarysetsv = sv
                                # aw.pidcontrol.setSV(sv,init=False) # this is called in updategraphics() within the GUI thread to move the sliders
                                
                    # update AUC running value
                    if local_flagstart: # only during recording
                        try:
                            aw.updateAUC()
                            if aw.qmc.AUCguideFlag:
                                aw.updateAUCguide()
                        except:
                            pass
                                
                    #output ET, BT, ETB, BTB to output program
                    if aw.ser.externaloutprogramFlag:
                        try:
                            if aw.qmc.background:
                                if aw.qmc.timeindex[0] != -1:
                                    j = aw.qmc.backgroundtime2index(tx - aw.qmc.timex[aw.qmc.timeindex[0]])
                                else:
                                    j = aw.qmc.backgroundtime2index(tx)
                                ETB = aw.qmc.temp1B[j]
                                BTB = aw.qmc.temp2B[j]
                            else:
                                ETB = -1
                                BTB = -1
                            subprocess.call([aw.ser.externaloutprogram,
                                '{0:.1f}'.format(aw.qmc.temp1[-1]),
                                '{0:.1f}'.format(aw.qmc.temp2[-1]),
                                '{0:.1f}'.format(ETB),
                                '{0:.1f}'.format(BTB)])
                        except:
                            pass

                    #check for each alarm that was not yet triggered
                    for i in range(len(aw.qmc.alarmflag)):
                        #if alarm on, and not triggered, and time is after set time:
                        # menu: 0:ON, 1:START, 2:CHARGE, 3:TP, 4:DRY, 5:FCs, 6:FCe, 7:SCs, 8:SCe, 9:DROP, 10:COOL
                        # qmc.alarmtime = -1 (None == START)
                        # qmc.alarmtime = 0 (CHARGE)
                        # qmc.alarmtime = 1 (DRY)
                        # qmc.alarmtime = 2 (FCs)
                        # qmc.alarmtime = 3 (FCe)
                        # qmc.alarmtime = 4 (SCs)
                        # qmc.alarmtime = 5 (SCe)
                        # qmc.alarmtime = 6 (DROP)
                        # qmc.alarmtime = 7 (COOL)
                        # qmc.alarmtime = 8 (TP)
                        # qmc.alarmtime = 9 (ON)
                        # qmc.alamrtime = 10 (If Alarm)
                        # Cases: (only between CHARGE and DRY we check for TP if alarmtime[i]=8)
                        # 1) the alarm From is START
                        # 2) the alarm was not triggered yet
                        # 3) the alarm From is ON
                        # 4) the alarm From is CHARGE
                        # 5) the alarm From is any other event but TP
                        # 6) the alarm From is TP, it is CHARGED and the TP pattern is recognized
                        if aw.qmc.alarmflag[i] \
                          and aw.qmc.alarmstate[i] == -1 \
                          and (aw.qmc.alarmguard[i] < 0 or (0 <= aw.qmc.alarmguard[i] < len(aw.qmc.alarmstate) and aw.qmc.alarmstate[aw.qmc.alarmguard[i]] != -1)) \
                          and (aw.qmc.alarmnegguard[i] < 0 or (0 <= aw.qmc.alarmnegguard[i] < len(aw.qmc.alarmstate) and aw.qmc.alarmstate[aw.qmc.alarmnegguard[i]] == -1)) \
                          and ((aw.qmc.alarmtime[i] == 9) or (aw.qmc.alarmtime[i] < 0 and local_flagstart) \
                            or (aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1) \
                            or (aw.qmc.alarmtime[i] > 0 and aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0) \
                            or (aw.qmc.alarmtime[i] == 10 and aw.qmc.alarmguard[i] != -1)  \
                            or (aw.qmc.alarmtime[i] == 8 and aw.qmc.timeindex[0] > -1 \
                                and aw.qmc.TPalarmtimeindex)):
                            #########
                            # check alarmoffset (time after From event):
                            if aw.qmc.alarmoffset[i] > 0:
                                alarm_time = aw.qmc.timeclock.elapsed()/1000.
                                if aw.qmc.alarmtime[i] < 0: # time after START
                                    pass # the alarm_time is the clock time
                                elif aw.qmc.alarmtime[i] == 0 and aw.qmc.timeindex[0] > -1: # time after CHARGE
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[0]]
                                elif aw.qmc.alarmtime[i] == 8 and aw.qmc.TPalarmtimeindex: # time after TP
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.TPalarmtimeindex]
                                elif aw.qmc.alarmtime[i] < 8 and aw.qmc.timeindex[aw.qmc.alarmtime[i]] > 0: # time after any other event
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.timeindex[aw.qmc.alarmtime[i]]]
                                elif aw.qmc.alarmtime[i] == 10: # time or temp after the trigger of the alarmguard (if one is set)
                                    # we know here that the alarmstate of the guard is valid as it has triggered
                                    alarm_time = alarm_time - aw.qmc.timex[aw.qmc.alarmstate[aw.qmc.alarmguard[i]]]
                                
                                if alarm_time >= aw.qmc.alarmoffset[i]:
                                    aw.qmc.temporaryalarmflag = i
                            #########
                            # check alarmtemp:
                            alarm_temp = None
                            if aw.qmc.alarmtime[i] == 10: # IF ALARM and only during recording as otherwise no data to refer to is available
                                # and this is a conditional alarm with alarm_time set to IF ALARM
                                if_alarm_state = aw.qmc.alarmstate[aw.qmc.alarmguard[i]] # reading when the IF ALARM triggered
                                if if_alarm_state != -1:
                                    if if_alarm_state < len(aw.qmc.timex):
                                        alarm_idx = if_alarm_state
                                    else:
                                        alarm_idx = -1
                                # we substract the reading at alarm_idx from the current reading of the channel determined by alarmsource
                            else:
                                alarm_idx = None
                            if aw.qmc.alarmsource[i] == -2 and aw.qmc.delta1[-1]:  #check DeltaET (might be None)
                                alarm_temp = aw.qmc.delta1[-1]
                                if alarm_idx != None:
                                    alarm_temp -= aw.qmc.delta1[alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                            elif aw.qmc.alarmsource[i] == -1 and aw.qmc.delta2[-1]: #check DeltaBT (might be None
                                alarm_temp = aw.qmc.delta2[-1]
                                if alarm_idx != None:
                                    alarm_temp -= aw.qmc.delta2[alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                            elif aw.qmc.alarmsource[i] == 0:                      #check ET
                                alarm_temp = aw.qmc.temp1[-1]
                                if alarm_idx != None:
                                    alarm_temp -= aw.qmc.temp1[alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                            elif aw.qmc.alarmsource[i] == 1:                      #check BT
                                alarm_temp = aw.qmc.temp2[-1]
                                if alarm_idx != None:
                                    alarm_temp -= aw.qmc.temp2[alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                            elif aw.qmc.alarmsource[i] > 1 and ((aw.qmc.alarmsource[i] - 2) < (2*len(aw.qmc.extradevices))):
                                if (aw.qmc.alarmsource[i])%2==0:
                                    alarm_temp = aw.qmc.extratemp1[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                    if alarm_idx != None:
                                        alarm_temp -= aw.qmc.extratemp1[(aw.qmc.alarmsource[i] - 2)//2][alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                                else:
                                    alarm_temp = aw.qmc.extratemp2[(aw.qmc.alarmsource[i] - 2)//2][-1]
                                    if alarm_idx != None:
                                        alarm_temp -= aw.qmc.extratemp2[(aw.qmc.alarmsource[i] - 2)//2][alarm_idx] # substract the reading at alarm_idx for IF ALARMs
                                
                            alarm_limit = aw.qmc.alarmtemperature[i]
                            if alarm_temp is not None and alarm_temp != -1 and (
                                    (aw.qmc.alarmcond[i] == 1 and alarm_temp > alarm_limit) or 
                                    (aw.qmc.alarmcond[i] == 0 and alarm_temp < alarm_limit) or
                                    (alarm_idx != None and alarm_temp == alarm_limit)): # for relative IF_ALARMS we include the equality
                                aw.qmc.temporaryalarmflag = i

                #############    if using DEVICE 18 (no device). Manual mode
                # temperatures are entered when pressing push buttons like for example at aw.qmc.markDryEnd()
                else:
                    tx = int(aw.qmc.timeclock.elapsed()/1000.)
                    #readjust xlimit of plot if needed
                    if  not aw.qmc.fixmaxtime and not aw.qmc.locktimex and tx > (aw.qmc.endofx - 45):            # if difference is smaller than 45 seconds
                        aw.qmc.endofx = tx + 180              # increase x limit by 3 minutes (180)
                        aw.qmc.ax.set_xlim(aw.qmc.startofx,aw.qmc.endofx)
                        aw.qmc.xaxistosm(redraw=False) # don't redraw within the sampling process!!
                    #aw.qmc.resetlines()
                    # also in the manual case we check for TP
                    if local_flagstart:
                        # check for TP event if already CHARGEed and not yet recognized
                        if not aw.qmc.TPalarmtimeindex and aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[0]+5 < len(aw.qmc.temp2) and self.checkTPalarmtime():
                            aw.qmc.autoTPIdx = 1
                            aw.qmc.TPalarmtimeindex = aw.findTP()
#                #add to plot a vertical time line
#                if aw.qmc.flagstart and (aw.qmc.showtimeguide or aw.qmc.device == 18) and aw.qmc.l_timeline is not None:
#                    aw.qmc.l_timeline.set_data([tx,tx], [aw.qmc.ylimit_min,aw.qmc.ylimit])
            except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " sample() {0}").format(str(e)),exc_tb.tb_lineno)
            finally:
                if aw.qmc.samplingsemaphore.available() < 1:
                    aw.qmc.samplingsemaphore.release(1)
                #update screen in main GUI thread
                self.updategraphics.emit()


    # returns true after BT passed the TP
    def checkTPalarmtime(self):
        seconds_since_CHARGE = int(aw.qmc.timex[-1]-aw.qmc.timex[aw.qmc.timeindex[0]])
        # if v[-1] is the current temperature then check if
        #   we are 20sec after CHARGE
        #   len(BT) > 4
        # BT[-5] <= BT[-4] abd BT[-5] <= BT[-3] and BT[-5] <= BT[-2] and BT[-5] <= BT[-1] and BT[-5] < BT[-1]
        if seconds_since_CHARGE > 20 and not self.afterTP and len(aw.qmc.temp2) > 3 and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-4]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-3]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-2]) and (aw.qmc.temp2[-5] <= aw.qmc.temp2[-1]) and (aw.qmc.temp2[-5] < aw.qmc.temp2[-1]):
            self.afterTP = True
        return self.afterTP

    def run(self):
        try:
            aw.qmc.flagsamplingthreadrunning = True
            if sys.platform.startswith("darwin"):
                pool = Foundation.NSAutoreleasePool.alloc().init()  # @UndefinedVariable
            self.afterTP = False
            if not aw.qmc.flagon:
                return
            
            # initialize digitizer
            aw.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
            aw.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier

            interval = aw.qmc.delay/1000.
            next_tx = libtime.perf_counter()
            while True:
                if aw.qmc.flagon:
                    # if we are already beyond 1/4 of the next sampling we skip this one
                    if libtime.perf_counter() < (next_tx + 0.25*interval):
                        # only if we still have the time in this sampling interval, we sample
                        
#                        print(datetime.datetime.now()) # use this to check for drifts
                        
                        #collect information
                        try:
                            aw.qmc.flagsampling = True # we signal that we are sampling
                            self.sample()
                        finally:
                            aw.qmc.flagsampling = False # we signal that we are done with sampling
                        
                    # calculate the time still to sleep based on the time the sampling took and the requested sampling interval (qmc.delay)
                    # apply sampling interval here
                    if aw.qmc.flagon:
                        next_tx += interval
                        now = libtime.perf_counter()
                        libtime.sleep(max(0.2,next_tx - now)) # the 200ms here to allow other threads to intercept
                else:
                    aw.qmc.flagsampling = False # we signal that we are done with sampling
                    try:
                        if aw.ser.SP.isOpen():
                            aw.ser.closeport()
                        QApplication.processEvents()
                    except Exception:
                        pass
                    self.quit()
                    break  #thread ends
        finally:
            aw.qmc.flagsampling = False # we signal that we are done with sampling
            aw.qmc.flagsamplingthreadrunning = False
            if sys.platform.startswith("darwin"):
                del pool

#########################################################################################################
###     Artisan thread Server
#########################################################################################################

class Athreadserver(QWidget):
    def __init__(self,parent = None):
        super(Athreadserver,self).__init__(parent)

    def createSampleThread(self):
        if not aw.qmc.flagsamplingthreadrunning: # we only start a new sampling thread if none is running yet
            sthread = SampleThread(self)
            sthread.decay_weights = None
            sthread.temp_decay_weights = None
            #QApplication.processEvents()

            #connect graphics to GUI thread
            sthread.updategraphics.connect(aw.qmc.updategraphics)
            sthread.start(QThread.TimeCriticalPriority) # QThread.HighPriority, QThread.HighestPriority
            sthread.wait(300)    #needed in some Win OS


#########################################################################################################
###     Event Action Thread
#########################################################################################################

class EventActionThread(QThread):

    def __init__(self, action, command):
        QThread.__init__(self)
        self.action = action
        self.command = command

    def run(self):    
        aw.eventaction_internal(self.action,self.command)


########################################################################################
#################### MAIN APPLICATION WINDOW ###########################################
########################################################################################


class ApplicationWindow(QMainWindow):
    global locale

    singleShotPhidgetsPulseOFF = pyqtSignal(int,int,str) # signal to be called from the eventaction thread to realise Phidgets pulse via QTimer in the main thread
    singleShotPhidgetsPulseOFFSerial = pyqtSignal(int,int,str,str)
#PLUS
    updatePlusStatusSignal = pyqtSignal() # can be called from another thread or a QTimer to trigger to update the plus icon status
    setTitleSignal = pyqtSignal(str,bool) # can be called from another thread or a QTimer to set the profile title in the main GUI thread
    sendmessageSignal = pyqtSignal(str,bool,str)
    openPropertiesSignal = pyqtSignal()
    
    def __init__(self, parent = None):
    
        self.superusermode = False
        
#PLUS
        self.plus_account = None # if set to a login string, Artisan plus features are enabled
        self.plus_remember_credentials = True # store plus account credentials in systems keychain
        self.plus_email = None # if self.plus_remember_credentials is ticked, we remember here the login to be pre-set as plus_account in the dialog
        self.plus_language = "en" # one of ["en", "de", "it"] indicates the language setting of the plus_account used on the artisan.plus platform,
                # used in links back to objects on the platform (see plus/util.py#storeLink() and similars)
        self.plus_subscription = None # one of [None, "HOME", "PRO"]
        self.plus_paidUntil = None # either None if unknown or otherwise a Date object with indicating the expiration date of the account
        self.plus_readonly = False # True if the plus user has only read rights to the plus account
        
        self.appearance = ""
        
        # matplotlib font properties:
        self.mpl_fontproperties = mpl.font_manager.FontProperties()
        self.full_screen_mode_active = False
        
        self.processingKeyEvent = False
        
        self.quickEventShortCut = None 
        # this is None if inactive, or holds a tuple (n,s) with n a number {1,..,4} indicating the custom event number
        # and s a string of length 0 (no digit yet), length 1 (if first digit is typed) or 2 (both digits are typed) indicating the value (00-99)
        
        
        self.eventaction_running_threads = []
        
        # locales that come with a standard qtbase translation for standard elements/buttons
        # for other locales standard OK/Cancel buttons created in dialogs via QDialogButtonBoxes should be
        # renamed via setText to link them to artisan translations (which hopefully provides those translations)

        self.qtbase_locales = ["ar","de","en","es","fi","fr","he","hu","it","ja","ko","pl","ru","artisan_zh_TW"] + ["fa","pt","sv","zh_CN"]
        
        try:
            if locale is None or locale == "None": 
                self.locale = "en"
            else:
                self.locale = locale
        except Exception:
            self.locale = "en"

        #############################  Define variables that need to exist before calling settingsload()
        self.curFile = None
        self.MaxRecentFiles = 20
        self.recentFileActs = []
        self.recentSettingActs = []
        self.recentThemeActs = []
        self.applicationDirectory =  QDir().current().absolutePath()
        
        super(ApplicationWindow, self).__init__(parent)
        
        # a timer that is triggered by resizing the main window
        self.redrawTimer = QTimer()
        self.redrawTimer.setSingleShot(True)
        self.redrawTimer.timeout.connect(self.redraw_action)
        
        # used on startup to reload previous loaded profiles
        self.lastLoadedProfile = ""
        self.lastLoadedBackground = ""
        
        # analyzer
        self.analysisresultsanno = None
        self.segmentresultsanno = None
        
        # large LCDs
        self.largeLCDs_dialog = None
        self.LargeLCDsFlag = False
        self.largeDeltaLCDs_dialog = None
        self.LargeDeltaLCDsFlag = False
        self.largePIDLCDs_dialog = None
        self.LargePIDLCDsFlag = False
        self.largeExtraLCDs_dialog = None
        self.LargeExtraLCDsFlag = False
        self.largePhasesLCDs_dialog = None
        self.LargePhasesLCDsFlag = False
        self.WebLCDs = False
        self.WebLCDsPort = 8080
        self.WebLCDsAlerts = False


        #flag to reset Qsettings
        self.resetqsettings = 0
        #path of last loadded QSettings
        self.settingspath = "" # if empty string, the settingspath will be ignored, otherwise it will be used to update the batchcounter of those settings
        
        # path of last loaded WheelGraph
        self.wheelpath = ""

        # self.profilepath is obteined at dirstruct() and points to profiles/year/month file-open/save will point to profilepath
        self.profilepath = ""
        if platf == 'Darwin' or platf == 'Linux':
            self.profilepath = QDir().homePath() + u("/Documents/")
        else:
            self.profilepath = QDir().homePath()
            
        # on the Mac preferences should be stored outside of applications in the users ~/Library/Preferences path
        if platf == 'Darwin':
            preference_path = QDir().homePath() + u("/Library/Preferences//")
            preference_dir = QDir()
            preference_dir.setPath(preference_path)
            if not preference_dir.exists():
                QDir().mkpath(preference_path)
            QDir().setCurrent(preference_path)

        #checks executable directory. dirstruct() checks or creates: /profile/year/month directory to store profiles
        #self.dirstruct()


        #defaults the users profile path to the standard profilepath (incl. month/year subdirectories)
        self.userprofilepath = self.profilepath

        self.printer = QPrinter(QPrinter.HighResolution)
        self.printer.setCreator("Artisan")

        self.main_widget = QWidget(self)
        #set a minimum size (main window can be bigger but never smaller)
        self.main_widget.setMinimumWidth(800)
        #self.main_widget.setMinimumHeight(670)

        ####      create Matplotlib canvas widget
        #resolution
        self.defaultdpi = 100
        self.dpi = self.defaultdpi
        
        #mpl.rc_context({'toolbar': None}) # this does not work to remove the default toolbar
        #mpl.rcParams['toolbar'] == None # this does not work to remove the default toolbar
                
        settings = QSettings()
        if settings.contains("dpi") and (not settings.contains("resetqsettings") or toInt(settings.value("resetqsettings",self.resetqsettings)) == 0):
            try:
                self.dpi = toInt(settings.value("dpi",self.dpi))
            except:
                pass
        
        self.qmc = tgraphcanvas(self.main_widget,self.dpi)
        
        #self.qmc.setAttribute(Qt.WA_NoSystemBackground)
        
        #### Hottop Control
        self.HottopControlActive = False
        
        #### Async Sampling Action
        self.AsyncSamplingAction = False
        
        self.wheeldialog = None
        
        self.simulator = None # holds the simulator in simulation mode
        self.simulatorpath = None # points to the last profile used by the simulator

        ####    HUD
        self.HUD = QLabel()  #main canvas for hud widget
        self.HUD.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)

        #This is a list of different HUD functions.
        self.showHUD = [self.showHUDmetrics, self.showHUDthermal]
        #this holds the index of the HUD functions above
        self.HUDfunction = 0

        self.stack = QStackedWidget()
        self.stack.addWidget(self.qmc)
        self.stack.addWidget(self.HUD)
        self.stack.setCurrentIndex(0)
        self.stack.setContentsMargins(0,0,0,0)
        self.qmc.setContentsMargins(0,0,0,0)
        self.HUD.setContentsMargins(0,0,0,0)
        #events config
        self.eventsbuttonflag = 0
        self.minieventsflag = 0   #minieditor flag
        
        #records serial comm (Help menu)
        self.seriallogflag = False
        self.seriallog = []

        #create a serial port object (main ET BT device)
        self.ser = serialport()
        #create a modbus port object (main modbus device)
        self.modbus = modbusport(self.sendmessage,self.qmc.adderror,self.addserial,self)
        #temporary storage to pass values. Holds the MODBUS channels T1 and T2 as well as the extra channels T3, T4, T5 and T6 values for MODBUS connected devices
        self.extraMODBUStemps = [-1]*self.modbus.channels
        self.extraMODBUStx = 0.
        
        #create an s7 port object (main s7 device)
        self.s7 = s7port(self.sendmessage,self.qmc.adderror,self.addserial,self)
        #create scale port object
        self.scale = scaleport()
        #create color port object
        self.color = colorport()
        #list with extra serial ports (extra devices)
        self.extraser = []
        #extra comm port settings 
        self.extracomport,self.extrabaudrate,self.extrabytesize,self.extraparity,self.extrastopbits,self.extratimeout = [],[],[],[],[],[]

        # create a ET control objects
        self.fujipid = FujiPID()
        self.dtapid = DtaPID()
        # PID control for Arduino, Hottop and generic MODBUS devices
        self.pidcontrol = PIDcontrol()
        
        self.soundflag = 0
        
        # recent roasts, an ordered list (first-in, first-out) of dictionaries holding partial roast-properties and a link to the background profile if any
        self.recentRoasts = []
        self.maxRecentRoasts = 25 # the maximum number of recent roasts held

        #lcd1 = time, lcd2 = met, lcd3 = bt, lcd4 = roc et, lcd5 = roc bt, lcd6 = sv (extra devices lcd same as sv seetings)
        self.lcdpaletteB = {
            "timer":'#F8F8F8',
            "et":'#cc0f50', #'black',
            "bt":'#0A5C90', #'black',
            "deltaet":'#EBEBEB', #'black',
            "deltabt":'#EBEBEB', #'black',
            "sv":'#F8F8F8', #'black'
            }
        self.lcdpaletteF = {
            "timer":'#262626',
            "et":'white', #'white',
            "bt":'white', #'white',
            "deltaet":'#cc0f50', #'white',
            "deltabt":'#0A5C90', #'white',
            "sv":'#4C4C4C'
            }

        #user defined event buttons
        self.extraeventsbuttonsflags = [0,1,1] # extra button visibility per state OFF, ON, START
        self.extraeventslabels,self.extraeventsdescriptions, self.extraeventstypes,self.extraeventsvalues = [],[],[],[]  #hold string,string,index,index
        # extraeventtypes: 
        #  0-3: custom event types (absolute value assignments)
        #  4: no event type assigned
        #  5-8: custom event types (relative value assignments; +/- steps)
        self.extraeventbuttoncolor,self.extraeventbuttontextcolor = [],[]
        self.extraeventsactionstrings,self.extraeventsactions,self.extraeventsvisibility = [],[],[] #hold string,index,index
        
        # indicates if the button is 
        #   0: square
        #   1: left rounded
        #   2: right rounded
        #   3: rounded on both sides
        self.extraeventbuttonround = [] # set by realignbuttons on rendering the button rows and read by setExtraEventButtonStyle to update the style

        # quantification is blocked if lock_quantification_sampling_ticks is not 0
        # (eg. after a change of the event value by button or slider actions)
        self.block_quantification_sampling_ticks = [0,0,0,0]
        # by default we block quantification for sampling_ticks_to_block_quantifiction sampling intervals after
        # a button/slider event
        self.sampling_ticks_to_block_quantifiction = 15
                        
        self.extraeventsactionslastvalue = [None,None,None,None]

        #event sliders
        self.eventslidervalues = [0,0,0,0]
        self.eventslidervisibilities = [0,0,0,0]
        self.eventslideractions = [0,0,0,0] # 0: None, 1: Serial Command, 2: Modbus Command, 3: DTA Command, 4: Call Program, 5: Hottop Heater, 6: Hottop Fan
        self.eventslidercommands = ["","","",""]
        self.eventslideroffsets = [0,0,0,0]
        self.eventsliderfactors = [1.0,1.0,1.0,1.0]
        self.eventslidermin = [0,0,0,0]
        self.eventsMaxValue = 999
        self.eventslidermax = [100,100,100,100]
        self.eventslidersflags = [0,1,1] # slider visibility per state OFF, ON, START
        self.eventslidercoarse = [0,0,0,0] # if 1, sliders step in multiples of 10, otherwise 1
        self.eventslidertemp = [0,0,0,0] # if 1, slider values are interpreted as temperatures and min/max limit are converted with the temp mode
        self.eventsliderunits = ["","","",""]
        self.eventslidermoved = [0,0,0,0] # just set on move and reset on release to avoid unprecise slider moves
        self.SVslidermoved = 0
        
        #event quantifiers        
        self.eventquantifieractive = [0,0,0,0]
        self.eventquantifiersource = [0,0,0,0]
        self.eventquantifiermin = [0,0,0,0]
        self.eventquantifiermax = [100,100,100,100]
        self.eventquantifiercoarse = [0,0,0,0]
        self.clusterEventsFlag = False
        self.eventquantifierlinspaces = [self.computeLinespace(0),self.computeLinespace(1),self.computeLinespace(2),self.computeLinespace(3)]
        self.eventquantifiersteps = 10
        self.eventquantifierthresholdfine = .5 # original: 1.5, changed to 0.5 for Probat Probatone
        self.eventquantifierthresholdcoarse = .5
        self.lastdigitizedvalue = [None,None,None,None] # last digitized value per quantifier
        self.lastdigitizedtemp = [None,None,None,None] # last digitized temp value per quantifier
        
        self.readingslcdsflags = [0,1,1] # readings LCD visibility per state OFF, ON, START
        
        #watermark image
        self.logoimgalpha = 2.0
        self.logoimgflag = False # display during OnMonitor?
        self.logofilename = ""
        
        self.redrawOnResize = True # if a logofilename is set and redrawOnResize is True a redraw is triggered; usually set to True!

        # set window title
        if app.artisanviewerMode:
            self.windowTitle = "ArtisanViewer %s"%str(__version__)
        else:
            self.windowTitle = "Artisan %s"%str(__version__)
        self.setWindowTitle(self.windowTitle)
        # populate recent file menu
        for i in range(self.MaxRecentFiles):
            self.recentFileActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentFile))
        # populate recent settings menu
        for i in range(self.MaxRecentFiles):
            self.recentSettingActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentSetting))
        # populate recent themes menu 
        for i in range(self.MaxRecentFiles):
            self.recentThemeActs.append(
                    QAction(self, visible=False,
                            triggered=self.openRecentTheme))


        #temp variable for text searches in Help menu artisan seetings
        self.searchtextartisansettings = ""

        #######################    MENUS SECTION ##################################################
        ###############  create Top MENUS

        
        self.fileMenu = self.menuBar().addMenu(UIconst.FILE_MENU)
        self.editMenu = self.menuBar().addMenu(UIconst.EDIT_MENU)
        self.GraphMenu = self.menuBar().addMenu(UIconst.ROAST_MENU)
        self.ConfMenu = self.menuBar().addMenu(UIconst.CONF_MENU)
        self.ToolkitMenu = self.menuBar().addMenu(UIconst.TOOLKIT_MENU)
        self.viewMenu = self.menuBar().addMenu(UIconst.VIEW_MENU)
        self.helpMenu = self.menuBar().addMenu(UIconst.HELP_MENU)
        
        #FILE menu
        self.newRoastMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_NEW)
        # add NEW menu item
        newRoastAction = QAction(UIconst.FILE_MENU_NEW,self)
        newRoastAction.setShortcut(QKeySequence.New)
        newRoastAction.triggered.connect(self.newRoast)
        self.newRoastMenu.addAction(newRoastAction)

        self.fileLoadAction = QAction(UIconst.FILE_MENU_OPEN,self)
        self.fileLoadAction.setShortcut(QKeySequence.Open)
        self.fileLoadAction.triggered.connect(self.fileLoad)
        self.fileMenu.addAction(self.fileLoadAction)

        self.openRecentMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_OPENRECENT)
        for i in range(self.MaxRecentFiles):
            self.openRecentMenu.addAction(self.recentFileActs[i])
        self.updateRecentFileActions()

        self.importMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_IMPORT)

        fileImportCSVAction = QAction("Artisan CSV...",self)
        fileImportCSVAction.triggered.connect(self.fileImportCSV)
        self.importMenu.addAction(fileImportCSVAction)

        fileImportJSONAction = QAction("Artisan JSON...",self)
        fileImportJSONAction.triggered.connect(self.fileImportJSON)
        self.importMenu.addAction(fileImportJSONAction)
        
        self.importMenu.addSeparator()

        importBulletAction = QAction("Aillio Roastime...",self)
        importBulletAction.triggered.connect(self.importBullet)
        self.importMenu.addAction(importBulletAction)

        importCropsterAction = QAction("Cropster XLS...",self)
        importCropsterAction.triggered.connect(self.importCropster)
        self.importMenu.addAction(importCropsterAction)

        importGiesenAction = QAction("Giesen CSV...",self)
        importGiesenAction.triggered.connect(self.importGiesen)
        self.importMenu.addAction(importGiesenAction)

        importHH506RAAction = QAction("HH506RA...",self)
        importHH506RAAction.triggered.connect(self.importHH506RA)
        self.importMenu.addAction(importHH506RAAction)

        importIkawaAction = QAction("IKAWA CSV...",self)
        importIkawaAction.triggered.connect(self.importIkawa)
        self.importMenu.addAction(importIkawaAction)

        importK202Action = QAction("K202...",self)
        importK202Action.triggered.connect(self.importK202)
        self.importMenu.addAction(importK202Action)

        importK204Action = QAction("K204...",self)
        importK204Action.triggered.connect(self.importK204)
        self.importMenu.addAction(importK204Action)

        importPilotAction = QAction("Probat Pilot...",self)
        importPilotAction.triggered.connect(self.importPilot)
        self.importMenu.addAction(importPilotAction)

        fileImportRoastLoggerAction = QAction("RoastLogger...",self)
        fileImportRoastLoggerAction.triggered.connect(self.fileImportRoastLogger)
        self.importMenu.addAction(fileImportRoastLoggerAction)


        self.fileMenu.addSeparator()

        self.fileSaveAction = QAction(UIconst.FILE_MENU_SAVE,self)
        self.fileSaveAction.setShortcut(QKeySequence.Save)
        self.fileSaveAction.triggered.connect(self.fileSave_current_action)
        self.fileMenu.addAction(self.fileSaveAction)

        self.fileSaveAsAction = QAction(UIconst.FILE_MENU_SAVEAS,self)
        self.fileSaveAsAction.setShortcut(QKeySequence.SaveAs)
        self.fileSaveAsAction.triggered.connect(self.fileSave_new_action)
        self.fileMenu.addAction(self.fileSaveAsAction)

        # same as SaveAs, just that the saved file gets a new roastUUID assigned
        self.fileSaveCopyAsAction = QAction(UIconst.FILE_MENU_SAVECOPYAS,self)
        self.fileSaveCopyAsAction.triggered.connect(self.fileSave_copy_action)
        self.fileMenu.addAction(self.fileSaveCopyAsAction)

        self.fileMenu.addSeparator()

        self.exportMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_EXPORT)

        fileExportCSVAction = QAction(QApplication.translate("Menu", "Artisan CSV...",None),self)
        fileExportCSVAction.triggered.connect(self.fileExportCSV)
        self.exportMenu.addAction(fileExportCSVAction)

        fileExportJSONAction = QAction(QApplication.translate("Menu", "Artisan JSON...",None),self)
        fileExportJSONAction.triggered.connect(self.fileExportJSON)
        self.exportMenu.addAction(fileExportJSONAction)
        
        self.exportMenu.addSeparator()

        fileExportExcelAction = QAction(QApplication.translate("Menu", "Excel...",None),self)
        fileExportExcelAction.triggered.connect(self.fileExportExcel)
        self.exportMenu.addAction(fileExportExcelAction)
        
        self.exportMenu.addSeparator()

        fileExportPilotAction = QAction(QApplication.translate("Menu", "Probat Pilot...",None),self)
        fileExportPilotAction.triggered.connect(self.fileExportPilot)
        self.exportMenu.addAction(fileExportPilotAction)

        fileExportRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None),self)
        fileExportRoastLoggerAction.triggered.connect(self.fileExportRoastLogger)
        self.exportMenu.addAction(fileExportRoastLoggerAction)
        
        
        self.convMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_CONVERT)
        
        fileConvertFahrenheitAction = QAction(QApplication.translate("Menu", "Fahrenheit...",None),self)
        fileConvertFahrenheitAction.triggered.connect(self.fileConvertToFahrenheit)
        self.convMenu.addAction(fileConvertFahrenheitAction)
        
        fileConvertCelsiusAction = QAction(QApplication.translate("Menu", "Celsius...",None),self)
        fileConvertCelsiusAction.triggered.connect(self.fileConvertToCelsius)
        self.convMenu.addAction(fileConvertCelsiusAction)
        
        self.convMenu.addSeparator()

        fileConvertExcelAction = QAction(QApplication.translate("Menu", "Excel...",None),self)
        fileConvertExcelAction.triggered.connect(self.fileConvertExcel)
        self.convMenu.addAction(fileConvertExcelAction)
        
        self.convMenu.addSeparator()

        fileConvertCSVAction = QAction(QApplication.translate("Menu", "Artisan CSV...",None),self)
        fileConvertCSVAction.triggered.connect(self.fileConvertCSV)
        self.convMenu.addAction(fileConvertCSVAction)

        fileConvertJSONAction = QAction(QApplication.translate("Menu", "Artisan JSON...",None),self)
        fileConvertJSONAction.triggered.connect(self.fileConvertJSON)
        self.convMenu.addAction(fileConvertJSONAction)
        
        self.convMenu.addSeparator()

        fileConvertProbatAction = QAction(QApplication.translate("Menu", "Probat Pilot...",None),self)
        fileConvertProbatAction.triggered.connect(self.fileConvertPilot)
        self.convMenu.addAction(fileConvertProbatAction)

        fileConvertRoastLoggerAction = QAction(QApplication.translate("Menu", "RoastLogger...",None),self)
        fileConvertRoastLoggerAction.triggered.connect(self.fileConvertRoastLogger)
        self.convMenu.addAction(fileConvertRoastLoggerAction)
        
        self.convMenu.addSeparator()
        
        fileConvertPNGAction = QAction(QApplication.translate("Menu", "PNG...",None),self)
        fileConvertPNGAction.triggered.connect(self.fileConvertPNG)
        self.convMenu.addAction(fileConvertPNGAction)

        fileConvertJPEGAction = QAction(QApplication.translate("Menu", "JPEG...",None),self)
        fileConvertJPEGAction.triggered.connect(self.fileConvertJPEG)
        self.convMenu.addAction(fileConvertJPEGAction)

        fileConvertBMPAction = QAction(QApplication.translate("Menu", "BMP...",None),self)
        fileConvertBMPAction.triggered.connect(self.fileConvertBMP)
        self.convMenu.addAction(fileConvertBMPAction)
        
        fileConvertSVGAction = QAction(QApplication.translate("Menu", "SVG...",None),self)
        fileConvertSVGAction.triggered.connect(self.fileConvertSVG)
        self.convMenu.addAction(fileConvertSVGAction)
        
        fileConvertPDFAction = QAction(QApplication.translate("Menu", "PDF...",None),self)
        fileConvertPDFAction.triggered.connect(self.fileConvertPDF)
        self.convMenu.addAction(fileConvertPDFAction)
        

        self.fileMenu.addSeparator()

        self.saveGraphMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_SAVEGRAPH)

        fullsizeAction = QAction(UIconst.FILE_MENU_SAVEGRAPH_FULL_SIZE,self)
        fullsizeAction.triggered.connect(self.resizeImg_0_1)
        self.saveGraphMenu.addAction(fullsizeAction)

        largeSizeAction = QAction(UIconst.FILE_MENU_SAVEGRAPH_Large,self)
        largeSizeAction.triggered.connect(self.resizeImg_1200_1)
        self.saveGraphMenu.addAction(largeSizeAction)

        KaffeeNetzAction = QAction("Kaffee-Netz.de (800x?)...",self)
        KaffeeNetzAction.triggered.connect(self.resizeImg_800_1)
        self.saveGraphMenu.addAction(KaffeeNetzAction)

        HomeBaristaAction = QAction("Home-Barista.com (700x?)...",self)
        HomeBaristaAction.triggered.connect(self.resizeImg_700_1)
        self.saveGraphMenu.addAction(HomeBaristaAction)

        RiktigtKaffeAction = QAction("RiktigtKaffe.se (620x?)...",self)
        RiktigtKaffeAction.triggered.connect(self.resizeImg_620_1)
        self.saveGraphMenu.addAction(RiktigtKaffeAction)

        PlanetCafeAction = QAction("PlanetCafe.fr (600x?)...",self)
        PlanetCafeAction.triggered.connect(self.resizeImg_600_1)
        self.saveGraphMenu.addAction(PlanetCafeAction)

        CoffeeGeekAction = QAction("CoffeeGeek.com (500x?)...",self)
        CoffeeGeekAction.triggered.connect(self.resizeImg_500_1)
        self.saveGraphMenu.addAction(CoffeeGeekAction)
        
        JPEGAction = QAction("JPEG...",self)
        JPEGAction.triggered.connect(self.resizeImg_0_1_JPEG)
        self.saveGraphMenu.addAction(JPEGAction)
        
        BMPAction = QAction("BMP...",self)
        BMPAction.triggered.connect(self.resizeImg_0_1_BMP)
        self.saveGraphMenu.addAction(BMPAction)
        
        SVGAction = QAction("SVG...",self)
        SVGAction.triggered.connect(self.saveVectorGraph_SVG)
        self.saveGraphMenu.addAction(SVGAction)

        PDFAction = QAction("PDF...",self)
        PDFAction.triggered.connect(self.saveVectorGraph_PDF)
        self.saveGraphMenu.addAction(PDFAction)
        
        
        self.reportMenu = self.fileMenu.addMenu(UIconst.FILE_MENU_REPORT)

        self.htmlAction = QAction(UIconst.FILE_MENU_HTMLREPORT,self)
        self.htmlAction.triggered.connect(self.htmlReport)
        self.htmlAction.setShortcut("Ctrl+R")
        self.reportMenu.addAction(self.htmlAction)

        self.productionMenu = self.reportMenu.addMenu(UIconst.FILE_MENU_PRODUCTIONREPORT)
        
        self.productionWebAction = QAction(UIconst.FILE_MENU_REPORT_WEB,self)
        self.productionWebAction.triggered.connect(self.productionReport)
        self.productionMenu.addAction(self.productionWebAction)
        
        self.productionCsvAction = QAction(UIconst.FILE_MENU_REPORT_CSV,self)
        self.productionCsvAction.triggered.connect(self.productionCSVReport)
        self.productionMenu.addAction(self.productionCsvAction)
        
        self.productionExcelAction = QAction(UIconst.FILE_MENU_REPORT_EXCEL,self)
        self.productionExcelAction.triggered.connect(self.productionExcelReport)
        self.productionMenu.addAction(self.productionExcelAction)
        
        self.rankingMenu = self.reportMenu.addMenu(UIconst.FILE_MENU_RANKINGREPORT)
        
        self.rankingWebAction = QAction(UIconst.FILE_MENU_REPORT_WEB,self)
        self.rankingWebAction.triggered.connect(self.rankingReport)
        self.rankingMenu.addAction(self.rankingWebAction)
        
        self.rankingCsvAction = QAction(UIconst.FILE_MENU_REPORT_CSV,self)
        self.rankingCsvAction.triggered.connect(self.rankingCSVReport)
        self.rankingMenu.addAction(self.rankingCsvAction)
        
        self.rankingExcelAction = QAction(UIconst.FILE_MENU_REPORT_EXCEL,self)
        self.rankingExcelAction.triggered.connect(self.rankingExcelReport)
        self.rankingMenu.addAction(self.rankingExcelAction)

        self.savestatisticsAction = QAction(UIconst.FILE_MENU_SAVESTATISTICS,self)
        self.savestatisticsAction.triggered.connect(self.saveStatistics)
        self.fileMenu.addAction(self.savestatisticsAction)

        self.fileMenu.addSeparator()

        self.printAction = QAction(UIconst.FILE_MENU_PRINT,self)
        self.printAction.setShortcut(QKeySequence.Print)
        self.printAction.triggered.connect(self.filePrint)
        self.fileMenu.addAction(self.printAction)
        
        self.quitAction = QAction(UIconst.FILE_MENU_QUIT,self)
        self.quitAction.setMenuRole(QAction.QuitRole)
        self.quitAction.setShortcut(QKeySequence.Quit)
        self.quitAction.triggered.connect(self.fileQuit)
        self.fileMenu.addAction(self.quitAction)

        # EDIT menu
        self.cutAction = QAction(UIconst.EDIT_MENU_CUT,self)
        self.cutAction.setShortcut(QKeySequence.Cut)
        self.editMenu.addAction(self.cutAction)
        self.cutAction.triggered.connect(self.on_actionCut_triggered)
        self.copyAction = QAction(UIconst.EDIT_MENU_COPY,self)
        self.copyAction.setShortcut(QKeySequence.Copy)
        self.editMenu.addAction(self.copyAction)
        self.copyAction.triggered.connect(self.on_actionCopy_triggered)
        self.pasteAction = QAction(UIconst.EDIT_MENU_PASTE,self)
        self.pasteAction.setShortcut(QKeySequence.Paste)
        self.editMenu.addAction(self.pasteAction)
        self.pasteAction.triggered.connect(self.on_actionPaste_triggered)

        # ROAST menu
        self.editGraphAction = QAction(UIconst.ROAST_MENU_PROPERTIES,self)
        self.editGraphAction.triggered.connect(self.editgraph)
        self.GraphMenu.addAction(self.editGraphAction)
        self.editGraphAction.setShortcut("Ctrl+T")

        self.backgroundAction = QAction(UIconst.ROAST_MENU_BACKGROUND,self)
        self.backgroundAction.triggered.connect(self.background)
        self.GraphMenu.addAction(self.backgroundAction)
        self.backgroundAction.setShortcut("Ctrl+B")

        self.flavorAction = QAction(UIconst.ROAST_MENU_CUPPROFILE,self)
        self.flavorAction.triggered.connect(self.flavorchart)
        self.GraphMenu.addAction(self.flavorAction)

        self.GraphMenu.addSeparator()

        self.switchAction = QAction(UIconst.ROAST_MENU_SWITCH,self)
        self.switchAction.setShortcut(QKeySequence.Close)
        self.switchAction.triggered.connect(self.switch)
        self.GraphMenu.addAction(self.switchAction)
        
        self.switchETBTAction = QAction(UIconst.ROAST_MENU_SWITCH_ETBT,self)
        self.switchETBTAction.triggered.connect(self.switchETBT)
        self.GraphMenu.addAction(self.switchETBTAction)

        # CONFIGURATION menu
        self.machineMenu = QMenu(UIconst.CONF_MENU_MACHINE) # self.ConfMenu.addMenu(UIconst.CONF_MENU_MACHINE)
        self.populateMachineMenu()
          
        self.deviceAction = QAction(UIconst.CONF_MENU_DEVICE, self)
        self.deviceAction.triggered.connect(self.deviceassigment)
        self.ConfMenu.addAction(self.deviceAction)
        self.deviceAction.setShortcut("Ctrl+D")

        self.commportAction = QAction(UIconst.CONF_MENU_SERIALPORT,self)
        self.commportAction.triggered.connect(self.setcommport)
        self.ConfMenu.addAction(self.commportAction)
        
        self.ConfMenu.addSeparator()

        self.calibrateDelayAction = QAction(UIconst.CONF_MENU_SAMPLING,self)
        self.calibrateDelayAction.triggered.connect(self.calibratedelay)
        self.ConfMenu.addAction(self.calibrateDelayAction)

        self.oversamplingAction = QAction(UIconst.CONF_MENU_OVERSAMPLING,self)
        self.oversamplingAction.triggered.connect(self.oversampling)
        self.oversamplingAction.setCheckable(True)
        self.oversamplingAction.setChecked(self.qmc.oversampling)
        self.ConfMenu.addAction(self.oversamplingAction)

        self.ConfMenu.addSeparator()

        self.hudAction = QAction(UIconst.CONF_MENU_CURVES,self)
        self.hudAction.triggered.connect(self.hudset)
        self.ConfMenu.addAction(self.hudAction)
        
        self.ConfMenu.addSeparator()

        self.eventsAction = QAction(UIconst.CONF_MENU_EVENTS,self)
        self.eventsAction.triggered.connect(self.eventsconf)
        self.ConfMenu.addAction(self.eventsAction)
        self.eventsAction.setShortcut("Ctrl+E")

        self.alarmAction = QAction(UIconst.CONF_MENU_ALARMS,self)
        self.alarmAction.triggered.connect(self.alarmconfig)
        self.alarmAction.setShortcut("Ctrl+A")
        self.ConfMenu.addAction(self.alarmAction)
        
        self.ConfMenu.addSeparator()

        self.phasesGraphAction = QAction(UIconst.CONF_MENU_PHASES,self)
        self.phasesGraphAction.triggered.connect(self.editphases)
        self.ConfMenu.addAction(self.phasesGraphAction)

        self.StatisticsAction = QAction(UIconst.CONF_MENU_STATISTICS,self)
        self.StatisticsAction.triggered.connect(self.showstatistics)
        self.ConfMenu.addAction(self.StatisticsAction)

        self.WindowconfigAction = QAction(UIconst.CONF_MENU_AXES,self)
        self.WindowconfigAction.triggered.connect(self.Windowconfig)
        self.ConfMenu.addAction(self.WindowconfigAction)

        self.ConfMenu.addSeparator()
        
        self.colorsAction = QAction(UIconst.CONF_MENU_COLORS,self)
        self.colorsAction.triggered.connect(self.qmc.changeGColor3)
        self.ConfMenu.addAction(self.colorsAction)
        
        self.themeMenu = QMenu(UIconst.CONF_MENU_THEMES)
        self.populateThemeMenu()
        self.ConfMenu.addMenu(self.themeMenu)
        self.updateRecentThemeActions()
        
        self.ConfMenu.addSeparator()

        self.autosaveAction = QAction(UIconst.CONF_MENU_AUTOSAVE,self)
        self.autosaveAction.triggered.connect(self.autosaveconf)
        self.ConfMenu.addAction(self.autosaveAction)

        self.batchAction = QAction(UIconst.CONF_MENU_BATCH,self)
        self.batchAction.triggered.connect(self.batchconf)
        self.ConfMenu.addAction(self.batchAction)

        self.ConfMenu.addSeparator()
        
        self.temperatureConfMenu = self.ConfMenu.addMenu(UIconst.CONF_MENU_TEMPERATURE)
        
        self.FahrenheitAction = QAction(UIconst.ROAST_MENU_FAHRENHEIT_MODE,self)
        self.FahrenheitAction.triggered.connect(self.qmc.fahrenheitModeRedraw)
        self.temperatureConfMenu.addAction(self.FahrenheitAction)

        self.CelsiusAction = QAction(UIconst.ROAST_MENU_CELSIUS_MODE,self)
        self.CelsiusAction.triggered.connect(self.qmc.celsiusModeRedraw)
        self.temperatureConfMenu.addAction(self.CelsiusAction)        
            
        self.languageMenu = self.ConfMenu.addMenu(UIconst.CONF_MENU_LANGUAGE)

        self.ArabicLanguage = QAction(UIconst.CONF_MENU_ARABIC,self)
        self.ArabicLanguage.setCheckable(True)
        self.ArabicLanguage.triggered.connect(self.changelocale_ar)
        self.languageMenu.addAction(self.ArabicLanguage)
        if locale == "ar":
            self.ArabicLanguage.setChecked(True)

        self.GermanLanguage = QAction(UIconst.CONF_MENU_GERMAN,self)
        self.GermanLanguage.setCheckable(True)
        self.GermanLanguage.triggered.connect(self.changelocale_de)
        self.languageMenu.addAction(self.GermanLanguage)
        if locale == "de":
            self.GermanLanguage.setChecked(True)

        self.GreekLanguage = QAction(UIconst.CONF_MENU_GREEK,self)
        self.GreekLanguage.setCheckable(True)
        self.GreekLanguage.triggered.connect(self.changelocale_el)
        self.languageMenu.addAction(self.GreekLanguage)
        if locale == "el":
            self.GreekLanguage.setChecked(True)

        self.EnglishLanguage = QAction(UIconst.CONF_MENU_ENGLISH,self)
        self.EnglishLanguage.setCheckable(True)
        self.EnglishLanguage.triggered.connect(self.changelocale_en)
        self.languageMenu.addAction(self.EnglishLanguage)
        if locale == "en" or locale == "en_US":
            self.EnglishLanguage.setChecked(True)

        self.SpanishLanguage = QAction(UIconst.CONF_MENU_SPANISH,self)
        self.SpanishLanguage.setCheckable(True)
        self.SpanishLanguage.triggered.connect(self.changelocale_es)
        self.languageMenu.addAction(self.SpanishLanguage) 
        if locale == "es":
            self.SpanishLanguage.setChecked(True)

        self.FarsiLanguage = QAction(UIconst.CONF_MENU_FARSI,self)
        self.FarsiLanguage.setCheckable(True)
        self.FarsiLanguage.triggered.connect(self.changelocale_fa)
        self.languageMenu.addAction(self.FarsiLanguage)
        if locale == "fa":
            self.FarsiLanguage.setChecked(True)

        self.FinishLanguage = QAction(UIconst.CONF_MENU_FINISH,self)
        self.FinishLanguage.setCheckable(True)
        self.FinishLanguage.triggered.connect(self.changelocale_fi)
        self.languageMenu.addAction(self.FinishLanguage)
        if locale == "fi":
            self.FinishLanguage.setChecked(True)

        self.FrenchLanguage = QAction(UIconst.CONF_MENU_FRENCH,self)
        self.FrenchLanguage.setCheckable(True)
        self.FrenchLanguage.triggered.connect(self.changelocale_fr)
        self.languageMenu.addAction(self.FrenchLanguage)
        if locale == "fr":
            self.FrenchLanguage.setChecked(True)

        self.HebrewLanguage = QAction(UIconst.CONF_MENU_HEBREW,self)
        self.HebrewLanguage.setCheckable(True)
        self.HebrewLanguage.triggered.connect(self.changelocale_he)
        self.languageMenu.addAction(self.HebrewLanguage)
        if locale == "he":
            self.HebrewLanguage.setChecked(True)

        self.HungarianLanguage = QAction(UIconst.CONF_MENU_HUNGARIAN,self)
        self.HungarianLanguage.setCheckable(True)
        self.HungarianLanguage.triggered.connect(self.changelocale_hu)
        self.languageMenu.addAction(self.HungarianLanguage)
        if locale == "hu":
            self.HungarianLanguage.setChecked(True)

        self.IndonesianLanguage = QAction(UIconst.CONF_MENU_INDONESIAN,self)
        self.IndonesianLanguage.setCheckable(True)
        self.IndonesianLanguage.triggered.connect(self.changelocale_id)
        self.languageMenu.addAction(self.IndonesianLanguage)
        if locale == "id":
            self.IndonesianLanguage.setChecked(True)

        self.ItalianLanguage = QAction(UIconst.CONF_MENU_ITALIAN,self)
        self.ItalianLanguage.setCheckable(True)
        self.ItalianLanguage.triggered.connect(self.changelocale_it)
        self.languageMenu.addAction(self.ItalianLanguage) 
        if locale == "it":
            self.ItalianLanguage.setChecked(True)

        self.JapaneseLanguage = QAction(UIconst.CONF_MENU_JAPANESE,self)
        self.JapaneseLanguage.setCheckable(True)
        self.JapaneseLanguage.triggered.connect(self.changelocale_ja)
        self.languageMenu.addAction(self.JapaneseLanguage)
        if locale == "ja":
            self.JapaneseLanguage.setChecked(True)

        self.KoreanLanguage = QAction(UIconst.CONF_MENU_KOREAN,self)
        self.KoreanLanguage.setCheckable(True)
        self.KoreanLanguage.triggered.connect(self.changelocale_ko)
        self.languageMenu.addAction(self.KoreanLanguage)
        if locale == "ko":
            self.KoreanLanguage.setChecked(True)

        self.DutchLanguage = QAction(UIconst.CONF_MENU_DUTCH,self)
        self.DutchLanguage.setCheckable(True)
        self.DutchLanguage.triggered.connect(self.changelocale_nl)
        self.languageMenu.addAction(self.DutchLanguage)
        if locale == "nl":
            self.DutchLanguage.setChecked(True)

        self.NorwegianLanguage = QAction(UIconst.CONF_MENU_NORWEGIAN,self)
        self.NorwegianLanguage.setCheckable(True)
        self.NorwegianLanguage.triggered.connect(self.changelocale_no)
        self.languageMenu.addAction(self.NorwegianLanguage)
        if locale == "no":
            self.NorwegianLanguage.setChecked(True)

        self.PortugueseLanguage = QAction(UIconst.CONF_MENU_PORTUGUESE,self)
        self.PortugueseLanguage.setCheckable(True)
        self.PortugueseLanguage.triggered.connect(self.changelocale_pt)
        self.languageMenu.addAction(self.PortugueseLanguage)
        if locale == "pt":
            self.PortugueseLanguage.setChecked(True)

        self.PortugueseBrasilLanguage = QAction(UIconst.CONF_MENU_BRASIL,self)
        self.PortugueseBrasilLanguage.setCheckable(True)
        self.PortugueseBrasilLanguage.triggered.connect(self.changelocale_pt_BR)
        self.languageMenu.addAction(self.PortugueseBrasilLanguage)
        if locale == "pt_BR":
            self.PortugueseBrasilLanguage.setChecked(True)

        self.PolishLanguage = QAction(UIconst.CONF_MENU_POLISH,self)
        self.PolishLanguage.setCheckable(True)
        self.PolishLanguage.triggered.connect(self.changelocale_pl)
        self.languageMenu.addAction(self.PolishLanguage)
        if locale == "pl":
            self.PolishLanguage.setChecked(True)

        self.RussianLanguage = QAction(UIconst.CONF_MENU_RUSSIAN,self)
        self.RussianLanguage.setCheckable(True)
        self.RussianLanguage.triggered.connect(self.changelocale_ru)
        self.languageMenu.addAction(self.RussianLanguage)
        if locale == "ru":
            self.RussianLanguage.setChecked(True)

        self.SwedishLanguage = QAction(UIconst.CONF_MENU_SWEDISH,self)
        self.SwedishLanguage.setCheckable(True)
        self.SwedishLanguage.triggered.connect(self.changelocale_sv)
        self.languageMenu.addAction(self.SwedishLanguage) 
        if locale == "sv":
            self.SwedishLanguage.setChecked(True)
            
        self.ThaiLanguage = QAction(UIconst.CONF_MENU_THAI,self)
        self.ThaiLanguage.setCheckable(True)
        self.ThaiLanguage.triggered.connect(self.changelocale_th)
        self.languageMenu.addAction(self.ThaiLanguage)
        if locale == "th":
            self.ThaiLanguage.setChecked(True)

        self.TurkishLanguage = QAction(UIconst.CONF_MENU_TURKISH,self)
        self.TurkishLanguage.setCheckable(True)
        self.TurkishLanguage.triggered.connect(self.changelocale_tr)
        self.languageMenu.addAction(self.TurkishLanguage)
        if locale == "tr":
            self.TurkishLanguage.setChecked(True)

        # simplified Chinese
        self.ChineseChinaLanguage = QAction(UIconst.CONF_MENU_CHINESE_CN,self)
        self.ChineseChinaLanguage.setCheckable(True)
        self.ChineseChinaLanguage.triggered.connect(self.changelocale_zh_CN)
        self.languageMenu.addAction(self.ChineseChinaLanguage) 
        if locale == "zh_CN":
            self.ChineseChinaLanguage.setChecked(True)

        # traditional Chinese
        self.ChineseTaiwanLanguage = QAction(UIconst.CONF_MENU_CHINESE_TW,self)
        self.ChineseTaiwanLanguage.setCheckable(True)
        self.ChineseTaiwanLanguage.triggered.connect(self.changelocale_zh_TW)
        self.languageMenu.addAction(self.ChineseTaiwanLanguage) 
        if locale == "zh_TW":
            self.ChineseTaiwanLanguage.setChecked(True)
            

        # TOOLKIT menu

        self.analyzeMenu = self.ToolkitMenu.addMenu(UIconst.TOOLKIT_MENU_ANALYZER)
        self.fitIdealautoAction = QAction(QApplication.translate("Menu","Auto All",None),self)
        self.fitIdealautoAction.triggered.connect(self.analysisfitCurvesALL)
        self.fitIdealautoAction.setShortcut("Ctrl+K")
        self.analyzeMenu.addAction(self.fitIdealautoAction)
        self.analyzeMenu.addSeparator()
        self.fitIdealx2Action = QAction(QApplication.translate("Menu","Fit BT to",None) + " x\xb2",self)
        self.fitIdealx2Action.triggered.connect(self.analysisfitCurvesX2)
        self.analyzeMenu.addAction(self.fitIdealx2Action)
        self.fitIdealx3Action = QAction(QApplication.translate("Menu","Fit BT to",None) + " x\xb3",self)
        self.fitIdealx3Action.triggered.connect(self.analysisfitCurvesX3)
        self.analyzeMenu.addAction(self.fitIdealx3Action)
        self.fitIdealx0Action = QAction(QApplication.translate("Menu","Fit BT to",None) + " ln()",self)
        self.fitIdealx0Action.triggered.connect(self.analysisfitCurvesLN)
        self.analyzeMenu.addAction(self.fitIdealx0Action)
        self.analyzeMenu.addSeparator()
        self.fitBkgndAction = QAction(QApplication.translate("Menu","Fit BT to Bkgnd",None),self)
        self.fitBkgndAction.triggered.connect(self.analysisfitCurvesBkgnd)
        self.analyzeMenu.addAction(self.fitBkgndAction)
        self.analyzeMenu.addSeparator()
        self.clearresultsAction = QAction(QApplication.translate("Menu","Clear results",None),self)
        self.clearresultsAction.triggered.connect(self.clearResults)
        self.clearresultsAction.setShortcut("Ctrl+Alt+K")
        self.analyzeMenu.addAction(self.clearresultsAction)

        self.designerAction = QAction(UIconst.TOOLKIT_MENU_DESIGNER,self)
        self.designerAction.triggered.connect(self.designerTriggered)
        self.designerAction.setCheckable(True)
        self.designerAction.setChecked(self.qmc.designerflag)
        self.ToolkitMenu.addAction(self.designerAction)
        
        self.simulatorAction = QAction(UIconst.TOOLKIT_MENU_SIMULATOR,self)
        self.simulatorAction.triggered.connect(self.simulate)
        self.simulatorAction.setCheckable(True)
        self.simulatorAction.setChecked(bool(self.simulator))
        self.ToolkitMenu.addAction(self.simulatorAction)

#        self.roastCompareAction = QAction(UIconst.TOOLKIT_MENU_ROASTCOMPARE,self)
##        self.roastCompareAction.triggered.connect(self.roastCompare)
#        self.roastCompareAction.setCheckable(True)
##        self.roastCompareAction.setChecked(self.qmc.roastcompareflag)
#        self.ToolkitMenu.addAction(self.roastCompareAction)

        self.wheeleditorAction = QAction(UIconst.TOOLKIT_MENU_WHEELGRAPH,self)
        self.wheeleditorAction.triggered.connect(self.graphwheel)
        self.wheeleditorAction.setCheckable(True)
        self.wheeleditorAction.setChecked(self.qmc.wheelflag)
        self.ToolkitMenu.addAction(self.wheeleditorAction)
        
        self.ToolkitMenu.addSeparator()

        self.transformAction = QAction(UIconst.TOOLKIT_MENU_TRANSFORM,self)
        self.transformAction.triggered.connect(self.transform)
        self.ToolkitMenu.addAction(self.transformAction)

        self.temperatureMenu = self.ToolkitMenu.addMenu(UIconst.TOOLKIT_MENU_TEMPERATURE)
        
        self.ConvertToFahrenheitAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_FAHRENHEIT,self)
        self.ConvertToFahrenheitAction.triggered.connect(self.qmc.convertTemperatureF)
        self.temperatureMenu.addAction(self.ConvertToFahrenheitAction)

        self.ConvertToCelsiusAction = QAction(UIconst.ROAST_MENU_CONVERT_TO_CELSIUS,self)
        self.ConvertToCelsiusAction.triggered.connect(self.qmc.convertTemperatureC)
        self.temperatureMenu.addAction(self.ConvertToCelsiusAction)

        if self.qmc.mode == "F":
            self.FahrenheitAction.setDisabled(True)
            self.ConvertToFahrenheitAction.setDisabled(True)
        else:
            self.CelsiusAction.setDisabled(True)
            self.ConvertToCelsiusAction.setDisabled(True)

        self.ToolkitMenu.addSeparator()

        calculatorAction = QAction(UIconst.TOOLKIT_MENU_CALCULATOR,self)
        calculatorAction.triggered.connect(self.calculator)
        self.ToolkitMenu.addAction(calculatorAction)


        # VIEW menu
        
        self.controlsAction = QAction(UIconst.CONF_MENU_CONTROLS,self)
        self.controlsAction.triggered.connect(self.toggleControls)
        self.controlsAction.setCheckable(True)
        self.controlsAction.setChecked(True)
        self.viewMenu.addAction(self.controlsAction)
        
        self.readingsAction = QAction(UIconst.CONF_MENU_READINGS,self)
        self.readingsAction.triggered.connect(self.toggleReadings)
        self.readingsAction.setCheckable(True)
        self.readingsAction.setChecked(False)
        self.viewMenu.addAction(self.readingsAction)
        
        self.buttonsAction = QAction(UIconst.CONF_MENU_BUTTONS,self)
        self.buttonsAction.triggered.connect(self.toggleExtraButtons)
        self.buttonsAction.setCheckable(True)
        self.buttonsAction.setChecked(False)
        self.viewMenu.addAction(self.buttonsAction)

        self.slidersAction = QAction(UIconst.CONF_MENU_SLIDERS,self)
        self.slidersAction.triggered.connect(self.toggleSliders)
        self.slidersAction.setCheckable(True)
        self.slidersAction.setChecked(False)
        self.viewMenu.addAction(self.slidersAction)

        self.viewMenu.addSeparator()

        self.lcdsAction = QAction(UIconst.TOOLKIT_MENU_LCDS,self)
        self.lcdsAction.triggered.connect(self.largeLCDs)
        self.lcdsAction.setShortcut("Ctrl+L")
        self.viewMenu.addAction(self.lcdsAction)

        deltalcdsAction = QAction(UIconst.TOOLKIT_MENU_DELTA_LCDS,self)
        deltalcdsAction.triggered.connect(self.largeDeltaLCDs)
        self.viewMenu.addAction(deltalcdsAction)

        pidlcdsAction = QAction(UIconst.TOOLKIT_MENU_PID_LCDS,self)
        pidlcdsAction.triggered.connect(self.largePIDLCDs)
        self.viewMenu.addAction(pidlcdsAction)

        self.extralcdsAction = QAction(UIconst.TOOLKIT_MENU_EXTRA_LCDS,self)
        self.extralcdsAction.triggered.connect(self.largeExtraLCDs)
        self.viewMenu.addAction(self.extralcdsAction)

        self.phaseslcdsAction = QAction(UIconst.TOOLKIT_MENU_PHASES_LCDS,self)
        self.phaseslcdsAction.triggered.connect(self.largePhasesLCDs)
        self.viewMenu.addAction(self.phaseslcdsAction)
        
        self.viewMenu.addSeparator()

        if platf != 'Darwin': # MacOS X automatically adds the fullscreen action
            self.fullscreenAction = QAction(UIconst.VIEW_MENU_FULLSCREEN,self)
            self.fullscreenAction.triggered.connect(self.toggleFullscreen)
            self.fullscreenAction.setCheckable(True)
            self.fullscreenAction.setChecked(False)
            self.fullscreenAction.setShortcut("Ctrl+F")
            self.fullscreenAction.setMenuRole(QAction.NoRole)
            self.viewMenu.addAction(self.fullscreenAction)        

        # HELP menu
        if app.artisanviewerMode:
            helpAboutAction = QAction(UIconst.HELP_MENU_ABOUT_ARTISANVIEWER,self)
        else:
            helpAboutAction = QAction(UIconst.HELP_MENU_ABOUT,self)
        helpAboutAction.setMenuRole(QAction.AboutRole)
        helpAboutAction.triggered.connect(self.helpAbout)
        self.helpMenu.addAction(helpAboutAction)
        
        aboutQtAction = QAction(UIconst.HELP_MENU_ABOUTQT,self)
        aboutQtAction.setMenuRole(QAction.AboutQtRole)
        aboutQtAction.triggered.connect(self.showAboutQt)
        self.helpMenu.addAction(aboutQtAction)

        helpDocumentationAction = QAction(UIconst.HELP_MENU_DOCUMENTATION,self)
        helpDocumentationAction.triggered.connect(self.helpHelp)
        helpDocumentationAction.setShortcut(QKeySequence.HelpContents)
        self.helpMenu.addAction(helpDocumentationAction)

        KshortCAction = QAction(UIconst.HELP_MENU_KEYBOARDSHORTCUTS,self)
        KshortCAction.triggered.connect(self.viewKshortcuts)
        self.helpMenu.addAction(KshortCAction)
                
        self.helpMenu.addSeparator()

        checkUpdateAction = QAction(UIconst.HELP_MENU_CHECKUPDATE,self)
        checkUpdateAction.setMenuRole(QAction.NoRole)
        checkUpdateAction.triggered.connect(self.checkUpdate)
        self.helpMenu.addAction(checkUpdateAction)

        self.helpMenu.addSeparator()

        errorAction = QAction(UIconst.HELP_MENU_ERRORS,self)
        errorAction.triggered.connect(self.viewErrorLog)
        self.helpMenu.addAction(errorAction)

        messageAction = QAction(UIconst.HELP_MENU_MESSAGES,self)
        messageAction.triggered.connect(self.viewMessageLog)
        self.helpMenu.addAction(messageAction)

        serialAction = QAction(UIconst.HELP_MENU_SERIAL,self)
        serialAction.triggered.connect(self.viewSerialLog)
        serialAction.setMenuRole(QAction.NoRole)
        self.helpMenu.addAction(serialAction)

        platformAction = QAction(UIconst.HELP_MENU_PLATFORM,self)
        platformAction.triggered.connect(self.viewplatform)
        self.helpMenu.addAction(platformAction)
        
                
        # SETTINGS submenu
        self.helpMenu.addSeparator()
        
        self.loadSettingsAction = QAction(UIconst.SETTINGS_MENU_LOAD,self)
        self.loadSettingsAction.triggered.connect(self.loadSettings_triggered)
        self.loadSettingsAction.setMenuRole(QAction.NoRole) # avoid specific handling of settings menu
        self.helpMenu.addAction(self.loadSettingsAction)
                
        self.openRecentSettingMenu = self.helpMenu.addMenu(UIconst.SETTINGS_MENU_LOADRECENT)
        for i in range(self.MaxRecentFiles):
            self.openRecentSettingMenu.addAction(self.recentSettingActs[i])
        self.updateRecentSettingActions()
        
        self.saveAsSettingsAction = QAction(UIconst.SETTINGS_MENU_SAVEAS,self)
        self.saveAsSettingsAction.triggered.connect(self.saveSettings)
        self.saveAsSettingsAction.setMenuRole(QAction.NoRole)  # avoid specific handling of settings menu
        self.helpMenu.addAction(self.saveAsSettingsAction)

        self.helpMenu.addSeparator()

        self.resetAction = QAction(UIconst.HELP_MENU_RESET,self)
        self.resetAction.triggered.connect(self.resetApplication)
        self.helpMenu.addAction(self.resetAction)
        
        self.displayonlymenus()
        

        ############################## WIDGETS SECTION ########################################

        #create a Label object to display program status information
        self.messagelabel = QLabel()
        self.messagelabel.setIndent(6)
        # set a few broad style parameters
        if False: #locale == "es":
            self.button_font_size_pt = 12
        else:
            self.button_font_size_pt = 13
        if platf == 'Windows':
            self.button_font_size = str(self.button_font_size_pt - 2) + 'pt'
            self.button_font_size_small = str(self.button_font_size_pt - 3) + 'pt'
            self.button_font_size_small_selected = str(self.button_font_size_pt - 2) + 'pt'
            self.button_font_size_tiny = str(self.button_font_size_pt - 4) + 'pt'
            self.button_font_size_micro = str(self.button_font_size_pt - 5) + 'pt'
        else:
            self.button_font_size = str(self.button_font_size_pt) + 'pt'
            self.button_font_size_small = str(self.button_font_size_pt - 3) + 'pt'
            self.button_font_size_small_selected = str(self.button_font_size_pt - 2) + 'pt'
            self.button_font_size_tiny = str(self.button_font_size_pt - 4) + 'pt'
            self.button_font_size_micro = str(self.button_font_size_pt - 5) + 'pt'

        if platf == 'Windows':
            self.main_button_min_width = "110px"
            self.standard_button_min_width = "90px"
            self.small_button_min_width = "75px"
            self.tiny_button_min_width = "60px"
        else:
            self.main_button_min_width = "90px"
            self.standard_button_min_width = "75px"
            self.small_button_min_width = "60px"
            self.tiny_button_min_width = "50px"
        
        border_modern = "border-style:solid; border-radius:4;border-color:grey; border-width:0;" # modernize
        
        self.pushbuttonstyles_simulator = {
            "OFF":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: '#147bb3';
                    background: white;
                }
                QPushButton:pressed {
                    color: 116D98;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background: #F5F5F5;
                }
            """,
            "ON":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #cc0f50;
                    background: white;
                    
                }
                QPushButton:pressed {
                    color: #c70d49;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #d4336a;
                    background: #F5F5F5;
                }
            """,
            "STOP":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #147bb3;
                    background: white;
                }
                QPushButton:!enabled {
                    color: #EFEFEF;
                    background: darkgrey;
                }
                QPushButton:pressed {
                    color: #116999;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background: #F5F5F5;
                }
            """,
            "START":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,
        }

        # parking this green shade in case we want to use it later #00d55a
        self.pushbuttonstyles = {
            "RESET":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #43a7cf;
                }
            """,
            "OFF":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: '#147bb3';
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116D98;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #1985ba;
                }
            """,
            "ON":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #cc0f50;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #c70d49;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #d4336a;
                }
            """,
            "STOP":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #147bb3;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #1985ba;
                }
            """,
            "START":    """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,

            "CHARGE":    """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:flat{
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #BDBDBD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#116999') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#1985ba') + """ ;
                }
            """,
            "DRY END":    """
                QPushButton {
                    min-width:  """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "FC START":    """
                QPushButton {
                    min-width:  """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "FC END":    """
                QPushButton {
                    min-width:  """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "SC START":    """
                QPushButton {
                    min-width:  """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "SC END":    """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "DROP":    """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:flat{
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #BDBDBD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#116999') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#1985ba') + """ ;
                }
            """,
            "COOL END":    """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#66b8d7') + """ ;
                }
                QPushButton:flat{
                    color: #BDBDBD;
                    background-color: #EEEEEE;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #DDDDDD;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #9E9E9E;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
            """,
            "EVENT":    """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#bdbdbd') + """ ;
                }
                QPushButton:pressed {
                    color: white;
                    background:""" + self.createGradient('#757575') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#9e9e9e') + """ ;
                }
            """,
            "PID":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #43a7cf;
                }
            """,
            "PIDactive":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #54b5ff;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #77cafd;
                }
            """,
            "SV +":     """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#db5785') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#d4336a') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#e480a2') + """ ;
                                     }
            """,
            "SV -":     """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#64b7d8') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background:""" + self.createGradient('#43a7cf') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#85cae1') + """ ;
                }
            """,

            "HUD_OFF":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #43a7cf;
                }
            """,
            "HUD_ON":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background: #54b5ff;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background: #77cafd;
                }
            """,
            "SELECTED":     """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small_selected + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#d4336a') + """ ;
                }
                QPushButton:flat{
                    color: darkgrey;
                    background-color: #f9e2ea;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #e687a8;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #d4336a;
                }
                QPushButton:pressed {
                    color: white;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#cc0f50') + """ ;
                }
            """,
            "SELECTED_MAIN":     """
                QPushButton {
                    min-width: """ + self.standard_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small_selected + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#c00b40') + """ ;
                }
                QPushButton:flat{
                    color: darkgrey;
                    background-color: #f0b7cb;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #db5785;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #cc0f50;
                }
                QPushButton:pressed {
                    color: white;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#c70d49') + """ ;
                }
            """,
            "SELECTED_MAIN_LARGE":     """
                QPushButton {
                    min-width: """ + self.main_button_min_width + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background:""" + self.createGradient('#c00b40') + """ ;
                }
                QPushButton:flat{
                    color: darkgrey;
                    background-color: #f0b7cb;
                }
                QPushButton:flat:hover:!pressed{
                    color: #F5F5F5;
                    background-color: #db5785;
                }
                QPushButton:flat:hover:pressed{
                    color: #EEEEEE;
                    background-color: #cc0f50;
                }
                QPushButton:pressed {
                    color: white;
                    background:""" + self.createGradient('#147bb3') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background:""" + self.createGradient('#c70d49') + """ ;
                }
            """
            }
#        if locale == "es":
#            # slightly smaller font size for Spanish
#            self.pushbuttonstyles["DISABLED"] = "QPushButton {font-size: 12pt; font-weight: normal; color: darkgrey; background-color: lightgrey}"
#            self.pushbuttonstyles["STOP"] = "QPushButton {font-size: 12pt; font-weight: bold; color: white; background-color: #43d300}"
#            self.pushbuttonstyles["START"] = "QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: red}"
#            self.pushbuttonstyles["OFF"] = "QPushButton {font-size: 12pt; font-weight: bold; color: white; background-color: #43d300}"
#            self.pushbuttonstyles["ON"] = "QPushButton {font-size: 12pt; font-weight: bold; color: yellow; background-color: red }"
        # we use this high to dynamically adjust the button size to different font sizes (important for high-dpi displays on Windows)
        if platf == 'Windows':
            default_button_height = QPushButton("Test").sizeHint().height()
            self.standard_button_tiny_height = default_button_height * 1.1
            self.standard_button_small_height = default_button_height * 1.5
            self.standard_button_height = default_button_height * 2
        else:
            self.standard_button_small_height = QPushButton("Test").sizeHint().height()
            self.standard_button_tiny_height = self.standard_button_small_height * 0.8
            self.standard_button_height = self.standard_button_small_height * 1.3

        #create ON/OFF buttons
        
#        if locale in ["el"]:
#            self.pushbuttonstyles["OFF"] = self.pushbuttonstyles["OFF"].replace("90px","120px")
            
        self.button_1 = QPushButton(QApplication.translate("Button", "ON", None))
        self.button_1.setFocusPolicy(Qt.NoFocus)
        self.button_1.setToolTip(QApplication.translate("Tooltip", "Start monitoring", None))
        self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
        self.shadow_1 = QGraphicsDropShadowEffect(self)
        self.shadow_1.setBlurRadius(20)
        self.shadow_1.setOffset(0,0.9)
        self.button_1.setGraphicsEffect(self.shadow_1)
        self.button_1.pressed.connect(self.button1Pressed)
        self.button_1.released.connect(self.button1Released)
        self.button_1.setCursor(QCursor(Qt.PointingHandCursor))
        self.button_1.setMinimumHeight(self.standard_button_height)
        self.button_1.clicked.connect(self.qmc.ToggleMonitor)
        if app.artisanviewerMode:
            self.button_1.setVisible(False)

        #create START/STOP buttons
        self.button_2 = QPushButton(QApplication.translate("Button", "START", None))
        self.button_2.setFocusPolicy(Qt.NoFocus)
        self.button_2.setToolTip(QApplication.translate("Tooltip", "Start recording", None))
        self.button_2.setStyleSheet(self.pushbuttonstyles["STOP"])
        self.shadow_2 = QGraphicsDropShadowEffect(self)
        self.shadow_2.setBlurRadius(20)
        self.shadow_2.setOffset(0,0.9)
        self.button_2.setGraphicsEffect(self.shadow_2)
        self.button_2.pressed.connect(self.button2Pressed)
        self.button_2.released.connect(self.button2Released)
        self.button_2.setCursor(QCursor(Qt.PointingHandCursor))

        self.button_2.setMinimumHeight(self.standard_button_height)
        self.button_2.clicked.connect(self.qmc.ToggleRecorder)
        if app.artisanviewerMode:
            self.button_2.setVisible(False)
        
        #create 1C START, 1C END, 2C START and 2C END buttons
        self.button_3 = QPushButton(QApplication.translate("Button", "FC\nSTART", None))
        self.button_3.setFocusPolicy(Qt.NoFocus)
        self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
        self.button_3.setMinimumHeight(self.standard_button_height)
        self.button_3.setToolTip(QApplication.translate("Tooltip", "First Crack Start", None))
        self.button_3.clicked.connect(self.qmc.mark1Cstart)
        self.button_3.setCursor(QCursor(Qt.PointingHandCursor))

        self.button_4 = QPushButton(QApplication.translate("Button", "FC\nEND", None))
        self.button_4.setFocusPolicy(Qt.NoFocus)
        self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
        self.button_4.setMinimumHeight(self.standard_button_height)
        self.button_4.setToolTip(QApplication.translate("Tooltip", "First Crack End", None))
        self.button_4.clicked.connect(self.qmc.mark1Cend)
        self.button_4.setCursor(QCursor(Qt.PointingHandCursor))

        self.button_5 = QPushButton(QApplication.translate("Button", "SC\nSTART", None))
        self.button_5.setFocusPolicy(Qt.NoFocus)
        self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
        self.button_5.setMinimumHeight(self.standard_button_height)
        self.button_5.setToolTip(QApplication.translate("Tooltip", "Second Crack Start", None))
        self.button_5.clicked.connect(self.qmc.mark2Cstart)
        self.button_5.setCursor(QCursor(Qt.PointingHandCursor))

        self.button_6 = QPushButton(QApplication.translate("Button", "SC\nEND", None))
        self.button_6.setFocusPolicy(Qt.NoFocus)
        self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
        self.button_6.setMinimumHeight(self.standard_button_height)
        self.button_6.setToolTip(QApplication.translate("Tooltip", "Second Crack End", None))
        self.button_6.clicked.connect(self.qmc.mark2Cend)
        self.button_6.setCursor(QCursor(Qt.PointingHandCursor))

        #create RESET button
        self.button_7 = QPushButton(QApplication.translate("Button", "RESET", None))
        self.button_7.setFocusPolicy(Qt.NoFocus)
        self.button_7.setStyleSheet(self.pushbuttonstyles["RESET"])
        self.shadow_7 = QGraphicsDropShadowEffect(self)
        self.shadow_7.setBlurRadius(20)
        self.shadow_7.setOffset(0,0.9)
        self.button_7.setGraphicsEffect(self.shadow_7)
        self.button_7.pressed.connect(self.button7Pressed)
        self.button_7.released.connect(self.button7Released)
        self.button_7.setCursor(QCursor(Qt.PointingHandCursor))
        self.button_7.setMinimumHeight(self.standard_button_height)
        self.button_7.setToolTip(QApplication.translate("Tooltip", "Reset", None))
        self.button_7.clicked.connect(self.qmc.resetButtonAction)

        #create CHARGE button
        self.button_8 = QPushButton(QApplication.translate("Button", "CHARGE", None))
        self.button_8.setFocusPolicy(Qt.NoFocus)
        self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
        self.button_8.setMinimumHeight(self.standard_button_height)
        self.button_8.setToolTip(QApplication.translate("Tooltip", "Charge", None))
        self.button_8.clicked.connect(self.qmc.markCharge)
        self.button_8.setCursor(QCursor(Qt.PointingHandCursor))

        #create DROP button
        self.button_9 = QPushButton(QApplication.translate("Button", "DROP", None))
        self.button_9.setFocusPolicy(Qt.NoFocus)
        self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
        self.button_9.setMinimumHeight(self.standard_button_height)
        self.button_9.setToolTip(QApplication.translate("Tooltip", "Drop", None))
        self.button_9.clicked.connect(self.qmc.markDrop)
        self.button_9.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID control button
        self.button_10 = QPushButton(QApplication.translate("Button", "Control", None))
        self.button_10.setFocusPolicy(Qt.NoFocus)
        self.button_10.setStyleSheet(self.pushbuttonstyles["PID"])
        self.shadow_10 = QGraphicsDropShadowEffect(self)
        self.shadow_10.setBlurRadius(20)
        self.shadow_10.setOffset(0,0.9)
        self.button_10.setGraphicsEffect(self.shadow_10)
        self.button_10.pressed.connect(self.button10Pressed)
        self.button_10.released.connect(self.button10Released)
        self.button_10.setCursor(QCursor(Qt.PointingHandCursor))
        self.button_10.setMinimumHeight(self.standard_button_height)
        self.button_10.clicked.connect(self.PIDcontrol)
        if app.artisanviewerMode:
            self.button_10.setVisible(False)

        #create EVENT record button
        self.button_11 = QPushButton(QApplication.translate("Button", "EVENT", None))
        self.button_11.setFocusPolicy(Qt.NoFocus)
        self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
        self.button_11.setMinimumHeight(self.standard_button_height)
        self.button_11.setToolTip(QApplication.translate("Tooltip", "Event", None))
        self.button_11.clicked.connect(self.qmc.EventRecord_action)
        self.button_11.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID+5 button
        self.button_12 = QPushButton(QApplication.translate("Button", "SV +5", None))
        self.button_12.setFocusPolicy(Qt.NoFocus)
        self.button_12.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_12.setMinimumWidth(90)
        self.button_12.setMinimumHeight(self.standard_button_height)
        self.button_12.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 5", None))
        self.button_12.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID+10 button
        self.button_13 = QPushButton(QApplication.translate("Button", "SV +10", None))
        self.button_13.setFocusPolicy(Qt.NoFocus)
        self.button_13.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_13.setMinimumWidth(90)
        self.button_13.setMinimumHeight(self.standard_button_height)
        self.button_13.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 10", None))
        self.button_13.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID+20 button
        self.button_14 = QPushButton(QApplication.translate("Button", "SV +20", None))
        self.button_14.setFocusPolicy(Qt.NoFocus)
        self.button_14.setStyleSheet(self.pushbuttonstyles["SV +"])
        self.button_14.setMinimumWidth(90)
        self.button_14.setMinimumHeight(self.standard_button_height)
        self.button_14.setToolTip(QApplication.translate("Tooltip", "Increases the current SV value by 20", None))
        self.button_14.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID-20 button
        self.button_15 = QPushButton(QApplication.translate("Button", "SV -20", None))
        self.button_15.setFocusPolicy(Qt.NoFocus)
        self.button_15.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_15.setMinimumWidth(90)
        self.button_15.setMinimumHeight(self.standard_button_height)
        self.button_15.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 20", None))
        self.button_15.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID-10 button
        self.button_16 = QPushButton(QApplication.translate("Button", "SV -10", None))
        self.button_16.setFocusPolicy(Qt.NoFocus)
        self.button_16.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_16.setMinimumWidth(90)
        self.button_16.setMinimumHeight(self.standard_button_height)
        self.button_16.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 10", None))
        self.button_16.setCursor(QCursor(Qt.PointingHandCursor))

        #create PID-5 button
        self.button_17 = QPushButton(QApplication.translate("Button", "SV -5", None))
        self.button_17.setFocusPolicy(Qt.NoFocus)
        self.button_17.setStyleSheet(self.pushbuttonstyles["SV -"])
        self.button_17.setMinimumWidth(90)
        self.button_17.setMinimumHeight(self.standard_button_height)
        self.button_17.setToolTip(QApplication.translate("Tooltip", "Decreases the current SV value by 5", None))
        self.button_17.setCursor(QCursor(Qt.PointingHandCursor))

        #create HUD button
        self.button_18 = QPushButton(QApplication.translate("Button", "HUD", None))
        self.button_18.setFocusPolicy(Qt.NoFocus)
        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
        self.button_18.setMinimumHeight(self.standard_button_height)
        self.button_18.setContentsMargins(0,0,0,0)
        self.button_18.clicked.connect(self.qmc.toggleHUD)
        self.button_18.setToolTip(QApplication.translate("Tooltip", "Turns ON/OFF the HUD", None))
        self.button_18.setEnabled(False)
        self.button_18.setCursor(QCursor(Qt.PointingHandCursor))
        if not self.qmc.HUDbuttonflag:
            self.button_18.setVisible(False)
        if app.artisanviewerMode:
            self.button_18.setVisible(False)
            
        #create DRY button
        self.button_19 = QPushButton(QApplication.translate("Button", "DRY\nEND", None))
        self.button_19.setFocusPolicy(Qt.NoFocus)
        self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
        self.button_19.setMinimumHeight(self.standard_button_height)
        self.button_19.setToolTip(QApplication.translate("Tooltip", "Dry End", None))
        self.button_19.clicked.connect(lambda _:self.qmc.markDryEnd())
        self.button_19.setCursor(QCursor(Qt.PointingHandCursor))

        #create COOLe button
        self.button_20 = QPushButton(QApplication.translate("Button", "COOL\nEND", None))
        self.button_20.setFocusPolicy(Qt.NoFocus)
        self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
        self.button_20.setMinimumHeight(self.standard_button_height)
        self.button_20.setToolTip(QApplication.translate("Tooltip", "Cool End", None))
        self.button_20.clicked.connect(self.qmc.markCoolEnd)
        self.button_20.setCursor(QCursor(Qt.PointingHandCursor))

        #connect PID sv easy buttons
        self.button_12.clicked.connect(self.adjustPIDsv5)
        self.button_13.clicked.connect(self.adjustPIDsv10)
        self.button_14.clicked.connect(self.adjustPIDsv20)
        self.button_15.clicked.connect(self.adjustPIDsv20m)
        self.button_16.clicked.connect(self.adjustPIDsv10m)
        self.button_17.clicked.connect(self.adjustPIDsv5m)

        # NavigationToolbar VMToolbar       
        self.ntb = VMToolbar(self.qmc, self.main_widget)
        
        #self.ntb.setMinimumHeight(50)

        #create LCD displays
        #RIGHT COLUMN
        self.lcd1 = QLCDNumber() # time
        self.lcd1.setSegmentStyle(2)
        self.lcd1.setMinimumHeight(40)
        self.lcd1.setMinimumWidth(100)
        self.lcd1.setFrameStyle(QFrame.Plain)
        # switch superusermode action:
        self.lcd1.setContextMenuPolicy(Qt.CustomContextMenu)
        self.lcd1.customContextMenuRequested.connect(self.superusermodeClicked)
        self.lcd1.setVisible(False)


        self.lcd2 = self.ArtisanLCD() # Temperature ET
        self.lcd2.setContextMenuPolicy(Qt.CustomContextMenu)
        self.lcd2.customContextMenuRequested.connect(self.setTareET)
        self.lcd3 = self.ArtisanLCD() # Temperature BT
        self.lcd3.setContextMenuPolicy(Qt.CustomContextMenu)
        self.lcd3.customContextMenuRequested.connect(self.setTareBT)
        self.lcd4 = self.ArtisanLCD() # rate of change ET
        self.lcd5 = self.ArtisanLCD() # rate of change BT
        self.lcd6 = self.ArtisanLCD() # pid sv
        self.lcd7 = self.ArtisanLCD() # pid power % duty cycle

        self.lcd1.display("00:00")
        if self.qmc.LCDdecimalplaces:
            zz = "-.-"
        else:
            zz = "--"
        self.lcd2.display(zz)
        self.lcd3.display(zz)
        self.lcd4.display(zz)
        self.lcd5.display(zz)
        self.lcd6.display(zz)
        self.lcd7.display(zz)

        self.lcd1.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
        self.lcd2.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
        self.lcd3.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
        self.lcd4.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
        self.lcd5.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
        self.lcd6.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
        self.lcd7.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))

        self.lcd1.setToolTip(QApplication.translate("Tooltip", "Timer",None))
        self.lcd2.setToolTip(QApplication.translate("Tooltip", "ET Temperature",None))
        self.lcd3.setToolTip(QApplication.translate("Tooltip", "BT Temperature",None))
        self.lcd4.setToolTip(QApplication.translate("Tooltip", "ET/time (degrees/min)",None))
        self.lcd5.setToolTip(QApplication.translate("Tooltip", "BT/time (degrees/min)",None))
        self.lcd6.setToolTip(QApplication.translate("Tooltip", "Value of SV in PID",None))
        self.lcd7.setToolTip(QApplication.translate("Tooltip", "PID power %",None))

        #MET
        self.label2 = QLabel()
        self.label2.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label2.setText("<big><b>" + u(QApplication.translate("Label", "ET",None)) + "</b></big>")
        self.setLabelColor(self.label2,QColor(self.qmc.palette["et"]))
        #BT
        self.label3 = QLabel()
        self.label3.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label3.setText("<big><b>" + u(QApplication.translate("Label", "BT",None)) + "</b></big>")
        self.setLabelColor(self.label3,QColor(self.qmc.palette["bt"]))
        #DELTA MET
        self.label4 = QLabel()
        self.label4.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label4.setText(deltaLabelBigPrefix + u(QApplication.translate("Label", "ET",None)) + "</b></big>")
        self.setLabelColor(self.label4,QColor(self.qmc.palette["deltaet"]))
        # DELTA BT
        self.label5 = QLabel()
        self.label5.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label5.setText(deltaLabelBigPrefix + u(QApplication.translate("Label", "BT",None)) + "</b></big>")
        self.setLabelColor(self.label5,QColor(self.qmc.palette["deltabt"]))
        # pid sv
        self.label6 = QLabel()
        self.label6.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label6.setText("<big><b>" + u(QApplication.translate("Label", "PID SV",None)) + "</b></big>")
        # pid power % duty cycle
        self.label7 = QLabel()
        self.label7.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        self.label7.setText("<big><b>" + u(QApplication.translate("Label", "PID %",None)) + "</b></big>")

        #extra LCDs
        self.nLCDS = 10 # maximum number of LCDs and extra devices
        self.extraLCD1,self.extraLCD2 = [],[]
        self.extraLCDlabel1,self.extraLCDlabel2 = [],[]
        self.extraLCDframe1,self.extraLCDframe2 = [],[]
        self.extraLCDvisibility1,self.extraLCDvisibility2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraCurveVisibility1,self.extraCurveVisibility2 = [True]*self.nLCDS,[True]*self.nLCDS
        self.extraDelta1,self.extraDelta2 = [False]*self.nLCDS,[False]*self.nLCDS
        self.extraFill1,self.extraFill2 = [0]*self.nLCDS,[0]*self.nLCDS # alpha values 0-100 in % of fill between extra curve and x-axis
        for i in range(self.nLCDS):
            #configure LCDs
            self.extraLCDframe1.append(QFrame())
            self.extraLCD1.append(self.ArtisanLCD())
            self.extraLCDlabel1.append(QLabel())
            self.extraLCDframe2.append(QFrame())
            self.extraLCD2.append(self.ArtisanLCD())
            self.extraLCDlabel2.append(QLabel())
            self.extraLCDframe1[i].setVisible(False)
            if self.qmc.LCDdecimalplaces:
                self.extraLCD1[i].display("-.-")
                self.extraLCD2[i].display("-.-")
            else:
                self.extraLCD1[i].display("--")
                self.extraLCD2[i].display("--")
            self.extraLCD1[i].setContextMenuPolicy(Qt.CustomContextMenu)
            self.extraLCD1[i].setContextMenuPolicy(Qt.CustomContextMenu)
            self.extraLCD1[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCD2[i].setContextMenuPolicy(Qt.CustomContextMenu)
            self.extraLCD2[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCDframe2[i].setVisible(False)
            self.extraLCD1[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.extraLCD2[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            #configure Labels
            self.extraLCDlabel1[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
            self.extraLCDlabel2[i].setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
            self.extraLCDlabel1[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
            self.extraLCDlabel2[i].setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
            
        # channel tare values (set by clicking on the corresponding LCDs)
        # for ET/BT and each extra channel (2x self.nLCDS)
        self.channel_tare_values = [0.0]*(2+self.nLCDS*2)

        # Stores messages up to 500
        self.messagehist = []

        #only leave operational the control button if the device is Fuji PID
        #the SV buttons are activated from the PID control panel 
        self.button_10.setVisible(False)

        self.button_12.setVisible(False)
        self.button_13.setVisible(False)
        self.button_14.setVisible(False)
        self.button_15.setVisible(False)
        self.button_16.setVisible(False)
        self.button_17.setVisible(False)

        #### EVENT MINI EDITOR: View&Edits events without opening roast properties Dlg.
        self.eventlabel = QLabel(QApplication.translate("Label","Event #<b>0 </b>", None))
        self.eventlabel.setIndent(5)
        self.eNumberSpinBox = QSpinBox()

        self.eNumberSpinBox.setAlignment(Qt.AlignCenter)
        self.eNumberSpinBox.setToolTip(QApplication.translate("Tooltip", "Number of events found", None))
        self.eNumberSpinBox.setRange(0,99)
        self.eNumberSpinBox.valueChanged.connect(self.changeEventNumber)
        self.eNumberSpinBox.setMaximumWidth(40)
        self.lineEvent = QLineEdit()
        self.lineEvent.setMinimumWidth(200)

        self.eventlabel.setStyleSheet("background-color:'#bdbdbd';")

        self.etypeComboBox = QComboBox()
        self.etypeComboBox.setToolTip(QApplication.translate("Tooltip", "Type of event", None))
        self.etypeComboBox.addItems(self.qmc.etypes)

        #regexvalue = QRegExp(r"^100|\d?\d?$") # allow event values 0-100 (%)
        regexvalue = QRegExp(r"^[1-9][0-9]{1,3}$|^\d$") # allow event values 0-9999
        self.valueEdit = QLineEdit()
        self.valueEdit.setValidator(QRegExpValidator(regexvalue,self))
        self.valueEdit.setToolTip(QApplication.translate("Tooltip", "Value of event", None))
        self.valueEdit.setMaximumWidth(50)

        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.etimeline = QLineEdit()
        self.etimeline.setValidator(QRegExpValidator(regextime,self))
        self.etimeline.setMaximumWidth(50)

        #create EVENT mini button
        self.buttonminiEvent = QPushButton(QApplication.translate("Button", "Update", None))
        self.buttonminiEvent.setFocusPolicy(Qt.StrongFocus)
        self.buttonminiEvent.clicked.connect(self.miniEventRecord)
        self.buttonminiEvent.setToolTip(QApplication.translate("Tooltip", "Updates the event", None))

        #### CUSTOM events buttons
        self.buttonlist = []
        self.lastbuttonpressed = -1
        self.buttonlistmaxlen = 11
        #10 palettes of buttons
        self.buttonpalette = [[],[],[],[],[],[],[],[],[],[]] # ,[],[],[],[],[]]
        self.buttonpalettemaxlen = [14]*10  #keeps max number of buttons per row per palette
        self.buttonpalette_shortcuts = True # if True palettes can be changed via the number keys
        self.buttonsize = 1 # 0: tiny, 1: small (default), 2: large

        self.eventbuttontablecolumnwidths = [] # custom event button table column widths

        #Create LOWER BUTTONS Widget layout QDialogButtonBox to stack all lower buttons
        self.lowerbuttondialogLayout = QHBoxLayout()
        self.lowerbuttondialogLayout.setSpacing(5)
        self.lowerbuttondialogLayout.setContentsMargins(0, 0, 0, 10)
        self.lowerbuttondialog = QFrame()
        self.lowerbuttondialog.setLayout(self.lowerbuttondialogLayout)
        self.lowerbuttondialog.setVisible(False)
        
        #initiate configuration
        self.lowerbuttondialogLayout.addStretch()
        self.lowerbuttondialogLayout.addWidget(self.button_8)
        self.lowerbuttondialogLayout.addWidget(self.button_19)
        self.lowerbuttondialogLayout.addWidget(self.button_3)
        self.lowerbuttondialogLayout.addWidget(self.button_4)
        self.lowerbuttondialogLayout.addWidget(self.button_5)
        self.lowerbuttondialogLayout.addWidget(self.button_6)
        self.lowerbuttondialogLayout.addWidget(self.button_9)
        self.lowerbuttondialogLayout.addWidget(self.button_20)
        self.lowerbuttondialogLayout.addWidget(self.button_11)
        self.lowerbuttondialogLayout.addStretch()

        self.e1buttonbarLayout = QHBoxLayout()
        self.e1buttonbarLayout.setSpacing(1)
        self.e1buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog = QFrame()
        self.e1buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog.setLayout(self.e1buttonbarLayout)
        
        self.e2buttonbarLayout = QHBoxLayout()
        self.e2buttonbarLayout.setSpacing(1)
        self.e2buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog = QFrame()
        self.e2buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog.setLayout(self.e2buttonbarLayout)
        
        self.e3buttonbarLayout = QHBoxLayout()
        self.e3buttonbarLayout.setSpacing(1)
        self.e3buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog = QFrame()
        self.e3buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog.setLayout(self.e3buttonbarLayout)
        
        self.e4buttonbarLayout = QHBoxLayout()
        self.e4buttonbarLayout.setSpacing(1)
        self.e4buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog = QFrame()
        self.e4buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog.setLayout(self.e4buttonbarLayout)

        # set the focus on the main widget
        self.main_widget.setFocus()

        # set the central widget of MainWindow to main_widget
        self.setCentralWidget(self.main_widget)

        #list of functions to chose from (using left-right keyboard arrow)
        self.keyboardmove = [self.qmc.reset,self.qmc.toggleHUD,self.qmc.ToggleMonitor,self.qmc.markCharge,self.qmc.markDryEnd,self.qmc.mark1Cstart,self.qmc.mark1Cend,
                             self.qmc.mark2Cstart,self.qmc.mark2Cend,self.qmc.markDrop,self.qmc.markCoolEnd,self.qmc.EventRecord]
        # list of buttons that can be controlled via the keyboard
        # RESET -> HUD -> ON/OFF -> .. -> EVENT (RESET at index 0 is never used)
        self.keyboardButtonList = [self.button_7, self.button_18,self.button_1,self.button_8,self.button_19,self.button_3,self.button_4,self.button_5,self.button_6,self.button_9,self.button_20,self.button_11]
        # 0:RESET,1:HUD,2:ON/OFF,3:CHARGE,4:DRY,5:FCs,6:FCe,7:SCs,8:SCe,9:DROP,10:COOL,11:EVENT
        self.keyboardButtonStyles = ["RESET","HUD_ON","ON","CHARGE","DRY END","FC START","FC END","SC START","SC END","DROP","COOL END","EVENT"]

        #current function above
        self.keyboardmoveindex = 3
        #state flag for above. It is initialized by pressing SPACE or left-right arrows
        self.keyboardmoveflag = 0
        #time stamp of last keyboard event SPACE to prevent multiple recognitions
        self.lastkeyboardcmd = 0
        
        self.error_dlg = None # bound to the error message window instance if open, update by updategraphics
        self.serial_dlg = None # bound to the serial message window if open, update by updategraphics
        self.message_dlg = None # bound to the serial message window if open, update by updategraphics

        self.ETname = QApplication.translate("Label", "ET",None)
        self.BTname = QApplication.translate("Label", "BT",None)

        ####################   APPLICATION WINDOW (AW) LAYOUT  ##############################################

        self.level1frame = QFrame()
        self.level1layout = QHBoxLayout()   # matplotlib toolbox + HUD button + reset button + LCD Timer
        self.level1frame.setLayout(self.level1layout)

        level3layout = QHBoxLayout()   # PID buttons, graph, temperature LCDs

        pidbuttonLayout = QVBoxLayout()

        EventsLayout = QHBoxLayout()
        EventsLayout.setContentsMargins(1,1,1,1)
        EventsLayout.setSpacing(0)

        #EVENT MINIEDITOR layout
        EventsLayout.addWidget(self.eventlabel)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etimeline)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.lineEvent)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etypeComboBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.valueEdit)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.eNumberSpinBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.buttonminiEvent)
        self.EventsGroupLayout = QGroupBox()
        self.EventsGroupLayout.setLayout(EventsLayout)
        self.EventsGroupLayout.setVisible(False)

        LCDlayout = QVBoxLayout() 
        LCDlayout.setSpacing(0)
        LCDlayout.setContentsMargins(0,0,5,0)

        #place control buttons + LCDs inside vertical button layout manager
        self.LCD2frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label2,self.lcd2,self.LCD2frame))

        self.LCD3frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label3,self.lcd3,self.LCD3frame))

        self.LCD6frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label6,self.lcd6,self.LCD6frame))
        self.LCD6frame.setVisible(False)

        self.LCD7frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label7,self.lcd7,self.LCD7frame))
        self.LCD7frame.setVisible(False)

        self.LCD4frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label4,self.lcd4,self.LCD4frame))
        self.LCD4frame.setVisible(False) # by default this one is not visible

        self.LCD5frame = QFrame()
        LCDlayout.addWidget(self.makeLCDbox(self.label5,self.lcd5,self.LCD5frame))

        #add extra LCDs
        for i in range(self.nLCDS):
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel1[i],self.extraLCD1[i],self.extraLCDframe1[i]))
            LCDlayout.addWidget(self.makeLCDbox(self.extraLCDlabel2[i],self.extraLCD2[i],self.extraLCDframe2[i]))
        LCDlayout.addStretch()

        #PID Buttons
        pidbuttonLayout.addWidget(self.button_14)
        pidbuttonLayout.addWidget(self.button_13)
        pidbuttonLayout.addWidget(self.button_12)
        pidbuttonLayout.addWidget(self.button_17)
        pidbuttonLayout.addWidget(self.button_16)
        pidbuttonLayout.addWidget(self.button_15)

        # phases LCDs
        
        # TP
        self.TPlabel = QLabel()
        self.TPlabel.setText("<small><b>" + u(QApplication.translate("Label", "TP",None)) + "&raquo;</b></small>")
        self.TPlcd = QLCDNumber()
        self.TPlcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.TPlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.TPlcd.display("--:--")
        self.TPlcdFrame = self.makePhasesLCDbox(self.TPlabel,self.TPlcd)

        # TP2DRY
        self.TP2DRYlabel = QLabel("")
        self.TP2DRYlabel.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        TP2DRYlayout = QHBoxLayout()
        TP2DRYlayout.addWidget(self.TP2DRYlabel)
        TP2DRYlayout.setContentsMargins(3,0,3,0)
        self.TP2DRYframe = QFrame()
        self.TP2DRYframe.setLayout(TP2DRYlayout)

        # DRY
        self.DRYlabel = QLabel()
        self.DRYlabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "DRY",None)) + "</b></small>")
        self.DRYlcd = QLCDNumber()
        self.DRYlcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.DRYlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.DRYlcd.display("--:--")
        self.DRYlcdFrame = self.makePhasesLCDbox(self.DRYlabel,self.DRYlcd)

        # DRY2FCs
        self.DRY2FCslabel = QLabel("")
        self.DRY2FCslabel.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        DRY2FCslayout = QHBoxLayout()
        DRY2FCslayout.addWidget(self.DRY2FCslabel)
        DRY2FCslayout.setContentsMargins(3,0,3,0)
        self.DRY2FCsframe = QFrame()
        self.DRY2FCsframe.setLayout(DRY2FCslayout)

        # FCs
        self.FCslabel = QLabel()
        self.FCslabel.setText("<small><b>&raquo;" + u(QApplication.translate("Label", "FCs",None)) + "</b></small>")
        self.FCslcd = QLCDNumber()
        self.FCslcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.FCslcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.FCslcd.display("--:--")
        self.FCslcdFrame = self.makePhasesLCDbox(self.FCslabel,self.FCslcd)

        # AUC LCD
        self.AUClabel = QLabel()
        self.AUClabel.setText("<small><b>" + u(QApplication.translate("Label", "AUC",None)) + "</b></small>")
        self.AUClcd = QLCDNumber()
        self.AUClcd.setContextMenuPolicy(Qt.CustomContextMenu)
        self.AUClcd.customContextMenuRequested.connect(self.AUClcdClicked)
        self.AUClcd.display("---")
        self.AUClcdFrame = self.makePhasesLCDbox(self.AUClabel,self.AUClcd)
#        self.AUClcdFrame.setFrameStyle(QFrame.Plain)
        self.AUClcd.setNumDigits(3)
        self.AUClcd.setMinimumWidth(65)
        self.AUClcdFrame.setStyleSheet("QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}")
        
        AUCLayout = QHBoxLayout()
        AUCLayout.addSpacing(20)
        AUCLayout.addWidget(self.AUClcdFrame)
        AUCLayout.setContentsMargins(0, 0, 0, 0)
        AUCLayout.setSpacing(0)
        
        self.AUCLCD = QFrame()
        self.AUCLCD.setContentsMargins(0, 0, 0, 0)
        self.AUCLCD.setLayout(AUCLayout)
        self.AUCLCD.hide()
        

        self.phasesLCDs = QFrame()
        self.phasesLCDs.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout = QHBoxLayout()
        phasesLCDlayout.addWidget(self.TPlcdFrame)
        phasesLCDlayout.addWidget(self.TP2DRYframe)
        phasesLCDlayout.addWidget(self.DRYlcdFrame)
        phasesLCDlayout.addWidget(self.DRY2FCsframe)
        phasesLCDlayout.addWidget(self.FCslcdFrame)
        phasesLCDlayout.setContentsMargins(0, 0, 0, 0)
        phasesLCDlayout.setSpacing(0)
        self.phasesLCDs.setLayout(phasesLCDlayout)
        self.phasesLCDs.hide()
        self.phasesLCDs.setToolTip(QApplication.translate("Tooltip","Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE", None))

        #level 1
#        self.level1layout.addWidget(self.ntb)
        self.level1layout.addStretch()
        self.level1layout.addWidget(self.phasesLCDs)
        self.level1layout.addWidget(self.AUCLCD)
        self.level1layout.addSpacing(20)
        self.level1layout.addWidget(self.button_7)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.button_1)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.button_2)
        self.level1layout.addSpacing(15)
        self.level1layout.addWidget(self.button_10)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.button_18)
        self.level1layout.addSpacing(10)
        self.level1layout.addWidget(self.lcd1)
        self.level1layout.setSpacing(0)
        self.level1layout.setContentsMargins(0,7,7,12) # left, top, right, bottom

        #level 3
        level3layout.addLayout(pidbuttonLayout,0)
        level3layout.addWidget(self.stack,1)
        level3layout.setSpacing(0)
        level3layout.setContentsMargins(0,0,0,0)

        extrabuttonsLayout = QVBoxLayout()
        extrabuttonsLayout.setContentsMargins(0,0,0,10)
        extrabuttonsLayout.setSpacing(5)
        extrabuttonsLayout.addWidget(self.e1buttondialog)
        extrabuttonsLayout.addWidget(self.e2buttondialog)
        extrabuttonsLayout.addWidget(self.e3buttondialog)
        extrabuttonsLayout.addWidget(self.e4buttondialog)

        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)
        
        self.extrabuttondialogs = QFrame()
        self.extrabuttondialogs.setLayout(extrabuttonsLayout)
        self.extrabuttondialogs.setVisible(False)

        midleftlayout = QVBoxLayout()
        midleftlayout.setSpacing(0)
        midleftlayout.setContentsMargins(0,0,0,0)
        midleftlayout.addWidget(self.messagelabel)
        midleftlayout.addLayout(level3layout)
        midleftlayout.addWidget(self.lowerbuttondialog)
        midleftlayout.addWidget(self.extrabuttondialogs) 
        midleftlayout.addWidget(self.EventsGroupLayout)

        self.slider1 = self.slider()
        self.sliderLCD1 = self.sliderLCD()
        self.sliderLCD1.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[0])
        self.sliderLCD1.display(self.slider1.value())
        sliderGrp1 = QVBoxLayout()
        sliderGrp1.addWidget(self.sliderLCD1)
        sliderGrp1.addWidget(self.slider1)
        sliderGrp1.setAlignment(Qt.AlignCenter)
        sliderGrp1.setContentsMargins(0,7,0,0)
        sliderGrp1.setSpacing(0)
        self.sliderGrpBox1 = QGroupBox()
        self.sliderGrpBox1.setLayout(sliderGrp1)
        self.sliderGrpBox1.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox1.setMinimumWidth(55) 
        self.sliderGrpBox1.setMaximumWidth(55)
        self.sliderGrpBox1.setVisible(False)
        self.sliderGrpBox1.setFlat(True)
        self.sliderGrpBox1x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox1x.addWidget(self.sliderGrpBox1)
        self.slider1.setTracking(False)
        self.slider1.sliderMoved.connect(self.slider1Moved)
        self.slider1.valueChanged.connect(self.slider1valueChanged)
        self.slider1.actionTriggered.connect(self.slider1actionTriggered)
        self.slider1.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus
        

        self.slider2 = self.slider()
        self.sliderLCD2 = self.sliderLCD() 
        self.sliderLCD2.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[1])
        self.sliderLCD2.display(self.slider2.value())
        sliderGrp2 = QVBoxLayout()
        sliderGrp2.addWidget(self.sliderLCD2)
        sliderGrp2.addWidget(self.slider2)
        sliderGrp2.setAlignment(Qt.AlignCenter)
        sliderGrp2.setContentsMargins(0,7,0,0)
        sliderGrp2.setSpacing(0)
        self.sliderGrpBox2 = QGroupBox()
        self.sliderGrpBox2.setLayout(sliderGrp2)
        self.sliderGrpBox2.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox2.setMinimumWidth(55) 
        self.sliderGrpBox2.setMaximumWidth(55) 
        self.sliderGrpBox2.setVisible(False)
        self.sliderGrpBox2.setFlat(True)
        self.sliderGrpBox2x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox2x.addWidget(self.sliderGrpBox2)
        self.slider2.setTracking(False)
        self.slider2.sliderMoved.connect(self.slider2Moved)
        self.slider2.valueChanged.connect(self.slider2valueChanged)
        self.slider2.actionTriggered.connect(self.slider2actionTriggered)
        self.slider2.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider3 = self.slider()
        self.sliderLCD3 = self.sliderLCD()
        self.sliderLCD3.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[2])
        self.sliderLCD3.display(self.slider3.value())
        sliderGrp3 = QVBoxLayout()
        sliderGrp3.addWidget(self.sliderLCD3)
        sliderGrp3.addWidget(self.slider3)
        sliderGrp3.setAlignment(Qt.AlignCenter)
        sliderGrp3.setContentsMargins(0,7,0,0)
        sliderGrp3.setSpacing(0)
        self.sliderGrpBox3 = QGroupBox()
        self.sliderGrpBox3.setLayout(sliderGrp3)
        self.sliderGrpBox3.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox3.setMinimumWidth(55) 
        self.sliderGrpBox3.setMaximumWidth(55) 
        self.sliderGrpBox3.setVisible(False)
        self.sliderGrpBox3.setFlat(True)
        self.sliderGrpBox3x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox3x.addWidget(self.sliderGrpBox3)
        self.slider3.setTracking(False)
        self.slider3.sliderMoved.connect(self.slider3Moved)
        self.slider3.valueChanged.connect(self.slider3valueChanged)
        self.slider3.actionTriggered.connect(self.slider3actionTriggered)
        self.slider3.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.slider4 = self.slider()
        self.sliderLCD4 = self.sliderLCD()
        self.sliderLCD4.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[3])
        self.sliderLCD4.display(self.slider4.value())
        sliderGrp4 = QVBoxLayout()
        sliderGrp4.addWidget(self.sliderLCD4)
        sliderGrp4.addWidget(self.slider4)
        sliderGrp4.setAlignment(Qt.AlignCenter)
        sliderGrp4.setContentsMargins(0,7,0,0)
        sliderGrp4.setSpacing(0)
        self.sliderGrpBox4 = QGroupBox()
        self.sliderGrpBox4.setLayout(sliderGrp4)
        self.sliderGrpBox4.setAlignment(Qt.AlignCenter)
        self.sliderGrpBox4.setMinimumWidth(55) 
        self.sliderGrpBox4.setMaximumWidth(55) 
        self.sliderGrpBox4.setVisible(False)
        self.sliderGrpBox4.setFlat(True)
        self.sliderGrpBox4x = QVBoxLayout() # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox4x.addWidget(self.sliderGrpBox4)
        self.slider4.setTracking(False)
        self.slider4.sliderMoved.connect(self.slider4Moved)
        self.slider4.valueChanged.connect(self.slider4valueChanged)
        self.slider4.actionTriggered.connect(self.slider4actionTriggered)
        self.slider4.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        self.sliderSV = self.slider()
        self.sliderLCDSV = self.sliderLCD()
#        self.sliderLCDSV.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.palette["text"])
        self.sliderLCDSV.setNumDigits(3)
        self.sliderLCDSV.setStyleSheet("font-weight: bold;")
        self.sliderLCDSV.display(self.pidcontrol.svValue)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.addWidget(self.sliderLCDSV)
        sliderGrpSV.addWidget(self.sliderSV)
        sliderGrpSV.setAlignment(Qt.AlignCenter)
        sliderGrpSV.setContentsMargins(0,7,0,0)
        sliderGrpSV.setSpacing(0)
        self.sliderGrpBoxSV = QGroupBox()
        self.sliderGrpBoxSV.setLayout(sliderGrpSV)
        self.sliderGrpBoxSV.setAlignment(Qt.AlignCenter)
        self.sliderGrpBoxSV.setMinimumWidth(55) 
        self.sliderGrpBoxSV.setMaximumWidth(55) 
        self.sliderGrpBoxSV.setVisible(False)
        self.sliderGrpBoxSV.setTitle("SV")
        self.sliderGrpBoxSV.setFlat(True)
        #self.sliderSV.setTracking(False)
        self.sliderSV.valueChanged.connect(self.updateSVSliderLCD)
        self.sliderSV.sliderReleased.connect(self.sliderSVreleased)
        self.sliderSV.actionTriggered.connect(self.sliderSVactionTriggered)
        self.sliderSV.setFocusPolicy(Qt.StrongFocus) # ClickFocus TabFocus StrongFocus

        sliderGrp12 = QVBoxLayout()
        sliderGrp12.setSpacing(0)
        sliderGrp12.setContentsMargins(0,0,0,0)
        sliderGrp12.addLayout(self.sliderGrpBox1x)
        sliderGrp12.addLayout(self.sliderGrpBox2x)
        sliderGrp34 = QVBoxLayout()
        sliderGrp34.setSpacing(0)
        sliderGrp34.setContentsMargins(0,0,0,0)
        sliderGrp34.addLayout(self.sliderGrpBox3x)
        sliderGrp34.addLayout(self.sliderGrpBox4x)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.setSpacing(0)
        sliderGrpSV.setContentsMargins(0,0,0,0)
        sliderGrpSV.addWidget(self.sliderGrpBoxSV)

        self.leftlayout = QHBoxLayout()
        self.leftlayout.setSpacing(0)
        self.leftlayout.setContentsMargins(0,0,0,0)
        self.leftlayout.addLayout(sliderGrp12)
        self.leftlayout.addLayout(sliderGrp34)
        self.leftlayout.addLayout(sliderGrpSV)

        self.sliderFrame = QFrame()
        self.sliderFrame.setLayout(self.leftlayout)
        self.sliderFrame.setVisible(False)
        self.sliderFrame.setContentsMargins(0,0,0,0)

        self.lcdFrame = QFrame()
        self.lcdFrame.setLayout(LCDlayout)
        self.lcdFrame.setVisible(False)
        self.lcdFrame.setContentsMargins(0,0,0,0)
        self.lcdFrame.setSizePolicy(QSizePolicy.Maximum,QSizePolicy.Expanding) # prevent horizontal expansion (graph might not maximize otherwise)

        self.midlayout = QHBoxLayout()
        self.midlayout.addWidget(self.sliderFrame)
        self.midlayout.addLayout(midleftlayout)
        self.midlayout.addWidget(self.lcdFrame)
        self.midlayout.setSpacing(0)
        self.midlayout.setContentsMargins(0,0,0,0)

        mainlayout = QVBoxLayout(self.main_widget)
        mainlayout.addWidget(self.level1frame)
        mainlayout.addLayout(self.midlayout) 
        mainlayout.setContentsMargins(0,0,0,0)
        mainlayout.setSpacing(0)
        
        self.qmc.toolbar.hide() # we need to hide the default navigation toolbar that we don't use
        self.qmc.toolbar.destroy()
        
        # this variable is bound to the Roast Properties dialog if it is open, set to False to block opening the dialog or None otherwise
        self.editgraphdialog = None 
        
#        # provide information message to user about sharing settings at start-up
        if settingsRelocated:
            string =  QApplication.translate("Message","Welcome to version {0} of Artisan!", None).format(__version__) + "\n\n"
            string += QApplication.translate("Message","This is a one time message to inform you about a change in Artisan.", None) + "\n\n"
            string += QApplication.translate("Message","If you never run older versions of Artisan you can skip this message, the change does not affect you.", None) + "  "
            string += QApplication.translate("Message","Artisan preserves all your configuration settings when you exit so they will automatically be available the next time you start Artisan.", None) + "  "
            string += QApplication.translate("Message","Beginning with release v2.0, settings will no longer be automatically shared at start-up with versions before v2.0.", None) + "\n\n"  
            string += QApplication.translate("Message","Do not worry. Since this is the first time you opened this new version Artisan has already loaded your last used settings.", None) + "\n\n"
            string += QApplication.translate("Message","To share settings between this version and Artisan versions before v2.0 use 'Help>Save Settings' and 'Help>Load Settings'.", None) + "\n\n"
            string += QApplication.translate("Message","Enjoy using Artisan, The Artisan Team", None)
            QMessageBox.information(aw,QApplication.translate("Message","One time message about loading settings at start-up", None),string)

        # provide information message to user about ArtisanViewer the first time it is started
        if artisanviewerFirstStart:
            string =  QApplication.translate("Message","Welcome to the ArtisanViewer!", None).format(__version__) + "\n\n"
            string += QApplication.translate("Message","This is a one time message to introduce you to the ArtisanViewer.", None) + "\n\n"
            string += QApplication.translate("Message","The ArtisanViewer opens whenever a copy of Artisan is already running.", None) + "\n\n"
            string += QApplication.translate("Message","ArtisanViewer will preserve all your configuration settings when you exit so they will automatically be available the next time you start ArtisanViewer.", None) + "\n\n"
            string += QApplication.translate("Message","Caution, the only way to share settings between Artisan and ArtisanViewer is to explicitly save and load them using 'Help>Save Settings' and 'Help>Load Settings'.", None) + "\n\n"
            string += QApplication.translate("Message","Enjoy using ArtisanViewer,", None) +"\n"
            string += QApplication.translate("Message","The Artisan Team", None)
            QMessageBox.information(aw,QApplication.translate("Message","One time message about ArtisanViewer", None),string)
            settings.setValue("Mode",self.qmc.mode)  #prevent this popup in case a second instance is started before this first one is closed.

        # we connect the signals
        self.singleShotPhidgetsPulseOFF.connect(self.processSingleShotPhidgetsPulse)
        self.singleShotPhidgetsPulseOFFSerial.connect(self.processSingleShotPhidgetsPulse)
        self.setTitleSignal.connect(self.qmc.setProfileTitle)
        self.sendmessageSignal.connect(self.sendmessage)
        self.openPropertiesSignal.connect(self.editgraph)
        
        
        if sys.platform.startswith("darwin"):
            # only on macOS we install the eventFilter to catch the signal on switching between light and dark modes
            self.installEventFilter(self)
        
#PLUS
        self.updatePlusStatusSignal.connect(self.updatePlusStatusSlot)

    # takes a fit from numpy.polyfit and renders it as string to be copied as symbolic formula
    def fit2str(self,fit):
        s = ""
        sign = "+"
        fit = fit[::-1]
        try:
            for i in range(len(fit)):
                v = abs(fit[i])
                if round(v,3) != 0.0:
                    if i == 0:
                        s = ("%.4f" % v)
                    elif i == 1:
                        if s != "":
                            s = " " + sign + " " + s
                        if v == 1:
                            s = ("x" + s)
                        else:
                            s = ("%.4f*x" % v + s)
                    else:
                        if s != "":
                            s = " " + sign + " " + s
                        if v == 1:
                            s = ("x^%i" % i + s)
                        else:
                            s = ("%.4f*x^%i" % (v,i) + s)
                    s = s.rstrip('0').rstrip('.')
                    if fit[i] < 0:
                        sign = "-"
                    else:
                        sign = "+"
            if sign == "-":
                s = sign + s
        except:
            pass
        return s

    def eventFilter(self, obj, event):
        if event.type() == QEvent.ApplicationPaletteChange:  # called if the palette changed (switch between dark and light mode on macOS)
            self.updateCanvasColors()
            return True
        return super(ApplicationWindow, self).eventFilter(obj, event)
    
    # search the given QTable table for a row with the given widget as cellWidget or item in column col or as a sub-widget contained in the layout of a widget in place
    # returns the row number if the widget was found or None
    def findWidgetsRow(self,table,widget,col):
        for r in range(table.rowCount()):
            if table.cellWidget(r,col) == widget or table.item(r,col) == widget or \
                (table.cellWidget(r,col) is not None and table.cellWidget(r,col).layout() is not None and table.cellWidget(r,col).layout().indexOf(widget) > -1):
                return r
        return None

    # search the given QTable table for a column with the given widget in row
    # returns the column number if the widget was found or None
    def findWidgetsColumn(self,table,widget,row):
        for c in range(table.columnCount()):
            if table.cellWidget(row,c) == widget or table.item(row,c) == widget or \
                (table.cellWidget(row,c) is not None and table.cellWidget(row,c).layout() is not None and table.cellWidget(row,c).layout().indexOf(widget) > -1):
                return c
        return None

    @pyqtSlot()
    def redraw_action(self):
        try:
            self.qmc.redraw(False,False)
        except:
            # self.qmc might not be defined yet
            pass

    # c a QColor instance, returns the standard W3C value for the perceived brightness of an RGB color in the range of 0-255, ignoring the alpha channel
    # see https://www.w3.org/TR/AERT/#color-contrast
    def QColorBrightness(self,c):
        r,g,b,_ = c.getRgb()
        return ((r*299) + (g*587) + (b*114)) / 1000

    # this is important to have . as decimal separator independent of the systems locale
    def createCLocaleDoubleValidator(self,bot,top,dec,w):
        validator = QDoubleValidator(bot,top,dec,w)
        validator.setLocale(QLocale.c())
        return validator
    
    def buttonPressed(self, button):
        # shadow needs to be recreated each time?
        self.strong_shadow = QGraphicsDropShadowEffect(self)
        self.strong_shadow.setBlurRadius(30)
        self.strong_shadow.setOffset(0,3)
        button.setGraphicsEffect(self.strong_shadow)

    def buttonReleased(self,button):
        # shadow needs to be recreated each time?
        self.shadow = QGraphicsDropShadowEffect(self)
        self.shadow.setBlurRadius(20)
        self.shadow.setOffset(0,0.9)
        button.setGraphicsEffect(self.shadow)
    
    @pyqtSlot()
    def button1Pressed(self):
        self.buttonPressed(self.button_1)
    @pyqtSlot()
    def button2Pressed(self):
        self.buttonPressed(self.button_2)
    @pyqtSlot()
    def button7Pressed(self):
        self.buttonPressed(self.button_7)
    @pyqtSlot()
    def button10Pressed(self):
        self.buttonPressed(self.button_10)
        
    @pyqtSlot()
    def button1Released(self):
        self.buttonReleased(self.button_1)
    @pyqtSlot()
    def button2Released(self):
        self.buttonReleased(self.button_2)
    @pyqtSlot()
    def button7Released(self):
        self.buttonReleased(self.button_7)
    @pyqtSlot()
    def button10Released(self):
        self.buttonReleased(self.button_10)

    def createGradient(self,rgb, tint_factor=0.1, shade_factor=0.1, reverse=False):
        default_gradient = 'light_to_dark'  # set this to either 'dark_to_light' or 'light_to_dark'
        if reverse == True:
            if default_gradient == 'dark_to_light':
                cdir = 'light2dark'
            else:
                cdir = 'dark2light'
        else:
            if default_gradient == 'dark_to_light':
                cdir = 'dark2light'
            else:
                cdir = 'light2dark'
        if cdir == 'dark2light':
            res = "QLinearGradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 " + self.createRGBGradient(rgb,tint_factor,shade_factor)[1] + ", stop: 1 " + self.createRGBGradient(rgb,tint_factor,shade_factor)[0] +");"
        else:    # light2dark
            res = "QLinearGradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 " + self.createRGBGradient(rgb,tint_factor,shade_factor)[0] + ", stop: 1 " + self.createRGBGradient(rgb,tint_factor,shade_factor)[1] +");"
        return res

    def createRGBGradient(self,rgb, tint_factor=0.3, shade_factor=0.3):
        from matplotlib import colors
        try:
            if rgb[0:1] == "#":   # hex input like "#ffaa00"
                rgb_tuple = tuple(int(rgb[i:i+2], 16)/255 for i in (1, 3 ,5))
            else:                 # color name
                rgb_tuple = colors.hex2color(colors.cnames[rgb])
            #ref: https://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade
#            rgb_tuple = tuple(int(rgb[i:i+2], 16)/255 for i in (1, 3 ,5))
            darker_rgb  = '#%02x%02x%02x' % (tuple([int(255 * (x * (1 - shade_factor))) for x in rgb_tuple]))
            lighter_rgb = '#%02x%02x%02x' % (tuple([int(255 * (x + (1 - x) * tint_factor)) for x in rgb_tuple]))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " createRGBGradient(): {0}").format(str(e)),exc_tb.tb_lineno)
            lighter_rgb = darker_rgb = "000000"
        return lighter_rgb,darker_rgb

    # for use in widgets that expects a double via a aw.createCLocalDoubleValidator that accepts both,
    # one dot and several commas. If there is no dot, the last comma is interpreted as decimal separator and the others removed
    # if there is a dot, the last one is used as a decimal separator and all other comma and dots are removed
    def comma2dot(self,s):
        s = s.strip()
        last_dot = s.rfind('.')
        if last_dot > -1:
            if last_dot + 1 == len(s):
                # this is just a trailing dot, we remove this and all other dots and commas
                return s.replace(',','').replace('.','')
            else:
                # we just keep this one and remove all other comma and dots
                return s[:last_dot].replace(',','').replace('.','') + s[last_dot:].replace(',','')
        else:
            # there is no dot in the string
            last_pos = s.rfind(',')
            if last_pos > -1:
                if last_pos + 1 == len(s):
                    # this is just a trailing comma, we remove this and all other dots and commas
                    return s.replace(',','').replace('.','')
                else:
                    # we turn the last comma into a dot and remove all others
                    return s[:last_pos].replace(',','') + '.' + s[last_pos+1:]
            else:
                return s
    
    @pyqtSlot("QPoint")
    def setTareET(self,_):
        self.setTare(0)

    @pyqtSlot("QPoint")
    def setTareBT(self,_):
        self.setTare(1)
    
    @pyqtSlot("QPoint")
    def setTare_slot(self,_):
        sender = self.sender()
        try:
            idx = self.extraLCD1.index(sender)
            self.setTare(2+idx*2)
        except:
            pass
        try:
            idx = self.extraLCD2.index(sender)
            self.setTare(2+idx*2 + 1)
        except:
            pass
    
    # set the tare values per channel (0: ET, 1:BT, 2:E1c0, 3:E1c1, 4:E1c0, 5:E1c1,...)
    def setTare(self,n):
        if self.qmc.flagon: # we set the tare value
            if n == 0 and len(self.qmc.temp1)>0: # ET
                self.channel_tare_values[n] = self.channel_tare_values[n] + self.qmc.temp1[-1]
            elif n == 1 and len(self.qmc.temp2)>0: # BT
                self.channel_tare_values[n] = self.channel_tare_values[n] + self.qmc.temp2[-1]
            else:
                i = (n - 2) // 2
                if n % 2 == 0 and len(self.qmc.extratemp1)>i and len(self.qmc.extratemp1[i])>0: # even
                    self.channel_tare_values[n] = self.channel_tare_values[n] + self.qmc.extratemp1[i][-1]
                elif len(self.qmc.extratemp2)>i and len(self.qmc.extratemp2[i])>0:
                    self.channel_tare_values[n] = self.channel_tare_values[n] + self.qmc.extratemp2[i][-1]
        else: # we reset the tare value
            self.channel_tare_values[n] = 0
    
#PLUS
    @pyqtSlot()
    def updatePlusStatusSlot(self):
        self.updatePlusStatus()
        
    def updatePlusStatus(self,ntb=None):
        if ntb is None:
            ntb = self.ntb
        try:
            subscription_icon = None
            if aw.plus_account is not None:
                if plus.controller.is_connected():
                    if aw.editgraphdialog == False:
                        # syncing from server in progress
                        plus_icon = "plus-dirty"
                        tooltip = QApplication.translate("Tooltip", 'Syncing with artisan.plus', None)    
                    else:
                        if plus.controller.is_synced():
                            plus_icon = "plus-connected"
                            tooltip = QApplication.translate("Tooltip", 'Disconnect artisan.plus', None)
                        else:
                            plus_icon = "plus-unsynced"   
                            tooltip = QApplication.translate("Tooltip", 'Upload to artisan.plus', None)
                    if not aw.plus_readonly:
                        if aw.plus_subscription == "HOME":
                            subscription_icon = "plus-home"
                            if aw.plus_paidUntil is not None:
                                remaining_days = (aw.plus_paidUntil.date() - datetime.datetime.now().date()).days
                                if remaining_days <= 0:
                                    subscription_icon = "plus-home-off"
                                elif  remaining_days < 31:
                                    subscription_icon = "plus-home-low"
                        elif aw.plus_subscription == "PRO":
                            subscription_icon = "plus-pro"
                            if aw.plus_paidUntil is not None:
                                remaining_days = (aw.plus_paidUntil.date() - datetime.datetime.now().date()).days
                                if remaining_days <= 0:
                                    subscription_icon = "plus-pro-off"
                                elif  remaining_days < 31:
                                    subscription_icon = "plus-pro-low"
                else:
                    plus_icon = "plus-on"
                    tooltip = QApplication.translate("Tooltip", 'Disconnect artisan.plus', None)
            else:
                plus_icon = "plus-off"
                tooltip = QApplication.translate("Tooltip", 'Connect artisan.plus', None)
            if svgsupport:
                plus_icon += ".svg"
            else:
                plus_icon += ".png"
            if subscription_icon is not None:
                if svgsupport:
                    subscription_icon += ".svg"
                else:
                    subscription_icon += ".png"
            if len(ntb.actions()) > 0:
                a = ntb.actions()[0] # the plus action is the first one
                a.setIcon(ntb._icon(plus_icon))
                a.setToolTip(tooltip)
                if len(ntb.actions()) > 1:
                    a = ntb.actions()[1] # the plus subscription action is the second one
                    if subscription_icon is None:
                        a.setEnabled(False)
                        a.setIcon(QIcon())
                    else:
                        a.setEnabled(True)
                        a.setIcon(ntb._icon(subscription_icon))
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " updatePlusStatus(): {0}").format(str(e)),exc_tb.tb_lineno)


    
    # turns channel off after millis
    def processSingleShotPhidgetsPulse(self,channel,millis,fct,serial=None):
        if fct == "OUTsetPWM":
            QTimer.singleShot(millis,lambda : self.ser.phidgetOUTsetPWM(channel,0,serial))
        elif fct == "OUTsetPWMhub":
            QTimer.singleShot(millis,lambda : self.ser.phidgetOUTsetPWMhub(channel,0,serial))
        elif fct == "BinaryOUTset":
            QTimer.singleShot(millis,lambda : self.ser.phidgetBinaryOUTset(channel,0,serial))
        

###################################   APPLICATION WINDOW (AW) FUNCTIONS  ##################################### 

    # if recurse is True (default) and no selection exists, all is selected before calling the copy function again
    def copy_cells_to_clipboard(self,table_widget, adjustment=0,recurse=True):  # adjustment bitwise 0:None, 1: add leading tab to header, 2: add leading tab to first data row, 4: remove extra cell at the end of header
        if len(table_widget.selectionModel().selectedIndexes()) > 0:
            # sort select indexes into rows and columns
            previous = table_widget.selectionModel().selectedIndexes()[0]
            columns = []
            rows = []
            for index in table_widget.selectionModel().selectedIndexes():
                if previous.row() != index.row():
                    columns.append(rows)
                    rows = []
                rows.append(index.data())
                previous = index
            columns.append(rows)

            # add rows and columns to clipboard
            clipboard = ""
            nrows = len(columns)
            ncols = len(columns[0])
            if adjustment & 4:
                ncols = ncols - 1

            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.AltModifier:  #alt click
                tbl = prettytable.PrettyTable()
                re_strip = re.compile(u'[\u2009]')  #thin space is not read properly by prettytable
                fields = []
                if adjustment & 1:
                    fields.append(u(" "))
                for c in range(ncols):
                    hdr = re_strip.sub('',u(table_widget.horizontalHeaderItem(c).text()))
                    #protect against duplicate header labels
                    while hdr in fields:
                        hdr = hdr + " "
                    fields.append(hdr)
                tbl.field_names = fields
                for r in range(nrows):
                    tblrows = []
                    if adjustment & 2 and r == 0:
                        tblrows.append(" ")
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(" ")
                            if idx > -1 and c == 0:
                                tblrows.append(entry[:idx])
                                tblrows.append(entry[idx+1:])
                            else:
                                tblrows.append(entry)
                    tbl.add_row(tblrows)
                clipboard = tbl.get_string()
            else:
                if adjustment & 1:
                    clipboard += "" + '\t'
                for c in range(ncols):
                    clipboard += u(table_widget.horizontalHeaderItem(c).text())
                    if c != (ncols-1):
                        clipboard += '\t'
                clipboard += '\n'
                if adjustment & 2:
                    clipboard += "" + '\t'
                for r in range(nrows):
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(" ")
                            if idx > -1 and c == 0:
                                entry = entry[:idx] + "\t" + entry[idx+1:]
                            clipboard += entry
                            if c != (ncols-1):
                                clipboard += '\t'
                    clipboard = clipboard[:-1] + '\n'
            # copy to the system clipboard
            sys_clip = QApplication.clipboard()
            sys_clip.setText(clipboard)
        # if nothing is selected, temporary select all and try to copy
        elif recurse:
            table_widget.selectAll()
            self.copy_cells_to_clipboard(table_widget, adjustment, False)
            table_widget.clearSelection()
            
    def createRecentRoast(self,title,beans,weightIn,
            weightUnit,volumeIn,volumeUnit,densityWeight,beanSize_min, beanSize_max,
            moistureGreen,colorSystem,file,roastUUID,
            batchnr,batchprefix,plus_account,plus_store,plus_store_label,plus_coffee,
            plus_coffee_label,plus_blend_label,plus_blend_spec,plus_blend_spec_labels,
            weightOut, volumeOut, densityRoasted, moistureRoasted, wholeColor, groundColor):
        d = {
            "title": title,
            "weightIn": weightIn,
            "weightUnit": weightUnit,
        }
        d["beans"] = beans
        if weightOut is not None:
            d["weightOut"] = weightOut
        d["volumeIn"] = volumeIn
        if volumeOut is not None:
            d["volumeOut"] = volumeOut
        d["volumeUnit"] = volumeUnit
        d["densityWeight"] = densityWeight
#        d["densityWeightUnit"] = densityWeightUnit
#        d["densityVolume"] = densityVolume
#        d["densityVolumeUnit"] = densityVolumeUnit
        if densityRoasted is not None:
            d["densityRoasted"] = densityRoasted
        d["beanSize_min"] = beanSize_min
        d["beanSize_max"] = beanSize_max
        d["moistureGreen"] = moistureGreen
        if moistureRoasted is not None:
            d["moistureRoasted"] = moistureRoasted
        if wholeColor is not None:
            d["wholeColor"] = wholeColor
        if groundColor is not None:
            d["groundColor"] = groundColor
        if colorSystem is not None:
            d["colorSystem"] = colorSystem
        d["background"] = file
        d["roastUUID"] = roastUUID
        d["batchnr"] = batchnr
        d["batchprefix"] = batchprefix
        d["plus_account"] = plus_account
        d["plus_store"] = plus_store
        d["plus_store_label"] = plus_store_label
        d["plus_coffee"] = plus_coffee
        d["plus_coffee_label"] = plus_coffee_label
        d["plus_blend_label"] = plus_blend_label
        d["plus_blend_spec"] = plus_blend_spec
        d["plus_blend_spec_labels"] = plus_blend_spec_labels
        return d
    
    # recentRoast activated via NEW
    def setRecentRoast(self,rr):
        if "title" in rr and rr["title"] is not None:
            self.qmc.title = rr["title"]
            if not aw.qmc.flagstart or aw.qmc.title_show_always:
                aw.qmc.setProfileTitle(self.qmc.title,updatebackground=True)
        if "weightIn" in rr and "weightUnit" in rr and rr["weightIn"] is not None and rr["weightUnit"] is not None:
            self.qmc.weight = [rr["weightIn"],self.qmc.weight[1],rr["weightUnit"]]
        if "weightOut" in rr and "weightUnit" in rr and rr["weightOut"] is not None and rr["weightUnit"] is not None:
            self.qmc.weight = [self.qmc.weight[0],rr["weightOut"],rr["weightUnit"]]
        else:
            self.qmc.weight[1] = 0
        if "volumeIn" in rr and "volumeUnit" in rr and rr["volumeIn"] is not None and rr["volumeUnit"] is not None:
            self.qmc.volume = [rr["volumeIn"],self.qmc.volume[1],rr["volumeUnit"]]
        if "volumeOut" in rr and "volumeUnit" in rr and rr["volumeOut"] is not None and rr["volumeUnit"] is not None:
            self.qmc.volume = [self.qmc.volume[0],rr["volumeOut"],rr["volumeUnit"]]
        else:
            self.qmc.volume[1] = 0
        if "densityWeight" in rr and rr["densityWeight"] is not None:
            self.qmc.density[0] = rr["densityWeight"]
        if "densityRoasted" in rr and rr["densityRoasted"] is not None:
            self.qmc.density_roasted[0] = rr["densityRoasted"]
        else:
            self.qmc.density_roasted[0] = 0
        if "beans" in rr and rr["beans"] is not None:
            aw.qmc.beans = rr["beans"]
        if "beanSize_min" in rr and rr["beanSize_min"] is not None:
            self.qmc.beansize_min = rr["beanSize_min"]
        if "beanSize_max" in rr and rr["beanSize_max"] is not None:
            self.qmc.beansize_max = rr["beanSize_max"]
        if "moistureGreen" in rr and rr["moistureGreen"] is not None:
            self.qmc.moisture_greens = rr["moistureGreen"]
        if "moistureRoasted" in rr and rr["moistureRoasted"] is not None:
            self.qmc.moisture_roasted = rr["moistureRoasted"]
        else:
            self.qmc.moisture_roasted = 0
        if "wholeColor" in rr and rr["wholeColor"] is not None:
            self.qmc.whole_color = rr["wholeColor"]
        else:
            self.qmc.whole_color = 0
        if "groundColor" in rr and rr["groundColor"] is not None:
            self.qmc.ground_color = rr["groundColor"]
        else:
            self.qmc.ground_color = 0
        if "colorSystem" in rr and rr["colorSystem"] is not None:
            self.qmc.color_system_idx = rr["colorSystem"]
        # Note: the background profile will not be changed if recent roast is activated from Roast Properties
#PLUS
        if self.plus_account is not None and "plus_account" in rr and self.plus_account == rr["plus_account"]:
            if "plus_store" in rr:
                self.qmc.plus_store = rr["plus_store"]
            if "plus_store_label" in rr:
                self.qmc.plus_store_label = rr["plus_store_label"]
            if "plus_coffee" in rr:
                self.qmc.plus_coffee = rr["plus_coffee"]
            if "plus_coffee_label" in rr:
                self.qmc.plus_coffee_label = rr["plus_coffee_label"]
            if "plus_blend_label" in rr:
                self.qmc.plus_blend_label = rr["plus_blend_label"]
            if "plus_blend_spec" in rr:
                self.qmc.plus_blend_spec = rr["plus_blend_spec"]
            if "plus_blend_spec_labels" in rr:
                self.qmc.plus_blend_spec_labels = rr["plus_blend_spec_labels"]
            if self.qmc.plus_default_store is not None and self.qmc.plus_default_store != self.qmc.plus_store:
                self.qmc.plus_default_store = None # we reset the defaultstore
                
        aw.sendmessage(QApplication.translate("Message","Recent roast properties '{0}' set".format(aw.recentRoastLabel(rr))))
        
    # returns the list of recentRoasts with the first entry with the given title, weight and weightunit removed
    def delRecentRoast(self,title,weightIn,weightUnit):
        # check for duplications
        entry_with_same_title = None
        for i in range(len(self.recentRoasts)):
            if self.recentRoasts[i]["title"] == title and self.recentRoasts[i]["weightIn"] == weightIn and self.recentRoasts[i]["weightUnit"] == weightUnit:
                entry_with_same_title = i
                break
        if entry_with_same_title is not None:
            # we remove the duplicate entry first
            return self.recentRoasts[:entry_with_same_title] + self.recentRoasts[entry_with_same_title+1:]
        else:
            return self.recentRoasts

    # d is a recentRoast dict
    def addRecentRoast(self,d):
        try:
            # check for duplications
            rr = self.delRecentRoast(d["title"],d["weightIn"],d["weightUnit"])
            self.recentRoasts = [d] + rr[:self.maxRecentRoasts-1]
            self.updateNewMenuRecentRoasts()
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " addRecentRoast(): {0}").format(str(e)),exc_tb.tb_lineno)
        
    def recentRoastLabel(self,rr):
        res = rr["title"] + " (" + "%g" % rr["weightIn"] +rr["weightUnit"]+")"
        return res
        
    def newRecentRoast(self):
        action = self.sender()
        if action:
            modifiers = QApplication.keyboardModifiers()
            alt_modifier = modifiers == Qt.AltModifier
            rr = action.data()
            if "background" in rr and rr["background"] is not None and rr["background"] != "":
                try:
                    aw.qmc.resetlinecountcaches()
                    self.loadbackground(rr["background"])
                    aw.qmc.background = True
                    aw.qmc.timealign(redraw=False)
                    aw.qmc.redraw()
                except:
                    pass
            if alt_modifier:
                if self.qmc.flagon:
                    self.setRecentRoast(rr)
                # only in off mode we first do a reset
                elif self.qmc.reset():
                    # and if successfull (not canceled) we set just the recent roast properties without starting a new roast
                    self.setRecentRoast(rr)
            else:
                # in "normal" mode, we do the NEW action
                if self.newRoast():
                    # and then set the recent roast properties selected
                    self.setRecentRoast(rr)
                
        
    def updateNewMenuRecentRoasts(self):
        self.newRoastMenu.clear()
        # add NEW menu item
        newRoastAction = QAction(UIconst.FILE_MENU_NEW,self)
        newRoastAction.setShortcut(QKeySequence.New)
        newRoastAction.triggered.connect(self.newRoast)
        self.newRoastMenu.addAction(newRoastAction)
        # add recent roasts items
        if len(self.recentRoasts) > 0:
            self.newRoastMenu.addSeparator()
            for rr in self.recentRoasts:
                act = QAction(self, visible=True,
                                triggered=self.newRecentRoast)
                act.setData(rr)
                act.setText(self.recentRoastLabel(rr))
                self.newRoastMenu.addAction(act)
        
    def recentRoastsMenuList(self):
        return [self.recentRoastLabel(rr) for rr in self.recentRoasts]
        
    def establish_etypes(self):
        # update extra LCD label substitutions
        for i in range(len(aw.qmc.extradevices)):
            if i < len(aw.qmc.extraname1):
                l1 = "<b>" + aw.qmc.extraname1[i] + "</b>"
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel1[i].setText(l1)
            if i < len(aw.qmc.extraname2):
                l2 = "<b>" + aw.qmc.extraname2[i] + "</b>"
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel2[i].setText(l2)
        aw.settooltip()

    def populateListMenu(self,resourceName,ext,triggered,menu,addMenu = True,forceSubmenu=False):
        one_added = False
        res = {}
        for root,dirs,files in os.walk(os.path.join(self.getResourcePath(),resourceName)):
            dirs.sort()
            files.sort()
            for fl in files:
                if fl.endswith(ext): 
                    d = os.path.split(root)[-1]
                    p = os.path.join(root,fl)
                    f = fl.replace(ext,"").replace("_"," ")
                    if len(d) > 0:
                        if not d in res:
                            res[d] = []
                        res[d].append((f,p))
        keys = list(res.keys())
        keys.sort()
        for k in keys:
            if len(res[k]) > 1:
                if len(keys) == 1 and not forceSubmenu:
                    for e in res[k]:
                        a = QAction(self, visible=True, triggered=triggered)
                        a.setData((e[1],u(k)))
                        if k == resourceName:
                            a.setText(u(e[0])) # + u("...")
                        else:
                            a.setText(u(k) + u(" ") + u(e[0])) # + u("...")
                            menu.addAction(a)
                    one_added = True
                else:
                    submenu = menu.addMenu(k)
                    sorted_subentries = natsort.natsorted(res[k],key=lambda x: x[0])
                    for e in sorted_subentries: #res[k]:
                        a = QAction(self, visible=True, triggered=triggered)
                        a.setData((e[1],u(k)))
                        a.setText(u(e[0]))
                        submenu.addAction(a)
                        one_added = True
            else:
                entry = res[k][0]
                a = QAction(self, visible=True, triggered=triggered)
                a.setData((entry[1],""))
                if k == resourceName:
                    a.setText(u(entry[0])) # + u("...")
                else:
                    a.setText(u(k) + u(" ") + u(entry[0])) # + u("...")
                    menu.addAction(a)
                one_added = True
        if one_added and addMenu:
            self.ConfMenu.addMenu(menu)
   
    def populateMachineMenu(self):
        self.populateListMenu("Machines",".aset",self.openMachineSettings,self.machineMenu)

    def openMachineSettings(self):
        action = self.sender()
        if action:
            label = (action.text() if action.data()[1] == "" else "{} {}".format(action.data()[1],action.text()))
            string = QApplication.translate("Message", "Configure for {0}?<br><br>Your current settings will be overwritten!<br><br>"+
                    "It is advisable to save your current settings beforehand via menu Help >> Save Settings.",None).format(label)
            reply = QMessageBox.question(aw,QApplication.translate("Message", "Adjust Settings",None),string,
                QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Cancel:
                return 
            elif reply == QMessageBox.Yes:
                aw.qmc.etypes = aw.qmc.etypesdefault
                aw.loadSettings(fn=action.data()[0],remember=False)
                aw.sendmessage(QApplication.translate("Message","Artisan configured for {0}",None).format(label))
                if action.data()[1] == "Phidget":
                    if action.text() == "VINT Ambient Modules":
                        elevation,res = QInputDialog.getInt(self,
                            QApplication.translate("Message", "Ambient",None),
                            QApplication.translate("Message", "Elevation (MASL)",None),value=aw.qmc.elevation)
                        if res:
                            try:
                                aw.qmc.elevation = int(elevation)
                            except:
                                pass
                        else:
                            aw.sendmessage(QApplication.translate("Message","Action canceled",None))
                    else:
                        aw.qmc.machinesetup = action.text()
                else:
                    aw.establish_etypes()
                    aw.qmc.machinesetup = action.text()
                    if aw.qmc.device == 29 and aw.modbus.type in [3,4]: # MODBUS TCP or UDP
                        host,res = QInputDialog.getText(self,
                            QApplication.translate("Message", "Machine",None),
                            QApplication.translate("Message", "Network name or IP address",None),text=aw.modbus.host) #"127.0.0.1"
                        if res:
                            aw.modbus.host = host
                        else:
                            aw.sendmessage(QApplication.translate("Message","Action canceled",None))
                    elif aw.qmc.device == 79: # S7
                        host,res = QInputDialog.getText(self,
                            QApplication.translate("Message", "Machine",None),
                            QApplication.translate("Message", "Network name or IP address",None),text=aw.s7.host) #"127.0.0.1"
                        if res:
                            aw.s7.host = host
                        else:
                            aw.sendmessage(QApplication.translate("Message","Action canceled",None))
                    elif aw.qmc.device in [0,9,19,53,101] or (aw.qmc.device == 29 and aw.modbus.type in [0,1,2]): # Fuji, Center301, TC4, Hottop, Behmor or MODBUS serial
                        import serial.tools.list_ports
                        comports = [(cp if isinstance(cp, (list, tuple)) else [cp.device, cp.product, None]) for cp in serial.tools.list_ports.comports()]
                        if platf == 'Darwin':
                            ports = list([p for p in comports if not(p[0] in ['/dev/cu.Bluetooth-PDA-Sync',
                                '/dev/cu.Bluetooth-Modem','/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem',"/dev/cu.Bluetooth-Incoming-Port","/dev/tty.Bluetooth-Incoming-Port"])])
                            ports = list(filter (lambda x: 'Bluetooth-Inc' not in x[0],ports))
                        else:
                            ports = list(comports)
                        if aw.ser.comport not in [p[0] for p in ports]:
                            ports.append([aw.ser.comport,"",""])
                        ports = sorted(ports,key=lambda p: p[0])
                        items = [(p[1] if (p[1] and p[1]!="n/a") else p[0]) for p in ports]
                        current = 0
                        try:
                            current = [p[0] for p in ports].index(aw.ser.comport)
                        except Exception:
                            pass
                        if aw.qmc.device == 53: # Hottop 2k+
                            try:
                                current = [p[0] for p in ports].index("FT230X Basic UART")
                            except Exception:
                                pass
                        port_name,res = QInputDialog.getItem(self,
                            QApplication.translate("Message", "Port Configuration",None),
                            QApplication.translate("Message", "Comm Port",None),
                            items,
                            current,
                            False)
                        if res:
                            try:
                                pos = items.index(port_name)
                                if aw.qmc.device == 29: # MODBUS serial
                                    aw.modbus.comport = ports[pos][0]
                                else: # Fuji or HOTTOP
                                    aw.ser.comport = ports[pos][0]
                            except:
                                pass

                                
    def populateThemeMenu(self):
        self.themeMenu.clear()
        self.populateListMenu("Themes",".athm",self.openThemeSettings,self.themeMenu, False, True)
        submenu = self.themeMenu.addMenu("User")
        for i in range(self.MaxRecentFiles):
            submenu.addAction(self.recentThemeActs[i])

        self.loadThemeAction = QAction(QApplication.translate("Menu", "Load Theme...", None),self)
        self.loadThemeAction.triggered.connect(self.loadSettings_theme_Slot)
        self.loadThemeAction.setMenuRole(QAction.NoRole) # avoid specific handling of settings menu
        
        self.saveAsThemeAction = QAction(UIconst.SETTINGS_MENU_SAVETHEME,self)
        self.saveAsThemeAction.triggered.connect(self.saveSettings_theme)
        self.saveAsThemeAction.setMenuRole(QAction.NoRole)  # avoid specific handling of settings menu
        
        submenu.addSeparator()
        submenu.addAction(self.loadThemeAction)
        submenu.addAction(self.saveAsThemeAction)

    def openThemeSettings(self):
        action = self.sender()
        if action:
            label = (action.text() if action.data()[1] == "" else "{} {}".format(action.data()[1],action.text()))
            string = QApplication.translate("Message", "Load theme {0}?",None).format(label)
            reply = QMessageBox.question(aw,QApplication.translate("Message", "Adjust Theme Related Settings",None),string,
                QMessageBox.Yes|QMessageBox.Cancel)
            if reply == QMessageBox.Cancel:
                return 
            elif reply == QMessageBox.Yes:
                aw.loadSettings(fn=action.data()[0],remember=False,reset=False)
                self.sendmessage(QApplication.translate("Message","Loaded theme {0}", None).format(action.text()))
                libtime.sleep(.8)
                aw.qmc.redraw(True)

    def getcolorPairsToCheck(self):
        try:
            colorPairsToCheck = [
                # aw.qmc.palette
                (QApplication.translate("Label","BT",None), aw.qmc.palette["bt"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","ET",None), aw.qmc.palette["et"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (deltaLabelPrefix+QApplication.translate("Label","BT",None), aw.qmc.palette["deltabt"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (deltaLabelPrefix+QApplication.translate("Label","ET",None), aw.qmc.palette["deltaet"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Markers",None), aw.qmc.palette["markers"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Text",None), aw.qmc.palette["text"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Time Guide",None), aw.qmc.palette["timeguide"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Background ET",None), aw.qmc.backgroundmetcolor,
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Background BT",None), aw.qmc.backgroundbtcolor,
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Background",None)+" "+deltaLabelPrefix+QApplication.translate("Label","ET",None), aw.qmc.backgrounddeltaetcolor,
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Background",None)+" "+deltaLabelPrefix+QApplication.translate("Label","BT",None), aw.qmc.backgrounddeltabtcolor,
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","Background Extra",None), aw.qmc.palette["xt"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                (QApplication.translate("Label","X Label",None), aw.qmc.palette["xlabel"],
                 QApplication.translate("Label","Canvas",None), aw.qmc.palette["canvas"]),

                (QApplication.translate("Label","Y Label",None), aw.qmc.palette["ylabel"],
                 QApplication.translate("Label","Canvas",None), aw.qmc.palette["canvas"]),

                (QApplication.translate("Label","Title",None), aw.qmc.palette["title"],
                 QApplication.translate("Label","Canvas",None), aw.qmc.palette["canvas"]),

                (QApplication.translate("Label","SpecialEventText",None), aw.qmc.palette["specialeventtext"],
                 QApplication.translate("Label","SpecialEventBox",None), aw.qmc.palette["specialeventbox"]),

                (QApplication.translate("Label","Bg SpecialEventText",None), aw.qmc.palette["bgeventtext"],
                 QApplication.translate("Label","Bg SpecialEventBox",None), aw.qmc.palette["bgeventmarker"]),

                (QApplication.translate("Label","ET",None), aw.qmc.palette["et"],
                 QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette["legendbg"]),

                (QApplication.translate("Label","BT",None), aw.qmc.palette["bt"],
                 QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette["legendbg"]),

                (deltaLabelPrefix+QApplication.translate("Label","ET",None), aw.qmc.palette["deltaet"],
                 QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette["legendbg"]),

                (deltaLabelPrefix+QApplication.translate("Label","BT",None), aw.qmc.palette["deltabt"],
                 QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette["legendbg"]),

                (QApplication.translate("Label","MET Text",None), aw.qmc.palette["mettext"],
                 QApplication.translate("Label","MET Box",None), aw.qmc.palette["metbox"]),

                (QApplication.translate("Label","MET Box",None), aw.qmc.palette["metbox"],
                 QApplication.translate("Label","Background",None), aw.qmc.palette["background"]),

                # aw.lcdpalette
                (QApplication.translate("Label","Timer LCD Digits",None), aw.lcdpaletteF["timer"],
                 QApplication.translate("Label","Timer LCD Background",None), aw.lcdpaletteB["timer"]),

                (QApplication.translate("Label","ET LCD Digits",None), aw.lcdpaletteF["et"],
                 QApplication.translate("Label","ET LCD Background",None), aw.lcdpaletteB["et"]),

                (QApplication.translate("Label","BT LCD Digits",None), aw.lcdpaletteF["bt"],
                 QApplication.translate("Label","BT LCD Background",None), aw.lcdpaletteB["bt"]),

                (deltaLabelPrefix+QApplication.translate("Label","ET LCD Digits",None), aw.lcdpaletteF["deltaet"],
                 deltaLabelPrefix+QApplication.translate("Label","ET LCD Background",None), aw.lcdpaletteB["deltaet"]),

                (deltaLabelPrefix+QApplication.translate("Label","BT LCD Digits",None), aw.lcdpaletteF["deltabt"],
                 deltaLabelPrefix+QApplication.translate("Label","BT LCD Background",None), aw.lcdpaletteB["deltabt"]),

                (QApplication.translate("Label","Extra/PID LCD Digits",None), aw.lcdpaletteF["sv"],
                 QApplication.translate("Label","Extra/PID LCD Background",None), aw.lcdpaletteB["sv"]),
            ]

            # extra devices
            for i in range(len(aw.qmc.extradevices)):
                if  aw.extraCurveVisibility1[i]:
                    colorPairsToCheck.append(
                        (aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate("Label","Background",None), aw.qmc.palette['background']),
                    )                           
                    colorPairsToCheck.append(
                        (aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette['background']),
                    )                           
                if  aw.extraCurveVisibility2[i]:
                    colorPairsToCheck.append(   
                        (aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate("Label","Background",None), aw.qmc.palette['background']),
                    )
                    colorPairsToCheck.append(   
                        (aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate("Label","Legend bkgnd",None),aw.qmc.palette['background']),
                    )

            # special events
            for i in range(len(aw.qmc.EvalueColor)):
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +" "+QApplication.translate("Label","Event",None), aw.qmc.EvalueColor[i], QApplication.translate("Label","Background",None),   aw.qmc.palette['background']),
                )                           
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +" "+QApplication.translate("Label","Event",None), aw.qmc.EvalueColor[i], QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette['background']),
                )                           
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +" "+QApplication.translate("Label","Slider",None),aw.qmc.EvalueColor[i], QApplication.translate("Label","Background",None),       aw.qmc.palette['canvas']),
                )                           
                colorPairsToCheck.append(
                    (aw.qmc.etypes[i] +" "+QApplication.translate("Label","Text",None), aw.qmc.EvalueTextColor[i], aw.qmc.etypes[i] +" "+QApplication.translate("Label","Event",None), aw.qmc.EvalueColor[i]),
                )                           

            #events buttons
            for i in range(len(aw.extraeventstypes)):
                colorPairsToCheck.append(
                    (QApplication.translate("Label","Event button",None)+" "+ u(aw.extraeventslabels[i]), aw.extraeventbuttoncolor[i], " "+QApplication.translate("Label","its text",None), aw.extraeventbuttontextcolor[i]),
                )                           

        except Exception as e:        
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " getcolorPairsToCheck() {0}").format(str(e)),exc_tb.tb_lineno)

        return colorPairsToCheck
        

    def colorDifference(self,color1,color2):
        cDiff = 100
        try:
            from colorspacious import deltaE
            if color1 == None or color1 == "None":
                color1 = "#f0f0f0"
            if color2 == None or color2 == "None":
                color2 = "#f0f0f0"
            if color1.lower() == "transparent":
                if aw.qmc.palette["canvas"] == None or aw.qmc.palette["canvas"] == "None":
                    color1 = "#f0f0f0"
                else:
                    color1 = aw.qmc.palette["canvas"]
            if color2.lower() == "transparent":
                if aw.qmc.palette["canvas"] == None or aw.qmc.palette["canvas"] == "None":
                    color2 = "#f0f0f0"
                else:
                    color2 = aw.qmc.palette["canvas"]
            c1 = str(QColor(color1).name())
            c2 = str(QColor(color2).name())
            c1_rgb = tuple(int(c1[i:i+2], 16) for i in (1, 3 ,5))
            c2_rgb = tuple(int(c2[i:i+2], 16) for i in (1, 3 ,5))
            cDiff = deltaE(c1_rgb, c2_rgb, input_space="sRGB255", uniform_space="CIELab")
        except Exception as e:        
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " colorDifference() {0}").format(str(e)),exc_tb.tb_lineno)

        return cDiff

        
    def checkColors(self,colorPairsToCheck=[],showMsg=True):
        val = -1
        try:
            for c in colorPairsToCheck:
                c1 = c[1]
                c3 = c[3]
                # if one color is the canvas color set to None (transparent), we try to avoid a false warning
                if str(c1) == "None" and c[0] == "Canvas":
                    if sys.platform.startswith("darwin") and darkdetect.isDark():
                        c1 = "black"
                    else:
                        c1 = "white"
                if str(c3) == "None" and c[2] == "Canvas":
                    if sys.platform.startswith("darwin") and darkdetect.isDark():
                        c3 = "black"
                    else:
                        c3 = "white"
                val = self.colorDifference(c1,c3) 
                if val < aw.qmc.colorDifferenceThreshold :
                    val = aw.float2float(val,1)
                    if showMsg:
                        aw.sendmessage(u(QApplication.translate("Message","Detected a color pair that may be hard to see: ",None) + "{0!s} ({1!s}) <-> {2!s} ({3!s}) [deltaE={4:.1f}]".format(c[0], c[1], c[2], c[3],val)))
#                    print("checkColors", str(c[0]), "/", str(c[2]), "  Too similar", str(c[1]), str(c[3]), str(val)) #debugprint
#                else: #debugprint
#                    print("checkColors", str(c[0]), "/", str(c[2]), "  Okay", str(c[1]), str(c[3]), str(val))  #debugprint
        except Exception as e:        
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " checkColors() {0}").format(str(e)),exc_tb.tb_lineno)

        return val
    
    def convertToGreyscale(self,c):
        try:
            nc = c
            from colorspacious import cspace_convert
            if c == None or c == "None":
                return "None"
            if c.lower() == "transparent":
                return "transparent"          
            cq = str(QColor(c).name())
            c_rgb = tuple(int(cq[i:i+2], 16) for i in (1, 3 ,5))
            nc_greyscale_JCh = cspace_convert(c_rgb, "sRGB255", "JCh")
            nc_greyscale_JCh[..., 1] = 0
            nc_greyscale_sRGB = cspace_convert(nc_greyscale_JCh, "JCh", "sRGB255")
            nc_greyscale_sRGB = numpy.clip(nc_greyscale_sRGB, 0, 255)
            nc_greyscale = "#{0:2x}{1:2x}{2:2x}".format(int(nc_greyscale_sRGB[0]),int(nc_greyscale_sRGB[1]),int(nc_greyscale_sRGB[2]))
            nc = str(QColor(nc_greyscale).name())
        except Exception as e:        
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " convertToGreyscale() {0}").format(str(e)),exc_tb.tb_lineno)
        return nc

    def labelBorW(self,backgroundcolor):
        base = self.convertToGreyscale(backgroundcolor)
        if self.checkColors([("base",base,"white","#ffffff")], False) > self.checkColors([("base",base,"black","#000000")],False):
            return "white"
        else:
            return "black"
        
    def setLCDsBW(self):
        aw.lcdpaletteB["timer"] = "black"
        aw.lcdpaletteF["timer"] = "white"
        aw.lcdpaletteB["et"] = "black"
        aw.lcdpaletteF["et"] = "white"
        aw.lcdpaletteB["bt"] = "black"
        aw.lcdpaletteF["bt"] = "white"
        aw.lcdpaletteB["deltaet"] = "black"
        aw.lcdpaletteF["deltaet"] = "white"
        aw.lcdpaletteB["deltabt"] = "black"
        aw.lcdpaletteF["deltabt"] = "white"
        aw.lcdpaletteB["sv"] = "black"
        aw.lcdpaletteF["sv"] = "white"
        aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        aw.lcd2.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
        aw.lcd3.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
        aw.lcd4.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
        aw.lcd5.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
        aw.lcd6.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.lcd7.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
        aw.updateExtraLCDvisibility()

        
    def updateCanvasColors(self):
        canvas_color = aw.qmc.palette["canvas"]
        try:
            if str(canvas_color) == 'None' and sys.platform.startswith("darwin"):
                if darkdetect.isDark():
                    # in dark mode on macOS, the transparent canvas of the classic Artisan theme leeds to unreadable text, thus we switch to standard gray
                    canvas_color = "#333333" # for light: "#F8F8F8"
                    aw.qmc.palette["title"] = "#e6e6e6"
                    aw.qmc.palette["xlabel"] = "#cccccc"
                    aw.qmc.palette["ylabel"] = "#cccccc"
                else:
                    if aw.qmc.palette["title"] == "#e6e6e6":
                        aw.qmc.palette["title"] = "#000000"
                    if aw.qmc.palette["xlabel"] == "#cccccc":
                        aw.qmc.palette["xlabel"] = "#000000"
                    if aw.qmc.palette["ylabel"] == "#cccccc":
                        aw.qmc.palette["ylabel"] = "#000000"
                for label in aw.qmc.ax.xaxis.get_ticklabels():
                    label.set_color(aw.qmc.palette["xlabel"])
                for label in aw.qmc.ax.yaxis.get_ticklabels():
                    label.set_color(aw.qmc.palette["ylabel"])
                if aw.qmc.delta_ax:
                    for label in aw.qmc.delta_ax.yaxis.get_ticklabels():
                        label.set_color(aw.qmc.palette["ylabel"])
                    aw.qmc.delta_ax.yaxis.get_label().set_color(aw.qmc.palette["ylabel"])
                aw.qmc.ax.xaxis.get_label().set_color(aw.qmc.palette["xlabel"])
                aw.qmc.ax.yaxis.get_label().set_color(aw.qmc.palette["ylabel"])
        except:
            pass
        
        title_color = aw.qmc.palette["title"]

        current_background_color = None
        try:
            s = aw.styleSheet()[12+len("background-color:"):]
            current_background_color = s[:s.index(";")]
        except:
            pass

        if str(canvas_color) == 'None':
            if sys.platform.startswith("darwin"):
                whitep = darkdetect.isDark()
            else:
                whitep = False
        else:
            whitep = aw.colorDifference("white",canvas_color) > aw.colorDifference("black",canvas_color)

        aw.qmc.fig.patch.set_facecolor(str(canvas_color))
        aw.setStyleSheet("QMainWindow{background-color:" + str(canvas_color) + ";"
                                   + "border: 0px solid black;"
                                   + "}" )

        if current_background_color is None or current_background_color != str(canvas_color) or (whitep and aw.qmc.palette["messages"] != 'white'): # canvas color did not change, we do not need to redo the navigation bar        
            # update navigationbar
            aw.level1layout.removeWidget(aw.ntb) # remove current bar
            if aw.ntb._active == 'PAN':
                aw.ntb.pan() # PAN is active, we deactivate it before changing the ToolBar
            if aw.ntb._active == 'ZOOM':
                aw.ntb.zoom() # ZOOM is active, we deactivate it before changing the ToolBar
            aw.removeToolBar(aw.ntb)
#            aw.ntb.hide() # seems not to be necessary anymore with the removeToolBar() above
            aw.ntb.destroy()
            aw.ntb = VMToolbar(aw.qmc, aw.main_widget, whitep)
        
        if whitep:
            aw.qmc.palette["messages"] = 'white'
        else:
            aw.qmc.palette["messages"] = 'black'
        aw.sendmessage("")
        aw.ntb.setMinimumHeight(50)
        aw.sliderFrame.setStyleSheet("QGroupBox {background-color:" + str(canvas_color) + ";"
                                    + "color: " + str(title_color) + ";"
                                    + "border: 0px solid gray;"
                                    + "border-width: 0px;"
                                    + "padding-top: 12px;"
                                    + "padding-bottom: 5px;"
                                    + "padding-left: 0px;"
                                    + "padding-right: 0px;"
                                    + "}"
                                    + "QGroupBox::title {background-color:" + str(canvas_color) + ";"
                                    + "subcontrol-origin: margin;" # or border or margin
                                    + "subcontrol-position: top center;" #/* position at the top center */
                                    + "color: " + aw.qmc.palette["messages"] + ";"
                                    + "}")
        
        # ensure x/y coordinates are readable
        aw.ntb.locLabel.setStyleSheet("QWidget {background-color:" + str(canvas_color) + ";"
                                    + "color: " + str(title_color) + ";"
                                    + "}" )
        # make QToolBar background transparent
        aw.ntb.setStyleSheet("QToolBar {background-color:" + str(canvas_color) + ";"
                                    + "border: 5px solid " + str(canvas_color) + ";"
                                    + "color: " + str(title_color) + ";"
                                    + "}" )
        
        self.qmc.setProfileTitle(aw.qmc.title,updatebackground=True)
            
        aw.level1layout.insertWidget(0,aw.ntb)
        
        if str(canvas_color) == 'None':
            aw.qmc.fig.canvas.setStyleSheet("background-color:transparent;") 
            aw.ntb.setStyleSheet("QToolBar {background-color:transparent;}")

        aw.updateSliderColors()
        aw.updatePhasesLCDsColors()
        
        colorPairsToCheck = self.getcolorPairsToCheck()
        self.checkColors(colorPairsToCheck)

                    
    def process_active_quantifiers(self):
        # called every sampling interval
        for i in range(4):
            if aw.eventquantifieractive[i]:
                # we reduce the block values by one for each channel
                aw.block_quantification_sampling_ticks[i] = max(0, aw.block_quantification_sampling_ticks[i] - 1)

                if not aw.block_quantification_sampling_ticks[i]:
                    temp,_ = aw.quantifier2tempandtime(i)
                    if temp: # corresponding curve is available
                        linespace = aw.eventquantifierlinspaces[i]
                        if aw.eventquantifiercoarse[i]:
                            linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdcoarse
                        else:
                            linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdfine
                        t = temp[-1]
                        if t != -1: # -1 is an error value
                            d = aw.digitize(t,linespace,aw.eventquantifiercoarse[i],i)
                            ld = aw.lastdigitizedvalue[i] # in internal format so 8 representing 70%
                            lt = aw.lastdigitizedtemp[i] # last digitized raw value corresponding to ld
                            if d is not None and (ld is None or ld != d):
                                if ld is None or lt is None or linespacethreshold < abs(t - lt): # and only if significantly different than previous to avoid fluktuation
                                    # test if t is increasing or decreasing
                                    v = d * 10.
                                    # establish this one
                                    aw.lastdigitizedvalue[i] = d
                                    aw.lastdigitizedtemp[i] = t
                                    lv = aw.lastEventValue(i)
                                    # now move corresponding slider and add event if its value is not equal to the previous one
                                    if (aw.float2float((v + 10.0) / 10.0)) != lv:
                                        # we set the last value to be used for relative +- button action as base
                                        aw.extraeventsactionslastvalue[i] = int(round(v))
                                        aw.qmc.quantifiedEvent.append([i,v])

    def updateSliderColors(self):
        self.sliderLCD1.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[0])
        self.sliderLCD2.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[1])
        self.sliderLCD3.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[2])
        self.sliderLCD4.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.EvalueColor[3])
        self.sliderLCDSV.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.palette['title'])
        self.slider1.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[0]))
        self.slider2.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[1]))
        self.slider3.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[2]))
        self.slider4.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[3]))
        self.sliderSV.setStyleSheet(artisan_slider_style.format(color=self.qmc.palette['title']))
        
    def updatePhasesLCDsColors(self):
        label_style = "QLabel { color : " + self.qmc.palette["messages"]  + "; }"
        self.TPlabel.setStyleSheet(label_style)
        self.TP2DRYlabel.setStyleSheet(label_style)
        self.DRYlabel.setStyleSheet(label_style)
        self.DRY2FCslabel.setStyleSheet(label_style)
        self.FCslabel.setStyleSheet(label_style)
        self.AUClabel.setStyleSheet(label_style)


    def autoAdjustAxis(self,background=False):
        try:
            if aw.qmc.autotimex:
                # auto adjust
                if background:
                    t_min,t_max = aw.calcAutoAxisBackground()
                else:
                    t_min,t_max = aw.calcAutoAxis()
                    
                if aw.qmc.background:
                    _,t_max_b = aw.calcAutoAxisBackground()
                    if aw.qmc.timeindexB[0] != -1:
                        t_max = max(t_max,t_max_b - aw.qmc.timeB[aw.qmc.timeindexB[0]])
                    else:
                        t_max = max(t_max,t_max_b)
                
                if background and aw.qmc.timeindexB[0] != -1:
                    aw.qmc.startofx = t_min - aw.qmc.timeB[aw.qmc.timeindexB[0]]
                else:
                    aw.qmc.startofx = t_min
                
                if not background and aw.qmc.timeindex[0] != -1 and len(aw.qmc.timex) > aw.qmc.timeindex[0]:
                    aw.qmc.endofx = t_max - aw.qmc.timex[aw.qmc.timeindex[0]]
                elif background and aw.qmc.timeindexB[0] != -1 and len(aw.qmc.timeB) > aw.qmc.timeindexB[0]:
                    aw.qmc.endofx = t_max - aw.qmc.timeB[aw.qmc.timeindexB[0]]
                else:
                    aw.qmc.endofx = t_max
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " autoAdjustAxis() {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleFullscreen(self,_=False):
        if self.full_screen_mode_active or self.isFullScreen():
            self.full_screen_mode_active = False
            self.showNormal()
            if platf != 'Darwin':
                aw.fullscreenAction.setChecked(False)
        else:
            self.full_screen_mode_active = True
            self.showFullScreen()
            if platf != 'Darwin':
                aw.fullscreenAction.setChecked(True)

    # returns time axis min and max
    # min to be 1min before CHARGE or first recording if no CHARGE
    # max to be 1min after COOL or DROP or last recording if no DROP nor COO
    def calcAutoAxis(self):
        if len(aw.qmc.timex) > 3:
            # profile loaded?
            t_start = aw.qmc.startofx
            t_end = aw.qmc.endofx
            if self.qmc.timeindex[0] > -1: # CHARGE set
                t_start = aw.qmc.timex[aw.qmc.timeindex[0]] - 60
            if self.qmc.timeindex[7] > 0: # COOL set
                t_end = aw.qmc.timex[aw.qmc.timeindex[7]] + 60
            elif self.qmc.timeindex[6] > 0: # DROP set
                t_end = aw.qmc.timex[aw.qmc.timeindex[6]] + 90
            return t_start, t_end
        else:
            return aw.qmc.startofx, aw.qmc.endofx
            
    def calcAutoAxisBackground(self):
        if len(aw.qmc.timeB) > 3:
            # profile loaded?
            t_start = aw.qmc.startofx
            t_end = aw.qmc.endofx
            if self.qmc.timeindexB[0] > -1: # CHARGE set
                t_start = aw.qmc.timeB[aw.qmc.timeindexB[0]] - 60
            if self.qmc.timeindexB[7] > 0: # COOL set
                t_end = aw.qmc.timeB[aw.qmc.timeindexB[7]] + 60
            elif self.qmc.timeindexB[6] > 0: # DROP set
                t_end = aw.qmc.timeB[aw.qmc.timeindexB[6]] + 90
            return t_start, t_end
        else:
            return aw.qmc.startofx, aw.qmc.endofx
        
    # returns the last event value of the given type, or None if no event was ever recorded
    def lastEventValue(self,tp):
        res_last = None
        try:
            r = range(len(aw.qmc.specialeventstype) - 1, -1, -1)  # @UndefinedVariable
            for i in r:
                if aw.qmc.specialeventstype[i] == tp:
                    res_last = aw.qmc.specialeventsvalue[i]
                    break
        except Exception:
            pass
        return res_last

    # order event table by time
    def orderEvents(self,lock=True):
        try:
            #### lock shared resources #####
            if lock:
                aw.qmc.samplingsemaphore.acquire(1)
            nevents = len(aw.qmc.specialevents)
            packed_events = []
            # pack
            for i in range(nevents):
                packed_events.append(
                    (aw.qmc.specialevents[i],
                     aw.qmc.specialeventstype[i],
                     aw.qmc.specialeventsStrings[i],
                     aw.qmc.specialeventsvalue[i]))
            # sort
            packed_events.sort(key=lambda tup: tup[0])
            # unpack
            for i in range(nevents):
                aw.qmc.specialevents[i] = packed_events[i][0]
                aw.qmc.specialeventstype[i] = packed_events[i][1]
                aw.qmc.specialeventsStrings[i] = packed_events[i][2]
                aw.qmc.specialeventsvalue[i] = packed_events[i][3]
        finally:
            if lock and aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)


    # if only_active then only the event types with quantifiers activated are grouped
    def clusterEvents(self,only_active=False):
        for i in range(4):
            if not only_active or aw.eventquantifieractive[i]:
                self.clusterEventsType(i)
            
    # cluster of events of the given type (0-3)
    def clusterEventsType(self,tp):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            nevents = len(aw.qmc.specialevents)
            if nevents:
                # first order the events table
                self.orderEvents(lock=False)
                # second detect the minimum time span between two events (could be equal to the sampling rate)
                min_span = None
                last_event_idx = None # index of last event analyzed
                for i in range(len(aw.qmc.specialevents)):
                    if aw.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                        time_diff = aw.qmc.specialevents[i] - aw.qmc.specialevents[last_event_idx]
                        if min_span is None or time_diff < min_span:
                            min_span = time_diff
                    last_event_idx = i
                if min_span is not None:
                    min_span = min(1,min_span,aw.qmc.delay/1000 * 3)
                    indexes_to_be_removed = []
                    last_event_idx = None # index of last event analyzed
                    last_index_not_removed = None
                    # group those with minimally 2x min_span time delta by keeping the first with the value of the last
                    for i in range(len(aw.qmc.specialevents)):
                        if aw.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                            if aw.qmc.specialeventsvalue[last_event_idx] == aw.qmc.specialeventsvalue[i]:
                                # if the value of the event is the same as the previous, we remove it
                                indexes_to_be_removed.append(i)
                            else:
                                time_diff = aw.qmc.specialevents[i] - aw.qmc.specialevents[last_event_idx]
                                if time_diff < 2*min_span:
                                    indexes_to_be_removed.append(i)
                                    if last_index_not_removed is not None:
                                        aw.qmc.specialeventsvalue[last_index_not_removed] = aw.qmc.specialeventsvalue[i]
                                else:
                                    last_index_not_removed = i
                        if aw.qmc.specialeventstype[i] == tp:
                            last_event_idx = i
                    # remove marked events
                    specialevents = []
                    specialeventstype = []
                    specialeventsStrings = []
                    specialeventsvalue = []   
                    for i in range(len(aw.qmc.specialevents)):
                        if not (i in indexes_to_be_removed):
                            specialevents.append(aw.qmc.specialevents[i])
                            specialeventstype.append(aw.qmc.specialeventstype[i])
                            specialeventsStrings.append(aw.qmc.specialeventsStrings[i])
                            specialeventsvalue.append(aw.qmc.specialeventsvalue[i])
                    aw.qmc.specialevents = specialevents
                    aw.qmc.specialeventstype = specialeventstype
                    aw.qmc.specialeventsStrings = specialeventsStrings
                    aw.qmc.specialeventsvalue = specialeventsvalue
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)


    # decides on visibility of the Control button based on the selected devices and configuration
    def showControlButton(self):
        res = False
        lcds = False
        if aw.qmc.device in [0,26]: # FUJI, DTA
            res = True
            if aw.ser.showFujiLCDs:
                lcds = True
#        elif aw.qmc.device == 19 and aw.qmc.PIDbuttonflag: # ARDUINOTC4
#            res = True
        elif aw.qmc.Controlbuttonflag:
            res = True
        if res:
            aw.pidcontrol.activateONOFFeasySV(aw.pidcontrol.svButtons)
            aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider)
        else:
            aw.pidcontrol.activateONOFFeasySV(False)
            aw.pidcontrol.activateSVSlider(False)
        if app.artisanviewerMode:
            aw.button_10.setVisible(False)
        else:
            aw.button_10.setVisible(res)
        self.LCD6frame.setVisible(lcds)
        self.LCD7frame.setVisible(lcds)
            
    # i/o: 0:g, 1:Kg, 2:lb (pound), 3:oz (ounce)
    def convertWeight(self,v,i,o):
        #                g,            kg,         lb,             oz,
        convtable = [
                        [1.,           0.001,      0.00220462262,  0.035274],  # g
                        [1000,         1.,         2.205,          35.274],    # Kg
                        [453.591999,   0.45359237, 1.,             16.],       # lb
                        [28.3495,      0.0283495,  0.0625,         1.]         # oz
                    ]
        return v*convtable[i][o]

    # i/o: 0:l (liter), 1:gal (gallons US), 2:qt, 3:pt, 4:cup, 5:cm^3/ml
    def convertVolume(self,v,i,o):
                        #liter          gal             qt              pt              cup             ml/cm^3
        convtable = [
                        [1.,            0.26417205,     1.05668821,     2.11337643,     4.22675284,     1000.                ],    # liter
                        [3.78541181,    1.,             4.,             8.,             16,             3785.4117884         ],    # gallon
                        [0.94635294,    0.25,           1.,             2.,             4.,             946.352946           ],    # quart
                        [0.47317647,    0.125,          0.5,            1.,             2.,             473.176473           ],    # pint
                        [0.23658823,    0.0625,         0.25,           0.5,            1.,             236.5882365          ],    # cup
                        [0.001,         2.6417205e-4,   1.05668821e-3,  2.11337641e-3,  4.2267528e-3,   1.                   ]     # cm^3
                    ]
        return v*convtable[i][o]
            
    @pyqtSlot("QPoint")
    def superusermodeClicked(self,_):
        self.superusermode = not self.superusermode
        if self.superusermode:
            aw.sendmessage(QApplication.translate("Message","super on",None))
        else:
            aw.sendmessage(QApplication.translate("Message","super off",None))

    @pyqtSlot("QPoint")
    def PhaseslcdClicked(self,_):
        aw.qmc.phasesLCDmode = (aw.qmc.phasesLCDmode + 1)%3
        aw.updatePhasesLCDs()
        
    @pyqtSlot("QPoint")
    def AUClcdClicked(self,_):
        aw.qmc.AUCLCDmode = (aw.qmc.AUCLCDmode + 1)%3
        if aw.qmc.AUCLCDmode == 0:
            label = QApplication.translate("Label", "AUC",None)
        elif aw.qmc.AUCLCDmode == 1:
            label = "&raquo;" + QApplication.translate("Label", "AUC",None)
        else:
            label = QApplication.translate("Label", "AUC FCs",None)
        self.AUClabel.setText("<small><b>" + label + "</b></small>")
        if aw.LargePhasesLCDsFlag and aw.largePhasesLCDs_dialog:
            aw.largePhasesLCDs_dialog.updateLabels([None,None,None,label])
        aw.updateAUCLCD()

    def colordialog(self,c,noButtons=False,parent=None): # c a QColor
        if platform.system() == 'Darwin':
            if noButtons:
                if parent is None:
                    parent = aw
                cd = QColorDialog(parent)
                cd.setModal(True)
                cd.setWindowModality(Qt.ApplicationModal)
                cd.setOption(QColorDialog.NoButtons,True)
#                cd.setOption(QColorDialog.ShowAlphaChannel,True)
#                cd.setOption(QColorDialog.NoButtons | QColorDialog.ShowAlphaChannel,True)
                cd.setCurrentColor(c)
                cd.exec_()
                cr = cd.currentColor()
                return cr
            else:
#                return QColorDialog.getColor(c,aw,"Color",QColorDialog.ShowAlphaChannel)
                return QColorDialog.getColor(c)
            #return QColorDialog.getColor(c,self,"Color",QColorDialog.DontUseNativeDialog) # works, but does not show native dialog
        else:
            return QColorDialog.getColor(c) # blocks on Mac OS X in the build

    def adjustPIDsv(self,x):
        if self.qmc.device == 0: # Fuji PID
            self.fujipid.adjustsv(x)
        elif self.qmc.device == 19: # Arduino TC4
            self.pidcontrol.adjustsv(x)
    
    @pyqtSlot(bool)
    def adjustPIDsv5(self,_=False):
        self.adjustPIDsv(5)
    
    @pyqtSlot(bool)
    def adjustPIDsv10(self,_=False):
        self.adjustPIDsv(10)
    
    @pyqtSlot(bool)
    def adjustPIDsv20(self,_=False):
        self.adjustPIDsv(20)
    
    @pyqtSlot(bool)
    def adjustPIDsv20m(self,_=False):
        self.adjustPIDsv(-20)
    
    @pyqtSlot(bool)
    def adjustPIDsv10m(self,_=False):
        self.adjustPIDsv(-10)
    
    @pyqtSlot(bool)
    def adjustPIDsv5m(self,_=False):
        self.adjustPIDsv(-5)

    # compute the 12 or 102 event quantifier linespace for type n in [0,3]
    def computeLinespace(self,n):
        if self.eventquantifiercoarse[n]:
            num = int(round((self.eventslidermax[n] - self.eventslidermin[n])/10.)) + 1
        else:
            num = self.eventslidermax[n] - self.eventslidermin[n] + 1
        return numpy.linspace(self.eventquantifiermin[n], self.eventquantifiermax[n], num=num)
        
    # update all 4 event quantifier linespaces
    def computeLinespaces(self):
        for n in range(4):
            self.eventquantifierlinspaces[n] = self.computeLinespace(n)
        
    # returns temp and time arrays corresponding to the quantifier source
    # temp might be None if there is no corresponding curve
    def quantifier2tempandtime(self,i):
        temp = None
        timex = aw.qmc.timex
        if aw.eventquantifiersource[i] == 0:
            temp = aw.qmc.temp1
        elif aw.eventquantifiersource[i] == 1:
            temp = aw.qmc.temp2
        else:
            x = (aw.eventquantifiersource[i]-2)
            timex = aw.qmc.extratimex[x // 2]
            if x % 2 == 0:
                # even
                if len(aw.qmc.extratemp1) > (x/2):
                    temp = aw.qmc.extratemp1[x // 2]
            else:
                # odd
                if len(aw.qmc.extratemp2) > (x/2):
                    temp = aw.qmc.extratemp2[x // 2]
        return temp,timex
        
    # returns min/max 0/(aw.eventsMaxValue / 10) for values outside of the given linespace ls defining the interval
    # note that the value returned is the event value divided by 10, but not with the internal offset of +1 !!
    # otherwise the bin number from [0-self.eventquantifiersteps]
    def digitize(self,v,ls,coarse,i):
        if coarse:
            r = ((numpy.digitize([v],ls)[0] - 1) * 10. + aw.eventslidermin[i]) / 10.
        else:
            r = (numpy.digitize([v],ls)[0]+aw.eventslidermin[i] - 1) / 10.
        return max(aw.eventslidermin[i]/10., min(aw.eventslidermax[i] / 10.,r))


    def curveSimilarity2(self,exp=-1,analysis_starttime=0,analysis_endtime=0):
        result = {}
        try:
            analysis_start = aw.qmc.time2index(analysis_starttime)
            analysis_end = aw.qmc.time2index(analysis_endtime)
            analysis_BT = aw.qmc.stemp2[analysis_start:analysis_end]
            analysis_DeltaBT = aw.qmc.delta2[analysis_start:analysis_end]
            if exp == 4:
                # create background BT and background delta BT arrays over the interval of interest
                xarray = numpy.array(aw.qmc.timex[aw.time2index(analysis_starttime):aw.time2index(analysis_endtime)])
                # replace None entries with 0 in the background delta list
                _delta2B = [0 if i == None else i for i in aw.qmc.delta2B]
                analysis_DeltaBTB = numpy.array([self.qmc.timetemparray2temp(aw.qmc.timeB,_delta2B,x) for x in xarray])
                analysis_BTB = numpy.array([self.qmc.timetemparray2temp(aw.qmc.timeB,aw.qmc.temp2B,x) for x in xarray])
            else:
                analysis_BTB = aw.qmc.stemp2B[analysis_start:analysis_end]
                analysis_DeltaBTB = aw.qmc.delta2B[analysis_start:analysis_end]

            # Replace None values in the Delta curves with the closest numeric value on the right
            for i in range(len(analysis_DeltaBT) - 1, -1, -1):
                if analysis_DeltaBT[i] == None:
                    try:
                        analysis_DeltaBT[i] = analysis_DeltaBT[i+1]
                    except:
                        analysis_DeltaBT[i] = 0
            for i in range(len(analysis_DeltaBTB) - 1, -1, -1):
                if analysis_DeltaBTB[i] == None:
                    try:
                        analysis_DeltaBTB[i] = analysis_DeltaBTB[i+1]
                    except:
                        analysis_DeltaBTB[i] = 0

            np_bt = numpy.array(analysis_BT)
            np_btb = numpy.array(analysis_BTB)
            np_dbt = numpy.array(analysis_DeltaBT)
            np_dbtb = numpy.array(analysis_DeltaBTB)

            #MSE
            mse_BT = numpy.mean(numpy.square(np_bt - np_btb))
            mse_deltaBT = numpy.mean(numpy.square(np_dbt - np_dbtb))
            
            # RMSE
            rmse_BT = numpy.sqrt(mse_BT)
            rmse_deltaBT = numpy.sqrt(mse_deltaBT)

            # R squared - Coefficient of determination (1 is a good result, 0 is not good)
            # residual sum of squares
            ss_res_bt = numpy.sum((np_bt - np_btb) ** 2)
            ss_res_dbt = numpy.sum((np_dbt - np_dbtb) ** 2)
            # total sum of squares
            ss_tot_bt = numpy.sum((np_bt - numpy.mean(np_bt)) ** 2)
            ss_tot_dbt = numpy.sum((np_dbt - numpy.mean(np_dbt)) ** 2)
            # r-squared
            r2_BT = 1 - (ss_res_bt / ss_tot_bt)
            r2_deltaBT = 1 - (ss_res_dbt / ss_tot_dbt)

            # Tests that require FCs is marked
            if aw.qmc.timeindex[2]:
                # RoR at time of FCs, and Actual RoR versus Template RoR at FCs
                RoR_FCs_act = aw.qmc.delta2[aw.qmc.timeindex[2]]
                try:
                    fcs_idx = numpy.where(np_dbt==aw.qmc.delta2[aw.qmc.timeindex[2]])
                    RoR_FCs_templ = np_dbtb[fcs_idx[0][0]].item()  #it is possible for fcs_idx[0] to be a tuple so we take the first element
                    RoR_FCs_delta = RoR_FCs_act - RoR_FCs_templ
                    if (fcs_idx[0][-1] - fcs_idx[0][0]) != (len(fcs_idx[0]) - 1) or len(fcs_idx[0]) > 3:  #if there are multiple and discontiguous elements in fcs_idx
                        #we don't have an accurate value
                        #print(fcs_idx[0])
                        RoR_FCs_delta = float('nan')
                except:
                    RoR_FCs_delta = float('nan')

                #max and min difference between actual RoR and template RoR 
                maxdelta = numpy.max(np_dbt - np_dbtb)
                mindelta = numpy.min(np_dbt - np_dbtb)

                # calculate the rise, crash and flick
                #create array of differences between actual curve and the fit curve
                deltas_all = numpy.array(np_dbt - np_dbtb)
                #array indicating actual curve is greater than fit curve (+1) or is less than (-1)
                signs_all = numpy.sign(deltas_all)
                #array with start index of each interal between crossings
                starts = numpy.r_[0, numpy.flatnonzero(~numpy.isclose(signs_all[1:], signs_all[:-1])) + 1]
                #array with the length of each interal between crossings
                lengths = numpy.diff(numpy.r_[starts, len(signs_all)])
                #array indicating segment has actual greater than fit (+1) or actual less than fit (-1)
                signs = signs_all[starts]
                #array of max difference for each segment
                maxdeltas = []
                for i in range(len(starts)):
                    maxdeltas.append(numpy.amax(numpy.absolute(deltas_all[starts[i]:starts[i]+lengths[i]])) * signs[i])
                #array of lengths in seconds
                seconds = lengths * self.qmc.profile_sampling_interval

                # array of all the time index values
                timeindexs_all = numpy.arange(analysis_start, analysis_end, 1)
                # time indexes of the segements
                timeindexs = timeindexs_all[starts]
                
                # thresholds
                segtimethreshold = aw.qmc.segmentsamplesthreshold * self.qmc.profile_sampling_interval
                segdeltathreshold = aw.qmc.segmentdeltathreshold
                reductions = numpy.zeros_like(signs)

                # mark segments that are insignificant and should be combined to the left
                for i in range(len(starts)):
                    if seconds[i] <= segtimethreshold or abs(maxdeltas[i]) <= segdeltathreshold:
                        reductions[i] = 1

                # extend the reduction to include the sample on the right when its sign matches the sign of the first segment in the reduction
                prevsign = signs[0]
                prevreduction = 0        
                addtoprev = numpy.copy(reductions)   #can replace 'addtoprev[]' with change -in-place 'reductions[]' once debugged 
                addtoprev[0] = 0      #the first entry is never combined to the left.
                for i in range(1,len(starts)):
                    # reductions = 1
                    if reductions[i] == 1:
                        prevreduction = 1
                    # reductions=0 & signs=prevsign & prevreduction=1
                    elif signs[i] == prevsign and prevreduction == 1:
                        addtoprev[i] = 1
                    # reductions=0
                    else:
                        prevreduction = 0
                        prevsign = signs[i]

                # generate the per segement arrays
                _starts = numpy.zeros_like(starts)
                _lengths = numpy.zeros_like(starts)
                _seconds = numpy.zeros_like(starts)
                addtoprev[0] = 0
                lasti = 0
                for i in range(0,len(starts)):
                    if addtoprev[i] == 1 and i+1 < len(starts):
                        _lengths[lasti] += lengths[i]
                        _seconds[lasti] += seconds[i]
                    elif addtoprev[i] == 1 :
                        _lengths[lasti] += numpy.sum(lengths[i:])
                        _seconds[lasti] += numpy.sum(seconds[i:])
                    else:   
                        _lengths[i] = lengths[i]
                        _seconds[i] = seconds[i]
                        _starts[i] = starts[i]
                        lasti = i
                mask = numpy.r_[0, numpy.flatnonzero(_starts)]
                starts_seg = _starts[mask]
                lengths_seg = _lengths[mask]
                signs_seg = signs[mask]
                seconds_seg = _seconds[mask]
                timeindexs_seg = timeindexs[mask]
                maxdeltas_seg = []
                for i in range(len(mask)):
                    if i < len(mask) -1:
                        maxdeltas_seg.append(numpy.amax(numpy.absolute(maxdeltas[mask[i]:mask[i+1]])) * signs_seg[i])
                    else:
                        maxdeltas_seg.append(numpy.amax(numpy.absolute(maxdeltas[mask[i]:])) * signs_seg[i])

                # Per segment metrics
                segment_rmse_deltas = [] #segement root mean square error (difference)
                segment_mse_deltas = []  #segement mean square error (difference)
                segment_abc_deltas = []  #segemnt area between the curves
                for i in range(len(starts_seg)):
                    segment_deltas = deltas_all[starts_seg[i]:starts_seg[i]+lengths_seg[i]+1]
                    segment_abs_deltas = numpy.absolute(segment_deltas)
                    segment_rmse_deltas.append(numpy.sqrt(numpy.mean(numpy.square(segment_deltas))))
                    segment_mse_deltas.append(numpy.mean(numpy.square(segment_deltas)))
                    segment_abc_deltas.append(numpy.sum((segment_abs_deltas[1:] + segment_abs_deltas[:-1]) * self.qmc.profile_sampling_interval /2))  #trapazoidal area height*(base1+base2)/2
                    #segment_abc_deltas.append(numpy.trapz(segment_abs_deltas, dx=self.qmc.profile_sampling_interval))  #alternate method 

                # interval of interest metrics
                ioi_start = self.eventtime2string(aw.qmc.timex[timeindexs_seg[0]] - aw.qmc.timex[aw.qmc.timeindex[0]])
                ioi_seconds = (analysis_end - analysis_start) * self.qmc.profile_sampling_interval
                ioi_duration = self.eventtime2string(ioi_seconds)
                ioi_abs_deltas = numpy.absolute(deltas_all)
                ioi_maxdelta = deltas_all[numpy.where(ioi_abs_deltas == numpy.amax(ioi_abs_deltas))[0][0]]
#                ioi_mse_deltas = numpy.mean(numpy.square(deltas_all))
                ioi_abc_deltas = numpy.sum((ioi_abs_deltas[1:] + ioi_abs_deltas[:-1]) * self.qmc.profile_sampling_interval /2)  #trapazoidal area height*(base1+base2)/2
                ioi_abcprime = ioi_abc_deltas / ioi_seconds

                # general information
                fitRoR = 60*(analysis_DeltaBTB[-1] - analysis_DeltaBTB[0]) / (aw.qmc.timex[timeindexs_all[-1]] - aw.qmc.timex[timeindexs_all[0]])
                fitTypes = [QApplication.translate("Label","ln()",None), 
                            "", 
                            QApplication.translate("Label","x",None) + "\u00b2", 
                            QApplication.translate("Label","x",None) + "\u00b3", 
                            QApplication.translate("Label","Bkgnd",None), ""]
                fitType = fitTypes[exp]
                if aw.qmc.filterDropOuts:
                    smoothspikes = "On"
                else:
                    smoothspikes = "Off"

                # build a table of results
                tbl = prettytable.PrettyTable()
                tbl.field_names = [QApplication.translate("Label","Start",None),
                                   QApplication.translate("Label","Duration",None), 
                                   QApplication.translate("Label","Max Delta",None),
                                   QApplication.translate("Label","Swing",None),
                                   QApplication.translate("Label","ABC/secs",None)  ]
                tbl.float_format = "5.2"
                for i in range(len(mask)):
                    thistime = self.eventtime2string(aw.qmc.timex[timeindexs_seg[i]] - aw.qmc.timex[aw.qmc.timeindex[0]])
                    duration = self.eventtime2string(seconds_seg[i])
                    if i > 0:
                        swing = maxdeltas_seg[i] - maxdeltas_seg[i-1]
                    else:
                        swing = ""
#                    if signs_seg[i] == 1:
#                        abovebelow = QApplication.translate("Label","Above",None)
#                    else:
#                        abovebelow = QApplication.translate("Label","Below",None)
                    abcprime = segment_abc_deltas[i] / seconds_seg[i]
                    tbl.add_row([thistime, duration, maxdeltas_seg[i], swing, abcprime ])
                if len(mask) > 1:
                    tbl.add_row(['~~~~~','~~~~~','~~~~~','~~~~~','~~~~~'])
                    tbl.add_row([ioi_start, ioi_duration, ioi_maxdelta, '-', ioi_abcprime ])
                segmentresultstr = QApplication.translate("Label","Segment Analysis (rise, crash and flick)",None) + "\n"
                segmentresultstr += tbl.get_string(border=True)

                # build table of general information
                tbl2 = prettytable.PrettyTable()
                tbl2.field_names = ["A","A1", "B", "B1"  ]
                tbl2.align = 'l'
                tbl2.align["A1"] = "r"
                tbl2.align["B1"] = "r"
                tbl2.float_format = "5.2"
                tbl2.add_row([QApplication.translate("Label","Curve Fit",None), fitType, '', ''])
                tbl2.add_row([QApplication.translate("Label","Samples Threshold",None), aw.qmc.segmentsamplesthreshold, QApplication.translate("Label","Delta Threshold",None), aw.qmc.segmentdeltathreshold])
                tbl2.add_row([QApplication.translate("Label","Sample rate (secs)",None), self.qmc.profile_sampling_interval, QApplication.translate("Label","Smooth Curves/Spikes",None), str(int((aw.qmc.curvefilter-1)/2)) + "/" + str(smoothspikes) ])
                tbl2.add_row([QApplication.translate("Label","Delta Span",None), aw.qmc.deltaBTspan, QApplication.translate("Label","Delta Smoothing",None), int((aw.qmc.deltaBTfilter-1)/2) ])
                tbl2.add_row([QApplication.translate("Label","Fit RoRoR (C/min/min)",None), fitRoR, QApplication.translate("Label","Actual RoR at FCs",None), RoR_FCs_act])
                segmentresultstr += "{}{}".format("\n", tbl2.get_string(border=False,header=False))

                # this table is here just to help with validation
                if aw.superusermode and False:  #disabled 
                    tbl3 = prettytable.PrettyTable()
                    tbl3.field_names = ["Start","Duration","Length", "Max Delta","Sign","Reduction","TimeIndex"  ]
                    tbl3.float_format = "5.2"
                    for i in range(len(maxdeltas)):
                        thistime = self.eventtime2string(aw.qmc.timex[timeindexs[i]-aw.qmc.timeindex[0]])
                        tbl3.add_row([thistime,seconds[i],lengths[i],maxdeltas[i],signs[i],reductions[i],timeindexs[i]])
                    segmentresultstr += "{}{}".format("\n", tbl3.get_string(border=False))

                result['segmentresultstr'] = segmentresultstr

            else:
                RoR_FCs_act = 0
                RoR_FCs_delta = 0
                maxdelta = 0
                mindelta = 0
                result['segmentresultstr'] = ""

            # build the dict to return
            result['mse_BT'] = mse_BT
            result['mse_deltaBT'] = mse_deltaBT
            result['rmse_BT'] = rmse_BT
            result['rmse_deltaBT'] = rmse_deltaBT
            result['r2_BT'] = r2_BT
            result['r2_deltaBT'] = r2_deltaBT
            result['ror_fcs_act'] = RoR_FCs_act
            result['ror_fcs_delta'] = RoR_FCs_delta
            result['ror_max_delta'] = maxdelta
            result['ror_min_delta'] = mindelta

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " curveSimilatrity2(): {0}").format(str(e)),exc_tb.tb_lineno)
        return result

    # computes the similarity between BT and backgroundBT as well as ET and backgroundET
    # iterates over all BT/ET values backward from DROP to the specified BT temperature
    # returns None in case no similarity can be computed
    def curveSimilarity(self,BTlimit=None):
        try:
            # if background profile is loaded and both profiles have a DROP even set
            if aw.qmc.background and aw.qmc.timeindex[6] and aw.qmc.timeindexB[6]:
                # calculate time delta between background and foreground DROP event
                dropTimeDelta = aw.qmc.timex[aw.qmc.timeindex[6]] - aw.qmc.timeB[aw.qmc.timeindexB[6]]
                totalQuadraticDeltaET = 0
                totalQuadraticDeltaBT = 0
                count = 0
                for i in range(aw.qmc.timeindex[6],0,-1):
                    # iterate backward from DROP to BTlimit
                    if aw.qmc.stemp1 and len(aw.qmc.stemp1) > i:
                        # take smoothed data if available
                        et = aw.qmc.stemp1[i]
                    else:
                        et = aw.qmc.temp1[i]
                    if aw.qmc.stemp2 and len(aw.qmc.stemp2) > i:
                        # take smoothed data if available
                        bt = aw.qmc.stemp2[i]
                    else:
                        bt = aw.qmc.temp2[i]
                    if BTlimit and bt > BTlimit:
                        # still above the limit
                        # retrieve corresponding values from the background (is always smoothed)
                        # first compute closest index at that time point in the background data
                        #j = aw.qmc.backgroundtime2index((aw.qmc.timex[i] - dropTimeDelta))
                        #etb = aw.qmc.temp1B[j]
                        #btb = aw.qmc.temp2B[j]
                        etb = aw.qmc.backgroundETat(aw.qmc.timex[i] - dropTimeDelta)
                        btb = aw.qmc.backgroundBTat(aw.qmc.timex[i] - dropTimeDelta)
                        det = (et - etb)
                        totalQuadraticDeltaET += det * det
                        dbt = (bt - btb)
                        totalQuadraticDeltaBT += dbt * dbt
                        count += 1
                    else:
                        break
                return math.sqrt(totalQuadraticDeltaET/float(count)), math.sqrt(totalQuadraticDeltaBT/float(count))
            else:
                # no DROP event registered
                return None, None
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            return None, None
            
    def setLCDsDigitCount(self,n):
        self.lcd2.setDigitCount(n)
        self.lcd2.setMinimumWidth(n*16)
        self.lcd3.setDigitCount(n)
        self.lcd3.setMinimumWidth(n*16)
        self.lcd4.setDigitCount(n)
        self.lcd4.setMinimumWidth(n*16)
        self.lcd5.setDigitCount(n)
        self.lcd5.setMinimumWidth(n*16)
        self.lcd6.setDigitCount(n)
        self.lcd6.setMinimumWidth(n*16)
        self.lcd7.setDigitCount(n)
        self.lcd7.setMinimumWidth(n*16)
        for i in range(self.nLCDS):
            self.extraLCD1[i].setDigitCount(n)
            self.extraLCD1[i].setMinimumWidth(n*16)
            #self.extraLCD1[i].setMaximumWidth(n*16)
            self.extraLCD2[i].setDigitCount(n)
            self.extraLCD2[i].setMinimumWidth(n*16)
            #self.extraLCD2[i].setMaximumWidth(n*16)
        #
        if not aw.qmc.flagon:
            if self.qmc.LCDdecimalplaces:
                zz = "-.-"
            else:
                zz = "--"
            self.lcd2.display(zz)
            self.lcd3.display(zz)
            self.lcd4.display(zz)
            self.lcd5.display(zz)
            self.lcd6.display(zz)
            self.lcd7.display(zz)
        #
        if aw.largeLCDs_dialog:
            aw.largeLCDs_dialog.updateDecimals()
        if aw.largeDeltaLCDs_dialog:
            aw.largeDeltaLCDs_dialog.updateDecimals()
        if aw.largePIDLCDs_dialog:
            aw.largePIDLCDs_dialog.updateDecimals()
        if aw.largeExtraLCDs_dialog:
            aw.largeExtraLCDs_dialog.updateDecimals()
            
    def ArtisanLCD(self):
        lcd = QLCDNumber()
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)
        lcd.setSmallDecimalPoint(False)
        lcd.setMinimumHeight(35)
        x = 16
        if self.qmc.LCDdecimalplaces:
            lcd.setDigitCount(5) # default is 5
            lcd.setMinimumWidth(5*x)
            lcd.setMaximumWidth(5*x)
        else:
            lcd.setDigitCount(3) # default is 5
            lcd.setMinimumWidth(3*x)
            lcd.setMaximumWidth(3*x)
        return lcd

    # set slider focus to Qt.StrongFocus to allow keyboard control and
    # Qt.NoFocus to deactivate it
    def setSliderFocusPolicy(self,focus):
        if bool(aw.eventslidervisibilities[0]):
            self.slider1.setFocusPolicy(focus)
        else:
            self.slider1.setFocusPolicy(Qt.NoFocus)
        self.slider1.clearFocus()
        if bool(aw.eventslidervisibilities[1]):
            self.slider2.setFocusPolicy(focus)
        else:
            self.slider2.setFocusPolicy(Qt.NoFocus)
        self.slider2.clearFocus()
        if bool(aw.eventslidervisibilities[2]):
            self.slider3.setFocusPolicy(focus)
        else:
            self.slider3.setFocusPolicy(Qt.NoFocus)
        self.slider3.clearFocus()
        if bool(aw.eventslidervisibilities[3]):
            self.slider4.setFocusPolicy(focus)
        else:
            self.slider4.setFocusPolicy(Qt.NoFocus)
        self.slider4.clearFocus()

    def getAppPath(self):
        res = ""
        if platf in ['Darwin','Linux']:
            if appFrozen():
                res = QApplication.applicationDirPath() + "/../../../"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "/../"
        elif platf == "Windows":
            if appFrozen():
                res = os.path.dirname(sys.executable) + "\\"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "\\..\\"
        else:
            res = QApplication.applicationDirPath() + "/"
        return res

    def getResourcePath(self):
        res = ""
        if platf == 'Darwin':
            if appFrozen():
                res = QApplication.applicationDirPath() + "/../Resources/"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "/../includes/"
        elif platf == 'Linux':
            if appFrozen():
                res = QApplication.applicationDirPath() + "/"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "/../includes/"
        elif platf == "Windows":
            if appFrozen():
                res = os.path.dirname(sys.executable) + "\\"
            else:
                res = os.path.dirname(os.path.realpath(__file__)) + "\\..\\includes\\"
        else:
            res = QApplication.applicationDirPath() + "/"
        return res
       
    def setFonts(self,redraw=True):
        # try to select the right font for matplotlib according to the given locale and plattform
        if self.qmc.graphfont == 0:
            try:
                rcParams['font.size'] = 12.0
                if platf == "Darwin":
                    mpl.rcParams['font.family'] = "Arial Unicode MS"
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                elif platf == "Linux":
                    if locale:
                        if locale == "ar":
                            mpl.rcParams['font.family'] = ["DejaVu Sans","DejaVu Sans Mono","Times New Roman"]
                        elif locale == "ja":
                            mpl.rcParams['font.family'] = ["TakaoPGothic"]
                        elif locale == "el":
                            mpl.rcParams['font.family'] = ["DejaVu Sans","DejaVu Sans Mono"]
                        elif locale == "zh_CN":
                            mpl.rcParams['font.family'] = ["NanumGothic","DejaVu Sans Mono"]
                        elif locale == "zh_TW":
                            mpl.rcParams['font.family'] = ["NanumGothic","DejaVu Sans Mono"]
                        self.mpl_fontproperties = mpl.font_manager.FontProperties()
                else: # Windows:
                    mpl.rcParams['font.family'] = ["Microsoft Sans Serif", "Arial"] # works for Greek and Arabic
                    self.mpl_fontproperties = mpl.font_manager.FontProperties()
                    # for asian languages on Windows we have to set the parameters directly to *.ttc fonts (mpl supports only *.ttf)
                    if locale == "ja":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\MSGOTHIC.ttc")
                    elif locale == "zh_CN":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\simsun.ttc")
                    elif locale == "zh_TW":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\mingliu.ttc")
                    elif locale == "ko":
                        aw.set_mpl_fontproperties("C:\\Windows\\Fonts\\batang.ttc")
#                    elif locale == "ar":
#                        mpl.rcParams['font.family'] = "TraditionalArabic"
#                        self.mpl_fontproperties = mpl.font_manager.FontProperties()
            except Exception:
                pass
        # no Comic on Linux!
        elif self.qmc.graphfont == 1 or platf == "Linux":
            # font Humor selected
            rcParams['font.size'] = 16.0
            if platf == 'Linux':
                rcParams['font.family'] = ['Humor Sans']
            else:
                rcParams['font.family'] = ['Humor Sans', 'Comic Sans MS']
            aw.set_mpl_fontproperties(u(self.getResourcePath() + "Humor-Sans.ttf"))
        elif self.qmc.graphfont == 2 and not platf == "Linux":
            # font Comic selected
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Comic Sans MS','Humor Sans']
            self.mpl_fontproperties = mpl.font_manager.FontProperties()
        if redraw:
            self.qmc.redraw(recomputeAllDeltas=False)

    def set_mpl_fontproperties(self,fontpath):
        if os.path.exists(fontpath):
            self.mpl_fontproperties = mpl.font_manager.FontProperties(fname=fontpath)

    # trims arabic strings to be rendered correctly with unicode fonts if arabic locale is active
    # if s is a QString with one {0} placeholder and a is an argument, the argument is reversed, and then the wohle string result is reversed
    # if it contains any arabic characters
    def arabicReshape(self,s,a=None):
        if locale and locale == "ar":
            st = u(s)
            if artisanlib.arabic_reshaper.has_arabic_letters(st):
                if a: 
                    return u(artisanlib.arabic_reshaper.reshape(u(s.format(a[::-1])))[::-1])
                else:
                    return u(artisanlib.arabic_reshaper.reshape(st)[::-1])
            else:
                if a:
                    return u(s.format(a))
                else:
                    return u(s)
        elif locale and locale == "he":
            if a:
                return u(s[::-1].format(a[::-1]))
            else:
                return u(s[::-1])
        else:
            if a:
                return u(s.format(a))
            else:
                return u(s)

    def makePhasesLCDbox(self,label,lcd):
        label.setAlignment(Qt.Alignment(Qt.AlignRight | Qt.AlignVCenter))
        lcd.setMinimumHeight(30)
        lcd.setMinimumWidth(80)  # NOTE: with minimumWidth 84 the lcds not always fit in on Mac, 80 works! Better to keep at default.
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)
        lcd.setNumDigits(6)
        lcd.setLineWidth(0)
        lcd.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        LCDVbox = QVBoxLayout()
        LCDVbox.addWidget(label)
        LCDVbox.addWidget(lcd)
        LCDVbox.addSpacing(5)
        LCDVbox.setSpacing(0)
        LCDVbox.setContentsMargins(0, 0, 0, 0)
        frame.setStyleSheet("QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}")
#        frame.setFrameShadow(QFrame.Sunken)
#        frame.setLineWidth(1)
#        frame.setFrameShape(QFrame.Panel)
        frame.setLayout(LCDVbox)

        return frame

    def updateAUCLCD(self):
        try:
            auc_value_str = "---"
            auc_style = "QLCDNumber { color: black; }"
            if ((aw.qmc.AUCbegin == 0 and aw.qmc.timeindex[0] > -1) or
                (aw.qmc.AUCbegin == 1 and aw.qmc.TPalarmtimeindex) or
                (aw.qmc.AUCbegin == 2 and self.qmc.timeindex[1] > 0) or
                (aw.qmc.AUCbegin == 3 and self.qmc.timeindex[2] > 0)):
                if aw.qmc.AUCLCDmode == 0:
                    v = int(round(aw.qmc.AUCvalue))
                    if v > 999:
                        auc_value_str = "---"
                    else:
                        auc_value_str = str(v)
                    auc_style = "QLCDNumber { color: black; }"
                elif aw.qmc.AUCLCDmode == 1:
                    if aw.qmc.AUCtargetFlag and aw.qmc.background and aw.qmc.AUCbackground > 0:
                        # background AUC as target
                        target = aw.qmc.AUCbackground
                    else:
                        # use target AUC as specified by the user
                        target = aw.qmc.AUCtarget
                    d = aw.qmc.AUCvalue-target
                    if d < 0:
                        # too low => blue
                        auc_style = "QLCDNumber { color: blue; }"
                    else:
                        # too high => red
                        auc_style = "QLCDNumber { color: red; }"
                        self.AUClabel.setText("<small><b>" + u(QApplication.translate("Label", "AUC",None)) + "&laquo;</b></small>")
                    v = abs(int(round(d)))
                    if v > 999:
                        auc_value_str = "---"
                        auc_style = "QLCDNumber { color: black; }"
                    else:
                        auc_value_str = str(v)
                elif aw.qmc.timeindex[2] > 0:
                    v = int(round(aw.qmc.AUCsinceFCs))
                    if v > 999:
                        auc_value_str = "---"
                    else:
                        auc_value_str = str(v)
                    auc_style = "QLCDNumber { color: black; }"
                else:
                    auc_value_str = "---"
                    auc_style = "QLCDNumber { color: black; }"
            self.AUClcd.display(auc_value_str)
            self.AUClcd.setStyleSheet(auc_style)
            if aw.LargePhasesLCDsFlag and aw.largePhasesLCDs_dialog:
                aw.largePhasesLCDs_dialog.updateValues([None,None],[None,auc_value_str])
                aw.largePhasesLCDs_dialog.updateAUCstyle(auc_style)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " updateAUCLCD(): {0}").format(str(ex)),exc_tb.tb_lineno)

    # returns multiple results on the current state of the phases:
    #  TP, TPlabel, DRY, DRY, FCs, FCslabel
    #  TP2DRYlabel, DRY2FCslabel
    #  TP2DRYframeTooltip
    #  DRY2FCsframeTooltip
    #  phasesLCDsTooltip
    # all are returning strings with the actual values or None if values did not change
    def getPhasesLCDsData(self,updateLabels=True):
        TP = TPlabel = DRY = DRYlabel = FCs = FCslabel = TP2DRYlabel = DRY2FCslabel = TP2DRYframeTooltip = DRY2FCsframeTooltip = phasesLCDsTooltip = None
        try:
            if self.qmc.timex: # requires at least some recordings
                window_width = aw.width()
                if aw.qmc.LCDdecimalplaces:
                    fmtstr = "%.1f"
                else:
                    fmtstr = "%.0f" 
                tx = self.qmc.timex[-1]
                if self.qmc.timeindex[0]:
                    chrg = self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    chrg = 0
                if self.qmc.timeindex[6]: # after drop
                    totaltime = self.qmc.timex[self.qmc.timeindex[6]] - chrg
                else: # before drop
                    totaltime = tx - chrg

                if aw.qmc.phasesLCDmode_all[2] and self.qmc.timeindex[1] and self.qmc.timeindex[2]: # DRY and FCs
                    # show all finish phase values: time/percent/temp
                    # FIN phase temp on LCD1
                    # FIN phase time on LCD2
                    # FIN phase percentage on LCD3
                    if updateLabels:
                        phasesLCDsTooltip = QApplication.translate("Tooltip","Phase LCDs\nCurrently in ALL FINISHING MODE", None)
                    if self.qmc.timeindex[6]: # after drop
                        ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                    else: # before drop
                        ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                    if updateLabels:
                        DRY2FCsframeTooltip = QApplication.translate("Label","ALL FINISHING MODE",None)
                        TPlabel = QApplication.translate("Label", "FCs",None) + "&raquo;"
                    #time
                    TP = self.qmc.stringfromseconds(ts,leadingzero=False)
                    #temp
                    if self.qmc.timeindex[6]: # after drop
                        dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                    else:
                        dBT = self.qmc.temp2[-1]
                    dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[2]])
                    if updateLabels:
                        DRYlabel = QApplication.translate("Label", "FCs",None) + "&raquo;"
                    DRY = dBT + self.qmc.mode
                    #percentage
                    if totaltime:
                        finishphaseP = fmtstr%(ts*100./totaltime)
                    else:
                        finishphaseP = " --- "
                    if not aw.qmc.LCDdecimalplaces and totaltime:
                        finishphaseP += " "
                    if updateLabels:
                        FCslabel = QApplication.translate("Label", "DEV%",None)
                    FCs = finishphaseP
                    # DRY2FCs
                    if  window_width > 950 and self.qmc.timeindex[1]:
                        t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                        DRY2FCslabel = self.qmc.stringfromseconds(t,leadingzero=False)
                    else:
                        DRY2FCslabel = ""
                else:
                    # show the regular phases LCD values split by phase

                    # 1st PhaseLCD: TP
                    if aw.qmc.phasesLCDmode == 0: # time mode
                        if updateLabels:
                            phasesLCDsTooltip = QApplication.translate("Tooltip","Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TIME MODE", None)
                            TPlabel = QApplication.translate("Label", "TP",None) + "&raquo;"
                        if self.qmc.TPalarmtimeindex and self.qmc.TPalarmtimeindex < len(self.qmc.timex):
                            # after TP
                            if self.qmc.timeindex[6]:
                                ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                            else:
                                ts = tx - self.qmc.timex[self.qmc.TPalarmtimeindex]
                            tss = self.qmc.stringfromseconds(ts,leadingzero=False)
                            TP = tss
                        else:
                            # before TP
                            TP = "--:--"
                    elif aw.qmc.phasesLCDmode == 1: # percentage mode
                        if updateLabels:
                            phasesLCDsTooltip = QApplication.translate("Tooltip","Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in PERCENTAGE MODE", None)
                            TPlabel = QApplication.translate("Label", "DRY%",None)
                        if self.qmc.timeindex[1]: # after DRY
                            ts = self.qmc.timex[self.qmc.timeindex[1]] - chrg
                            if totaltime:
                                dryphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                dryphaseP = " --- "
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                dryphaseP += " "
                            TP = dryphaseP
                        else:
                            TP = " --- "
                    elif aw.qmc.phasesLCDmode == 2: # temp mode
                        if updateLabels:
                            phasesLCDsTooltip = QApplication.translate("Tooltip","Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TEMP MODE", None)
                            TPlabel = QApplication.translate("Label", "TP",None) + "&raquo;"

                        if self.qmc.TPalarmtimeindex:
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.TPalarmtimeindex])
                            TP = dBT + self.qmc.mode
                        else:
                            # before TP
                            TP = " --- "
                            
                    # 2nd PhaseLCD: DRY
                    if self.qmc.timeindex[1]:
                        # after DRY
                        if self.qmc.timeindex[6]:
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[1]]
                        else:
                            ts = tx - self.qmc.timex[self.qmc.timeindex[1]]
                        if aw.qmc.phasesLCDmode == 0: # time mode
                            if updateLabels:
                                TP2DRYframeTooltip = QApplication.translate("Label","TIME MODE",None)
                                DRYlabel = QApplication.translate("Label", "DRY",None) + "&raquo;"
                            DRY = self.qmc.stringfromseconds(ts,leadingzero=False)
                        elif aw.qmc.phasesLCDmode == 1: # percentage mode
                            if updateLabels:
                                TP2DRYframeTooltip = QApplication.translate("Label","PERCENTAGE MODE",None)
                            if self.qmc.timeindex[2]:
                                ts = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            if totaltime:
                                midphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                midphaseP = " --- "
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                midphaseP += " "
                            if updateLabels:
                                DRYlabel = QApplication.translate("Label", "RAMP%",None)
                            DRY = midphaseP
                        elif aw.qmc.phasesLCDmode == 2: # temp mode
                            if updateLabels:
                                TP2DRYframeTooltip = QApplication.translate("Label","TEMP MODE",None)
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[1]])
                            if updateLabels:
                                DRYlabel = QApplication.translate("Label", "DRY",None) + "&raquo;"
                            DRY = dBT + self.qmc.mode
                        # TP2DRY
                        if window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = self.qmc.timex[self.qmc.timeindex[1]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                            TP2DRYlabel = self.qmc.stringfromseconds(t,leadingzero=False)
                        else:
                            TP2DRYlabel = ""
                    else:
                        # before DRY
                        dryexpectedtime = None
                        if updateLabels:
                            if aw.qmc.phasesLCDmode == 2:
                                DRYlabel = "&darr;" + QApplication.translate("Label", "DRY",None)
                            else:
                                DRYlabel = "&raquo;" + QApplication.translate("Label", "DRY",None)
                        if self.qmc.timeindex[0] > -1 and self.qmc.TPalarmtimeindex and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            # display expected time to reach DRY as defined in the background profile or the phases dialog
                            if self.qmc.background and self.qmc.timeindexB[1] and not aw.qmc.autoDRYflag: # with AutoDRY, we always use the set DRY phase temperature as target
                                drytarget = self.qmc.temp2B[self.qmc.timeindexB[1]] # Background DRY BT temperature
                            else:
                                drytarget = self.qmc.phases[1] # Drying max phases definition
                            if drytarget > self.qmc.temp2[-1]:
                                dryexpectedtime = (drytarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                                if aw.qmc.phasesLCDmode == 2:
                                    tstring = self.qmc.stringfromseconds(dryexpectedtime,leadingzero=False)
                                else:
                                    tstring = self.qmc.stringfromseconds(tx - self.qmc.timex[self.qmc.timeindex[0]] + dryexpectedtime,leadingzero=False)
                                DRY = tstring
                            else:
                                DRY = "--:--"
                        else:
                            DRY = "--:--"
                        
                        # TP2DRY (display estimated time between TP and DRY)
                        if dryexpectedtime and window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = tx - self.qmc.timex[self.qmc.TPalarmtimeindex] + dryexpectedtime # time after TP plus expected-time-to-DRY = total time expected for 1nd phase
                            if t > 3600:
                                TP2DRYlabel = ""
                            else:
                                TP2DRYlabel = self.qmc.stringfromseconds(t,leadingzero=False)
                        else:
                            TP2DRYlabel = ""
                    
                    # 3rd PhasesLCD: FCs
                    if self.qmc.timeindex[2]:
                        # after FCs
                        if self.qmc.timeindex[6]: # after drop
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                        else: # before drop
                            ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                        if aw.qmc.phasesLCDmode == 0: # time mode
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","TIME MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","TIME MODE",None)
                                FCslabel = QApplication.translate("Label", "FCs",None) + "&raquo;"
                            FCs = self.qmc.stringfromseconds(ts,leadingzero=False)
                        elif aw.qmc.phasesLCDmode == 1: # percentage mode
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","PERCENTAGE MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","PERCENTAGE MODE",None)
                                FCslabel = QApplication.translate("Label", "DEV%",None)
                            if totaltime:
                                finishphaseP = fmtstr%(ts*100./totaltime)
                            else:
                                finishphaseP = " --- "
                            if not aw.qmc.LCDdecimalplaces and totaltime:
                                finishphaseP += " "
                            FCs = finishphaseP
                        elif aw.qmc.phasesLCDmode == 2: # temp mode
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","TEMP MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","TEMP MODE",None)
                                FCslabel = QApplication.translate("Label", "FCs",None) + "&raquo;"
                            if self.qmc.timeindex[6]: # after drop
                                dBT = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBT = self.qmc.temp2[-1]
                            dBT = fmtstr%(dBT-self.qmc.temp2[self.qmc.timeindex[2]])
                            FCs = dBT + self.qmc.mode
                        # DRY2FCs
                        if  window_width > 950 and self.qmc.timeindex[1]:
                            t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            DRY2FCslabel = self.qmc.stringfromseconds(t,leadingzero=False)
                        else:
                            DRY2FCslabel = ""
                    else:
                        # before FCs
                        fcsexpectedtime = None
                        if aw.qmc.phasesLCDmode == 0:
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","TIME MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","TIME MODE",None)
                                FCslabel = "&raquo;" + QApplication.translate("Label", "FCs",None)
                        elif aw.qmc.phasesLCDmode == 1:
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","PERCENTAGE MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","PERCENTAGE MODE",None)
                                FCslabel = "&raquo;" + QApplication.translate("Label", "FCs",None)
                        elif aw.qmc.phasesLCDmode == 2:
                            if updateLabels:
                                DRY2FCsframeTooltip = QApplication.translate("Label","TEMP MODE",None)
                                TP2DRYframeTooltip = QApplication.translate("Label","TEMP MODE",None)
                                FCslabel = "&darr;" + QApplication.translate("Label", "FCs",None)
                                
                        if self.qmc.timeindex[0] > -1 and self.qmc.timeindex[1] and len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            ## after DRY:
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.qmc.background and self.qmc.timeindexB[2]:
                                fcstarget = self.qmc.temp2B[self.qmc.timeindexB[2]] # Background FCs BT temperature
                            else:
                                fcstarget = self.qmc.phases[2] # FCs min phases definition
                            if fcstarget > self.qmc.temp2[-1]:
                                fcsexpectedtime = (fcstarget - self.qmc.temp2[-1])/(self.qmc.delta2[-1]/60.)
                                if aw.qmc.phasesLCDmode == 2:
                                    tstring = self.qmc.stringfromseconds(fcsexpectedtime, leadingzero=False)
                                else:
                                    tstring = self.qmc.stringfromseconds(tx - self.qmc.timex[self.qmc.timeindex[0]] + fcsexpectedtime, leadingzero=False)
                                FCs = tstring
                            else:
                                FCs = "--:--"
                        else:
                            FCs = "--:--"
                        
                        # DRY2FCs (display estimated time between DRY and FCs)
                        if fcsexpectedtime and window_width > 950 and self.qmc.timeindex[1]:
                            t = tx - self.qmc.timex[self.qmc.timeindex[1]] + fcsexpectedtime # time after DRY plus expected-time-to-FCs = total time expected for 2nd phase
                            DRY2FCslabel =self.qmc.stringfromseconds(t, leadingzero=False)
                        else:
                            DRY2FCslabel = ""
            else:
                if aw.qmc.phasesLCDmode == 0: # time mode
                    TP = "--:--"
                    if updateLabels:
                        TPlabel = QApplication.translate("Label", "TP",None) + "&raquo;"
                elif aw.qmc.phasesLCDmode == 1: # percentage mode
                    TP = " --- "
                    if updateLabels:
                        TPlabel = QApplication.translate("Label", "DRY%",None)
                elif aw.qmc.phasesLCDmode == 2: # temp mode
                    TP = " --- "
                    if updateLabels:
                        TPlabel = QApplication.translate("Label", "TP",None) + "&raquo;"
                if updateLabels:
                    DRYlabel = "&raquo;" + QApplication.translate("Label", "DRY",None)
                    FCslabel = "&raquo;" + QApplication.translate("Label", "FCs",None)
                TP2DRYlabel = ""
                DRY2FCslabel = ""
                DRY =  "--:--"
                FCs = "--:--"
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " updatePhasesLCDs() {0}").format(str(e)),exc_tb.tb_lineno)
        return TP,TPlabel,DRY,DRYlabel,FCs,FCslabel,TP2DRYlabel,DRY2FCslabel,TP2DRYframeTooltip,DRY2FCsframeTooltip,phasesLCDsTooltip

    
    def updatePhasesLCDs(self,updateLabels=True):
        try:
            if aw.qmc.phasesLCDflag or aw.LargePhasesLCDsFlag:
                TP,TPlabel,DRY,DRYlabel,FCs,FCslabel,TP2DRYlabel,DRY2FCslabel,TP2DRYframeTooltip,DRY2FCsframeTooltip,phasesLCDsTooltip = self.getPhasesLCDsData(updateLabels=updateLabels)
                
                if aw.qmc.phasesLCDflag:
                    label_fmt = "<small><b>{}</b></small>"
                    #
                    if TP is not None:
                        self.TPlcd.display(TP)
                    if DRY is not None:
                        self.DRYlcd.display(DRY)
                    if FCs is not None:
                        self.FCslcd.display(FCs)
                    #
                    if TPlabel is not None:
                        self.TPlabel.setText(label_fmt.format(TPlabel))
                    if DRYlabel is not None:
                        self.DRYlabel.setText(label_fmt.format(DRYlabel))
                    if FCslabel is not None:
                        self.FCslabel.setText(label_fmt.format(FCslabel))
                    #
                    if TP2DRYlabel is not None:
                        self.TP2DRYlabel.setText(TP2DRYlabel)
                        if TP2DRYlabel == "":
                            width = 0
                        else:
                            width = self.TP2DRYlabel.fontMetrics().boundingRect("88:::88").width()
                        self.TP2DRYlabel.setMinimumWidth(width)
                    if DRY2FCslabel is not None:
                        self.DRY2FCslabel.setText(DRY2FCslabel)
                        if DRY2FCslabel == "":
                            width = 0
                        else:
                            width = self.DRY2FCslabel.fontMetrics().boundingRect("88:::88").width()
                        self.DRY2FCslabel.setMinimumWidth(width)
                    #
                    if TP2DRYframeTooltip is not None:
                        self.TP2DRYframe.setToolTip(TP2DRYframeTooltip)
                    if DRY2FCsframeTooltip is not None:
                        self.DRY2FCsframe.setToolTip(DRY2FCsframeTooltip)
                    if phasesLCDsTooltip is not None:
                        self.phasesLCDs.setToolTip(phasesLCDsTooltip)
                        
                if aw.LargePhasesLCDsFlag:
                    # update large phases LCDs
                    try:
                        if aw.largePhasesLCDs_dialog is not None:
                            values1 = [TP, FCs] # TP and FCs phase LCDs
                            values2 = [DRY, None] # DRY phase and AUC LCDs
                            aw.largePhasesLCDs_dialog.updateValues(values1,values2)
                            if updateLabels:
                                aw.largePhasesLCDs_dialog.updateLabels([TPlabel,DRYlabel,FCslabel,None])
                    except:
                        pass
                    
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " updatePhasesLCDs() {0}").format(str(e)),exc_tb.tb_lineno)

    def makeLCDbox(self,label,lcd,lcdframe):
        LCDbox = QVBoxLayout()
        LCDbox.setSpacing(0)
        LCDbox.addWidget(label)
        LCDhBox = QHBoxLayout()
        LCDhBox.addStretch()
        LCDhBox.addWidget(lcd)
        LCDbox.addLayout(LCDhBox)
        LCDhBox.setContentsMargins(0, 0, 0, 0)
        LCDbox.setContentsMargins(0, 0, 0, 0)
        lcdframe.setContentsMargins(0, 10, 0, 3)
        lcdframe.setLayout(LCDbox)
        return lcdframe

    def setSliderNumber(self,lcd,v):
        if v < 10:
            lcd.setNumDigits(1)
        elif v > 99:
            lcd.setNumDigits(3)
        else:
            lcd.setNumDigits(2)
        lcd.display(v)
        
    def updateSliderLCD(self,n,v):
        if n == 0:
            self.setSliderNumber(self.sliderLCD1,v)
        elif n == 1:
            self.setSliderNumber(self.sliderLCD2,v)
        elif n == 2:
            self.setSliderNumber(self.sliderLCD3,v)
        elif n == 3:
            self.setSliderNumber(self.sliderLCD4,v)
    
    @pyqtSlot(int)
    def updateSVSliderLCD(self,v):
        if v > aw.pidcontrol.svSliderMax:
            v = aw.pidcontrol.svSliderMax
        if v < aw.pidcontrol.svSliderMin:
            v = aw.pidcontrol.svSliderMin
        self.sliderLCDSV.display(v)
        if self.SVslidermoved and self.sliderLCDSV.intValue() != self.sliderSV.value():
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            self.sliderSV.setValue(self.sliderLCDSV.intValue())
            self.sliderSVreleased()
            self.SVslidermoved = 0

    @pyqtSlot(int)
    def sliderSVactionTriggered(self,n):
        if n in [1,2,3,4]: # keyboard moves enable the slider value change
            self.SVslidermoved = 1

    @pyqtSlot()
    def sliderSVreleased(self):
        try:
            if aw.qmc.device == 0:
                aw.fujipid.setsv(self.sliderSV.value(),silent=True)
            else:
                aw.pidcontrol.setSV(self.sliderSV.value(),False)
        except:
            pass

    # if setValue=False, the slider is only moved without a change signal being issued
    def moveSVslider(self,v,setValue=True):
        if aw.pidcontrol.svSlider:
            if setValue:
                self.sliderSV.setValue(v)
            else:
                self.sliderSV.setSliderPosition(v)
    
    # NOTE on those slider signals:
    # there are different ways to move the sliders
    # - by click into the slider bar
    # - by drag and release the slider handle
    # - by using the up/down cursor keys or page up/down keys
    # - using the Artisan slider shortcuts via keys Q, W, E, R
    # - programatically
    # The drag-and-release action (at least on Mac OS X) in some cases triggers a valueChanged signal short after fetching the handle and before moving it.
    # To avoid the generation of an additional event with an event value close to the last one, the eventslidermoved variable has been added.
    # It is set after a slider move. If it is not set, only value changes above a certain limit (here 3) are accepted.
    @pyqtSlot(int)
    def slider1Moved(self,v):
        self.eventslidermoved[0]=1
        self.updateSliderLCD(0,v)
    @pyqtSlot(int)
    def slider2Moved(self,v):
        self.eventslidermoved[1]=1
        self.updateSliderLCD(1,v)
    @pyqtSlot(int)
    def slider3Moved(self,v):
        self.eventslidermoved[2]=1
        self.updateSliderLCD(2,v)
    @pyqtSlot(int)
    def slider4Moved(self,v):
        self.eventslidermoved[3]=1
        self.updateSliderLCD(3,v)
        
    @pyqtSlot(int)
    def slider1valueChanged(self,_):
        self.sliderReleased(0,updateLCD=True)
    @pyqtSlot(int)
    def slider2valueChanged(self,_):
        self.sliderReleased(1,updateLCD=True)
    @pyqtSlot(int)
    def slider3valueChanged(self,_):
        self.sliderReleased(2,updateLCD=True)
    @pyqtSlot(int)
    def slider4valueChanged(self,_):
        self.sliderReleased(3,updateLCD=True)
    
    @pyqtSlot(int)
    def slider1actionTriggered(self,n):
        if n in [1,2,3,4]: # keyboard moves enable the slider value change
            self.eventslidermoved[0]=1
    @pyqtSlot(int)
    def slider2actionTriggered(self,n):
        if n in [1,2,3,4]: # keyboard moves enable the slider value change
            self.eventslidermoved[1]=1
    @pyqtSlot(int)
    def slider3actionTriggered(self,n):
        if n in [1,2,3,4]: # keyboard moves enable the slider value change
            self.eventslidermoved[2]=1
    @pyqtSlot(int)
    def slider4actionTriggered(self,n):
        if n in [1,2,3,4]: # keyboard moves enable the slider value change
            self.eventslidermoved[3]=1
        
    # if updateLCD=True, call moveslider() which in turn updates the LCD
    def sliderReleased(self,n,force=False,updateLCD=False):
        if n == 0:
            sv1 = self.slider1.value()
            if force or (self.eventslidermoved[0] and sv1 != self.eventslidervalues[0]) or abs(sv1-self.eventslidervalues[0]) > 3:
                self.eventslidermoved[0] = 0
                if aw.eventslidercoarse[0]:
                    sv1 = int(round(sv1 / 10.))*10
                self.eventslidervalues[0] = sv1
                if updateLCD:
                    self.moveslider(0,sv1,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 1:
            sv2 = self.slider2.value()
            if force or (self.eventslidermoved[1] and sv2 != self.eventslidervalues[1]) or abs(sv2-self.eventslidervalues[1]) > 3:
                self.eventslidermoved[1] = 0
                if aw.eventslidercoarse[1]:
                    sv2 = int(round(sv2 / 10.))*10
                self.eventslidervalues[1] = sv2
                if updateLCD:
                    self.moveslider(1,sv2,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 2:
            sv3 = self.slider3.value()
            if force or (self.eventslidermoved[2] and sv3 != self.eventslidervalues[2]) or abs(sv3-self.eventslidervalues[2]) > 3:
                self.eventslidermoved[2] = 0
                if aw.eventslidercoarse[2]:
                    sv3 = int(round(sv3 / 10.))*10
                self.eventslidervalues[2] = sv3
                if updateLCD:
                    self.moveslider(2,sv3,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 3:
            sv4 = self.slider4.value()
            if force or (self.eventslidermoved[3] and sv4 != self.eventslidervalues[3]) or abs(sv4-self.eventslidervalues[3]) > 3:
                self.eventslidermoved[3] = 0
                if aw.eventslidercoarse[3]:
                    sv4 = int(round(sv4 / 10.))*10
                self.eventslidervalues[3] = sv4
                if updateLCD:
                    self.moveslider(3,sv4,forceLCDupdate=True) # move slider if need and update slider LCD
                self.recordsliderevent(n)
        return False

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    def fireslideraction(self,n):
        action = self.eventslideractions[n]
        if action:
            try:
            # before adaption:
                # action =0 (None), =1 (Serial), =2 (Modbus), =3 (DTA Command), =4 (Call Program [with argument])
                #  =5 (Hottop Heater), =6 (Hottop Fan), =7 (Hottop Command), =8 (Fuji Command), =9 (PWM Command), =10 (VOUT Command)
                #  =11 (IO Command), =12 (S7 Command), =13 (Aillio R1 Heater Command), =14 (Aillio R1 Fan Command), =15 (Aillio R1 Drum Command)
                #  =16 (Artisan Command), 17= (RC Command)
                action = (action+2 if action > 1 else action) # skipping (2 Call Program and 3 Multiple Event)
                if action > 5:
                    action = action + 1 # skip the 6:IO Command
                    if action > 10 and action < 15:
                        action = action + 1 # skip the 11 p-i-d action
                        if action == 15:
                            action = 6 # map IO Command back
                    if action > 18:
                        action = action + 1 # skip the 19: Aillio PRS
            # after adaption: (see eventaction)
                value = (self.eventsliderfactors[n] * self.eventslidervalues[n]) + self.eventslideroffsets[n]
                if not (action in [6,14,21]): # only for IO, VOUT and RC Commands we keep the floats
                    value = int(round(value))
                if action in [8,9,16,17,18]: # for Hottop/R1 Heater or Fan, we just forward the value
                    cmd = value
                else:
                    cmd = self.eventslidercommands[n]
                    cmd = cmd.format(*(tuple([value]*cmd.count("{}"))))
                self.eventaction(action,cmd)
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " fireslideraction() {0}").format(str(e)),exc_tb.tb_lineno)

    def recordsliderevent(self,n):
        aw.block_quantification_sampling_ticks[n] = aw.sampling_ticks_to_block_quantifiction
        self.extraeventsactionslastvalue[n] = self.eventslidervalues[n]
        if self.qmc.flagstart:
            value = aw.float2float((self.eventslidervalues[n] + 10.0) / 10.0)
            description = str(aw.float2float(self.eventslidervalues[n] * self.eventsliderfactors[n] + self.eventslideroffsets[n])).rstrip('0').rstrip('.') + self.eventsliderunits[n]
            description = str(aw.float2float(self.eventslidervalues[n] * self.eventsliderfactors[n] + self.eventslideroffsets[n])).rstrip('0').rstrip('.') + self.eventsliderunits[n]
            self.qmc.EventRecordAction(extraevent = 1,eventtype=n,eventvalue=value,eventdescription=description)
        self.fireslideraction(n)

    def sliderLCD(self):
        slcd = QLCDNumber()
        slcd.setSegmentStyle(2)
        slcd.setNumDigits(1)
        slcd.setMinimumHeight(35)
        slcd.setMinimumWidth(50)
        slcd.setMaximumWidth(50)
        slcd.setFrameStyle(QFrame.Panel | QFrame.Plain)
        slcd.setLineWidth(0)
        slcd.setContentsMargins(0,0,0,0)
        return slcd

    def slider(self):
        s = QSlider()
        s.setTickPosition(3)
        s.setTickInterval(10)
        s.setSingleStep(1)
        s.setPageStep(10)
        s.setMaximum(100)
        s.setMinimumWidth(50) 
        s.setMaximumWidth(50) 
        s.setContentsMargins(0,0,0,0)
        return s
        
    def updateSliderMinMax(self):
        # first block slider signals to avoid sending out signals
        self.slider1.blockSignals(True)
        self.slider2.blockSignals(True)
        self.slider3.blockSignals(True)
        self.slider4.blockSignals(True)
        # reset limits
        self.slider1.setMinimum(self.eventslidermin[0])
        self.slider1.setMaximum(self.eventslidermax[0])
        self.slider2.setMinimum(self.eventslidermin[1])
        self.slider2.setMaximum(self.eventslidermax[1])
        self.slider3.setMinimum(self.eventslidermin[2])
        self.slider3.setMaximum(self.eventslidermax[2])
        self.slider4.setMinimum(self.eventslidermin[3])
        self.slider4.setMaximum(self.eventslidermax[3])
        # update slider LCDs
        self.updateSliderLCD(0,min(self.eventslidermax[0],max(self.eventslidermin[0],self.slider1.value())))
        self.updateSliderLCD(1,min(self.eventslidermax[1],max(self.eventslidermin[1],self.slider2.value())))
        self.updateSliderLCD(2,min(self.eventslidermax[2],max(self.eventslidermin[2],self.slider3.value())))
        self.updateSliderLCD(3,min(self.eventslidermax[3],max(self.eventslidermin[3],self.slider4.value())))
        # unblock sliders signaling
        self.slider1.blockSignals(False)
        self.slider2.blockSignals(False)
        self.slider3.blockSignals(False)
        self.slider4.blockSignals(False)

    def setLabelColor(self,label,color):
        label.setStyleSheet("QLabel { color: %s; }" % color.name())

    #adds to serial log
    def addserial(self,serialstring):
        if aw.seriallogflag:
            try:
                #### lock shared resources #####
                aw.qmc.serialsemaphore.acquire(1)
                timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                #keep a max of 1000 comm strings
                if len(self.seriallog) > 999:
                    self.seriallog = self.seriallog[1:]
                self.seriallog.append(timez + " " + serialstring)
            except Exception:
                pass
            finally:
                if aw.qmc.serialsemaphore.available() < 1:
                    aw.qmc.serialsemaphore.release(1)

    def resizeEvent(self, event):
        if not aw.qmc.flagon and aw.qmc.statssummary and len(aw.qmc.timex) > 3:
            self.redrawTimer.start(500) # (re-) start the redraw time to be fired in half a second
        #if HUD is ON when resizing application. No drawing should be done inside this handler
        if self.qmc.HUDflag:
            self.qmc.hudresizeflag = True
        super(ApplicationWindow,self).resizeEvent(event)
        
    def setdpi(self,dpi,moveWindow=True):
        if aw:
            aw.dpi = dpi
            # on mpl >= v2 we assume hidpi support and consider the pixel ratio
            self.qmc.fig.set_dpi(dpi*aw.devicePixelRatio())
            #move widget to update display
            if moveWindow: 
                aw.qmc.fig.canvas.draw()
                aw.qmc.fig.canvas.update()
                aw.stack.adjustSize()
                FigureCanvas.updateGeometry(aw.stack)  #@UndefinedVariable
                QApplication.processEvents()

    def enableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(True)
            self.fileSaveAsAction.setEnabled(True) 
            #self.ConfMenu.setEnabled(True)
            self.calibrateDelayAction.setEnabled(True)

    def disableSaveActions(self):
        if aw:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False) 
            #self.ConfMenu.setEnabled(False)
            self.calibrateDelayAction.setEnabled(False)

    # relocate event actions, by skippig 3=MultipleEvent and 7=Call Program SliderAction
    def eventactionx(self,a,cmd):
        try:
            # we added "Multiple Events" at position 20 which has to be mapped to action 3
            self.eventaction((a if (a < 3) else (3 if (a == 20) else ((a + 2) if (a > 5) else (a + 1)))), cmd)
        except Exception:
            pass

    #actions: 0 = None; 1= Serial Command; 2= Call program; 3= Multiple Event; 4= Modbus Command; 5=DTA Command; 6=IO Command (Phidgets/Yocto IO); 
    #         7= Call Program with argument (slider action); 8= HOTTOP Heater; 9= HOTTOP Main Fan; 10= HOTTOP Command; 11= p-i-d; 12= Fuji Command;
    #         13= PWM Command; 14= VOUT Command; 15= S7 Command; 16= Aillio R1 Heater; 17= Aillio R1 Fan; 18= Aillio R1 Drum; 19= Aillio R1 Command;
    #         20= Artisan Command; 21= RC Command
    def eventaction(self,action,cmd,parallel=True):
        if action:
            if not parallel: # subactions of multiple event actions, may crash if run in parallel, especially if they update the UI like button shape!
                self.eventaction_internal(action,cmd)
            else:
                eventActionThread = EventActionThread(action,cmd)
                eventActionThread.finished.connect(self.eventactionThreadDone_slot)
                try:
                    aw.qmc.eventactionsemaphore.acquire(1)
                    self.eventaction_running_threads.append(eventActionThread)
                finally:
                    if aw.qmc.eventactionsemaphore.available() < 1:
                        aw.qmc.eventactionsemaphore.release(1)
                eventActionThread.start()
    
    @pyqtSlot()
    def eventactionThreadDone_slot(self):
        try:
            aw.qmc.eventactionsemaphore.acquire(1)
            actionthread = self.sender()
            if actionthread in self.eventaction_running_threads:
                self.eventaction_running_threads.remove(actionthread)
            actionthread.disconnect()
        finally:
            if aw.qmc.eventactionsemaphore.available() < 1:
                aw.qmc.eventactionsemaphore.release(1)
    
    def eventaction_internal(self,action,cmd):
        if action:
            try:
                if action in [8,9,10]:
                    from artisanlib.hottop import setHottop
                cmd_str = u(cmd)
                
                if aw.simulator and action != 16:
                    # disable all communicating commands in simulation mode
                    return
                
                # we add {BT}, {ET}, {time} substitutions for Serial/CallProgram/MODBUS/S7 command actions
                if action in [1,2,4,7,15] and len(self.qmc.timex) > 0:
                    try:
                        timex = self.qmc.timex[-1]
                        if self.qmc.timeindex[0] != -1:
                            timex -= self.qmc.timex[self.qmc.timeindex[0]]
                        cmd_str = cmd_str.format(BT=self.qmc.temp2[-1],ET=self.qmc.temp1[-1],t=timex)
                    except:
                        cmd_str = cmd_str.format(BT=0,ET=0,t=0)
                
                if action == 1:
                    cmd_str_bin = ""
                    #example a2b_uu("Hello") sends Hello in binary format instead of ASCII
                    if "a2b_uu" in cmd_str:
                        cmd_str = cmd_str[(len("a2b_uu")+1):][:1]  # removes function-name + char ( and )
                        cmd_str_bin = binascii.a2b_uu(cmd_str)
                    if cmd_str_bin:
                        self.ser.sendTXcommand(cmd_str_bin)
                    else:
                        cmd_str = cmd_str.replace('\\r\\n','\n\r').replace('\\n', '\n').replace('\\t','\t')
                        self.ser.sendTXcommand(cmd_str)
                elif action == 2: # button call program action
                    try:
                        if cmd_str:
                            self.call_prog_with_args(cmd_str)
#                        if cmd_str and (len(cmd_str.split(" ")) > 1 or platf == 'Darwin' or platf == 'Linux'):
#                            self.call_prog_with_args(cmd_str) # a command with argument
#                        else:
## take care, the QDir().current() directory changes with loads and saves 
##                        QDesktopServices.openUrl(QUrl("file:///" + u(QDir().current().absolutePath()) + "/" + cmd_str, QUrl.TolerantMode))
#                            if platf in ['Windows','Linux']:
#                                QDesktopServices.openUrl(QUrl("file:///" + u(QApplication.applicationDirPath()) + "/" + cmd_str, QUrl.TolerantMode))
#                            else: # on Darwin
#                                QDesktopServices.openUrl(QUrl("file:///" + u(QApplication.applicationDirPath()) + "/../../../" + cmd_str, QUrl.TolerantMode))
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " eventaction() {0}").format(str(e)),exc_tb.tb_lineno)
                elif action == 3: # Multiple Event
                    cmd_list = cmd_str.split(",")
                    for i in range(len(cmd_list)):
                        cs = cmd_list[i]
                        if cs.startswith('sleep'):
                            try:
                                cmds = eval(cs[len('sleep'):])
                                if isinstance(cmds,float) or isinstance(cmds,int):
                                    # cmd has format "sleep(xx.yy)"
                                    libtime.sleep(cmds)
                            except Exception:
                                pass
                        else:
                            buttonnumber = int(cs)-1
                            if self.extraeventsactions[buttonnumber] != 3:   #avoid calling other buttons with multiple actions to avoid possible infinite loops
                                self.recordextraevent(buttonnumber,updateButtons=False)
                elif action == 4: # MODBUS Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0 # contains the required sleep time
                        for c in cmds:
                            cs = c.strip().replace("_",str(aw.modbus.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                if followupCmd == 0.08:
                                    aw.modbus.sleepBetween(write=True)
                                else:
                                    aw.modbus.sleepBetween(write=False)
                                #libtime.sleep(followupCmd) #this garantees a minimum of 30 miliseconds between readings and 80ms between writes (according to the Modbus spec)                                
                            if cs.startswith('writem'):
                                try:
                                    cmds = eval(cs[len('writem'):])
                                    if isinstance(cmds,tuple) and len(cmds) == 3:
                                        # cmd has format "writem(s,r,[v1,..,vn])"
                                        aw.modbus.writeRegisters(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith('sleep'):
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith("writeBCD"):
                                try:
                                    cmds = eval(cs[len('writeBCD'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "writeBCD(s,r,v)"
                                            aw.modbus.writeBCD(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "writeBCD([s,r,v],..,[s,r,v])"
                                            for cmd in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                aw.modbus.writeBCD(*cmd)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeBCD([s,r,v])"
                                        aw.modbus.writeBCD(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith('writeWord'): # writing directly floats
                                try:
                                    cmds = eval(cs[len('writeWord'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            aw.modbus.writeWord(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cmd in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                aw.modbus.writeWord(*cmd)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        aw.modbus.writeWord(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            aw.modbus.writeRegister(*cmds)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cmd in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                aw.modbus.writeRegister(*cmd)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        aw.modbus.writeRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith('mwrite'):
                                try:
                                    cmds = eval(cs[len('mwrite'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 4 and not isinstance(cmds[0],list):
                                            # cmd has format "mwrite(s,r,am,om)"
                                            aw.modbus.maskWriteRegister(*cmds)
                                            followupCmd = 0.08
                                        elif len(cmds) == 5 and not isinstance(cmds[0],list):
                                            # cmd has format "mwrite(s,r,am,om,v)" with v the new value that might be evaluated from _ (last MODBUS read result)
                                            # here a local mask write is computed on v and send via MODBUS fct. 6 (instead of fct.25 used by the standard mwrite function below)
                                            aw.modbus.localMaskWriteRegister(*cmds)
                                        else:
                                        # cmd has format "mwrite([s,r,am,om],..,[s,r,am,om])"
                                            for cmd in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                if len(cmd) == 4:
                                                    aw.modbus.maskWriteRegister(*cmd)
                                                elif len(cmd) == 5:
                                                    aw.modbus.localMaskWriteRegister(*cmd)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,am,om])"
                                        aw.modbus.maskWriteRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith("wcoils"):
                                try:
                                    cmds = eval(cs[len('wcoils'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "wcoils(s,r,[<b>,..<b>])"
                                            aw.modbus.writeCoils(*cmds)
                                            followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith("wcoil"):
                                try:
                                    cmds = eval(cs[len('wcoil'):])
                                    if isinstance(cmds,tuple) and len(cmds) == 3:
                                        # cmd has format "wcoil(s,r,<b>)"
                                        aw.modbus.writeCoil(*cmds)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                            elif cs.startswith("read"):
                                try:
                                    cmds = eval(cs[len('read'):])
                                    if isinstance(cmds,tuple) and len(cmds) == 2:
                                        # cmd has format "read(s,r)" 
                                        aw.modbus.lastReadResult = aw.modbus.readSingleRegister(*cmds)
                                        followupCmd = 0.03
                                except Exception:
                                    pass
                            elif cs.startswith("button"):
                                # cmd has format "button(0)" # 0 or 1 or True or False
                                try:
                                    cmds = eval(cs[len('button'):])
                                    last = self.lastbuttonpressed
                                    if last != -1 and len(self.buttonlist)>last:
                                        #block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        if cmds:
                                            aw.setExtraEventButtonStyle(last, style="pressed")
                                        else:
                                            aw.setExtraEventButtonStyle(last, style="normal")
                                except Exception:
                                    pass
                elif action == 5: # DTA Command
                    try:
                        DTAvalue=cmd_str.split(':')[1]
                        DTAaddress=cmd_str.split(':')[0]
                        aw.dtapid.writeDTE(DTAvalue,DTAaddress)
                    except Exception:
                        pass
                elif action == 6:  # IO Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  set(c,b[,sn])   : switches channel c off (b=0) and on (b=1)
                    ##  toggle(c[,sn])  : toggles channel c
                    ##  pulse(c,t[,sn]) : sets the output of channel c to on for time t in milliseconds
                    ##  out(c,v[,sn])   : sets voltage output of channel c to v (float)
                    ##  accel(c,v[,sn]) : sets acceleration of channel c to v (float) on a DCMotor phidget
                    ##  vel(c,v[,sn])   : sets target velocity of channel c to v (float) on a DCMotor phidget
                    #
                    # YOCTOPUCE
                    ##  on(c[,sn])   : turn channel c of the relay module on
                    ##  off(c[,sn])  : turn channel c of the relay module off
                    ##  flip(c[,sn]) : toggle the state of channel c
                    ##  pip(c,delay,duration[,sn]) : pulse the channel c on after a delay of delay milliseconds for the duration of duration milliseconds
                    #
                    # OTHERS
                    ##  slider(c,v)   : move slider c to value v
                    ##  button(i,c,b[,sn]) : switches channel c off (b=0) and on (b=1) and sets button i to pressed or normal depending on the value b
                    ##  sleep(s) : sleep for s seconds, s a float
                    #
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs_a = re.findall("[0-9a-zA-Z-\.:]+", c)
                            cs_len = len(cs_a)

                            if cs_a[0] == "set":
                                if cs_len == 3:
                                    if not aw.ser.phidgetBinaryOUTset(toInt(cs_a[1]), bool(toInt(cs_a[2]))):
                                        aw.sendmessage(QApplication.translate("Message", "Failed to set(%s, %s)" % (cs_a[1], cs_a[2]), None))
                                elif cs_len == 4:
                                    if not aw.ser.phidgetBinaryOUTset(toInt(cs_a[1]), bool(toInt(cs_a[2])), cs_a[3]):
                                        aw.sendmessage(QApplication.translate("Message", "Failed to set(%s, %s, %s)" % (cs_a[1], cs_a[2], cs_a[3]), None))

                            elif cs_a[0] == "toggle" and cs_len > 1:
                                c = toInt(cs_a[1])
                                if cs_len > 2:
                                    sn = cs_a[2]
                                else:
                                    sn = None
                                #keep state of this gpio, rather than rely on phidget and use non-zero value to set button color
                                # NOTE: with this strategy the modules state might be different to this one if also a set command is used
                                newValue = (self.buttonStates[self.lastbuttonpressed] + 1) & 0x1
                                if aw.ser.phidgetBinaryOUTset(c, bool(newValue),sn):
                                    self.buttonStates[self.lastbuttonpressed] = newValue
                                else:
                                    aw.sendmessage(QApplication.translate("Message", "Failed to toggle(%s)" % (cs_a[1]), None))
                                    #clear style that got set in button press event handler
                                    if 0 != self.buttonStates[self.lastbuttonpressed]:
                                        self.setExtraEventButtonStyle(self.lastbuttonpressed, style="pressed")
                                    else:
                                        self.setExtraEventButtonStyle(self.lastbuttonpressed, style="normal")
                                #block resetting style of last button
                                self.lastbuttonpressed = -1

                            elif cs_a[0] == "pulse" and cs_len > 2:
                                c = toInt(cs_a[1])
                                t = toInt(cs_a[2])
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                if t>= 0.0 and t <= 999999:
                                    aw.ser.phidgetBinaryOUTpulse(c, t, sn)
                                else:
                                    aw.sendmessage(QApplication.translate("Message", "Pulse out of range (%d)" % (t), None))

                            elif cs_a[0] == "out" and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                if not aw.ser.phidgetVOUTsetVOUT(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn):
                                    aw.sendmessage(QApplication.translate("Message", "Failed to set VOUT(%s, %s)" % (cs_a[1], cs_a[2] ), None))

                            elif cs_a[0] == "accel" and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                aw.ser.phidgetDCMotorSetAcceleration(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn)

                            elif cs_a[0] == "vel" and cs_len > 2:
                                if cs_len > 3:
                                    sn = cs_a[3]
                                else:
                                    sn = None
                                aw.ser.phidgetDCMotorSetVelocity(toInt(cs_a[1]), toFloat(eval(cs_a[2])),sn)

                            elif cs_a[0] == "slider" and cs_len == 3:
                                v = toFloat(cs_a[2])
                                if v >= 0.0 and v <= 100.0:
                                    aw.moveslider(toInt(cs_a[1]), v)
                                else:
                                    aw.sendmessage(QApplication.translate("Message", "Slider out of range (%f)" % (v), None))
                            elif cs_a[0] == "button" and cs_len > 3:
                                b = toInt(cs_a[1]) - 1 # gui button list is indexed from 1
                                c = toInt(cs_a[2])
                                v = toInt(cs_a[3])
                                if cs_len > 4:
                                    sn = cs_a[4]
                                else:
                                    sn = None
                                if aw.ser.phidgetBinaryOUTset(c, bool(v & 0x1), sn):
                                    self.buttonStates[b] = v & 0x1
                                else:
                                    aw.sendmessage(QApplication.translate("Message", "Failed to set button(%s, %s, %s)" % (cs_a[1], cs_a[2], cs_a[3] ), None))

                                if self.buttonStates[b] != 0:
                                    self.setExtraEventButtonStyle(b, style="pressed")
                                else:
                                    self.setExtraEventButtonStyle(b, style="normal")
                            elif cs_a[0] == "sleep" and cs_len == 1: # in seconds
                                try:
                                    t = eval(cs_a[1])
                                    if isinstance(t,float) or isinstance(t,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(t)
                                except Exception:
                                    pass
                            
                            # Yoctopuce Relay Command Actions
                            # on(c[,sn])
                            elif cs_a[0] == "on" and cs_len == 2:
                                aw.ser.yoctoRELon(int(cs_a[1]),None)
                            elif cs_a[0] == "on" and cs_len == 3:
                                aw.ser.yoctoRELon(int(cs_a[1]),cs_a[2])
                            # off(c[,sn])
                            elif cs_a[0] == "off" and cs_len == 2:
                                aw.ser.yoctoRELoff(int(cs_a[1]),None)
                            elif cs_a[0] == "off" and cs_len == 3:
                                aw.ser.yoctoRELoff(int(cs_a[1]),cs_a[2])
                            # flip(c[,sn])
                            elif cs_a[0] == "flip" and cs_len == 2:
                                aw.ser.yoctoRELflip(int(cs_a[1]),None)
                            elif cs_a[0] == "flip" and cs_len == 3:
                                aw.ser.yoctoRELflip(int(cs_a[1]),cs_a[2])
                            # pulse(c,delay,duration[,sn])
                            elif cs_a[0] == "pip" and cs_len == 4:
                                aw.ser.yoctoRELpulse(int(cs_a[1]),int(cs_a[2]),int(cs_a[3]),None)
                            elif cs_a[0] == "pip" and cs_len == 5:
                                aw.ser.yoctoRELpulse(int(cs_a[1]),int(cs_a[2]),int(cs_a[3]),cs_a[4])
                            else:
                                #print("no match for command [%s], continue" % (cs_a[0]))
                                aw.sendmessage(QApplication.translate("Message","No match for command [%s], continuing" % (cs_a[0]), None))

                elif action == 7: # slider call-program action
                    try:
                        self.call_prog_with_args(cmd_str)
                    except Exception as e:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " callProgram(): {0}").format(str(e)),exc_tb.tb_lineno)
                elif action == 8: # HOTTOP Heater
                    setHottop(heater=int(cmd))
                elif action == 9: # HOTTOP Main Fan
                    setHottop(main_fan=int(cmd))
                elif action == 10: # HOTTOP Command (one of "heater", "fan", "motor", "solenoid", "stirrer")
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            if cs.startswith("heater"):
                                try:
                                    cmds = eval(cs[len('heater'):])
                                    if isinstance(cmds,int):
                                        setHottop(heater = min(max(cmds,0),100))
                                except Exception:
                                    pass
                            elif cs.startswith("fan"):
                                try:
                                    cmds = eval(cs[len('fan'):])
                                    if isinstance(cmds,int):
                                        setHottop(main_fan = int(min(max(cmds,0),10) * 10))
                                except Exception:
                                    pass
                            elif cs.startswith("motor"):
                                try:
                                    cmds = eval(cs[len('motor'):])
                                    if cmds:
                                        setHottop(drum_motor=True)
                                    else:
                                        setHottop(drum_motor=False)
                                except Exception:
                                    pass
                            elif cs.startswith("solenoid"):
                                try:
                                    cmds = eval(cs[len('solenoid'):])
                                    if cmds:
                                        setHottop(solenoid=True)
                                    else:
                                        setHottop(solenoid=False)
                                except Exception:
                                    pass
                            elif cs.startswith("stirrer"):
                                try:
                                    cmds = eval(cs[len('stirrer'):])
                                    if cmds:
                                        setHottop(cooling_motor=True)
                                    else:
                                        setHottop(cooling_motor=False)
                                except Exception:
                                    pass
                            elif cs.startswith('sleep') and cs.endswith(")"): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception:
                                    pass
                elif action == 11: # p-i-d, expects 3 float numbers separated by semicolon
                    if cmd_str:
                        cmds = list(filter(None, cmd_str.split(";"))) # "<p>;<i>;<d>"
                        if len(cmds) == 3:
                            kp = float(cmds[0])
                            ki = float(cmds[1])
                            kd = float(cmds[2])
                            #FUJI/DELTA pid
                            if aw.qmc.device == 0 or aw.qmc.device == 26:
                                # set-p-i-d currently only set from dialog
                                if self.ser.controlETpid[0] == 0:
                                    # 1. get current PID
                                    N = aw.fujipid.getCurrentPIDnumberPXG()     
                                    # 2. call setpid(self,k) with k that active pid
                                    aw.fujipid.setpidPXG(N,kp,ki,kd)
                                elif self.ser.controlETpid[0] == 1:
                                    aw.fujipid.setpidPXR("p",kp)
                                    libtime.sleep(0.035)
                                    aw.fujipid.setpidPXR("i",ki)
                                    libtime.sleep(0.035)
                                    aw.fujipid.setpidPXR("d",kd)
                            else:
                                aw.pidcontrol.confPID(kp,ki,kd,pOnE=aw.pidcontrol.pOnE)
                                #aw.pidcontrol.setPID(kp,ki,kd) # we don't set the new values in the dialog
                elif action == 12: # Fuji Command (currently only "write(<unitId>,<register>,<value>)" is supproted
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0 # contains the required sleep time
                        for c in cmds:
                            cs = c.strip().replace("_",str(aw.modbus.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                try:
                                    if followupCmd == 0.08:
                                        aw.modbus.sleepBetween(write=True)
                                    else:
                                        aw.modbus.sleepBetween(write=False)
                                except:
                                    pass
                            if cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):])
                                    if isinstance(cmds,tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0],list):
                                            # cmd has format "write(s,r,v)"
                                            command = aw.fujipid.message2send(cmds[0],6,cmds[1],cmds[2])
                                            aw.ser.sendFUJIcommand(command,8)
                                            followupCmd = 0.08
                                        else:
                                        # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cmd in cmds:
                                                if followupCmd:
                                                    libtime.sleep(followupCmd) # respect the MODBUS timing (a MODBUS command might have preceeded)
                                                command = aw.fujipid.message2send(cmd[0],6,cmd[1],cmd[2])
                                                aw.ser.sendFUJIcommand(command,8)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        command = aw.fujipid.message2send(cmds[0],6,cmds[1],cmds[2])
                                        aw.ser.sendFUJIcommand(command,8)
                                        followupCmd = 0.08
                                except Exception:
                                    pass
                elif action == 13: # PWM Command 
                    # PHIDGET  <sn> : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    # 
                    ## out(<channel>,<value>[,<sn>])  with <value> in [0-100]
                    ## toggle(<channel>[,<sn>])
                    ## outhub(<channel>,<value>[,<sn>])
                    ## togglehub(<channel>[,<sn>])
                    ## pulse(<channel>,<millis>[,<sn>])
                    ## pulsehub(<channel>,<millis>[,<sn>])
                    #
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            try:
                                if cs.startswith('out(') and len(cs)>7:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTsetPWM(int(cs_split[0]),int(eval(cs_split[1])))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTsetPWM(int(cs_split[0]),int(eval(cs_split[1])),cs_split[2])
                                elif cs.startswith('toggle(') and len(cs)>8:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 1:
                                        aw.ser.phidgetOUTtogglePWM(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        aw.ser.phidgetOUTtogglePWM(int(cs_split[0]),cs_split[1])
                                elif cs.startswith('outhub(') and len(cs)>10:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTsetPWMhub(int(cs_split[0]),int(eval(cs_split[1])))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTsetPWMhub(int(cs_split[0]),int(eval(cs_split[1])),cs_split[2])
                                elif cs.startswith('togglehub(') and len(cs)>11:
                                    cs_split = cs[10:-1].split(',')
                                    if len(cs_split) == 1:
                                        aw.ser.phidgetOUTtogglePWMhub(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        aw.ser.phidgetOUTtogglePWMhub(int(cs_split[0]),cs_split[1])
                                elif cs.startswith('pulsehub(') and len(cs)>12:
                                    cs_split = cs[9:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTpulsePWMhub(int(cs_split[0]),int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTpulsePWMhub(int(cs_split[0]),int(cs_split[1]),cs_split[2])
                                elif cs.startswith('pulse(') and len(cs)>9:
                                    cs_split = cs[6:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetOUTpulsePWM(int(cs_split[0]),int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetOUTpulsePWM(int(cs_split[0]),int(cs_split[1]),cs_split[2])
                                elif cs.startswith('sleep') and cs.endswith(")"): # in seconds
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                
                                
                                # Commands for the YoctoPWM module
                                
                                # enabled(c,b[,sn])
                                elif cs.startswith('enabled') and cs.endswith(")") and len(cs)>11:
                                    try:
                                        cs_split = cs[len('enabled('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMenabled(int(cs_split[0]),bool(eval(cs_split[1])),cs_split[2])
                                        else:
                                            aw.ser.yoctoPWMenabled(int(cs_split[0]),bool(eval(cs_split[1])))
                                    except Exception:
                                        pass
                                # freq(c,f[,sn])
                                elif cs.startswith('freq') and cs.endswith(")") and len(cs)>8:
                                    try:
                                        cs_split = cs[len('freq('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMsetFrequency(int(cs_split[0]),int(eval(cs_split[1])),cs_split[2])
                                        else:
                                            aw.ser.yoctoPWMsetFrequency(int(cs_split[0]),int(eval(cs_split[1])))
                                    except Exception:
                                        pass
                                # duty(c,d[,sn])
                                elif cs.startswith('duty') and cs.endswith(")") and len(cs)>8:
                                    try:
                                        cs_split = cs[len('duty('):-1].split(',')
                                        if len(cs_split) > 2:
                                            aw.ser.yoctoPWMsetDuty(int(cs_split[0]),float(eval(cs_split[1])),cs_split[2])
                                        else:
                                            aw.ser.yoctoPWMsetDuty(int(cs_split[0]),float(eval(cs_split[1])))
                                    except Exception:
                                        pass
                                # move(c,d,t[,sn])
                                elif cs.startswith('move') and cs.endswith(")") and len(cs)>10:
                                    try:
                                        cs_split = cs[len('move('):-1].split(',')
                                        if len(cs_split) > 3:
                                            aw.ser.yoctoPWMmove(int(cs_split[0]),float(eval(cs_split[1])),int(cs_split[2]),cs_split[3])
                                        else:
                                            aw.ser.yoctoPWMmove(int(cs_split[0]),float(eval(cs_split[1])),int(cs_split[2]))
                                    except Exception:
                                        pass
                            
                            except:
                                pass
                elif action == 14: # VOUT Command to drive Phidget/Yocto Output Modules
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # for Phidgets OUT modules "out(<channel>,<value>[,<serial>])" with <value> a float
                            if cs.startswith('out(') and len(cs)>7:
                                try:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split) == 2:
                                        aw.ser.phidgetVOUTsetVOUT(int(cs_split[0]),float(eval(cs_split[1])))
                                    elif len(cs_split) == 3:
                                        aw.ser.phidgetVOUTsetVOUT(int(cs_split[0]),float(eval(cs_split[1])),cs_split[2])
                                except Exception:
                                    pass
                            # for YOCTOPUCE VOLTAGE OUT modules "vout(c,v[,sn])" with c the channel (1 or 2),v the voltage as float [0.0-10.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('vout(') and len(cs)>8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 2:
                                        aw.ser.yoctoVOUTsetVOUT(int(cs_split[0]),float(eval(cs_split[1])),cs_split[2])
                                    else:
                                        aw.ser.yoctoVOUTsetVOUT(int(cs_split[0]),float(eval(cs_split[1])))
                                except Exception:
                                    pass
                            # for YOCTOPUCE CURRENT OUT modules "cout(c[,sn])" with c the current as float [3.0-21.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('cout(') and len(cs)>6:
                                try:
                                    #c = cs[5:-1]
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 1:
                                        aw.ser.yoctoCOUTsetCOUT(float(eval(cs_split[0])),cs_split[1])
                                    else:
                                        aw.ser.yoctoCOUTsetCOUT(float(eval(cs_split[0])))
                                except Exception:
                                    pass
                            elif cs.startswith('sleep') and cs.endswith(")"): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception:
                                    pass
                elif action == 15: # S7 Command
                    # getDBint(<dbnumber>,<start>)
                    # getDBfloat(<dbnumber>,<start>)
                    # setDBint(<dbnumber>,<start>,<value>)
                    # setDBfloat(<dbnumber>,<start>,<value>)
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:                        
                            cs = c.strip().replace("_",str(aw.s7.lastReadResult)) # the last read value can be accessed via the "_" symbol
                            if cs.startswith("setDBint(") and len(cs) > 14:
                                try:
                                    dbnr,s,v = cs[len("setDBint("):-1].split(',')
                                    aw.s7.writeInt(5,int(dbnr),int(s),eval(v))
                                except Exception:
                                    pass
                            elif cs.startswith("getDBint(") and len(cs) > 14:
                                try:
                                    dbnr,s,v = cs[len("getDBint("):-1].split(',')
                                    aw.s7.lastReadResult = aw.s7.getInt(5,int(dbnr),int(s))
                                except Exception:
                                    pass
                            elif cs.startswith("setDBfloat(") and len(cs) > 16:
                                try:
                                    dbnr,s,v = cs[len("setDBfloat("):-1].split(',')
                                    aw.s7.writeFloat(5,int(dbnr),int(s),eval(v))
                                except Exception:
                                    pass
                            elif cs.startswith("getDBfloat(") and len(cs) > 16:
                                try:
                                    dbnr,s,v = cs[len("getDBfloat("):-1].split(',')
                                    aw.s7.lastReadResult = aw.s7.readFloat(5,int(dbnr),int(s))
                                except Exception:
                                    pass
                            elif cs.startswith('sleep') and cs.endswith(")"): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception:
                                    pass
                elif action == 16: # Aillio Heater
                    self.ser.R1.set_heater(int(eval(cmd))/10)
                elif action == 17: # Aillio Fan
                    self.ser.R1.set_fan(int(eval(cmd))/10)
                elif action == 18: # Aillio Drum
                    self.ser.R1.set_drum(int(eval(cmd))/10)
                elif action == 19:
                    if cmd_str == "PRS":
                        self.ser.R1.prs()
                elif action == 20: # Artisan Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # alarms(<bool>) enable/disable alarms
                            if cs.startswith("alarms(") and cs.endswith(")"):
                                try:
                                    value = cs[len("alarms("):-1]
                                    if value.lower() in ("yes", "true", "t", "1"):
                                        aw.qmc.silent_alarms = False
                                        aw.sendmessage(QApplication.translate("Message","Alarms on", None))
                                    else:
                                        aw.qmc.silent_alarms = True
                                        aw.sendmessage(QApplication.translate("Message","Alarms off", None))
                                except Exception:
                                    pass
                            # autoCHARGE(<bool>) enable/disable autoCHARGE
                            elif cs.startswith("autoCHARGE(") and cs.endswith(")"):
                                try:
                                    value = cs[len("autoCHARGE("):-1]
                                    if value.lower() in ("yes", "true", "t", "1"):
                                        aw.qmc.autoChargeFlag = True
                                        aw.sendmessage(QApplication.translate("Message","autoCHARGE on", None))
                                    else:
                                        aw.qmc.autoChargeFlag = False
                                        aw.sendmessage(QApplication.translate("Message","autoCHARGE off", None))
                                except Exception:
                                    pass
                            # autoDROP(<bool>) enable/disable autoDROP
                            elif cs.startswith("autoDROP(") and cs.endswith(")"):
                                try:
                                    value = cs[len("autoDROP("):-1]
                                    if value.lower() in ("yes", "true", "t", "1"):
                                        aw.qmc.autoDropFlag = True
                                        aw.sendmessage(QApplication.translate("Message","autoDROP on", None))
                                    else:
                                        aw.qmc.autoDropFlag = False
                                        aw.sendmessage(QApplication.translate("Message","autoDROP off", None))
                                except Exception:
                                    pass
                            # sleep(<n>) sleep <n> seconds (might be a float like in "sleep(1.2)"
                            elif cs.startswith('sleep') and cs.endswith(")"): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception:
                                    pass
                            # tare(<n>) tare channel <n> with 1 => ET, 2 => BT, 3 => E1c1, 4: E1c2,..
                            elif cs.startswith('tare') and cs.endswith(")"): # in seconds
                                try:
                                    cmds = eval(cs[len('tare'):])
                                    if isinstance(cmds,int):
                                        aw.setTare(cmds-1)
                                except Exception:
                                    pass
                            elif cs == "PIDon":
                                aw.pidcontrol.pidOn()
                            elif cs == "PIDoff":
                                aw.pidcontrol.pidOff()
                            elif cs == "PIDtoggle":
                                aw.pidcontrol.togglePID()
                            # pidmode(<n>) : 0: manual, 1: RS, 2: background follow
                            if cs.startswith("pidmode(") and cs.endswith(")"):
                                try:
                                    value = int(cs[len("pidmode("):-1])
                                    if value == 0:
                                        aw.pidcontrol.svMode = 0
                                        aw.sendmessage(QApplication.translate("Message","PID mode manual", None))
                                    elif value == 1:
                                        aw.pidcontrol.svMode = 1
                                        aw.sendmessage(QApplication.translate("Message","PID mode Ramp/Soak", None))
                                    elif value == 2:
                                        aw.pidcontrol.svMode = 2
                                        aw.sendmessage(QApplication.translate("Message","PID mode background", None))
                                except Exception:
                                    pass
                            # playbackmode(<n> 0: off, 1: time, 2: BT, 3: ET
                            if cs.startswith("playbackmode(") and cs.endswith(")"):
                                try:
                                    value = int(cs[len("playbackmode("):-1])
                                    if value == 0:
                                        aw.qmc.replayType = 0
                                        aw.qmc.backgroundPlaybackEvents = False
                                        aw.sendmessage(QApplication.translate("Message","playback off", None))
                                    elif value == 1:
                                        aw.qmc.replayType = 0
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate("Message","playback by time", None))
                                    elif value == 2:
                                        aw.qmc.replayType = 1
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate("Message","playback by BT", None))
                                    elif value == 3:
                                        aw.qmc.replayType = 2
                                        aw.qmc.backgroundPlaybackEvents = True
                                        aw.sendmessage(QApplication.translate("Message","playback by ET", None))
                                except Exception:
                                    pass
                elif action == 21: # RC Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  pulse(ch,min,max[,sn]) : sets the min/max pulse width in microseconds
                    ##  pos(ch,min,max[,sn]) : sets the min/max position
                    ##  engaged(ch,b[,sn]) : engage (b=1) or disengage (b = 0)
                    ##  ramp(ch,b[,sn]) : activates or deactivates the speed ramping state
                    ##  volt(ch,v[,sn]) : set the voltage to one of 5, 6 or 7.4 in Volt
                    ##  accel(ch,a[,sn]) : set the acceleration
                    ##  veloc(ch,v[,sn]) : set the velocity
                    ##  set(ch,pos[,sn]) : set the target position
                    #
                    # YOCTOPUCE
                    #
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(";")) # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # pulse(ch,min,max[,sn]) # sets min/max pulse width
                            if cs.startswith("pulse(") and len(cs) > 11:
                                try:
                                    n = 3
                                    cs_split = cs[len("pulse("):-1].split(',')
                                    channel,min_pulse,max_pulse = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCpulse(int(channel),int(min_pulse),int(max_pulse),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("pos(") and len(cs) > 9:
                                # pos(ch,min,max[,sn]) # sets min/max position
                                try:
                                    n = 3
                                    cs_split = cs[len("pos("):-1].split(',')
                                    channel,min_pos,max_pos = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCpos(int(channel),float(min_pos),float(max_pos),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("engaged(") and len(cs) > 11:
                                # engaged(ch,state[,sn]) # engage channel
                                try:
                                    n = 2
                                    cs_split = cs[len("engaged("):-1].split(',')
                                    channel,state = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCengaged(int(channel),bool(int(state)),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("set(") and len(cs) > 7:
                                # set(ch,pos[,sn]) # set position
                                try:
                                    n = 2
                                    cs_split = cs[len("set("):-1].split(',')
                                    channel,pos = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCset(int(channel),float(eval(pos)),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("ramp(") and len(cs) > 8:
                                # ramp(ch,state) # set speed ramping state per channel
                                try:
                                    n = 2
                                    cs_split = s[len("ramp("):-1].split(',')
                                    channel,state = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCspeedRamping(int(channel),bool(int(state)),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("volt(") and len(cs) > 8:
                                # volt(ch,v) # sets voltage
                                try:
                                    n = 2
                                    cs_split = cs[len("volt("):-1].split(',')
                                    channel,volt = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCvoltage(int(channel),float(volt),n)
                                except Exception:
                                    pass
                            elif cs.startswith("accel(") and len(cs) > 9:
                                # accel(ch,accel) # sets acceleration
                                try:
                                    n = 2
                                    cs_split = cs[len("accel("):-1].split(',')
                                    channel,accel = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCaccel(int(channel),float(accel),sn)
                                except Exception:
                                    pass
                            elif cs.startswith("veloc(") and len(cs) > 9:
                                # veloc(ch,veloc) # sets velocity
                                try:
                                    n = 2
                                    cs_split = cs[len("veloc("):-1].split(',')
                                    channel,veloc = cs_split[0:n]
                                    if len(cs_split)>n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    aw.ser.phidgetRCveloc(int(channel),float(veloc),sn)
                                except Exception:
                                    pass
                            elif cs.startswith('sleep('): # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])
                                    if isinstance(cmds,float) or isinstance(cmds,int):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except:
                                    pass
                            
                            # functions supporting the Yoctopuce RC module
                            # enabled(c,b[,sn]) with c:int the channel, b a bool (eg. enabled(0,1) or enabled(0,True)), sn the optional modules serial number or logical name
                            elif cs.startswith('enabled(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    c = int(cs_split[0])
                                    b = bool(eval(cs_split[1]))
                                    if len(cs_split) > 2:
                                        sn = cs_split[2]
                                        aw.ser.yoctoSERVOenabled(c,b,sn)
                                    else:
                                        aw.ser.yoctoSERVOenabled(c,b)
                                except:
                                    pass
                            # move(c,p[,t][,sn]) with c:int the channel, p:int the target position, the optional t the duration in ms, sn the optional modules serial number or logical name
                            elif cs.startswith('move(') and len(cs) > 8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    c = int(cs_split[0])
                                    p = int(eval(cs_split[1]))
                                    if len(cs_split) > 2:
                                        try:
                                            t = int(cs_split[2])
                                            if len(cs_split) > 3:
                                                aw.ser.yoctoSERVOmove(c,p,t,cs_split[3])
                                            else:
                                                aw.ser.yoctoSERVOmove(c,p,t)
                                        except:
                                            aw.ser.yoctoSERVOposition(c,p,cs_split[2])
                                    else:
                                        aw.ser.yoctoSERVOposition(c,p)
                                except:
                                    pass
                            # neutral(c,n[,sn]) with n an int [0..65000] in us, sn the modules serial number or logical name
                            elif cs.startswith('neutral(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    c = int(cs_split[0])
                                    n = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        aw.ser.yoctoSERVOneutral(c,n,sn)
                                    else:
                                        aw.ser.yoctoSERVOneutral(c,n)
                                except:
                                    pass
                            # range(c,r[,sn]) with r an int in %, sn the modules serial number or logical name
                            elif cs.startswith('range(') and len(cs) > 8:
                                try:
                                    cs_split = cs[6:-1].split(',')
                                    c = int(cs_split[0])
                                    r = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        aw.ser.yoctoSERVOrange(c,r,sn)
                                    else:
                                        aw.ser.yoctoSERVOrange(c,r)
                                except:
                                    pass
            except Exception:
                pass
    
    def calc_env(self):
        # we try to set the users standard environment, replacing the one pointing to the restrictive python build in Artisan
        my_env = os.environ.copy()
        try:
            for v in ['PYTHONHOME','PYTHONPATH','LD_LIBRARY_PATH']:
                if v in my_env:
                    del my_env[v]
            # try to source users environment to make external Python scripts run in their "natural" env
            if platf in ['Darwin', 'Linux']:
                command = ['bash', '-c', 'source ~/.bash_profile ~/.bash_login ~/.profile 2>/dev/null && env']
                try:
                    proc = subprocess.Popen(command, stdout = subprocess.PIPE)
                    for line in proc.stdout:
                        (key, _, value) = line.partition("=")
                        # don't copy PYTHONHOME nor PYTHONPATH if it points to the Artisan.app
                        if not ((key in ['PYTHONHOME','PYTHONPATH']) and (("Artisan.app" in value) or "artisan" in value)):
                            my_env[key] = value
                    proc.communicate()
                except:
                    pass
        except:
            pass
        return my_env
        
    def re_split(self,s):
        def strip_quotes(s):
            if s and (s[0] == '"' or s[0] == "'") and s[0] == s[-1]:
                return s[1:-1]
            return s
        return [strip_quotes(p).replace('\\"', '"').replace("\\'", "'") for p in re.findall(r'"(?:\\.|[^"])*"|\'(?:\\.|[^\'])*\'|[^\s]+', s)] 
    # dummy ' for syntax parsers confused by odd numbers of quotes
        
                        
    def call_prog_with_args(self,cmd_str):
#        cmd_str_parts = cmd_str.split(" ") # does split quoted strings ('this "is a" test' => ['this','"is','a"','test'])
        cmd_str_parts = self.re_split(cmd_str) # this preserves quoted strings ('this "is a" test' => ['this','is a','test'])
        if len(cmd_str_parts) > 0:
            try:
                cmd = cmd_str_parts[0].strip()
                qd = QDir(u(cmd))
                current = QDir.current()
                QDir.setCurrent(u(aw.getAppPath()))
                my_env = self.calc_env()
                if platf == 'Windows':
                    startupinfo = subprocess.STARTUPINFO()
                    try:
                        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                    except AttributeError:
                        startupinfo.dwFlags |= subprocess._subprocess.STARTF_USESHOWWINDOW  # @UndefinedVariable
                    prg_file = u(qd.absolutePath())
#                    CREATE_NEW_PROCESS_GROUP = 0x00000200
#                    DETACHED_PROCESS = 0x00000008
                    #subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]], shell=False,env=my_env)
                    subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]], 
                        startupinfo=startupinfo,
                        stdin=None, stdout=None, stderr=None,
#                        creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP, # with this the process ends before sleep
#                        close_fds=True, # this seems not to change a thing
                        env=my_env) #.wait() # with this wait(), the script blocks the Artisan event loop
                else:
                    subprocess.Popen(os.path.expanduser(cmd_str),
                        shell=True,
                        stdin=None, stdout=None, stderr=None,
                        close_fds=True,
                        env=my_env)
                QDir.setCurrent(current.absolutePath())
                # alternative approach, that seems to fail on some Mac OS X versions:
                #QProcess.startDetached(prg_file)
            except Exception:
                pass

    def sliderpos(self,n):
        if n == 0:
            return self.slider1.value()
        elif n == 1:
            return self.slider2.value()
        elif n == 2:
            return self.slider3.value()
        elif n == 3:
            return self.slider4.value()
            
    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    # updates corresponding eventslidervalues
    def moveslider(self,n,v,forceLCDupdate=False):
        if v >= self.eventslidermin[n] and v <= self.eventslidermax[n]: #v >= 0 and v <= 100:
            self.eventslidervalues[n] = v
            # first update slider LCDs if needed
            if n == 0 and (forceLCDupdate or self.slider1.value() != v):
                self.updateSliderLCD(0,v)
            elif n == 1 and (forceLCDupdate or self.slider2.value() != v):
                self.updateSliderLCD(1,v)
            elif n == 2 and (forceLCDupdate or self.slider3.value() != v):
                self.updateSliderLCD(2,v)
            elif n == 3 and (forceLCDupdate or self.slider4.value() != v):
                self.updateSliderLCD(3,v)
            # now move sliders to actual values if needed
            if n == 0 and self.slider1.value() != v:
                self.slider1.setValue(v)
            elif n == 1 and self.slider2.value() != v:
                self.slider2.setValue(v)
            elif n == 2 and self.slider3.value() != v:
                self.slider3.setValue(v)
            elif n == 3 and self.slider4.value() != v:
                self.slider4.setValue(v)
                
    def extraEventButtonStyle(self,tee,style="normal"):
        left_rounded_style = "border-top-left-radius:4px;border-bottom-left-radius:4px;"
        right_rounded_style = "border-top-right-radius:4px; border-bottom-right-radius:4px;"
        fully_rounded_style = "border-radius:4px;"
        square_style = "border-radius:0px;"
        if aw.buttonsize == 0:
            # tiny
            buttonstyle = """min-width:""" + self.tiny_button_min_width + """;margin:0;padding:0px;border-style:solid;border-color:darkgrey;border-width:0;font-size:""" + self.button_font_size_micro + """; font-weight: bold;"""
        elif aw.buttonsize == 2:
            # large
            buttonstyle = """min-width:""" + self.standard_button_min_width + """;margin:0;padding:0px;border-style:solid;border-color:darkgrey;border-width:0;font-size:""" + self.button_font_size_small + """; font-weight: bold;"""
        else:
            # small (default)
            buttonstyle = """min-width:""" + self.small_button_min_width + """;margin:0;padding:0px;border-style:solid;border-color:darkgrey;border-width:0;font-size:""" + self.button_font_size_tiny + """; font-weight: bold;"""
        ##
        if len(self.extraeventbuttonround) > tee:
            if self.extraeventbuttonround[tee] == 1: # left-side rounded
                buttonstyle += left_rounded_style
            elif self.extraeventbuttonround[tee] == 2: # right-side rounded
                buttonstyle += right_rounded_style
            elif self.extraeventbuttonround[tee] == 3: # both-sides rounded
                buttonstyle += fully_rounded_style
            else:
                buttonstyle += square_style
        #
        if style=="normal":
            color = self.extraeventbuttontextcolor[tee]
            backgroundcolor = self.extraeventbuttoncolor[tee]
        else: # style=="pressed":
            # set color of this button to "pressed"
            color = self.extraeventbuttoncolor[tee]
            backgroundcolor = self.extraeventbuttontextcolor[tee]
        core_style = """color:%s;background:%s}"""
        #
        plain_style = "QPushButton {" + buttonstyle + core_style%(color,self.createGradient(backgroundcolor))
        pressed_style = "QPushButton:hover:pressed {" + buttonstyle + core_style%(color,self.createGradient(QColor(backgroundcolor).lighter(80).name()))
        hover_style = "QPushButton:hover:!pressed {" + buttonstyle + core_style%(color,self.createGradient(QColor(backgroundcolor).lighter(110).name()))
        return plain_style + hover_style + pressed_style
        
    def setExtraEventButtonStyle(self, tee, style="normal"):
        button_style = self.extraEventButtonStyle(tee, style)
        QApplication.processEvents() # without this the next call might crash
        self.buttonlist[tee].setStyleSheet(button_style)
        QApplication.processEvents() # without this the prev call might crash
    
    @pyqtSlot(bool)
    def recordextraevent_slot(self,_):
        try:
            self.recordextraevent(self.buttonlist.index(self.sender()))
        except:
            pass

    #called from user configured event buttons
    #by default actions are processed in a parallel thread, but components of multiple button actions not to avoid crashes
    def recordextraevent(self,ee,parallel=True,updateButtons=True):
        eventtype = self.extraeventstypes[ee]
        if updateButtons: # not if triggered from mutliplebutton actions:
            try:
                aw.qmc.eventactionsemaphore.acquire(1)
                # reset color of last pressed button
                if self.lastbuttonpressed != -1 and len(self.buttonlist)>self.lastbuttonpressed:
                    self.setExtraEventButtonStyle(self.lastbuttonpressed, style="normal")
    
                #toggle button if it has nonzero state prior to toggling
                if self.buttonStates[ee] != 0:
                    self.setExtraEventButtonStyle(ee, style="normal")
                else:
                    self.setExtraEventButtonStyle(ee, style="pressed")

                # reset lastbuttonpressed
                self.lastbuttonpressed = ee

            except Exception:
                pass
            finally:
                if aw.qmc.eventactionsemaphore.available() < 1:
                    aw.qmc.eventactionsemaphore.release(1)
        cmdvalue = self.qmc.eventsInternal2ExternalValue(self.extraeventsvalues[ee])
        if eventtype < 4 or eventtype > 4:  ## if eventtype == 4 we have an button event of type " " that does not add an event; if eventtype == 9 ("-") we have an untyped event
            if eventtype == 9: # an untyped event
                # we just fire the action
                cmd = u(self.extraeventsactionstrings[ee])
                cmd = cmd.format(*(tuple([cmdvalue]*cmd.count("{}"))))
#                self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)
                # and record the event
                if self.qmc.flagstart:
                    self.qmc.EventRecord(extraevent = ee)
            else:
                if eventtype < 4: # absolute values
                    etype = eventtype
                    new_value = cmdvalue
                elif eventtype > 4: # relative values for +/- actions
                    etype = eventtype-5 # the real event type has a offset of 5 in this case
                    p = self.extraeventsactionslastvalue[etype]
                    if p is None:
                        new_value = cmdvalue
                    else:
                        new_value = p + cmdvalue

                # limit value w.r.t. the event slider min/max specification
                new_value = min(aw.eventslidermax[etype],max(aw.eventslidermin[etype],new_value))
                    
                # the new_value is combined with the event factor and offset as specified in the slider definition
                actionvalue = (self.eventsliderfactors[etype] * new_value) + self.eventslideroffsets[etype]
                if self.extraeventsactions[ee] != 14: # only for VOUT Commands we keep the floats
                    actionvalue = int(round(actionvalue))
                if self.extraeventsactions[ee] in [8,9,16,17,18]: # for Hottop Heater/Fan/CoolingFan action we take the event value instead of the event string as cmd action
                    self.eventaction(self.extraeventsactions[ee],u(int(new_value)),parallel=parallel)
                else:
                    cmd = u(self.extraeventsactionstrings[ee])
                    cmd = cmd.format(*(tuple([actionvalue]*cmd.count("{}"))))
                    self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)
                # remember the new value as the last value set for this event
                self.block_quantification_sampling_ticks[etype] = self.sampling_ticks_to_block_quantifiction
                self.extraeventsactionslastvalue[etype] = new_value
                # move corresponding slider to new value:
                self.moveslider(etype,new_value)
                if self.qmc.flagstart:
                    self.qmc.EventRecord(extraevent = ee)
        else:
            # just issue the eventaction (no cmd substitution here)
            cmd = u(self.extraeventsactionstrings[ee])
            cmd = cmd.format(*(tuple([cmdvalue]*cmd.count("{}"))))
            self.eventaction(self.extraeventsactions[ee],cmd,parallel=parallel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resetApplication(self,_=False):
        if app.artisanviewerMode:
            string = QApplication.translate("Message","Do you want to reset all settings?<br> ArtisanViewer has to be restarted!", None)
        else:
            string = QApplication.translate("Message","Do you want to reset all settings?<br> Artisan has to be restarted!", None)
        reply = QMessageBox.warning(aw,QApplication.translate("Message","Factory Reset", None),string,
                            QMessageBox.Cancel | QMessageBox.Reset)
        if reply == QMessageBox.Reset :
            #raise flag. Next time app will open, the settings (bad settings) will not be loaded.
            self.resetqsettings = 1
            self.close()
        elif reply == QMessageBox.Cancel:
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCut_triggered(self,_=False):
        try:
            app.activeWindow().focusWidget().cut()
        except Exception:
            pass

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCopy_triggered(self,_=False):
        try:
            app.activeWindow().focusWidget().copy()
        except Exception:
            pass

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionPaste_triggered(self,_=False):
        try:
            app.activeWindow().focusWidget().paste()
        except Exception:
            pass

    # clears the message line without appending to the message log
    def clearMessageLine(self,style=None):
        self.sendmessage("",append=False,style=style)
        
    # this should only be called from within the main GUI thread (and never from the sampling thread!)
    @pyqtSlot(str,bool,str)
    def sendmessage(self,message,append=True,style=None):
        if isinstance(threading.current_thread(), threading._MainThread):
            # we are running in the main thread thus we can call sendmessage_internal via a QTimer to avoid redraw issues
            QTimer.singleShot(2,lambda : self.sendmessage_internal(message,append,style))
        else:
            # we are not running in the main thread thus we CANNOT call sendmessage_internal via a QTimer
            aw.sendmessageSignal.emit(message,append,style) # we emit a signal to the main thread to resend this message and then process it via the QTimer
            #self.sendmessage_internal(message,append,style,repaint=False)
            # if this is executed via a QTimer we receive "QObject::startTimer: Timers can only be used with threads started with QThread"
        
    def sendmessage_internal(self,message,append=True,style=None,repaint=True):
        try:
            #### lock shared resources #####
            aw.qmc.messagesemaphore.acquire(1)
            if style is not None and style != "":
                aw.messagelabel.setStyleSheet(style)
            else:
                aw.messagelabel.setStyleSheet("background-color:'transparent'; color: " + aw.qmc.palette["messages"] + ";")
            message = aw.arabicReshape(message)
            #keep a max of 100 messages
            if append:
                if len(self.messagehist) > 99:
                    self.messagehist = self.messagehist[1:]
                timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz ")))    #zzz = miliseconds
                self.messagehist.append(timez + message)
            self.messagelabel.setText(message)
            if repaint: # if repaint is executed in the main thread we receive "QWidget::repaint: Recursive repaint detected"
                self.messagelabel.repaint()
        except:
            pass
        finally:
            if aw.qmc.messagesemaphore.available() < 1:
                aw.qmc.messagesemaphore.release(1)

    def hideDefaultButtons(self):
        self.lowerbuttondialog.setVisible(False)

    def showDefaultButtons(self):
        self.lowerbuttondialog.setVisible(True)

    # update the visibility of the extra event buttons based on the users preference for the current state
    def updateExtraButtonsVisibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.extraeventsbuttonsflags[2]
        elif aw.qmc.flagon:
            visible = aw.extraeventsbuttonsflags[1]
        else:
            visible = aw.extraeventsbuttonsflags[0]
        if visible:
            self.showExtraButtons(False)
        else:
            self.hideExtraButtons(False)
        if app.artisanviewerMode:
            self.hideExtraButtons(True)
            
    def hideExtraButtons(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget:
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(False)
        aw.buttonsAction.setChecked(False)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.extraeventsbuttonsflags[2] = 0
            elif aw.qmc.flagon:
                aw.extraeventsbuttonsflags[1] = 0
            else:
                aw.extraeventsbuttonsflags[0] = 0

    def showExtraButtons(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget:
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(True)
        aw.buttonsAction.setChecked(True)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.extraeventsbuttonsflags[2] = 1
            elif aw.qmc.flagon:
                aw.extraeventsbuttonsflags[1] = 1
            else:
                aw.extraeventsbuttonsflags[0] = 1
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleExtraButtons(self,_=False):
        if self.extrabuttondialogs.isVisible():
            self.hideExtraButtons()
        else:
            self.showExtraButtons()
    
    # update the visibility of the sliders based on the users preference for the current state
    def updateSlidersVisibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.eventslidersflags[2]
        elif aw.qmc.flagon:
            visible = aw.eventslidersflags[1]
        else:
            visible = aw.eventslidersflags[0]
        if visible:
            self.showSliders(False)
        else:
            self.hideSliders(False)
        if app.artisanviewerMode:
            self.hideSliders(True)

    def hideSliders(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget:
            focused_widget.clearFocus()
        self.setSliderFocusPolicy(Qt.NoFocus)
        self.slider1.setVisible(False)
        self.slider2.setVisible(False)
        self.slider3.setVisible(False)
        self.slider4.setVisible(False)
        self.sliderSV.setVisible(False)
        self.sliderFrame.setVisible(False)
        aw.slidersAction.setChecked(False)
        # remember state
        if changeDefault:
            if aw.qmc.flagstart:
                aw.eventslidersflags[2] = 0
            elif aw.qmc.flagon:
                aw.eventslidersflags[1] = 0
            else:
                aw.eventslidersflags[0] = 0

    def showSliders(self,changeDefault=True):
        focused_widget = QApplication.focusWidget()
        if focused_widget:
            focused_widget.clearFocus()
        self.sliderFrame.setVisible(True)
        self.slider1.setVisible(True)
        self.slider2.setVisible(True)
        self.slider3.setVisible(True)
        self.slider4.setVisible(True)
        self.sliderSV.setVisible(True)
        self.setSliderFocusPolicy(Qt.StrongFocus)
        aw.slidersAction.setChecked(True)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.eventslidersflags[2] = 1
            elif aw.qmc.flagon:
                aw.eventslidersflags[1] = 1
            else:
                aw.eventslidersflags[0] = 1
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleSliders(self,_=False):
        if self.sliderFrame.isVisible():
            self.hideSliders()
        else:
            self.showSliders()
            
    def hideControls(self):
        self.level1frame.hide()
        aw.controlsAction.setChecked(False)
        
    def showControls(self):
        self.level1frame.show()
        aw.controlsAction.setChecked(True)
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleControls(self,_=False):
        if self.level1frame.isVisible():
            self.hideControls()
        else:
            self.showControls()
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleReadings(self,_=False):
        if self.lcdFrame.isVisible():
            self.hideLCDs()
        else:
            self.showLCDs()

    def updateSlidersProperties(self):
        # update slider properties and event type names
        if bool(aw.eventslidervisibilities[0]):
            aw.sliderGrpBox1.setVisible(True)
            aw.sliderGrpBox1.setTitle(aw.qmc.etypesf(0))
        else:
            aw.sliderGrpBox1.setVisible(False)
            aw.sliderGrpBox1.setTitle(None)
        if bool(aw.eventslidervisibilities[1]):
            aw.sliderGrpBox2.setVisible(True)
            aw.sliderGrpBox2.setTitle(aw.qmc.etypesf(1))
        else:
            aw.sliderGrpBox2.setVisible(False)
            aw.sliderGrpBox2.setTitle(None)
        if bool(aw.eventslidervisibilities[2]):
            aw.sliderGrpBox3.setVisible(True)
            aw.sliderGrpBox3.setTitle(aw.qmc.etypesf(2))
        else:
            aw.sliderGrpBox3.setVisible(False)
            aw.sliderGrpBox3.setTitle(None)
        if bool(aw.eventslidervisibilities[3]):
            aw.sliderGrpBox4.setVisible(True)
            aw.sliderGrpBox4.setTitle(aw.qmc.etypesf(3))
        else:
            aw.sliderGrpBox4.setVisible(False)
            aw.sliderGrpBox4.setTitle(None)

    def hideLCDs(self,changeDefault=True):
        self.lcd1.setVisible(False)
        self.lcdFrame.setVisible(False)
        aw.readingsAction.setChecked(False)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.readingslcdsflags[2] = 0
            elif aw.qmc.flagon:
                aw.readingslcdsflags[1] = 0
            else:
                aw.readingslcdsflags[0] = 0

    def showLCDs(self,changeDefault=True):
        self.lcd1.setVisible(True)
        self.lcdFrame.setVisible(True)
        aw.readingsAction.setChecked(True)
        if changeDefault:
            if aw.qmc.flagstart:
                aw.readingslcdsflags[2] = 1
            elif aw.qmc.flagon:
                aw.readingslcdsflags[1] = 1
            else:
                aw.readingslcdsflags[0] = 1
        
    def updateReadingsLCDsVisibility(self):
        # update visibility (based on the app state)
        if aw.qmc.flagstart:
            visible = aw.readingslcdsflags[2]
        elif aw.qmc.flagon:
            visible = aw.readingslcdsflags[1]
        else:
            visible = aw.readingslcdsflags[0]
        if visible:
            self.showLCDs(False)
        else:
            self.hideLCDs(False)
        if app.artisanviewerMode:
            self.hideLCDs(True)

    def hideEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(False)

    def showEventsMinieditor(self):
        self.EventsGroupLayout.setVisible(True)

    def updateLCDproperties(self):
        # set LCDframe visibilities and labels
        ndev = len(aw.qmc.extradevices)
        for i in range(ndev):
            aw.extraLCDframe1[i].setVisible(bool(aw.extraLCDvisibility1[i]))
            if i < len(aw.qmc.extraname1):
                l1 = "<b>" + aw.qmc.extraname1[i] + "</b>"
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel1[i].setText(l1)
                self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
            aw.extraLCD1[i].setStyleSheet("QLCDNumber { border-radius:4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.extraLCDframe2[i].setVisible(bool(aw.extraLCDvisibility2[i])) 
            if i < len(aw.qmc.extraname2):
                l2 = "<b>" + aw.qmc.extraname2[i] + "</b>"
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel2[i].setText(l2)
                self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
            aw.extraLCD2[i].setStyleSheet("QLCDNumber { border-radius:4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
        #hide the rest (just in case)
        for i in range(ndev,aw.nLCDS):
            aw.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)
        aw.LCD2frame.setVisible((aw.qmc.BTlcd if aw.qmc.swaplcds else aw.qmc.ETlcd))
        aw.LCD3frame.setVisible((aw.qmc.ETlcd if aw.qmc.swaplcds else aw.qmc.BTlcd))
        aw.LCD4frame.setVisible((aw.qmc.DeltaBTlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaETlcdflag))
        aw.LCD5frame.setVisible((aw.qmc.DeltaETlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaBTlcdflag))
        #
        if aw.largeLCDs_dialog is not None:
            aw.largeLCDs_dialog.updateVisiblitiesETBT()
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.updateVisiblitiesDeltaETBT()
        if aw.largePIDLCDs_dialog is not None:
            aw.largePIDLCDs_dialog.updateVisiblitiesPID()
        if aw.largeExtraLCDs_dialog is not None:
            aw.largeExtraLCDs_dialog.updateVisiblitiesExtra()
        if aw.largePhasesLCDs_dialog is not None:
            aw.largePhasesLCDs_dialog.updateVisiblitiesPhases()
        #
        if aw.ser.showFujiLCDs and aw.qmc.device == 0 or aw.qmc.device == 26:         #extra LCDs for Fuji or DTA pid
            aw.LCD6frame.setVisible(True)
            aw.LCD7frame.setVisible(True)
        else:
            aw.LCD6frame.setVisible(False) 
            aw.LCD7frame.setVisible(False)
        if self.qmc.LCDdecimalplaces:
            self.setLCDsDigitCount(5)
        else:
            self.setLCDsDigitCount(3)

    def enableEditMenus(self):
        self.newRoastMenu.setEnabled(True)
        self.fileLoadAction.setEnabled(True) # open
        self.openRecentMenu.setEnabled(True) # open recent
        self.importMenu.setEnabled(True) # import
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        self.fileSaveCopyAsAction.setEnabled(True)
        self.exportMenu.setEnabled(True)
        self.saveGraphMenu.setEnabled(True)
        self.importMenu.setEnabled(True) # roast
        self.htmlAction.setEnabled(True)
        self.reportMenu.setEnabled(True)
        self.productionMenu.setEnabled(True)
        self.rankingMenu.setEnabled(True)
        self.printAction.setEnabled(True)
        self.flavorAction.setEnabled(True)
        self.temperatureMenu.setEnabled(True)
        self.languageMenu.setEnabled(True)
        self.deviceAction.setEnabled(True)
        self.commportAction.setEnabled(True)
        self.designerAction.setEnabled(True)
        self.simulatorAction.setEnabled(True)
        self.wheeleditorAction.setEnabled(True)
        self.hudAction.setEnabled(True)
        self.analyzeMenu.setEnabled(True)
        self.transformAction.setEnabled(True)
        self.loadSettingsAction.setEnabled(True)
        self.openRecentSettingMenu.setEnabled(True)
        self.saveAsSettingsAction.setEnabled(True)
        self.resetAction.setEnabled(True)
        self.switchAction.setEnabled(True)
        self.machineMenu.setEnabled(True)
        self.editGraphAction.setEnabled(True)
        self.backgroundAction.setEnabled(True)
        self.switchETBTAction.setEnabled(True)
        self.eventsAction.setEnabled(True)
        self.phasesGraphAction.setEnabled(True)
        self.StatisticsAction.setEnabled(True)
        self.WindowconfigAction.setEnabled(True)
        self.colorsAction.setEnabled(True)
        self.themeMenu.setEnabled(True)
        if self.qmc.statssummary:
            self.savestatisticsAction.setEnabled(True)
        self.displayonlymenus()

    def disableEditMenus(self,designer=False,wheel=False):
        if designer or wheel:
            self.newRoastMenu.setEnabled(False)
        else:
            self.newRoastMenu.setEnabled(True)
        self.fileLoadAction.setEnabled(False) # open
        self.openRecentMenu.setEnabled(False) # open recent
        self.importMenu.setEnabled(False) # import
        self.fileSaveAction.setEnabled(False)
        self.fileSaveAsAction.setEnabled(False)
        self.fileSaveCopyAsAction.setEnabled(False)
        self.exportMenu.setEnabled(False)
        if not wheel:
            self.saveGraphMenu.setEnabled(False)
        self.htmlAction.setEnabled(False)
        self.reportMenu.setEnabled(False)
        self.productionMenu.setEnabled(False)
        self.rankingMenu.setEnabled(False)
        self.printAction.setEnabled(False)
        self.flavorAction.setEnabled(False)
        self.temperatureMenu.setEnabled(False)
        self.languageMenu.setEnabled(False)
        self.deviceAction.setEnabled(False)
        self.simulatorAction.setEnabled(False)
        self.commportAction.setEnabled(False)
        if not designer:
            self.designerAction.setEnabled(False)
        else:
            self.designerAction.setEnabled(True)
        if not wheel:
            self.wheeleditorAction.setEnabled(False)
        else:
            self.wheeleditorAction.setEnabled(True)
        if designer or wheel:
            self.hudAction.setEnabled(False)
        else:
            self.hudAction.setEnabled(True)
        if wheel:
            self.editGraphAction.setEnabled(False)
            self.backgroundAction.setEnabled(False)
            self.switchETBTAction.setEnabled(False)
            self.eventsAction.setEnabled(False)
            self.phasesGraphAction.setEnabled(False)
            self.StatisticsAction.setEnabled(False)
            self.WindowconfigAction.setEnabled(False)
            self.colorsAction.setEnabled(False)
        self.analyzeMenu.setEnabled(False)
        self.transformAction.setEnabled(False)
        self.loadSettingsAction.setEnabled(False)
        self.openRecentSettingMenu.setEnabled(False)
        self.saveAsSettingsAction.setEnabled(False)
        self.resetAction.setEnabled(False)
        self.switchAction.setEnabled(False)
        self.machineMenu.setEnabled(False)
        self.themeMenu.setEnabled(False)
        self.savestatisticsAction.setEnabled(False)
        self.displayonlymenus()

    def displayonlymenus(self):
        if app.artisanviewerMode:
            self.newRoastMenu.setEnabled(False)
#            self.deviceAction.setEnabled(False)
#            self.commportAction.setEnabled(False)
            self.calibrateDelayAction.setEnabled(False)
            self.oversamplingAction.setEnabled(False)
            self.saveAsSettingsAction.setEnabled(False)
#            self.resetAction.setEnabled(False)
            self.machineMenu.setEnabled(False)
            self.alarmAction.setEnabled(False)
            self.autosaveAction.setEnabled(False)
            self.batchAction.setEnabled(False)
            self.readingsAction.setEnabled(False)
            self.buttonsAction.setChecked(False)
            self.buttonsAction.setEnabled(False)
            self.slidersAction.setChecked(False)
            self.slidersAction.setEnabled(False)
            self.lcdsAction.setEnabled(False)
            self.simulatorAction.setEnabled(False)

        else:
            return

    def update_minieventline_visibility(self):
        if self.minieventsflag:
            self.EventsGroupLayout.setVisible(True)
        else:
            self.EventsGroupLayout.setVisible(False)

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        if not self.processingKeyEvent:
            try:
                self.processingKeyEvent = True
                key = int(event.key())
                modifiers = event.modifiers()
                control_modifier = modifiers == Qt.ControlModifier # command/apple key on macOS
                alt_modifier = modifiers == Qt.AltModifier
                control_alt_modifier = modifiers == (Qt.ControlModifier | Qt.AltModifier)
                #meta_modifier = modifiers == Qt.MetaModifier # Control on macOS, Meta on Windows
                #uncomment next line to find the integer value of a key
                #print(key)
                
                numberkeys = [48,49,50,51,52,53,54,55,56,57] # keycodes for number keys 0,1,...,9
                
                if key == 70: # F SELECTS FULL SCREEN MODE
                    aw.toggleFullscreen()
                elif aw.buttonpalette_shortcuts and control_modifier and key in numberkeys: # palette switch via SHIFT-NUM-Keys
                    self.setbuttonsfrom(numberkeys.index(key))

                elif key == 72:                       #H
                    if not aw.qmc.designerflag:
                        if alt_modifier:
                            aw.deleteBackground()
                            aw.qmc.redraw()
                        else:
                            self.filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Background",None),ext_alt=".alog")
                            if len(u(self.filename)) != 0:
                                try:
                                    aw.qmc.resetlinecountcaches()
                                    aw.loadbackground(u(self.filename))
                                except:
                                    pass
                                aw.qmc.background = True
                                aw.qmc.timealign(redraw=False)
                                aw.qmc.redraw()  
                elif key == 75:                       #K
                    if not aw.qmc.flagon:
                        if control_alt_modifier:
                            aw.clearResults()
                        elif control_modifier:
                            aw.analysisfitCurvesALL()
                elif key == 76:                       #L
                    self.filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Alarms",None),ext="*.alrm")
                    if len(u(self.filename)) == 0:
                        return
                    try:
                        aw.loadAlarms(u(self.filename))
                    except:
                        pass
                elif key == 80:                       #P
                    # switch PID mode
                    if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                        # toggle mode: manual => RS => background
                        if not aw.fujipid.rampsoak and not aw.fujipid.followBackground: # => RS
                            aw.fujipid.setrampsoak(1)
                            aw.fujipid.rampsoak = True # even if activation failed to allow to further toggle arround
                            aw.fujipid.followBackground = False
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Ramp/Soak", None))
                        elif aw.fujipid.rampsoak: # => background
                            aw.fujipid.setrampsoak(0)
                            aw.fujipid.rampsoak = False # even if activation failed to allow to further toggle arround
                            aw.fujipid.followBackground = True
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Background", None))
                        else: # => manual
                            aw.fujipid.setrampsoak(0)
                            aw.fujipid.followBackground = False
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Manual", None))
                    elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware/software PID
                        aw.pidcontrol.svMode = (aw.pidcontrol.svMode+1) %3
                        # 0: manual, 1: Ramp/Soak, 2: Follow (background profile)
                        if aw.pidcontrol.svMode == 0:
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Manual", None))
                        elif  aw.pidcontrol.svMode == 1:
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Ramp/Soak", None))
                        elif  aw.pidcontrol.svMode == 2:
                            aw.sendmessage(QApplication.translate("Message","PID Mode: Background", None))
                elif key == 45:                       #-
                    if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                        aw.fujipid.lookahead = max(0,aw.fujipid.lookahead-1)
                        aw.sendmessage(QApplication.translate("Message","PID Lookahead: {0}", None).format(aw.fujipid.lookahead))
                    elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware PID
                        aw.pidcontrol.svLookahead = max(0,aw.pidcontrol.svLookahead-1)
                        aw.sendmessage(QApplication.translate("Message","PID Lookahead: {0}", None).format(aw.pidcontrol.svLookahead))
                elif key == 43:                       #+
                    if aw.qmc.device == 0 and aw.fujipid and aw.qmc.Controlbuttonflag: # FUJI PID
                        aw.fujipid.lookahead = aw.fujipid.lookahead+1
                        aw.sendmessage(QApplication.translate("Message","PID Lookahead: {0}", None).format(aw.fujipid.lookahead))
                    elif (aw.pidcontrol and aw.qmc.Controlbuttonflag): # MODBUS hardware PID
                        aw.pidcontrol.svLookahead = aw.pidcontrol.svLookahead+1
                        aw.sendmessage(QApplication.translate("Message","PID Lookahead: {0}", None).format(aw.pidcontrol.svLookahead))
                elif key == 32:                       #SELECTS ACTIVE BUTTON
                    self.moveKbutton("space")
                elif key == 16777220:                 #TURN ON/OFF KEYBOARD MOVES
                    self.releaseminieditor()
                    self.moveKbutton("enter")
                elif key == 16777216:                 #ESCAPE
                    self.quickEventShortCut = None
                    aw.clearMessageLine()
                    macfullscreen = False
                    try:
                        if platf == 'Darwin' and app.allWindows()[0].visibility() == QWindow.FullScreen:
                            macfullscreen = True
                    except:
                        pass
                    if self.full_screen_mode_active or self.isFullScreen() or macfullscreen:
                        self.full_screen_mode_active = False
                        if platf != 'Darwin':
                            aw.fullscreenAction.setChecked(False)
                        self.showNormal()
                        try:
                            if macfullscreen and platf == 'Darwin':
                                app.allWindows()[0].setVisibility(QWindow.Windowed)
                        except:
                            pass
                    else:
                        #if designer ON
                        if self.qmc.designerflag:
                            string = QApplication.translate("Message","Exit Designer?", None)
                            reply = QMessageBox.question(aw,QApplication.translate("Message", "Designer Mode ON",None),string,QMessageBox.Yes|QMessageBox.Cancel)
                            if reply == QMessageBox.Yes:
                                self.stopdesigner()
                            else:
                                return
                        #if wheel graph ON
                        elif self.qmc.wheelflag:
                            self.qmc.wheelflag = False
                            self.wheeleditorAction.setChecked(self.qmc.wheelflag)
                            self.qmc.exitviewmode()
                            aw.enableEditMenus()
                            aw.showControls()
                        if self.minieventsflag:
                            self.releaseminieditor()
                elif key == 16777234:               #MOVES CURRENT BUTTON LEFT
                    if self.keyboardmoveflag:
                        self.moveKbutton("left")
                    elif aw.qmc.background:
                        aw.qmc.movebackground("left",aw.qmc.backgroundmovespeed)
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif key == 16777236:               #MOVES CURRENT BUTTON RIGHT
                    if self.keyboardmoveflag:
                        self.moveKbutton("right")
                    elif aw.qmc.background:
                        aw.qmc.movebackground("right",aw.qmc.backgroundmovespeed)
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif key == 16777235:               #UP
                    if aw.qmc.background:
                        aw.qmc.movebackground("up",aw.qmc.backgroundmovespeed)
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif key == 16777237:               #DOWN
                    if aw.qmc.background:
                        aw.qmc.movebackground("down",aw.qmc.backgroundmovespeed)
                        aw.qmc.redraw(recomputeAllDeltas=True,sampling=aw.qmc.flagon)
                elif key == 65:                     #letter A (automatic save)
                    if not app.artisanviewerMode and self.qmc.flagon:
                        self.automaticsave()
                elif key == 68:                     #letter D (toggle xy between temp and RoR scale)
                    self.qmc.fmt_data_RoR = not (self.qmc.fmt_data_RoR)
                    # force redraw crosslines if active
                    if aw.qmc.crossmarker:
                        try:
                            aw.ntb.mouse_move(mplLocationevent.lastevent)
                        except:
                            pass
                elif key == 67:                     #letter C (controls)
                    self.toggleControls()
                elif key == 88:                     #letter X (readings)
                    if not app.artisanviewerMode:
                        self.toggleReadings()
                elif key == 83:                     #letter S (sliders)
                    if not app.artisanviewerMode:
                        self.toggleSliders()
                elif key == 84 and not self.qmc.flagon:  #letter T (mouse cross)
                    self.qmc.togglecrosslines()
                elif key == 81:  #letter q (quick entry of custom event 1)
                    self.quickEventShortCut = (0,"")
                    aw.sendmessage("%s"%aw.qmc.etypes[0])
                elif key == 87:  #letter w (quick entry of custom event 2)
                    self.quickEventShortCut = (1,"")
                    aw.sendmessage("%s"%aw.qmc.etypes[1])
                elif key == 69:  #letter e (quick entry of custom event 3)
                    self.quickEventShortCut = (2,"")
                    aw.sendmessage("%s"%aw.qmc.etypes[2])
                elif key == 82:  #letter r (quick entry of custom event 4)
                    self.quickEventShortCut = (3,"")
                    aw.sendmessage("%s"%aw.qmc.etypes[3])
                elif key == 86: #letter v (Set SV)
                    self.quickEventShortCut = (4,"")
                    aw.sendmessage("SV")
                elif key == 66:  #letter b hides/shows extra rows of event buttons
                    if not app.artisanviewerMode:
                        self.toggleextraeventrows()
                elif key == 77:  #letter m hides/shows standard buttons row
                    if aw.qmc.flagstart:
                        self.standardButtonsVisibility()
                #Extra event buttons palette. Numerical keys [0,1,2,3,4,5,6,7,8,9]
                elif key > 47 and key < 58:
                    if not app.artisanviewerMode:
                        button = [48,49,50,51,52,53,54,55,56,57] 
                        if self.quickEventShortCut:
                            # quick custom event entry
                            eventNr = self.quickEventShortCut[0]
                            eventValueStr = self.quickEventShortCut[1] + str(button.index(key))
                            if eventNr == 4:
                                aw.sendmessage("SV %s"%(eventValueStr))
                            else:
                                aw.sendmessage("%s %s"%(aw.qmc.etypes[eventNr],eventValueStr))
                            if eventNr == 4: # SV
                                if len(eventValueStr) == 3:
                                    # three digits entered, set the SV
                                    self.quickEventShortCut = None
                                    value = int(eventValueStr)
                                    aw.clearMessageLine()
                                    self.SVslidermoved = 1
                                    self.updateSVSliderLCD(value)
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr,eventValueStr)
                            else:
                                if len(eventValueStr) == 2:
                                    # both digits entered, create the event
                                    self.quickEventShortCut = None
                                    value = max(aw.eventslidermin[eventNr],min(aw.eventslidermax[eventNr],int(eventValueStr)))
                                    aw.moveslider(eventNr,value)
                                    aw.recordsliderevent(eventNr)
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr,eventValueStr)
# now shift modifier is required to switch palettes via number keys
#                       else:
#                            if aw.buttonpalette_shortcuts:
#                               self.setbuttonsfrom(button.index(key))
                elif key == 58 and not aw.qmc.flagon: # screenshots only if not sampling!
                    self.desktopscreenshot()
                elif key == 59 and not aw.qmc.flagon: # screenshots only if not sampling!
                    self.applicationscreenshot()
                else:
                    QWidget.keyPressEvent(self, event)
            except:
                pass
            finally:
                self.processingKeyEvent = False

    def releaseminieditor(self):
        if self.minieventsflag:
            self.lineEvent.releaseKeyboard()
            self.valueEdit.releaseKeyboard()
            self.etimeline.releaseKeyboard()
            self.etypeComboBox.releaseKeyboard()
            self.eNumberSpinBox.releaseKeyboard()
            self.lineEvent.clearFocus()
            self.valueEdit.clearFocus()
            self.etimeline.clearFocus()
            self.etypeComboBox.clearFocus()
            self.eNumberSpinBox.clearFocus()

    # this function respects the button visibility via aw.qmc.buttonvisibility and if button.isDisabled()
    # ON/OFF (2,self.button_1) -> CHARGE (3,self.button_8) -> DRYEND (4,self.button_19) -> FCs (5,self.button_3)
    # -> FCe (6,self.button_4) -> SCs (7,self.button_5) -> SCe (8,self.button_6) -> DROP (9,self.button_9) 
    # -> COOLend (10,self.button_20) -> EVENT (11,self.button_11) -> HUD (1,self.button_18) -> ON/OFF
    # currentButtonIndex is from [1-11]
    # buttons that trigger events and can be triggered only once
    def nextActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 11 and aw.qmc.HUDbuttonflag: # current: EVENT
            # the current button index is the event button, we move to the HUD button
            return 1 # next: HUD
        elif currentButtonIndex == 1 or (currentButtonIndex == 11 and not aw.qmc.HUDbuttonflag): # current: HUD
            return 2 # next: ON/OFF
        elif currentButtonIndex == 10: # current: COOL
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # next: EVENT
            else:
                if aw.qmc.HUDbuttonflag:
                    return 1 # next: HUD
                else:
                    return 2 # next: ON/OFF
        else:
            # we check if the next button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 2] and self.keyboardButtonList[currentButtonIndex + 1].isEnabled():
                return currentButtonIndex + 1
            else:
                return self.nextActiveButton(currentButtonIndex + 1)

    def previousActiveButton(self,currentButtonIndex):
        if currentButtonIndex == 2 and aw.qmc.HUDbuttonflag: # current: ON/OFF
            # the current button index is the ON/OFF button, we move to the HUD button (if visible)
            return 1
        elif currentButtonIndex == 2 and not aw.qmc.HUDbuttonflag:
            return self.previousActiveButton(1)
        elif currentButtonIndex == 1 or (currentButtonIndex == 2 and not aw.qmc.HUDbuttonflag): # current: HUD
            # check if the EVENT button is active, else move to the HUD
            if aw.eventsbuttonflag:
                return 11 # move to EVENT
            else:
                return self.previousActiveButton(11) # move to prev(EVENT)
        elif currentButtonIndex == 3: # current: CHARGE
            return 2 # next: ON/OFF
        else:
            # we check if the previous button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
            # there is an offset of 3
            if aw.qmc.buttonvisibility[currentButtonIndex - 4] and self.keyboardButtonList[currentButtonIndex - 1].isEnabled():
                return currentButtonIndex - 1
            else:
                return self.previousActiveButton(currentButtonIndex - 1)

    def resetKeyboardButtonMarks(self):
        if self.qmc.flagon:
            if self.simulator:
                self.button_1.setStyleSheet(self.pushbuttonstyles_simulator["ON"])
            else:
                self.button_1.setStyleSheet(self.pushbuttonstyles["ON"])
        else:
            if self.simulator:
                self.button_1.setStyleSheet(self.pushbuttonstyles_simulator["OFF"])
            else:
                self.button_1.setStyleSheet(self.pushbuttonstyles["OFF"])
        self.button_8.setStyleSheet(self.pushbuttonstyles["CHARGE"])
        self.button_19.setStyleSheet(self.pushbuttonstyles["DRY END"])
        self.button_20.setStyleSheet(self.pushbuttonstyles["COOL END"])
        self.button_3.setStyleSheet(self.pushbuttonstyles["FC START"])
        self.button_4.setStyleSheet(self.pushbuttonstyles["FC END"])
        self.button_5.setStyleSheet(self.pushbuttonstyles["SC START"])
        self.button_6.setStyleSheet(self.pushbuttonstyles["SC END"])
        self.button_9.setStyleSheet(self.pushbuttonstyles["DROP"])
        self.button_11.setStyleSheet(self.pushbuttonstyles["EVENT"])
        if self.qmc.flagstart:
            if self.qmc.HUDflag:
                self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
            else:
                self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
        else:
            pass

    def ignoreFlatButtons(self,moveindex):
        if self.keyboardButtonList[moveindex].isFlat() or not aw.qmc.buttonvisibility[moveindex - 3]:
            # we search forward for the next non-flat button
            if moveindex < 10:
                m = moveindex + 1
                # we jump over invisible buttons
                while m < 10 and (not aw.qmc.buttonvisibility[m - 3] or self.keyboardButtonList[m].isFlat()):
                    m = m + 1
                return m
            else:
                return moveindex
        else:
            return moveindex
    
    # on manual 
    def onMarkMoveToNext(self,button):
        if aw.keyboardmoveflag: # keyboard navigation is active
            try:
                this_index = aw.keyboardButtonList.index(button)
                if aw.keyboardmoveindex < this_index:
                    for _ in range(this_index - aw.keyboardmoveindex):
                        aw.moveKbutton("right")
                        if aw.keyboardmoveindex == this_index:
                            break
                    aw.moveKbutton("right") # now to the next
            except:
                pass
            
    def moveKbutton(self,kcommand):
        #"Enter" toggles ON/OFF keyboard    
        if kcommand =="enter" and self.qmc.flagstart:
            if self.keyboardmoveflag == 0:
                #turn on
                self.keyboardmoveflag = 1
                # deactivate slider keyboard control
                self.setSliderFocusPolicy(Qt.NoFocus)
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned ON", None))
                self.keyboardmoveindex = self.ignoreFlatButtons(self.keyboardmoveindex) - 1
            elif self.keyboardmoveflag == 1:
                # turn off 
                self.keyboardmoveflag = 0
                # activate slider keyboard control
                self.setSliderFocusPolicy(Qt.StrongFocus)
                # clear all
                self.sendmessage(QApplication.translate("Message","Keyboard moves turned OFF", None))
                self.resetKeyboardButtonMarks()
        #if moves on
        if self.keyboardmoveflag:
            if kcommand == "space":
                now = libtime.perf_counter()
                if self.lastkeyboardcmd == 0 or (now > self.lastkeyboardcmd + 2): # accept SPACE keyboard cmds only every 2sec.
                    self.keyboardmove[self.keyboardmoveindex]()   #apply button command
                    #behaviour rules after pressing a button
                    #if less than EVENT jump forward to the right once automatically
                    if self.keyboardmoveindex > 1 and self.keyboardmoveindex < 11:
                        self.moveKbutton("right")
                    self.lastkeyboardcmd = now
                    self.releaseminieditor()
                else: # we ignore this event
                    return
            else:
                if kcommand == "left":
                    nextcmd = self.previousActiveButton(self.keyboardmoveindex)
                else:
                    nextcmd = self.nextActiveButton(self.keyboardmoveindex)
                # activate the button at index nextcmd
                if self.keyboardButtonStyles[nextcmd] in ["CHARGE","DROP"]:
                    self.keyboardButtonList[nextcmd].setStyleSheet(self.pushbuttonstyles["SELECTED_MAIN"])
                if self.keyboardButtonStyles[nextcmd] in ["ON"]:
                    self.keyboardButtonList[nextcmd].setStyleSheet(self.pushbuttonstyles["SELECTED_MAIN_LARGE"])
                else:
                    self.keyboardButtonList[nextcmd].setStyleSheet(self.pushbuttonstyles["SELECTED"])
                # deactivate the button at index self.keyboardmoveindex
                if self.keyboardmoveindex == 1: # we make an exception to respect the state of the HUD button
                    if self.qmc.HUDflag:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_ON"])
                    else:
                        self.button_18.setStyleSheet(self.pushbuttonstyles["HUD_OFF"])
                else:
                    self.keyboardButtonList[self.keyboardmoveindex].setStyleSheet(self.pushbuttonstyles[self.keyboardButtonStyles[self.keyboardmoveindex]])
                # update self.keyboardmoveindex
                self.keyboardmoveindex = nextcmd
        # we enable keyboard event processing again

    #sound feedback when pressing a push button
    def soundpop(self):
        if self.soundflag:
            QApplication.beep()

    def removeDisallowedFilenameChars(self,filename):
        validFilenameChars = "-_.() %s%s" % (libstring.ascii_letters, libstring.digits)
        cleanedFilename = s2a(unicodedata.normalize('NFKD', filename))
        return ''.join(c for c in d(cleanedFilename) if c in validFilenameChars)
    
    
    def generateFilename(self,prefix="",previewmode=0):
        filename = ""
        try:
            if prefix == "":
                title = None
                if  aw.qmc.title != "" and aw.qmc.title != QApplication.translate("Scope Title", "Roaster Scope",None):
                    title = aw.qmc.title
                if prefix == "" and title:
                    filename = title
                else:
                    filename = prefix
                if filename != "":                
                    filename += "_" + str(aw.qmc.roastdate.toString(u("yy-MM-dd_hhmm")))
                else:
                    filename += str(aw.qmc.roastdate.toString(u("yy-MM-dd_hhmm")))
            else:
                filename = self.parseAutosaveprefix(prefix,previewmode=previewmode)
            filename += ".alog"
            #clean name
            filename = self.removeDisallowedFilenameChars(u(filename))
            filename = filename.strip()
        except Exception:
            pass
        return filename

    #replace fields delimited as %field% with the corresponding value
    #previewmode 0=not preview, 1=preview for while recording, 2=preview for while not recording
    def parseAutosaveprefix(self,fn,previewmode=0):
        try:
            #it is text only when there are no disallowed characters, so add the date for backward compatibility and return.
            if fn == self.removeDisallowedFilenameChars(u(fn)):
                fn += '_' + u(self.qmc.roastdate.toString(u("yy-MM-dd_hhmm")))
                return fn

            #single, leading delimiter for the fields
            self.fieldDelim = '~'  #note this value is hard coded in autosavefieldsHelpDlg(). 
            #delimiter for ON only
            onDelim = "'"
            #delimiter for OFF only
            offDelim = '"'

            #newlines can sneak in from cut and paste from help page 
            fn = fn.replace('\n', '')  

            #if flagon then the batchcounter has not yet been incremented so we do that here
            if (self.qmc.flagon or previewmode==1) and self.qmc.batchcounter != -1:
                bnr = self.qmc.batchcounter + 1
            else:
                bnr = self.qmc.roastbatchnr

            #grab the first line of the beens field
            firstline = re.match(r'([^\n]*)',self.qmc.beans)
            if firstline:
                beansline = firstline.group(0)
            else:
                beansline = ""

            #note: since fields are delimited only at the start, to avoid ambiguity requires the shortest field string to be last in the list.  Example, "date_time" must come before "date" in the list.
            fields = [
                (QApplication.translate("AutosaveField", "batch_long",None), u(self.qmc.roastbatchprefix) + u(bnr) + ' (' + u(self.qmc.roastbatchpos) + ')'),
                (QApplication.translate("AutosaveField", "batchprefix",None),u(self.qmc.roastbatchprefix)),
                (QApplication.translate("AutosaveField", "batchcounter",None),u(bnr) if bnr!='' else '**'),
                (QApplication.translate("AutosaveField", "batchposition",None),u(self.qmc.roastbatchpos)),
                (QApplication.translate("AutosaveField", "batch",None), u(self.qmc.roastbatchprefix) + u(bnr)),
                (QApplication.translate("AutosaveField", "title",None),self.qmc.title),
                (QApplication.translate("AutosaveField", "datetime_long",None),u(self.qmc.roastdate.toString(u("yyyy-MM-dd_hhmm")))),
                (QApplication.translate("AutosaveField", "datetime",None),u(self.qmc.roastdate.toString(u("yy-MM-dd_hhmm")))),
                (QApplication.translate("AutosaveField", "date_long",None),u(self.qmc.roastdate.toString(u("yyyy-MM-dd")))),
                (QApplication.translate("AutosaveField", "date",None),u(self.qmc.roastdate.toString(u("yy-MM-dd")))),
                (QApplication.translate("AutosaveField", "time",None),u(self.qmc.roastdate.toString(u("hhmm")))),
                (QApplication.translate("AutosaveField", "operator",None),u(self.qmc.operator)),
                (QApplication.translate("AutosaveField", "machine",None),u(self.qmc.roastertype)),
                (QApplication.translate("AutosaveField", "drumspeed",None),u(self.qmc.drumspeed)),
                (QApplication.translate("AutosaveField", "weightunits",None),u(self.qmc.weight[2])),
                (QApplication.translate("AutosaveField", "weight",None),u(self.qmc.weight[0])),
                (QApplication.translate("AutosaveField", "volumeunits",None),u(self.qmc.volume[2])),
                (QApplication.translate("AutosaveField", "volume",None),u(self.qmc.volume[0])),
                (QApplication.translate("AutosaveField", "densityunits",None),u(self.qmc.density[1]) + '_' + u(self.qmc.density[3])),
                (QApplication.translate("AutosaveField", "density",None),u(self.qmc.density[0])),
                (QApplication.translate("AutosaveField", "moistureunits",None),QApplication.translate("AutosaveField","pct",None)),
                (QApplication.translate("AutosaveField", "moisture",None),u(self.qmc.moisture_greens)),
                (QApplication.translate("AutosaveField", "beans_line",None),u(beansline)),
                (QApplication.translate("AutosaveField", "beans",None),u(beansline[:30])),
                ]

            #text between single quotes ' will show only when recording or for preview recording
            fn = re.sub(fr"{onDelim}([^{onDelim}]+){onDelim}",r"\1",fn) if (previewmode==1 or (previewmode==0 and self.qmc.flagon)) else re.sub(fr"{onDelim}([^{onDelim}]+){onDelim}",r"",fn)
            #text between double quotes " will show only when flagon is False
            fn = re.sub(fr'{offDelim}([^{offDelim}]+){offDelim}',r'\1',fn) if (previewmode==2 or (previewmode==0 and not self.qmc.flagon))  else re.sub(fr'{offDelim}([^{offDelim}]+){offDelim}',r'',fn)
            #replace the fields with content
            for i in range(len(fields)):
                fn = fn.replace(self.fieldDelim + fields[i][0], u(fields[i][1]))

            #cleaning is performed in generateFilename()
            #fn = self.removeDisallowedFilenameChars(u(fn))
            #fn = fn.strip()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Error:",None) + " parseAutosaveprefix() {0}").format(str(e)),exc_tb.tb_lineno)
        return fn
        
    #automatation of filename when saving a file through keyboard shortcut. Speeds things up for batch roasting.
    def automaticsave(self,interactive=True):
        try:
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                prefix = ""
                if self.qmc.autosaveprefix != "":
                    prefix = self.qmc.autosaveprefix
                elif aw.qmc.batchcounter > -1 and aw.qmc.roastbatchnr > 0:
                    prefix += u(aw.qmc.batchprefix) + u(aw.qmc.roastbatchnr)
                filename = self.generateFilename(prefix=prefix)
                filename_path = os.path.join(self.qmc.autosavepath,filename)
                oldDir = u(QDir.current())
                res = QDir.setCurrent(self.qmc.autosavepath)
                if res:
                    #write
                    self.serialize(filename_path,self.getProfile())
                    self.sendmessage(QApplication.translate("Message","Profile {0} saved in: {1}", None).format(filename,self.qmc.autosavepath))
                    self.setCurrentFile(filename,False) # we do not add autosaved files any longer to the recent file menu
                    self.qmc.fileClean()
                    
                    if self.qmc.autosavealsopath != "":
                        other_filename_path = os.path.join(self.qmc.autosavealsopath,filename)
                    else:
                        other_filename_path = os.path.join(self.qmc.autosavepath,filename)
                    
                    if self.qmc.autosaveimage and not aw.qmc.flagon:
                        if other_filename_path.endswith(".alog"):
                            other_filename_path = other_filename_path[0:-5]
                        if self.qmc.autosaveimageformat == "PDF":
                            self.saveVectorGraph(extension=".pdf",fname=other_filename_path) 
                        elif self.qmc.autosaveimageformat == "SVG":
                            self.saveVectorGraph(extension=".svg",fname=other_filename_path)
                        elif self.qmc.autosaveimageformat == "CSV":
                            self.exportCSV(other_filename_path + ".csv")
                        elif self.qmc.autosaveimageformat == "JSON":
                            self.exportJSON(other_filename_path + ".json")
                        else:
                            self.resizeImg(0,1,self.qmc.autosaveimageformat,fname=other_filename_path)
                    #restore dirs
                    QDir.setCurrent(oldDir)
                    
                    return filename
                else:
                    self.sendmessage(QApplication.translate("Message","Autosave path does not exist. Autosave failed.", None))
            elif interactive:
                self.sendmessage(QApplication.translate("Message","Empty path or box unchecked in Autosave", None))
                self.autosaveconf()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Error:",None) + " automaticsave() {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewKshortcuts(self,_=False):
        string = u(QApplication.translate("Message", "<table><tr><td align='right'><b>[ENTER]</b></td><td>Turns ON/OFF Keyboard Shortcuts</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[SPACE]</b></td><td>Choses current button</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[LEFT,RIGHT,UP,DOWN]</b></td><td>Move background or key focus</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[a]</b></td><td>Autosave</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[CRTL N]</b></td><td>Autosave + Reset + START</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[t]</b></td><td>Toggle mouse cross lines</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[d]</b></td><td>Toggle xy scale (T/Delta)</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[c]</b></td><td>Shows/Hides Controls</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[x]</b></td><td>Shows/Hides LCD Readings</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[m]</b></td><td>Shows/Hides Event Buttons</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[b]</b></td><td>Shows/Hides Extra Event Buttons</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[s]</b></td><td>Shows/Hides Event Sliders</td></tr>",None))
#        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[i]</b></td><td>Retrieve Weight In from Scale</td></tr>",None))
#        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[o]</b></td><td>Retrieve Weight Out from Scale</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[p]</b></td><td>Toggle PID mode</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[h]</b></td><td>Load background profile</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[ALT h]</b></td><td>Remove background profile</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[l]</b></td><td>Load alarms</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[+,-]</b></td><td>Inc/dec PID lookahead</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[CRTL 0-9]</b></td><td>Changes Event Button Palettes</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[;]</b></td><td>Application ScreenShot</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[:]</b></td><td>Desktop ScreenShot</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[q,w,e,r + <i>nn</i>]</b></td><td>Quick Custom Event</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[v + <i>nnn</i>]</b></td><td>Quick PID SV</td></tr>",None))
        string += u(QApplication.translate("Message", "<tr><td align='right'><b>[f]</b></td><td>Full Screen Mode</td></tr></table>",None))

        msgbox = QMessageBox(self)
        msgbox.setWindowTitle(QApplication.translate("Message", "Keyboard Shortcuts",None))
        msgbox.setInformativeText(string)
        msgbox.show()
        
    #moves events in minieditor
    @pyqtSlot(int)
    def changeEventNumber(self,_=0):
        if self.qmc.designerflag:
            return
        #check
        lenevents = len(self.qmc.specialevents)
        currentevent = self.eNumberSpinBox.value()
        self.eNumberSpinBox.setDisabled(True)
        try:
            self.eventlabel.setText(QApplication.translate("Label", "Event #<b>{0} </b>",None).format(currentevent))
            if currentevent == 0:
                self.lineEvent.setText("")
                self.valueEdit.setText("")
                self.etypeComboBox.setCurrentIndex(0)
                self.etimeline.setText("")
                self.qmc.resetlines()
                if not aw.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
                return
            if currentevent > lenevents:
                self.eNumberSpinBox.setValue(lenevents)
                return
            else:
                self.lineEvent.setText(self.qmc.specialeventsStrings[currentevent-1])
                if aw.qmc.timeindex[0] > -1:
                    timez = self.qmc.stringfromseconds(int(self.qmc.timex[self.qmc.specialevents[currentevent-1]]-self.qmc.timex[self.qmc.timeindex[0]]))
                    self.etimeline.setText(timez)
                self.valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[currentevent-1]))
                self.etypeComboBox.setCurrentIndex(self.qmc.specialeventstype[currentevent-1])
                #plot little dot lines
                self.qmc.resetlines() #clear old
                etimeindex = self.qmc.specialevents[currentevent-1]
                if currentevent:
                    x = [self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex],self.qmc.timex[etimeindex]]
                    y = [(self.qmc.ylimit_min-100),self.qmc.temp2[etimeindex],self.qmc.temp1[etimeindex],(self.qmc.ylimit+100)]
                    self.qmc.ax.plot(x,y,marker ="o",markersize=12,color ="yellow",linestyle="-",linewidth = 7,alpha=.4)
                    if not aw.qmc.flagstart:
                        self.qmc.fig.canvas.draw()
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " changeEventNumber() {0}").format(str(e)),exc_tb.tb_lineno)        
        finally:
            self.eNumberSpinBox.setDisabled(False)
            self.eNumberSpinBox.setFocus()


    #updates events from mini edtitor
    @pyqtSlot(bool)
    def miniEventRecord(self,_):
        lenevents = self.eNumberSpinBox.value()
        if lenevents:
            self.qmc.specialeventstype[lenevents-1] = self.etypeComboBox.currentIndex()
            self.qmc.specialeventsvalue[lenevents-1] = aw.qmc.str2eventsvalue(str(self.valueEdit.text()))
            self.qmc.specialeventsStrings[lenevents-1] = u(self.lineEvent.text())
            if aw.qmc.timeindex[0] > -1:
                newtime = self.qmc.time2index(self.qmc.timex[self.qmc.timeindex[0]]+ self.qmc.stringtoseconds(str(self.etimeline.text())))
                self.qmc.specialevents[lenevents-1] = newtime

            self.lineEvent.clearFocus()
            self.eNumberSpinBox.clearFocus()
            self.etimeline.clearFocus()

            self.qmc.redraw(recomputeAllDeltas=False)

            #plot highest ET or BT (sometimes only BT is plot (et is zero))
            etimeindex = self.qmc.specialevents[lenevents-1]
            if self.qmc.temp1[etimeindex] > self.qmc.temp2[etimeindex]:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp1[etimeindex], "o", color = self.qmc.palette["et"])
            else:
                self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp2[etimeindex], "o", color = self.qmc.palette["bt"])
            
            if not aw.qmc.flagstart:
                self.qmc.fig.canvas.draw()

            string = ""
            if len(self.qmc.specialeventsStrings[lenevents-1]) > 5:
                string += self.qmc.specialeventsStrings[lenevents-1][0:5]
                string += "..."

            message = u(QApplication.translate("Message","Event #{0}:  {1} has been updated", None).format(str(lenevents),string))
            self.sendmessage(message)

    def strippedName(self, fullFileName):
        return u(QFileInfo(fullFileName).fileName())

    def strippedDir(self, fullFileName):
        return u(QFileInfo(fullFileName).dir().dirName())

    def setCurrentFile(self, fileName,addToRecent=True):
        self.curFile = fileName
        if self.curFile:
            self.setWindowTitle(("%s - " + self.windowTitle) % self.strippedName(self.curFile))
            if addToRecent:
                settings = QSettings()
                files = toStringList(settings.value('recentFileList'))
                try:
                    removeAll(files,fileName)
                except ValueError:
                    pass
                files.insert(0, fileName)
                del files[self.MaxRecentFiles:]
                settings.setValue('recentFileList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentFileActions()
        else:
            self.setWindowTitle(self.windowTitle)
 
    def updateRecentFileActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentFileList'))
        strippedNames = list(map(self.strippedName,files))
        numRecentFiles = min(len(files), self.MaxRecentFiles)
 
        for i in range(numRecentFiles):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = "&%s (%s)" % (strippedName, self.strippedDir(files[i]))
            else:
                text = "&%s" % strippedName
            self.recentFileActs[i].setText(text)
            self.recentFileActs[i].setData(files[i])
            self.recentFileActs[i].setVisible(True)
 
        for j in range(numRecentFiles, self.MaxRecentFiles):
            self.recentFileActs[j].setVisible(False)
 
    def openRecentFile(self):
        action = self.sender()
        if action:
            self.loadFile(toString(action.data()))

    def getDefaultPath(self):
        #compare profilepath with userprofilepath (modulo the last two segments which are month/year respectively)
        return self.userprofilepath

    def setDefaultPath(self,f):
        if f:
            filepath_dir = QDir()
            filepath_dir.setPath(f)
            filepath_elements = filepath_dir.absolutePath().split("/")[:-1] # directories as QStrings (without the filename)
            self.userprofilepath = u(freduce(lambda x,y: x + '/' + y, filepath_elements) + "/")

    def ArtisanOpenFilesDialog(self,msg=QApplication.translate("Message","Select",None),ext="*",path=None):
        if path is None:   
            path = self.getDefaultPath()
        res = QFileDialog.getOpenFileNames(self,msg,path,ext)[0]
        for f in res:
            self.setDefaultPath(u(f))
        return res
                
    #the central OpenFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    # if ext is given, the file selector allows only file with that extension to be selected for open
    # if ext_alt is given (not None), all files can be selected, but if a file was selected not having the ext_alt the empty string is returned (used in the background profile dialog)
    def ArtisanOpenFileDialog(self,msg=QApplication.translate("Message","Open",None),ext="*",ext_alt=None,path=None):
        if path is None:
            path = self.getDefaultPath()
        res = u(QFileDialog.getOpenFileName(self,caption=msg,directory=path,filter=ext)[0])
        f = u(res)
        if ext_alt is not None and not f.endswith(ext_alt):
            return ""
        else:
            self.setDefaultPath(f)
            return f
 
    #the central SaveFileDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanSaveFileDialog(self,msg=QApplication.translate("Message","Save",None),ext="*.alog",path=None):
        if path is None:
            path = self.getDefaultPath()
        f = u(QFileDialog.getSaveFileName(self,msg,path,ext)[0])
        self.setDefaultPath(f)
        return f
 
    #the central ExistingDirectoryDialog function that should always be called. Besides triggering the file dialog it
    #reads and sets the actual directory
    def ArtisanExistingDirectoryDialog(self,msg=QApplication.translate("Message","Select Directory",None),path=None,copy=False):
        if path is None:
            path = self.getDefaultPath()
        f = u(QFileDialog.getExistingDirectory(self,msg,path))
        if not copy:
            self.setDefaultPath(f)
        return f

    @pyqtSlot()
    @pyqtSlot(bool)
    def newRoast(self,_=False):
        #####################################
        #IF there is an ongoing roast (if START):
        #   (this block allows batch processing using the autosave feature)
        #   if no CHARGE found:
        #       return
        #   if no DROP found:
        #       #use last data point as DROP (mark DROP)
        #       return
        #   stop recording
        #   if there is an autosave path (from autosafe config) AND the autosave flag is ON:
        #       create filename using the autosavepath and date+time
        #   else:
        #       start autosave Dialog to set the name path
        #       return (nothing saved. Cancell New)
        #   reset  (delete everything)
        #   start new roast (START)
        #ELSE (if recording is stoped - OFF):
        #   if no profile present (no data present or profile loaded):
        #       start new roast (START)
        #   else:
        #       reset (reset offers three options: Save,Continue,Cancell)
        #       START
        #########################################
        
        # turn keepOn temporary off
        tmpKeepON = self.qmc.flagKeepON
        self.qmc.flagKeepON = False
        
        if self.qmc.flagstart:
            if self.qmc.timeindex[0] == -1:
                self.sendmessage(QApplication.translate("Message","NEW ROAST canceled: incomplete profile lacking CHARGE and DROP found", None))
                return False
            #mark drop if not yet done
            if self.qmc.timeindex[6] == 0:
#                self.qmc.markDrop()
                self.sendmessage(QApplication.translate("Message","NEW ROAST canceled: incomplete profile lacking DROP found", None))
                return False
            #invoke "OFF"
            self.qmc.OffMonitor()

            filename = self.automaticsave(interactive=False)
# the call to automaticsave() moved to OffRecorder() which is triggered by the above OffMonitor
            if self.qmc.reset():
                #start new roast
                self.qmc.ToggleRecorder()
                self.sendmessage(QApplication.translate("Message","{0} has been saved. New roast has started", None).format(filename))
        else:
            if len(self.qmc.timex) > 1:
                self.qmc.ToggleRecorder()
            else:
                if self.qmc.flagon:
                    self.qmc.OffMonitor()
                if self.qmc.reset():
                    self.qmc.ToggleRecorder()
        self.qmc.flagKeepON = tmpKeepON
        return True
    
    @pyqtSlot() 
    @pyqtSlot(bool)
    def fileLoad(self,_=False):
        try:
            fileName = self.ArtisanOpenFileDialog(ext="*.alog")
            if fileName:
                self.loadFile(fileName)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " fileLoad() {0}").format(str(ex)),exc_tb.tb_lineno)

    #loads stored profiles. Called from file menu
    def loadFile(self,filename):
        f = None
        try:
            f = QFile(u(filename))
            if not f.open(QFile.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                res = aw.qmc.reset(redraw=False,soundOn=False)
                obj = self.deserialize(filename)
                if "extradevices" in obj:
                    org_obj_extra_devs = obj["extradevices"][:]
                else:
                    org_obj_extra_devs = []
                if res:
                    res = self.setProfile(filename,obj)
            else:
                self.sendmessage(QApplication.translate("Message","Invalid artisan format", None))
                res = False
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                profile_changed = self.qmc.extradevices != org_obj_extra_devs
                self.setCurrentFile(filename) #update recent file list
                if profile_changed:
                    # profiles was adjusted, ensure that it does not overwrite the original file on saving
                    self.qmc.fileDirty()
                    self.curFile = None
                else:
                    self.qmc.fileClean()
                #Plot everything
                self.qmc.redraw()
                message = u(QApplication.translate("Message","{0}  loaded ", None).format(u(filename)))
                self.sendmessage(message)

                if aw is not None:
                    aw.updatePlusStatus()
                    if aw.plus_account is not None:
                        if plus.config.uuid_tag in obj:
                            QTimer.singleShot(100,lambda : plus.sync.sync())

                #check colors
                self.checkColors(self.getcolorPairsToCheck())
        except IOError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " {0}: {1}").format(str(ex),str(filename))),exc_tb.tb_lineno
            # remove file from the recent file list
            settings = QSettings()
            files = toStringList(settings.value('recentFileList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        except ValueError as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None) + " fileload() {0}").format(str(ex)),exc_tb.tb_lineno)
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " loadFile() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if f:
                f.close()

    def loadAlarmsFromProfile(self,filename,profile):
        self.qmc.alarmsfile = filename
        if "alarmflag" in profile:
            self.qmc.alarmflag = profile["alarmflag"]
        else:
            self.qmc.alarmflag = []
        if "alarmguard" in profile:
            self.qmc.alarmguard = profile["alarmguard"]
        else:
            self.qmc.alarmguard = [0]*len(self.qmc.alarmflag)
        if "alarmnegguard" in profile:
            self.qmc.alarmnegguard = profile["alarmnegguard"]
        else:
            self.qmc.alarmnegguard = [0]*len(self.qmc.alarmflag)
        if "alarmtime" in profile:
            self.qmc.alarmtime = profile["alarmtime"]
        else:
            self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
        if "alarmoffset" in profile:
            self.qmc.alarmoffset = profile["alarmoffset"]
        else:
            self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
        if "alarmcond" in profile:
            self.qmc.alarmcond = profile["alarmcond"]
        else:
            self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
        if "alarmsource" in profile:
            self.qmc.alarmsource = profile["alarmsource"]
        else:
            self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
        if "alarmtemperature" in profile:
            self.qmc.alarmtemperature = profile["alarmtemperature"]
        else:
            self.qmc.alarmtemperature = [500.]*len(self.qmc.alarmflag)
        if "alarmaction" in profile:
            self.qmc.alarmaction = profile["alarmaction"]
        else:
            self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
        if "alarmbeep" in profile:
            self.qmc.alarmbeep = profile["alarmbeep"]
        else:
            self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
        if "alarmstrings" in profile:
            self.qmc.alarmstrings = [d(x) for x in profile["alarmstrings"]]
        else:
            self.qmc.alarmstrings = [""]*len(self.qmc.alarmflag)
        self.qmc.alarmstate = [-1]*len(self.qmc.alarmflag)  #-1 = not triggered; otherwise idx = triggered

    # returns True if data got updated, False otherwise
    def calcVirtualdevices(self,update=False):
        try:
            dirty = False
            for j in range(len(self.qmc.extradevices)):
                if aw.qmc.extradevices[j] == 25:  #virtual device
                    if len(aw.qmc.extratimex[j]) > 0 and not update:  # move on if the virtual device already has data
                        continue
                    
                    if update and not len(aw.qmc.extratimex[j]) > 0:
                        self.qmc.extratimex[j] = aw.qmc.timex[:]
                        self.qmc.extratemp1[j] = [-1]*len((self.qmc.timex))
                        self.qmc.extratemp2[j] = [-1]*len((self.qmc.timex))
                        y_range1 = []
                        y_range2 = []

                    nonempty_mathexpression1 = bool(self.qmc.extramathexpression1[j] is not None and len(self.qmc.extramathexpression1[j].strip()))
                    nonempty_mathexpression2 = bool(self.qmc.extramathexpression2[j] is not None and len(self.qmc.extramathexpression2[j].strip()))
                    
                    if nonempty_mathexpression1 or nonempty_mathexpression2:
                        self.qmc.extratimex[j] = aw.qmc.timex[:]
                        
                        # need two seperate loops. without y2(x) cannot calculate a dependency on y1(x).
                        
                        if nonempty_mathexpression1:
                            dirty = True
                            self.qmc.extratemp1[j] = [-1]*len((self.qmc.extratimex[j]))
                            y_range1 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range1.append(self.qmc.eval_math_expression(self.qmc.extramathexpression1[j],self.qmc.extratimex[j][i]))
                            self.qmc.extratemp1[j] = y_range1[:]

                        if nonempty_mathexpression2:
                            dirty = True
                            self.qmc.extratemp2[j] = [-1]*len((self.qmc.extratimex[j]))
                            y_range2 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range2.append(self.qmc.eval_math_expression(self.qmc.extramathexpression2[j],self.qmc.extratimex[j][i]))
                            self.qmc.extratemp2[j] = y_range2[:]

            if dirty:
                self.qmc.fileDirty()
                return True
            else:
                return False
       
        except Exception as ex:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " calcVirtualdevices() {0}").format(str(ex)),exc_tb.tb_lineno)

    # Loads background profile
    def loadbackground(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                profile = self.deserialize(filename)
                self.qmc.backgroundprofile = profile
                tb = profile["timex"]
                t1 = profile["temp1"]
                t2 = profile["temp2"]
                t1x = profile["extratemp1"]
                t2x = profile["extratemp2"]
                
                #remove the analysis results annotation if it exists
                aw.qmc.analysisresultsstr = ""

                if "mode" in profile:
                    m = str(profile["mode"])
                    #convert modes only if needed comparing the new uploaded mode to the old one.
                    #otherwise it would incorrectly convert the uploaded phases
                    if m == "F" and self.qmc.mode == "C":
                        # we have to convert all temperatures from F to C
                        t1 = [self.qmc.fromFtoC(t) for t in t1]
                        t2 = [self.qmc.fromFtoC(t) for t in t2]
                        for e in range(len(t1x)):
                            t1x[e] = [self.qmc.fromFtoC(t) for t in t1x[e]]
                            t2x[e] = [self.qmc.fromFtoC(t) for t in t2x[e]]
                    if m == "C" and self.qmc.mode == "F":
                        # we have to convert all temperatures from C to F
                        t1 = [self.qmc.fromCtoF(t) for t in t1]
                        t2 = [self.qmc.fromCtoF(t) for t in t2]
                        for e in range(len(t1x)):
                            t1x[e] = [self.qmc.fromCtoF(t) for t in t1x[e]]
                            t2x[e] = [self.qmc.fromCtoF(t) for t in t2x[e]]
                
                names1x = [d(x) for x in profile["extraname1"]]
                names2x = [d(x) for x in profile["extraname2"]]
                timex = profile["extratimex"]
                self.qmc.temp1B,self.qmc.temp2B,self.qmc.timeB, self.qmc.temp1BX, self.qmc.temp2BX = t1,t2,tb,t1x,t2x
                self.qmc.extratimexB = timex

                # we resample the temperatures to regular interval timestamps
                if tb is not None and tb:
                    tb_lin = numpy.linspace(tb[0],tb[-1],len(tb))
                else:
                    tb_lin = None 
                decay_smoothing_p = not aw.qmc.optimalSmoothing 
                b1 = self.qmc.smooth_list(tb,self.qmc.fill_gaps(t1),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)
                b2 = self.qmc.smooth_list(tb,self.qmc.fill_gaps(t2),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tb_lin)
                
                self.qmc.extraname1B,self.qmc.extraname2B = names1x,names2x
                b1x = []
                b2x = []
                idx3 = aw.qmc.xtcurveidx - 1
                n3 = idx3 // 2
                for i in range(min(len(t1x),len(t2x))):
# we smooth also that 3rd background courve only on redraw with the actual smoothing parameters
                    if aw.qmc.xtcurveidx > 0 and n3 == 1: # this is the 3rd background curve to be drawn, we smooth it
                        tx=timex[i]
                        if tx is not None and tx:
                            tx_lin = numpy.linspace(tx[0],tx[-1],len(tx))
                        else:
                            tx_lin = None
                        if aw.qmc.xtcurveidx % 2:
                            b1x.append(self.qmc.smooth_list(tx,self.qmc.fill_gaps(t1x[i]),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin))
                            b2x.append(self.qmc.fill_gaps(t2x[i]))
                        else:
                            b1x.append(self.qmc.fill_gaps(t1x[i]))
                            b2x.append(self.qmc.smooth_list(tx,self.qmc.fill_gaps(t2x[i]),window_len=self.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=tx_lin))
                    else:
                        b1x.append(self.qmc.fill_gaps(t1x[i]))
                        b2x.append(self.qmc.fill_gaps(t2x[i]))
                # NOTE: parallel assignment after time intensive smoothing is necessary to avoid redraw failure!
                self.qmc.stemp1B,self.qmc.stemp2B,self.qmc.stemp1BX,self.qmc.stemp2BX = b1,b2,b1x,b2x
                self.qmc.backgroundEvents = profile["specialevents"]
                self.qmc.backgroundEtypes = profile["specialeventstype"]
                self.qmc.backgroundEvalues = profile["specialeventsvalue"]
                self.qmc.backgroundEStrings = [d(x) for x in profile["specialeventsStrings"]]
                self.qmc.backgroundFlavors = profile["flavors"]
                self.qmc.titleB = d(profile["title"])
                if "roastbatchnr" in profile:
                    try:
                        self.qmc.roastbatchnrB = int(profile["roastbatchnr"])
                    except:
                        pass
                    self.qmc.roastbatchprefixB = profile["roastbatchprefix"]
                    try:
                        self.qmc.roastbatchposB = profile["roastbatchpos"]
                    except:
                        pass
                else:
                    self.qmc.roastbatchnrB = 0
                    self.qmc.roastbatchprefixB = ""
                    self.qmc.roastbatchposB = 1
                
# on request we load alarms from backgrounds, but keep in mind as this would overload the one of the foreground profile that automatically loads this background
                if self.qmc.loadalarmsfrombackground:
                    self.loadAlarmsFromProfile(filename,profile)


                #if old format < 0.5.0 version  (identified by numbers less than 1.). convert
                if self.qmc.backgroundFlavors[0] < 1. and self.qmc.backgroundFlavors[-1] < 1.:
                    l = len(self.qmc.backgroundFlavors)
                    for i in range(l):
                        self.qmc.backgroundFlavors[i] *= 10.
                    self.qmc.backgroundFlavors = self.qmc.backgroundFlavors[:(l-1)]
                if "etypes" in profile:
                    self.qmc.Betypes = profile["etypes"]
                if "timeindex" in profile:
                    self.qmc.timeindexB = profile["timeindex"]          #if new profile found with variable timeindex
                    if self.qmc.phasesfromBackgroundflag:
                        # adjust phases by DryEnd and FCs events from background profile
                        if self.qmc.timeindexB[1]:
                            self.qmc.phases[1] = int(round(self.qmc.temp2B[self.qmc.timeindexB[1]]))
                        if self.qmc.timeindexB[2]:
                            self.qmc.phases[2] = int(round(self.qmc.temp2B[self.qmc.timeindexB[2]]))
                else:            
                    if "startend" in profile:
                        startendB = profile["startend"]
                        varCB = profile["cracks"]
                        if "dryend" in profile:
                            dryendB = profile["dryend"]
                        else:
                            dryendB = [0,0]
                        times = []
                        times.append(startendB[0])
                        times.append(dryendB[0])
                        times.append(varCB[0])
                        times.append(varCB[2])
                        times.append(varCB[4])
                        times.append(varCB[6])
                        times.append(startendB[2])
                        self.qmc.timebackgroundindexupdate(times[:])
                self.qmc.timeindexB = self.qmc.timeindexB + [0 for i in range(8-len(self.qmc.timeindexB))]
                self.qmc.background_profile_sampling_interval = profile["samplinginterval"]
                backgroundDrop = self.qmc.timeindexB[6]
                try:
                    try:
                        self.qmc.TP_time_B = profile["computed"]["TP_time"]
                        self.qmc.TP_time_B_loaded = profile["computed"]["TP_time"]
                    except:
                        if (self.qmc.extratimexB) > 0:
                            self.qmc.TP_time_B = 0
                        else:
                            self.qmc.TP_time_B = None
                    _,_,auc,_ = aw.ts(tp=aw.qmc.backgroundtime2index(self.qmc.TP_time_B),background=True)
                    aw.qmc.AUCbackground = auc
                except Exception:
                    pass
                    
                if not aw.curFile: # if no foreground is loaded, autoadjustAxis
                    aw.autoAdjustAxis(True)
                    
                if len(self.qmc.timeB) > backgroundDrop:
                    message =  u(QApplication.translate("Message", "Background {0} loaded successfully {1}",None).format(u(filename),str(self.qmc.stringfromseconds(self.qmc.timeB[self.qmc.timeindexB[6]]))))
                else:
                    message =  u(QApplication.translate("Message", "Background {0} loaded successfully {1}",None).format(u(filename),""))
                self.sendmessage(message)
                self.qmc.backgroundpath = u(filename)
                if "roastUUID" in profile:
                    self.qmc.backgroundUUID = profile["roastUUID"]
                else:
                    self.qmc.backgroundUUID = None
            else:
                self.sendmessage(QApplication.translate("Message", "Invalid artisan format",None))
        except IOError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " loadbackground() {0}").format(str(e)),exc_tb.tb_lineno)
            return

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Value Error:",None) + " loadbackground() {0}").format(str(e)),exc_tb.tb_lineno)
            return

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " loadbackground() {0}").format(str(e)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()

    def eventtime2string(self,time):
        if time == 0.0:
            return ""
        else:
            return "%02d:%02d"% divmod(time,60)

    #read Artisan CSV
    def importCSV(self,filename):
        try:
            import io
            import csv
            csvFile = io.open(filename, 'r', newline="",encoding='utf-8')
            data = csv.reader(csvFile,delimiter='\t')
            #read file header
            header = next(data)
            date = QDate.fromString(header[0].split('Date:')[1],"dd'.'MM'.'yyyy")
            if len(header) > 11:
                try:
                    tm = QTime.fromString(header[11].split('Time:')[1])
                    self.qmc.roastdate = QDateTime(date,tm)
                except Exception:
                    self.qmc.roastdate = QDateTime(date)
            else:
                self.qmc.roastdate = QDateTime(date)
            self.qmc.roastepoch = self.qmc.roastdate.toTime_t()
            self.qmc.roasttzoffset = 0
            unit = header[1].split('Unit:')[1]
            #set temperature mode
            if unit == "F" and self.qmc.mode == "C":
                self.qmc.fahrenheitMode()
            if unit == "C" and self.qmc.mode == "F":
                self.qmc.celsiusMode()
            #read column headers
            fields = next(data) 
            extra_fields = fields[5:] # colums after 'Event'
            # add devices if needed
            for i in range(max(0,(len(extra_fields) // 2) - len(self.qmc.extradevices))):
                self.addDevice()
            # set extra device names # NOTE: eventuelly we want to set/change the names only for devices that were just added in the line above!?
            for i in range(len(extra_fields)):
                if i % 2 == 1:
                    # odd
                    self.qmc.extraname2[int(i/2)] = extra_fields[i]
                else:
                    # even
                    self.qmc.extraname1[int(i/2)] = extra_fields[i]
            #read data
            last_time = None
            
            i = 0
            for row in data:
                i = i + 1
                items = list(zip(fields, row))
                item = {}
                for (name, value) in items:
                    item[name] = value.strip()
                #add one measurement
                timez = float(self.qmc.stringtoseconds(item['Time1']))
                if not last_time or last_time < timez:
                    self.qmc.timex.append(timez)
                    self.qmc.temp1.append(float(item['ET']))
                    self.qmc.temp2.append(float(item['BT']))
                    for j in range(len(extra_fields)):
                        if j % 2 == 1:
                            # odd
                            self.qmc.extratemp2[int(j/2)].append(float(item[extra_fields[j]]))
                        else:
                            # even
                            self.qmc.extratimex[int(j/2)].append(timez)
                            self.qmc.extratemp1[int(j/2)].append(float(item[extra_fields[j]]))
                last_time = timez
            csvFile.close()
            #set events
            CHARGE = self.qmc.stringtoseconds(header[2].split('CHARGE:')[1],False)
            if CHARGE > 0:
                self.qmc.timeindex[0] = self.time2index(CHARGE)
            DRYe = self.qmc.stringtoseconds(header[4].split('DRYe:')[1],False)
            if DRYe > 0:
                self.qmc.timeindex[1] = self.time2index(DRYe)
            FCs = self.qmc.stringtoseconds(header[5].split('FCs:')[1],False)
            if FCs > 0:
                self.qmc.timeindex[2] = self.time2index(FCs)
            FCe = self.qmc.stringtoseconds(header[6].split('FCe:')[1],False)
            if FCe > 0:
                self.qmc.timeindex[3] = self.time2index(FCe)
            SCs = self.qmc.stringtoseconds(header[7].split('SCs:')[1],False)
            if SCs > 0:
                self.qmc.timeindex[4] = self.time2index(SCs)
            SCe = self.qmc.stringtoseconds(header[8].split('SCe:')[1],False)
            if SCe> 0:
                self.qmc.timeindex[5] = self.time2index(SCe)
            DROP = self.qmc.stringtoseconds(header[9].split('DROP:')[1],False)
            if DROP > 0:
                self.qmc.timeindex[6] = self.time2index(DROP)
            COOL = self.qmc.stringtoseconds(header[10].split('COOL:')[1],False)
            if COOL > 0:
                self.qmc.timeindex[7] = self.time2index(COOL)
            self.qmc.endofx = self.qmc.timex[-1]
            self.sendmessage(QApplication.translate("Message","Artisan CSV file loaded successfully", None))
            self.qmc.fileDirty()
            aw.autoAdjustAxis()
            self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importCSV() {0}").format(str(ex)),exc_tb.tb_lineno)

    def addSerialPort(self):
        n = len(self.qmc.extradevices) - 1
        self.extraser = self.extraser[:n]
        self.extraser.append(serialport())
        self.extracomport = self.extracomport[:n]
        self.extracomport.append("COM1")
        self.extrabaudrate = self.extrabaudrate[:n]
        self.extrabaudrate.append(9600)
        self.extrabytesize = self.extrabytesize[:n]
        self.extrabytesize.append(8)
        self.extraparity = self.extraparity[:n]
        self.extraparity.append("E")
        self.extrastopbits = self.extrastopbits[:n]
        self.extrastopbits.append(1)
        self.extratimeout = self.extratimeout[:n]
        self.extratimeout.append(0.5)


    def addDevice(self):
        try:
            self.qmc.extradevices.append(25)
            n = len(self.qmc.extradevices)
            self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:n-1]
            self.qmc.extradevicecolor1.append("black") #init color to black
            self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:n-1]
            self.qmc.extradevicecolor2.append("black")
            self.qmc.extraname1 = self.qmc.extraname1[:n-1]
            self.qmc.extraname1.append(u"Extra 1")
            self.qmc.extraname2 = self.qmc.extraname2[:n-1]
            self.qmc.extraname2.append(u"Extra 2")
            self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:n-1]
            self.qmc.extramathexpression1.append("")
            self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:n-1]
            self.qmc.extramathexpression2.append("")
            
            # ensure that the curves and LCDs of the new device are visible:
            self.extraLCDvisibility1[n-1] = True
            self.extraLCDvisibility2[n-1] = True
            self.extraCurveVisibility1[n-1] = True
            self.extraCurveVisibility2[n-1] = True
            self.extraDelta1[n-1] = False
            self.extraDelta2[n-1] = False
            self.extraFill1[n-1] = 0
            self.extraFill2[n-1] = 0

            #create new serial port (but don't open it yet). Store initial settings
            self.addSerialPort()

            #add new line variables
            self.qmc.extratimex = self.qmc.extratimex[:n-1]
            self.qmc.extratimex.append([])
            self.qmc.extratemp1 = self.qmc.extratemp1[:n-1]
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2 = self.qmc.extratemp2[:n-1]
            self.qmc.extratemp2.append([])
            self.qmc.extrastemp1 = self.qmc.extrastemp1[:n-1]
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2 = self.qmc.extrastemp2[:n-1]
            self.qmc.extrastemp2.append([])
            self.qmc.extractimex1 = self.qmc.extractimex1[:n-1]
            self.qmc.extractimex1.append([])
            self.qmc.extractimex2 = self.qmc.extractimex2[:n-1]
            self.qmc.extractimex2.append([])
            self.qmc.extractemp1 = self.qmc.extractemp1[:n-1]
            self.qmc.extractemp1.append([])
            self.qmc.extractemp2 = self.qmc.extractemp2[:n-1]
            self.qmc.extractemp2.append([])

            #add new style variables
            self.qmc.extralinestyles1 = self.qmc.extralinestyles1[:n-1]
            self.qmc.extralinestyles1.append(self.qmc.linestyle_default)
            self.qmc.extralinestyles2 = self.qmc.extralinestyles2[:n-1]
            self.qmc.extralinestyles2.append(self.qmc.linestyle_default)
            self.qmc.extradrawstyles1 = self.qmc.extradrawstyles1[:n-1]
            self.qmc.extradrawstyles1.append(self.qmc.drawstyle_default)
            self.qmc.extradrawstyles2 = self.qmc.extradrawstyles2[:n-1]
            self.qmc.extradrawstyles2.append(self.qmc.drawstyle_default)
            self.qmc.extralinewidths1 = self.qmc.extralinewidths1[:n-1]
            self.qmc.extralinewidths1.append(self.qmc.extra_linewidth_default)
            self.qmc.extralinewidths2 = self.qmc.extralinewidths2[:n-1]
            self.qmc.extralinewidths2.append(self.qmc.extra_linewidth_default)
            self.qmc.extramarkers1 = self.qmc.extramarkers1[:n-1]
            self.qmc.extramarkers1.append(self.qmc.marker_default)
            self.qmc.extramarkers2 = self.qmc.extramarkers2[:n-1]
            self.qmc.extramarkers2.append(self.qmc.marker_default)
            self.qmc.extramarkersizes1 = self.qmc.extramarkersizes1[:n-1]
            self.qmc.extramarkersizes1.append(self.qmc.markersize_default)
            self.qmc.extramarkersizes2 = self.qmc.extramarkersizes2[:n-1]
            self.qmc.extramarkersizes2.append(self.qmc.markersize_default)

            #add two extra lines in figure for extra ET and extra BT
            l = len(self.qmc.extradevices)-1  #new line index
            self.qmc.extratemp1lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp1[l],color=self.qmc.extradevicecolor1[l],markersize=self.qmc.extramarkersizes1[l],marker=self.qmc.extramarkers1[l],linewidth=self.qmc.extralinewidths1[l],linestyle=self.qmc.extralinestyles1[l],drawstyle=self.qmc.extradrawstyles1[l],label=self.qmc.extraname1[l])[0])
            self.qmc.extratemp2lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp2[l],color=self.qmc.extradevicecolor2[l],markersize=self.qmc.extramarkersizes2[l],marker=self.qmc.extramarkers2[l],linewidth=self.qmc.extralinewidths2[l],linestyle=self.qmc.extralinestyles2[l],drawstyle=self.qmc.extradrawstyles2[l],label=self.qmc.extraname2[l])[0])

            self.updateExtraLCDvisibility()
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass

    #Write readings to Artisan JSON file
    def exportJSON(self,filename):
        try:
            outfile = open(filename, 'w')
            from json import dump as json_dump
            json_dump(self.getProfile(), outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
#            import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " exportJSON() {0}").format(str(ex)),exc_tb.tb_lineno)
            return False
            
    def indent(self,elem, level=0):
        i = "\r\n" + level*"  " # Windows line ending (as Pilot is only available on Windows)
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for elem in elem:
                self.indent(elem, level+1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i
            
    def exportPilot(self,filename):
        try:
            # warning popup if filename contains more than one _
            # only contain one _ followed by an index number like Name_0.xml
            s = filename.split("_")
            if (len(s) < 2 or len(s) > 2):
                QMessageBox.warning(aw,QApplication.translate("Message", "Warning",None),QApplication.translate("Message", "The Probat Shop Pilot Software expects files named <Name>_<Index>.xml like in Test_0.xml on import",None))
        
            try:
                import xml.etree.cElementTree as ET
            except ImportError:
                import xml.etree.ElementTree as ET
            tree = ET.Element("recipe")
            
            charge = ET.SubElement(tree, "charge")
            charge.text = u(aw.float2float(aw.convertWeight(aw.qmc.weight[0],aw.qmc.weight_units.index(aw.qmc.weight[2]),1)))
            
            beans = ET.SubElement(tree, "coffeetype")
            if aw.qmc.beans and aw.qmc.beans != "":
                beans.text = aw.qmc.beans
            
            color = ET.SubElement(tree, "coffeecolor")
            if aw.qmc.ground_color:
                color.text = str(aw.qmc.ground_color)
                
            endtemperature = ET.SubElement(tree, "endtemperature")
            endtime = ET.SubElement(tree, "endtime")
            cooling = ET.SubElement(tree, "coolingtime")                
            
            roaster = ET.SubElement(tree, "roaster")
            if aw.qmc.roastertype and aw.qmc.roastertype != "":
                roaster.text = aw.qmc.roastertype
            
            notes = ET.SubElement(tree, "notes")
            if self.qmc.roastingnotes and self.qmc.roastingnotes != "":
                notes.text = self.qmc.roastingnotes
            
            roasttype = ET.SubElement(tree, "roasttype")
            roasttype.text = "0" # 0: global, 1: time, 2: temp
            
            recipedata = ET.SubElement(tree, "recipedata_temp_unit")
            recipedata.text = aw.qmc.mode
            
            diagrampoints = ET.SubElement(tree, "diagrampoints")
            
            time_tag = "sTime"
            temp_tag = "nTemperature"
            burner_tag = "nBurnercapacity"
            rising_tag = "bRising"
            
            # if CHARGE is defined, only export from CHARGE
            # if DROP is defined only export until DROP
            end_temp = None
            end_time = None
            idx = 1
            for i in range(len(aw.qmc.timex)):
                if (self.qmc.timeindex[0] < 0 or i >= self.qmc.timeindex[0]) and (self.qmc.timeindex[6] == 0 or i <= self.qmc.timeindex[6]):
                    data = ET.SubElement(diagrampoints, "data", index=str(idx))
                    t = self.qmc.timex[i]
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timex[self.qmc.timeindex[0]]
                    time = ET.SubElement(data,time_tag)
                    time.text = "%02d:%02d"% divmod(t,60)
                    end_time = time.text
                    temp = ET.SubElement(data,temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[i])))
                    end_temp = temp.text
                    burner = ET.SubElement(data,burner_tag)
                    if len(self.qmc.extradevices) > 0:
                        burner.text = str(max(0,int(round(self.qmc.extratemp1[0][i]))))
                    else:
                        burner.text = "0"
                    rising = ET.SubElement(data,rising_tag)
                    if self.qmc.delta2[i] and self.qmc.delta2[i] > 0:
                        rising.text = "true"
                    else:
                        rising.text = "false"
                    idx = idx + 1

            if end_temp:
                endtemperature.text = end_temp
                
            if end_temp:
                endtime.text = end_time
                
            if self.qmc.timeindex[7]:
                t = self.qmc.timex[self.qmc.timeindex[7]] - self.qmc.timex[self.qmc.timeindex[6]]
                cooling.text = "%02d:%02d"% divmod(t,60)
            else:
                cooling.text = "00:00"
            
            switchpoints = ET.SubElement(tree, "switchpoints")
            # take data from 2nd extra event type
            idx = 1
            for i in range(len(self.qmc.specialevents)):
                if self.qmc.specialeventstype[i] == 3 and (self.qmc.timeindex[0] < 0 or self.qmc.specialevents[i] >= self.qmc.timeindex[0]) and (self.qmc.timeindex[6] == 0 or self.qmc.specialevents[i] <= self.qmc.timeindex[6]):
                    data = ET.SubElement(switchpoints, "data", index=str(idx))
                    if aw.qmc.timeindex[0] > -1 and len(aw.qmc.timex) > aw.qmc.timeindex[0]:
                        timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
                    else:
                        timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]))
                    t = self.qmc.specialevents[i]
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timeindex[0]
                    time = ET.SubElement(data,time_tag)
                    time.text = timez
                    temp = ET.SubElement(data,temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[self.qmc.specialevents[i]])))
                    burner = ET.SubElement(data,burner_tag)
                    b = self.qmc.eventsInternal2ExternalValue(self.qmc.specialeventsvalue[i])
                    burner.text = str(int(round(b)))
                    rising = ET.SubElement(data,rising_tag)
                    if self.qmc.delta2[i] and self.qmc.delta2[i] > 0:
                        rising.text = "true"
                    else:
                        rising.text = "false"
                    idx = idx + 1
            self.indent(tree)
            ET.ElementTree(tree).write(filename,encoding='utf-8', xml_declaration=True)
            return True
        except Exception as ex:
#           import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " exportPilot() {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    #Write readings to RoastLogger CSV file
    def exportRoastLogger(self,filename):
        outfile = open(filename, 'w')
        try:
            outfile.write("Log created at 09:00:00 "+ self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + "\n")
            outfile.write("Use Options|Set template for new log to modify this template.\n")
            outfile.write("------------------------------------------------------\n")
            outfile.write("Bean/Blend name:\n")
            outfile.write("\n")
            outfile.write("Profile description:\n")
            outfile.write("\n")
            outfile.write("Roast notes:\n")
            outfile.write("\n")
            outfile.write("Cupping results:\n")
            outfile.write("\n")
            outfile.write("Roast Logger Copyright ? T. R. Coxon (GreenBean TMC).\n")
            outfile.write("Roast started at 09:00:00 " + self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + "\n")
            if len(self.qmc.timex) > 0:
                CHARGE = aw.qmc.timex[aw.qmc.timeindex[0]] 
            else:
                CHARGE = 0
            import csv
            writer= csv.writer(outfile,delimiter=',')
            writer.writerow(["Elapsed time "," T1 "," T2 "," Event type"])
            for i in range(len(aw.qmc.timex)):
                if i == aw.qmc.timeindex[0]:
                    kind = "Beans loaded"
                elif i!=0 and i == aw.qmc.timeindex[2]:
                    kind = "First crack start"
                elif i!=0 and i == aw.qmc.timeindex[3]:
                    kind = "First crack end"
                elif i!=0 and i == aw.qmc.timeindex[4]:
                    kind = "Second crack start"
                elif i!=0 and i == aw.qmc.timeindex[6]:
                    kind = "Beans ejected"
                else:
                    kind = "timer"
                writer.writerow([aw.qmc.stringfromseconds(aw.qmc.timex[i]-CHARGE),"%.1f"%float(aw.qmc.temp2[i]),"%.1f"%float(aw.qmc.temp1[i]),kind])
            outfile.write("\n")
            outfile.write("@actionT1Table\n")
            outfile.write("120|null|30\n")
            outfile.write("178|65|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionSecsFCTable\n")
            outfile.write("60|50|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("null|null|null\n")
            outfile.write("\n")
            outfile.write("@actionResetTable\n")
            outfile.write("100|0\n")
            outfile.write("\n")
            outfile.write("@loadBeansTable\n")
            outfile.write("146\n")
            outfile.write("\n")
            outfile.close()
            return True
        except Exception as ex:
#           import traceback
#           traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " exportRoastLogger() {0}").format(str(ex)),exc_tb.tb_lineno)
            return False
        finally:
            outfile.close()

    def importJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            from json import load as json_load
            obj = json_load(infile)
            res = self.setProfile(filename,obj)
            infile.close()
            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                aw.autoAdjustAxis()
                self.qmc.redraw()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importJSON() {0}").format(str(ex)),exc_tb.tb_lineno)

    def importRoastLogger(self,filename):
        self.resetExtraDevices()
        # the RoastLogger file might be in utf-8 or latin1 encoding, we cannot know so let's test both
        try:
            try:
                self.importRoastLoggerEnc(filename,'utf-8')
            except Exception:
                self.importRoastLoggerEnc(filename,'latin1')
            aw.qmc.fileDirty()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importRoastLogger() {0}").format(str(ex)),exc_tb.tb_lineno)
            
    def resetExtraDevices(self):
        try:
            #delete extra devices
            aw.qmc.extradevices = []
            #delete extra curves variables
            aw.qmc.extratimex = []
            aw.qmc.extradevicecolor1 = []
            aw.qmc.extradevicecolor2 = []
            aw.qmc.extratemp1,aw.qmc.extratemp2 = [],[]
            aw.qmc.extrastemp1,aw.qmc.extrastemp2 = [],[]
            aw.qmc.extractimex1,aw.qmc.extractimex2 = [],[]
            aw.qmc.extractemp1,aw.qmc.extractemp2 = [],[]
            aw.qmc.extratemp1lines,aw.qmc.extratemp2lines = [],[]
            aw.qmc.extralinestyles1,aw.qmc.extralinestyles2 = [],[]
            aw.qmc.extradrawstyles1,aw.qmc.extradrawstyles2 = [],[]
            aw.qmc.extralinewidths1,aw.qmc.extralinewidths2 = [],[]
            aw.qmc.extramarkers1,aw.qmc.extramarkers2 = [],[]
            aw.qmc.extramarkersizes1,aw.qmc.extramarkersizes2 = [],[]
            aw.qmc.extraname1,aw.qmc.extraname2 = [],[]
            aw.qmc.extramathexpression1,aw.qmc.extramathexpression2 = [],[]
            for i in range(len(aw.extraLCDlabel1)):
                aw.extraLCDframe1[i].setVisible(False)
                aw.extraLCDframe2[i].setVisible(False)
            #delete EXTRA COMM PORTS VARIABLES
            aw.extraser = []
            aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            aw.qmc.resetlinecountcaches()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " resetExtraDevices(): {0}").format(str(e)),exc_tb.tb_lineno)
            
    def importRoastLoggerEnc(self,filename,enc='utf-8'):
        roastlogger_action_section = ""
        # use io.open instead of open to have encoding support on Python 2
        import io
        infile = io.open(filename, 'r', encoding=enc)
        obj = {}
        obj["mode"] = "C"
        obj["title"] = u(QFileInfo(filename).fileName())
        import csv
        obj["roastdate"] = encodeLocal(QDate.currentDate().toString())
        # read roastdate from file
        while True:
            l = infile.readline()
            if l.startswith("Roast started at "):
                #extract roast date
                roastdate = QDateTime(QDate.fromString(l.split(" ")[-1][0:10],"dd'/'MM'/'yyyy"))
                if not roastdate.isNull():
                    obj["roastdate"] = encodeLocal(roastdate.date().toString())
                break
            if l == '':
                break
        timeindex = [-1,0,0,0,0,0,0,0]
        timex = []
        temp1 = []
        temp2 = []
        data = csv.reader(infile,delimiter=',')
        #read file header
        next(data) # we do not use the labels
        #header = list(map(lambda s:s.strip(),next(data)))
        while True:
            fields = next(data)
            if len(fields) == 0:
                break
            else:
                timex.append(float(self.qmc.stringtoseconds(fields[0])))
                try:
                    t1 = float(fields[1])
                except Exception:
                    t1 = -1
                temp1.append(t1)
                try:
                    t2 = float(fields[2])
                except Exception:
                    t2 = -1
                temp2.append(t2)
                event = fields[3]
                if event == "Beans loaded":
                    timeindex[0] = len(timex) - 1
                elif event == "First crack start":
                    timeindex[2] = len(timex) - 1
                elif event == "First crack end":
                    timeindex[3] = len(timex) - 1
                elif event == "Second crack start":
                    timeindex[4] = len(timex) - 1
                elif event == "Beans ejected":
                    timeindex[6] = len(timex) - 1
        obj["timeindex"] = timeindex
        obj["timex"] = timex
        obj["temp1"] = temp2
        obj["temp2"] = temp1
        res = self.setProfile(filename,obj)
            
        try:
            error_msg = ""
            if aw.qmc.loadalarmsfromprofile:
                aw.qmc.alarmsfile = filename
                roastlogger_action_section = "No actions loaded"

                #Find sliders - exact names of the sliders must be defined
                slider_power = -1
                slider_fan = -1
                try:
                    slider_power=aw.qmc.etypes.index("Power")
                except Exception:
                    pass
                try:
                    slider_fan=aw.qmc.etypes.index("Fan")
                except Exception:
                    pass
                #load only "Power" and "Fan" events
                if slider_power != -1 and slider_fan != -1:
                    data_action = csv.reader(infile,delimiter='|')

                    aw.qmc.alarmflag = []
                    aw.qmc.alarmguard = []
                    aw.qmc.alarmnegguard = []
                    aw.qmc.alarmtime = []
                    aw.qmc.alarmoffset = []
                    aw.qmc.alarmcond = []
                    aw.qmc.alarmstate = []
                    aw.qmc.alarmsource = []
                    aw.qmc.alarmtemperature = []
                    aw.qmc.alarmaction = []
                    aw.qmc.alarmbeep = []
                    aw.qmc.alarmstrings = []

                    while True:
                        fields_action = next(data_action)
                        if len(fields_action) == 0:
                            pass
                        elif len(fields_action) == 1 and fields_action[0].startswith("@"):
                            roastlogger_action_section=fields_action[0]
                        else:
                            #process items in the section
                            if roastlogger_action_section.startswith("@actionT1Table"):
                                if len(fields_action) == 3 and fields_action[0] != "null":
                                    #add temp alarm - POWER
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(8)        #after TP
                                    aw.qmc.alarmoffset.append(0)
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(-1)
                                    aw.qmc.alarmsource.append(1)    #BT
                                    aw.qmc.alarmtemperature.append(float(fields_action[0]))
                                    aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[1],None))

                                    #add temp alarm - FAN
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(8)        #after TP
                                    aw.qmc.alarmoffset.append(0)
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(-1)
                                    aw.qmc.alarmsource.append(1)    #BT
                                    aw.qmc.alarmtemperature.append(int(fields_action[0]))
                                    aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[2],None))

                            elif roastlogger_action_section.startswith("@actionSecsFCTable"):
                                if len(fields_action) == 3 and fields_action[0] != "null":

                                    #add time alarm - POWER
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(2)        #after FC
                                    aw.qmc.alarmoffset.append(int(fields_action[0]))
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(-1)
                                    aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                    aw.qmc.alarmtemperature.append(0)
                                    aw.qmc.alarmaction.append(3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[1],None))

                                    #add time alarm - FAN
                                    aw.qmc.alarmflag.append(1)
                                    aw.qmc.alarmguard.append(-1)
                                    aw.qmc.alarmnegguard.append(-1)
                                    aw.qmc.alarmtime.append(2)        #after FC
                                    aw.qmc.alarmoffset.append(int(fields_action[0]))
                                    aw.qmc.alarmcond.append(1)
                                    aw.qmc.alarmstate.append(-1)
                                    aw.qmc.alarmsource.append(-3)       #no source - this is time alarm
                                    aw.qmc.alarmtemperature.append(0)
                                    aw.qmc.alarmaction.append(3+slider_fan)    #SLIDER FAN
                                    aw.qmc.alarmbeep.append(0)
                                    aw.qmc.alarmstrings.append(QApplication.translate("Label",fields_action[2],None))

                            elif roastlogger_action_section.startswith("@actionResetTable"):
                                if len(fields_action) == 2 and fields_action[0] != "null":

                                    #add temp alarm - POWER
                                    aw.qmc.alarmflag.insert(0,1)
                                    aw.qmc.alarmguard.insert(0,-1)
                                    aw.qmc.alarmnegguard.insert(0,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(0,0)
                                    aw.qmc.alarmcond.insert(0,1)
                                    aw.qmc.alarmstate.insert(0,-1)
                                    aw.qmc.alarmsource.insert(0,1)    #BT
                                    aw.qmc.alarmtemperature.insert(0,0)
                                    aw.qmc.alarmaction.insert(0,3+slider_power)    #SLIDER POWER
                                    aw.qmc.alarmbeep.insert(0,0)
                                    aw.qmc.alarmstrings.insert(0,QApplication.translate("Label",fields_action[0],None))

                                    #add temp alarm - FAN
                                    aw.qmc.alarmflag.insert(0,1)
                                    aw.qmc.alarmguard.insert(0,-1)
                                    aw.qmc.alarmnegguard.insert(0,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(0,0)
                                    aw.qmc.alarmcond.insert(0,1)
                                    aw.qmc.alarmstate.insert(0,-1)
                                    aw.qmc.alarmsource.insert(0,1)    #BT
                                    aw.qmc.alarmtemperature.insert(0,0)
                                    aw.qmc.alarmaction.insert(0,3+slider_fan)    #SLIDER POWER
                                    aw.qmc.alarmbeep.insert(0,0)
                                    aw.qmc.alarmstrings.insert(0,QApplication.translate("Label",fields_action[1],None))

                            elif roastlogger_action_section.startswith("@loadBeansTable"):
                                if len(fields_action) == 1 and fields_action[0] != "null":

                                    #add START TRIGGER - 10 DEG before charge temp
                                    aw.qmc.alarmflag.insert(2,1)
                                    aw.qmc.alarmguard.insert(2,-1)
                                    aw.qmc.alarmnegguard.insert(2,-1)
                                    aw.qmc.alarmtime.insert(0,9)        #after ON
                                    aw.qmc.alarmoffset.insert(2,0)
                                    aw.qmc.alarmcond.insert(2,1)
                                    aw.qmc.alarmstate.insert(2,-1)
                                    aw.qmc.alarmsource.insert(2,1)    #BT
                                    aw.qmc.alarmtemperature.insert(2,float(fields_action[0])-10)
                                    aw.qmc.alarmaction.insert(2,7)    #inititate 7 (START)
                                    aw.qmc.alarmbeep.insert(2,0)
                                    aw.qmc.alarmstrings.insert(2,QApplication.translate("Label","Start recording",None))

                                    #add CHARGE alarm
                                    aw.qmc.alarmflag.insert(3,1)
                                    aw.qmc.alarmguard.insert(3,-1)
                                    aw.qmc.alarmnegguard.insert(3,-1)
                                    aw.qmc.alarmtime.insert(3,-1)        #after START
                                    aw.qmc.alarmoffset.insert(3,0)
                                    aw.qmc.alarmcond.insert(3,1)
                                    aw.qmc.alarmstate.insert(3,-1)
                                    aw.qmc.alarmsource.insert(3,1)    #BT
                                    aw.qmc.alarmtemperature.insert(3,float(fields_action[0]))
                                    aw.qmc.alarmaction.insert(3,0)    #POPUP
                                    aw.qmc.alarmbeep.insert(3,1)      #do beep for charge
                                    aw.qmc.alarmstrings.insert(3,QApplication.translate("Label","Charge the beans",None))
                                break;
                    else:
                        if slider_power == -1: error_msg += "Could not find slider named 'Power' "
                        if slider_fan == -1: error_msg += "Could not find slider named 'Fan' "
                        error_msg += "Please rename sliders in Config - Events menu"

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            if roastlogger_action_section == "No actions loaded":
                error_msg += "Roastlogger file does not contain actions.  Alarms will not be loaded."
            else:
                error_msg += "Roastlogger actions are not complete. Last loaded section is '" + roastlogger_action_section + "'"

        finally:
            infile.close()
            if res:
                aw.autoAdjustAxis()
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading                
                self.qmc.redraw()

        if error_msg: 
            aw.qmc.adderror(QApplication.translate("Error Message","Roastlogger log file exception: " + error_msg,None))

    #Write readings to Artisan csv file
    def exportCSV(self,filename):
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]] 
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [     
                    [CHARGE,"Charge",False],
                    [TP,"TP",False],      
                    [DRYe,"Dry End",False], 
                    [FCs,"FCs",False],
                    [FCe,"FCe",False],
                    [SCs,"SCs",False],
                    [SCe,"SCe",False],
                    [DROP, "Drop",False],
                    [COOL, "COOL",False],
                    ]
                import csv
                import io
                outfile = io.open(filename, 'w',newline="",encoding='utf8')
                    
                writer= csv.writer(outfile,delimiter='\t')
                writer.writerow([
                    u("Date:" + self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy")),
                    u("Unit:" + self.qmc.mode),
                    u("CHARGE:" + self.eventtime2string(CHARGE)),
                    u("TP:" + self.eventtime2string(TP)),
                    u("DRYe:" + self.eventtime2string(DRYe)),
                    u("FCs:" + self.eventtime2string(FCs)),
                    u("FCe:" + self.eventtime2string(FCe)),
                    u("SCs:" + self.eventtime2string(SCs)),
                    u("SCe:" + self.eventtime2string(SCe)),
                    u("DROP:" + self.eventtime2string(DROP)),
                    u("COOL:" + self.eventtime2string(COOL)),
                    u("Time:" + self.qmc.roastdate.time().toString()[:-3])])
                row = ([u('Time1'),u('Time2'),u('ET'),u('BT'),u('Event')] + freduce(lambda x,y: x + [u(y[0]),u(y[1])], list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)])),[]))                
                writer.writerow(row)
                last_time = None
                for i in range(len(self.qmc.timex)):
                    if CHARGE > 0. and self.qmc.timex[i] >= CHARGE:
                        time2 = "%02d:%02d"% divmod(self.qmc.timex[i] - CHARGE, 60)
                    else:
                        time2 = "" 
                    event = ""               
                    for e in range(len(events)):
                        if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                            event = events[e][1]
                            events[e][2] = True
                            break
                    time1 = "%02d:%02d"% divmod(self.qmc.timex[i],60)
                    if not last_time or last_time != time1:
                        extratemps = []
                        for j in range(len(self.qmc.extradevices)):
                            if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                extratemps.append(u(self.qmc.extratemp1[j][i]))
                            else:
                                extratemps.append(u("-1"))
                            if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                extratemps.append(u(self.qmc.extratemp2[j][i]))
                            else:
                                extratemps.append(u("-1"))
                        writer.writerow([u(time1),u(time2),u(self.qmc.temp1[i]),u(self.qmc.temp2[i]),u(event)] + extratemps)
                    last_time = time1
                outfile.close()
                return True
            else:
                return False
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " exportCSV() {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    #Write readings to Artisan Excel file
    def exportExcel(self,filename):
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]] 
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    #manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                else:
                    #we use the dryEndIndex respecting the dry phase
                    if dryEndIndex < len(self.qmc.timex):
                        DRYe = self.qmc.timex[dryEndIndex]
                    else:
                        DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [     
                    [CHARGE,"Charge",False],
                    [TP,"TP",False],      
                    [DRYe,"Dry End",False], 
                    [FCs,"FCs",False],
                    [FCe,"FCe",False],
                    [SCs,"SCs",False],
                    [SCe,"SCe",False],
                    [DROP, "Drop",False],
                    [COOL, "COOL",False],
                    ]

                from openpyxl import Workbook
                from openpyxl.styles import Font,Alignment # , Fill # ML: not used

                wb = Workbook()
                ws = wb.active
                ws.title = u(QApplication.translate("HTML Report Template", "Profile",None)) 
                
                bf = Font(bold=True)                    

                #summary section
                fieldlist = [
                    ["Date",   self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy")   ],
                    ["Unit",   self.qmc.mode                                          ],
                    ["CHARGE", self.eventtime2string(CHARGE)                          ],
                    ["TP",     self.eventtime2string(TP)                              ],
                    ["DRYe",   self.eventtime2string(DRYe)                            ],
                    ["FCs",    self.eventtime2string(FCs)                             ],
                    ["FCe",    self.eventtime2string(FCe)                             ],
                    ["SCs",    self.eventtime2string(SCs)                             ],
                    ["SCe",    self.eventtime2string(SCe)                             ],
                    ["DROP",   self.eventtime2string(DROP)                            ],
                    ["COOL",   self.eventtime2string(COOL)                            ],
                    ["Time",   self.qmc.roastdate.time().toString()[:-3]              ],
                    ]
                for f in range(len(fieldlist)):
                    ws.cell(row=1,column=f+1).value = fieldlist[f][0]
                    ws.cell(row=1,column=f+1).font = bf
                    ws.cell(row=2,column=f+1).value = fieldlist[f][1]
                    ws.cell(row=1,column=f+1).alignment = Alignment(horizontal='center')
                    ws.cell(row=2,column=f+1).alignment = Alignment(horizontal='center')
                    
                #profile data
                fieldlist = [
                    ["Time1",  "time1"             ],
                    ["Time2",  "time2"             ],
                    ["ET",     "self.qmc.temp1[i]" ],
                    ["BT",     "self.qmc.temp2[i]" ],
                    [deltaLabelUTF8 + "BT","self.qmc.delta2[i]"],
                    ["Event",  "event"             ],
                    ]
                extraslist = list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],self.qmc.extraname2[0:len(self.qmc.extradevices)]))

                r = 4  #starting row number
                c = 0  #starting col number
                for f in range(len(fieldlist)):
                    c += 1
                    ws.cell(row=r,column=c,value=fieldlist[f][0])
                for f in range(len(extraslist)):
                    c += 1
                    ws.cell(row=r,column=c).value = extraslist[f][0]
                    c += 1
                    ws.cell(row=r,column=c).value = extraslist[f][1]

                for i in range(ws.max_column):
                    ws.cell(row=r,column=i+1).font = bf
                    ws.cell(row=r,column=i+1).alignment = Alignment(horizontal='center')
                r += 1
                
                last_time = None
                for i in range(len(self.qmc.timex)):
                    if CHARGE > 0. and self.qmc.timex[i] >= CHARGE:
                        time2 = "%02d:%02d"% divmod(self.qmc.timex[i] - CHARGE, 60) #@UnusedVariable
                    else:
                        time2 = "" #@UnusedVariable
                    event = ""     #@UnusedVariable       
                    for e in range(len(events)):
                        if not events[e][2] and int(round(self.qmc.timex[i])) == int(round(events[e][0])):
                            event = events[e][1] #@UnusedVariable
                            events[e][2] = True
                            break
                    if i in aw.qmc.specialevents:
#                        a = [k for k, j in enumerate(aw.qmc.specialevents) if j == i]
                        for n,m in enumerate(aw.qmc.specialevents):
                            if m == i:
                                if len(event) > 0:
                                    event += ","
                                #if aw.qmc.specialeventstype[n] == 4:       # only export the event Description for -- type events
                                if len(aw.qmc.specialeventsStrings[n]) > 0: # always export the event Description if it exist
                                    event += aw.qmc.specialeventsStrings[n]
                                else:
                                    event += aw.qmc.etypesf(aw.qmc.specialeventstype[n])[0] + aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[n])

                    time1 = "%02d:%02d"% divmod(self.qmc.timex[i],60)
                    if not last_time or last_time != time1:
                        extratemps = []
                        for j in range(len(self.qmc.extradevices)):
                            if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                extratemps.append(self.qmc.extratemp1[j][i])
                            else:
                                extratemps.append(-1)
                            if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                extratemps.append(self.qmc.extratemp2[j][i])
                            else:
                                extratemps.append(-1)

                        ws.cell(row=r+i, column=1).value = eval(fieldlist[0][1])
                        ws.cell(row=r+i, column=2).value = eval(fieldlist[1][1])
                        ws.cell(row=r+i, column=3).value = eval(fieldlist[2][1])
                        ws.cell(row=r+i, column=4).value = eval(fieldlist[3][1])
                        ws.cell(row=r+i, column=5).value = eval(fieldlist[4][1])
                        ws.cell(row=r+i, column=6).value = eval(fieldlist[5][1])

                        for j in range(len(extratemps)):
                            ws.cell(row=r+i, column=7+j).value = extratemps[j]

                    last_time = time1

                wb.save(filename)
                return True
            else:
                return False
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " exportExcel() {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    #Write object to file
    def serialize(self,filename,obj):
        fn = u(filename)
        f = codecs.open(fn, 'w+', encoding='utf-8')
        f.write(repr(obj))
        f.close()
        
#PLUS        
        # fill plus UUID register
        try:
            if obj is not None:
                if plus.config.uuid_tag in obj:
                    plus.register.addPath(obj[plus.config.uuid_tag],fn)
        except:
            pass

    #Read object from file 
    def deserialize(self,filename):
        try:
            obj = None
            fn = u(filename)
            if os.path.exists(fn):
                f = codecs.open(fn, 'rb', encoding='utf-8')
                obj=ast.literal_eval(f.read())
                f.close()

#PLUS
            # fill plus UUID register
            try:
                if obj is not None:
                    if plus.config.uuid_tag in obj:
                        plus.register.addPath(obj[plus.config.uuid_tag],fn)
            except:
                pass
                
            return obj
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " deserialize() {0}").format(str(ex)),exc_tb.tb_lineno)
            return {}
#            import traceback
#            traceback.print_exc(file=sys.stdout)

    def ensureCorrectExtraDeviceListLenght(self):
        self.qmc.extraname1 = self.qmc.extraname1[:len(self.qmc.extradevices)]
        self.qmc.extraname1 = self.qmc.extraname1 + [u"Extra 1"]*max(0,len(self.qmc.extradevices)-len(self.qmc.extraname1))
        self.qmc.extraname2 = self.qmc.extraname2[:len(self.qmc.extradevices)]
        self.qmc.extraname2 = self.qmc.extraname2 + [u"Extra 2"]*max(0,len(self.qmc.extradevices)-len(self.qmc.extraname2))
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1 + [""]*max(0,len(self.qmc.extradevices)-len(self.qmc.extramathexpression1))
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2 + [""]*max(0,len(self.qmc.extradevices)-len(self.qmc.extramathexpression2))
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1 + ["black"]*max(0,len(self.qmc.extradevices)-len(self.qmc.extradevicecolor1))
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2 + ["black"]*max(0,len(self.qmc.extradevices)-len(self.qmc.extradevicecolor2)) 
    
    
    #called by fileLoad()
    def setProfile(self,filename,profile,quiet=False):
        try:
            #extra devices load and check
            if "extratimex" in profile:
                if "extradevices" in profile:
                    if (len(self.qmc.extradevices) < len(profile["extradevices"])) or self.qmc.extradevices[:len(profile["extradevices"])] != profile["extradevices"]:
                        string = u(QApplication.translate("Message","To fully load this profile the extra device configuration needs to modified?\nModify your setup?",None))
                        if quiet:
                            reply = QMessageBox.Yes
                        else:
                            reply = QMessageBox.question(aw,QApplication.translate("Message", "Found a different number of curves",None), string,
                                    QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.No)
                        if reply == QMessageBox.Yes:
                            if self.qmc.reset(redraw=False): # operation not canceled by the user in the save dirty state dialog
                                aw.qmc.resetlinecountcaches()
                                self.qmc.extradevices = profile["extradevices"]
                            else:
                                return False
                        elif reply == QMessageBox.No:
                            # we remove the extra device elements that do not fit
                            l = len(self.qmc.extradevices)
                            for k in ["extratimex","extratemp1","extratemp2"]:
                                profile[k] = profile[k][:l]
                            profile["extradevices"] = self.qmc.extradevices
                            profile["extraname1"] = self.qmc.extraname1
                            profile["extraname2"] = self.qmc.extraname2
                            profile["extramathexpression1"] = self.qmc.extramathexpression1
                            profile["extramathexpression2"] = self.qmc.extramathexpression2
                            profile["extradevicecolor1"] = self.qmc.extradevicecolor1
                            profile["extradevicecolor2"] = self.qmc.extradevicecolor2
                            profile["extramarkersizes1"] = self.qmc.extramarkersizes1
                            profile["extramarkersizes2"] = self.qmc.extramarkersizes2
                            profile["extramarkers1"] = self.qmc.extramarkers1
                            profile["extramarkers2"] = self.qmc.extramarkers2
                            profile["extralinewidths1"] = self.qmc.extralinewidths1
                            profile["extralinewidths2"] = self.qmc.extralinewidths2
                            profile["extralinestyles1"] = self.qmc.extralinestyles1
                            profile["extralinestyles2"] = self.qmc.extralinestyles2
                            profile["extradrawstyles1"] = self.qmc.extradrawstyles1
                            profile["extradrawstyles2"] = self.qmc.extradrawstyles2
                        else:
                            return False

                # adjust extra serial device table
                # a) remove superfluous extra serial settings
                self.extraser = self.extraser[:len(self.qmc.extradevices)]
                self.extracomport = self.extracomport[:len(self.qmc.extradevices)]
                self.extrabaudrate = self.extrabaudrate[:len(self.qmc.extradevices)]
                self.extrabytesize = self.extrabytesize[:len(self.qmc.extradevices)]
                self.extraparity = self.extraparity[:len(self.qmc.extradevices)]
                self.extrastopbits = self.extrastopbits[:len(self.qmc.extradevices)]
                self.extratimeout = self.extratimeout[:len(self.qmc.extradevices)]
                # b) add missing extra serial settings
                for _ in range(len(self.qmc.extradevices) - len(self.extraser)):
                    self.addSerialPort()
                # c) set extra temp curves and prepare empty extra smoothed temp curves
                if "extratimex" in profile:
                    self.qmc.extratimex = profile["extratimex"] + [[]]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                if "extratemp1" in profile and len(self.qmc.extratimex) > 0:
                    self.qmc.extratemp1 = profile["extratemp1"] + [[]]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                    self.qmc.extrastemp1 = [[]]*len(self.qmc.extratemp1)
                    self.qmc.extractemp1 = [[]]*len(self.qmc.extratemp1)
                    self.qmc.extractimex1 = [[]]*len(self.qmc.extratemp1)
                if "extratemp2" in profile and len(self.qmc.extratimex) > 0:
                    self.qmc.extratemp2 = profile["extratemp2"] + [[]]*(len(self.qmc.extradevices) - len(profile["extratimex"]))
                    self.qmc.extrastemp2 = [[]]*len(self.qmc.extratemp2)
                    self.qmc.extractemp2 = [[]]*len(self.qmc.extratemp2)
                    self.qmc.extractimex2 = [[]]*len(self.qmc.extratemp2)
                # d) set other extra curve attribute lists
                if "extraname1" in profile:
                    self.qmc.extraname1 = [d(x) for x in profile["extraname1"] + self.qmc.extraname1[len(profile["extraname1"]):]]
                if "extraname2" in profile:
                    self.qmc.extraname2 = [d(x) for x in profile["extraname2"] + self.qmc.extraname2[len(profile["extraname2"]):]]
                    
                # we keep the mathexpressions and don't overwrite them from those of the profile to be loaded
                if "extramathexpression1" in profile:
                    old = self.qmc.extramathexpression1
                    new = [d(x) for x in profile["extramathexpression1"]]
                    self.qmc.extramathexpression1 = (old + new[len(old):])[:len(self.qmc.extraname1)]
                if "extramathexpression2" in profile:
                    old = self.qmc.extramathexpression2
                    new = [d(x) for x in profile["extramathexpression2"]]
                    self.qmc.extramathexpression2 = (old + new[len(old):])[:len(self.qmc.extraname2)]
                    
                if "extradevicecolor1" in profile:
                    self.qmc.extradevicecolor1 = [d(x) for x in profile["extradevicecolor1"]] + self.qmc.extradevicecolor1[len(profile["extradevicecolor1"]):]
                if "extradevicecolor2" in profile:
                    self.qmc.extradevicecolor2 = [d(x) for x in profile["extradevicecolor2"]] + self.qmc.extradevicecolor2[len(profile["extradevicecolor2"]):]
                    
                # ensure that extra list length are of the size of the extradevices:
                self.ensureCorrectExtraDeviceListLenght()
                                        
                if "extramarkersizes1" in profile:
                    self.qmc.extramarkersizes1 = profile["extramarkersizes1"] + self.qmc.extramarkersizes1[len(profile["extramarkersizes1"]):]
                else:
                    self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*len(self.qmc.extratemp1)
                if "extramarkersizes2" in profile:
                    self.qmc.extramarkersizes2 = profile["extramarkersizes2"] + self.qmc.extramarkersizes2[len(profile["extramarkersizes2"]):]
                else:
                    self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*len(self.qmc.extratemp2)
                if "extramarkers1" in profile:
                    self.qmc.extramarkers1 = [d(x) for x in profile["extramarkers1"]] + self.qmc.extramarkers1[len(profile["extramarkers1"]):]
                else:
                    self.qmc.extramarkers1 = [self.qmc.marker_default]*len(self.qmc.extratemp1)
                if "extramarkers2" in profile:
                    self.qmc.extramarkers2 = [d(x) for x in profile["extramarkers2"]] + self.qmc.extramarkers2[len(profile["extramarkers2"]):]
                else:
                    self.qmc.extramarkers2 = [self.qmc.marker_default]*len(self.qmc.extratemp2)
                if "extralinewidths1" in profile:
                    self.qmc.extralinewidths1 = [int(w) for w in profile["extralinewidths1"]] + self.qmc.extralinewidths1[len(profile["extralinewidths1"]):]
                else:
                    self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default]*len(self.qmc.extratemp1)
                if "extralinewidths2" in profile:
                    self.qmc.extralinewidths2 = [int(w) for w in profile["extralinewidths2"]] + self.qmc.extralinewidths2[len(profile["extralinewidths2"]):]
                else:
                    self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default]*len(self.qmc.extratemp2)
                if "extralinestyles1" in profile:
                    self.qmc.extralinestyles1 = [d(x) for x in profile["extralinestyles1"]] + self.qmc.extralinestyles1[len(profile["extralinestyles1"]):]
                else:
                    self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*len(self.qmc.extratemp1)
                if "extralinestyles2" in profile:
                    self.qmc.extralinestyles2 = [d(x) for x in profile["extralinestyles2"]] + self.qmc.extralinestyles2[len(profile["extralinestyles2"]):]
                else:
                    self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*len(self.qmc.extratemp2)
                if "extradrawstyles1" in profile:
                    self.qmc.extradrawstyles1 = [d(x) for x in profile["extradrawstyles1"]] + self.qmc.extradrawstyles1[len(profile["extradrawstyles1"]):]
                else:
                    self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp1)
                if "extradrawstyles2" in profile:
                    self.qmc.extradrawstyles2 = [d(x) for x in profile["extradrawstyles2"]] + self.qmc.extradrawstyles2[len(profile["extradrawstyles2"]):]
                else:
                    self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*len(self.qmc.extratemp2)
            self.updateExtraLCDvisibility()

# we don't change temp mode anymore on loading a profile
#            old_mode = self.qmc.mode
#            if "mode" in profile:
#                m = str(profile["mode"])
#                #convert modes only if needed comparing the new uploaded mode to the old one.
#                #otherwise it would incorrectly convert the uploaded phases
#                if m == "F" and self.qmc.mode == "C":
#                    self.qmc.fahrenheitMode()
#                if m == "C" and self.qmc.mode == "F":
#                    self.qmc.celsiusMode()

# if auto-adjusted is ticked phases will automatically adjust to the set values in the profile
# we better not load the phases from the profile not to change the user defined phases settings
#            if "phases" in profile:
#                self.qmc.phases = profile["phases"]
            if "flavors" in profile:
                self.qmc.flavors = [max(0,min(10,float(fl))) for fl in profile["flavors"]]
            if "flavorlabels" in profile:
                self.qmc.flavorlabels = toStringList([d(x) for x in profile["flavorlabels"]])
            if len(self.qmc.flavorlabels) > len(self.qmc.flavors):
                # fill with default 5. values
                self.qmc.flavors = self.qmc.flavors + [5.]*(len(self.qmc.flavorlabels)-len(self.qmc.flavors))
            elif len(self.qmc.flavorlabels) < len(self.qmc.flavors):
                # remove superfluous values
                self.qmc.flavors = self.qmc.flavors[:len(self.qmc.flavorlabels)]
            if "flavorstartangle" in profile:
                self.qmc.flavorstartangle = int(profile["flavorstartangle"])
            if "flavoraspect" in profile:
                self.qmc.flavoraspect = float(profile["flavoraspect"])
            else:
                self.qmc.flavoraspect = 1.
            if "title" in profile:
                self.qmc.title = d(profile["title"])
            else:            
                self.qmc.title = QApplication.translate("Scope Title", "Roaster Scope",None)
                
#PLUS
            if "plus_store" in profile:
                self.qmc.plus_store = d(profile["plus_store"])
                if "plus_store_label" in profile:
                    self.qmc.plus_store_label = d(profile["plus_store_label"])
                else:
                    self.qmc.plus_store_label = None
            else:
                self.qmc.plus_store = None
                self.qmc.plus_store_label = None
            if "plus_coffee" in profile:
                self.qmc.plus_coffee = d(profile["plus_coffee"])
                if "plus_coffee_label" in profile:
                    self.qmc.plus_coffee_label = d(profile["plus_coffee_label"])
                else:
                    self.qmc.plus_coffee_label = None
            else:
                self.qmc.plus_coffee = None
                self.qmc.plus_coffee_label = None
            if "plus_blend_spec" in profile:
                # we convert the blend specification from its list to its internal dictionary representation
                self.qmc.plus_blend_spec = plus.stock.list2blend(profile["plus_blend_spec"])
                if "plus_blend_label" in profile:
                    self.qmc.plus_blend_label = d(profile["plus_blend_label"])
                else:
                    self.qmc.plus_blend_label = None
                if "plus_blend_spec_labels" in profile:
                    self.qmc.plus_blend_spec_labels = [d(l) for l in profile["plus_blend_spec_labels"]]
                else:
                    self.qmc.plus_blend_spec_labels = None
            else:
                self.qmc.plus_blend_spec = None
                self.qmc.plus_blend_spec_labels = None
            if "plus_sync_record_hash" in profile:
                self.qmc.plus_sync_record_hash = d(profile["plus_sync_record_hash"])
            else:
                self.qmc.plus_sync_record_hash = None
                
            if "beans" in profile:
                self.qmc.beans = d(profile["beans"])
            else:
                self.qmc.beans = ""
            if "weight" in profile:
                self.qmc.weight = [profile["weight"][0],profile["weight"][1],d(profile["weight"][2])]
            else:
                self.qmc.weight = [0,0,"g"]
            if "volume" in profile:
                self.qmc.volume = profile["volume"]
            else:
                self.qmc.volume = [0,0,"l"]
            if "density" in profile:
                self.qmc.density = [profile["density"][0],d(profile["density"][1]),profile["density"][2],d(profile["density"][3])]
            else:
                self.qmc.density = [0,"g",1,"l"]
            if "density_roasted" in profile:
                self.qmc.density_roasted = [profile["density_roasted"][0],d(profile["density_roasted"][1]),profile["density_roasted"][2],d(profile["density_roasted"][3])]
            else:
                self.qmc.density_roasted = [0,"g",1,"l"]
            if "roastertype" in profile:
                self.qmc.roastertype = d(profile["roastertype"])
            else:
                self.qmc.roastertype = ""
            if "operator" in profile:
                self.qmc.operator = d(profile["operator"])
            else:
                self.qmc.operator = ""
            if "drumspeed" in profile:
                self.qmc.drumspeed = d(profile["drumspeed"])
            else:
                self.qmc.drumspeed = ""
            if "beansize" in profile:
                # we map beansize in mm to beansize_max in 1/64"
                try:            
                    self.qmc.beansize_max = int(round(float(profile["beansize"]) * 0.0393701 * 61))
                except:
                    pass
            if "beansize_min" in profile:
                self.qmc.beansize_min = float(profile["beansize_min"])
            else:
                self.qmc.beansize_min = 0
            if "beansize_max" in profile:
                self.qmc.beansize_max = float(profile["beansize_max"])
            else:
                self.qmc.beansize_max = 0
            if "heavyFC" in profile:
                self.qmc.heavyFC_flag = profile["heavyFC"]
            if "lowFC" in profile:
                self.qmc.lowFC_flag = profile["lowFC"]
            if "lightCut" in profile:
                self.qmc.lightCut_flag = profile["lightCut"]
            if "darkCut" in profile:
                self.qmc.darkCut_flag = profile["darkCut"]
            if "drops" in profile:
                self.qmc.drops_flag = profile["drops"]
            if "oily" in profile:
                self.qmc.oily_flag = profile["oily"]
            if "uneven" in profile:
                self.qmc.uneven_flag = profile["uneven"]
            if "tipping" in profile:
                self.qmc.tipping_flag = profile["tipping"]
            if "scorching" in profile:
                self.qmc.scorching_flag = profile["scorching"]
            if "divots" in profile:
                self.qmc.divots_flag = profile["divots"]
            # color
            if "whole_color" in profile:
                self.qmc.whole_color = profile["whole_color"]
            if "ground_color" in profile:
                self.qmc.ground_color = profile["ground_color"]
            if "color_system" in profile and profile["color_system"] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(profile["color_system"])
            if "volumeCalcWeightIn" in profile:
                self.qmc.volumeCalcWeightInStr = profile["volumeCalcWeightIn"]
            if "volumeCalcWeightOut" in profile:
                self.qmc.volumeCalcWeightOutStr = profile["volumeCalcWeightOut"]
            # for compatibility with older profiles:
            if "roastdate" in profile:
                try:
                    date = QDate.fromString(d(profile["roastdate"]))
                    if "roasttime" in profile:
                        try:
                            time = QTime.fromString(d(profile["roasttime"]))
                            self.qmc.roastdate = QDateTime(date,time)
                        except Exception:
                            self.qmc.roastdate = QDateTime(date)
                    else:
                        self.qmc.roastdate = QDateTime(date)
                except Exception:
                    pass
            # the new dates have the locale independent isodate format:
            if "roastisodate" in profile:
                try:
                    date = QDate.fromString(d(profile["roastisodate"]),Qt.ISODate)
                    if "roasttime" in profile:
                        try:
                            time = QTime.fromString(d(profile["roasttime"]))
                            self.qmc.roastdate = QDateTime(date,time)
                        except Exception:
                            self.qmc.roastdate = QDateTime(date)
                    else:
                        self.qmc.roastdate = QDateTime(date)
                except Exception:
                    pass
            if "roastepoch" in profile:
                try:
                    self.qmc.roastdate = QDateTime.fromTime_t(profile["roastepoch"])
                except Exception:
                    pass
            if "roastUUID" in profile:
                self.qmc.roastUUID = d(profile["roastUUID"])
            else:
                self.qmc.roastUUID = uuid.uuid4().hex # generate UUID
                self.qmc.fileDirty()
            if "roastbatchnr" in profile:
                try:
                    self.qmc.roastbatchnr = int(profile["roastbatchnr"])
                except:
                    pass
                self.qmc.roastbatchprefix = d(profile["roastbatchprefix"])
                try:
                    self.qmc.roastbatchpos = int(profile["roastbatchpos"])
                except:
                    pass
            if "specialevents" in profile:
                self.qmc.specialevents = profile["specialevents"]
            else:
                self.qmc.specialevents = []
            if "specialeventstype" in profile:
                self.qmc.specialeventstype = profile["specialeventstype"]
            else:  
                self.qmc.specialeventstype = []
            if "specialeventsvalue" in profile:
                self.qmc.specialeventsvalue = profile["specialeventsvalue"]
            else:
                self.qmc.specialeventsvalue = []
            if "specialeventsStrings" in profile:
                self.qmc.specialeventsStrings = [d(x) for x in profile["specialeventsStrings"]]
            else:
                self.qmc.specialeventsStrings = []
            if "etypes" in profile:
                self.qmc.etypes = [d(x) for x in profile["etypes"]]
                
            if "roastingnotes" in profile:
                self.qmc.roastingnotes = d(profile["roastingnotes"])
            else:
                self.qmc.roastingnotes = ""
            if "cuppingnotes" in profile:
                self.qmc.cuppingnotes = d(profile["cuppingnotes"])
            else:
                self.qmc.cuppingnotes = ""
            if "timex" in profile:
                self.qmc.timex = profile["timex"]
                
            # alarms
            if self.qmc.loadalarmsfromprofile:
                self.loadAlarmsFromProfile(filename,profile)
                
            if "extraNoneTempHint1" in profile:
                self.qmc.extraNoneTempHint1 = profile["extraNoneTempHint1"]
            else:
                self.qmc.extraNoneTempHint1 = []
            if "extraNoneTempHint2" in profile:
                self.qmc.extraNoneTempHint2 = profile["extraNoneTempHint2"]
            else:
                self.qmc.extraNoneTempHint2 = []
                
            if "mode" in profile:
                m = str(profile["mode"]) 
            else:
                m = self.qmc.mode
            if "temp1" in profile:
                self.qmc.temp1 = profile["temp1"]
            if "temp2" in profile:
                self.qmc.temp2 = profile["temp2"] 
            if "ambientTemp" in profile:
                self.qmc.ambientTemp = profile["ambientTemp"]
            if "greens_temp" in profile:
                self.qmc.greens_temp = profile["greens_temp"]
            else:
                self.qmc.greens_temp = 0.
                
            if self.qmc.mode == "C" and m == "F":
                self.qmc.temp1 = [self.qmc.fromFtoC(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [self.qmc.fromFtoC(t) for t in self.qmc.temp2]
                for e in range(len(self.qmc.extratimex)):
                    if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                        self.qmc.extratemp1[e] = [self.qmc.fromFtoC(t) for t in self.qmc.extratemp1[e]]
                    if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                        self.qmc.extratemp2[e] = [self.qmc.fromFtoC(t) for t in self.qmc.extratemp2[e]]
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = self.qmc.fromFtoC(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and "alarmtemperature" in profile:
                    self.qmc.alarmtemperature = [(self.qmc.fromFtoC(t) if t != 500 else t) for t in self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = self.qmc.fromFtoC(self.qmc.greens_temp)
                self.qmc.fileDirty()
            elif self.qmc.mode == "F" and m == "C":
                self.qmc.temp1 = [self.qmc.fromCtoF(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [self.qmc.fromCtoF(t) for t in self.qmc.temp2]
                for e in range(len(self.qmc.extratimex)):
                    if not (len(aw.qmc.extraNoneTempHint1) > e and aw.qmc.extraNoneTempHint1[e]):
                        self.qmc.extratemp1[e] = [self.qmc.fromCtoF(t) for t in self.qmc.extratemp1[e]]
                    if not (len(aw.qmc.extraNoneTempHint2) > e and aw.qmc.extraNoneTempHint2[e]):
                        self.qmc.extratemp2[e] = [self.qmc.fromCtoF(t) for t in self.qmc.extratemp2[e]]
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = self.qmc.fromCtoF(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and "alarmtemperature" in profile:
                    self.qmc.alarmtemperature = [self.qmc.fromCtoF(t) for t in self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = self.qmc.fromCtoF(self.qmc.greens_temp)
                self.qmc.fileDirty()
            elif self.qmc.loadaxisfromprofile:
                # only if the temperature mode of the profile equals to our current mode, and loadfromprofile is ticked, we respect the temp/RoR axis limits
                if "zmax" in profile:
                    self.qmc.zlimit = min(int(profile["zmax"]),self.qmc.zlimit_max)
                if "zmin" in profile:
                    self.qmc.zlimit_min = max(min(int(profile["zmin"]),self.qmc.zlimit),self.qmc.zlimit_min_max)
                if "ymax" in profile:
                    self.qmc.ylimit = min(int(profile["ymax"]),self.qmc.ylimit_max)
                if "ymin" in profile:
                    self.qmc.ylimit_min = max(min(int(profile["ymin"]),self.qmc.ylimit),self.qmc.ylimit_min_max)
            if not self.qmc.locktimex and self.qmc.loadaxisfromprofile:
                # otherwise don't let the users y/z min/max axis limits be overwritten by loading a profile
                if "xmin" in profile:
                    self.qmc.startofx = float(profile["xmin"])
                if "xmax" in profile:
                    self.qmc.endofx = float(profile["xmax"])
                else:
                    #Set the xlimits
                    if self.qmc.timex:
                        self.qmc.endofx = self.qmc.timex[-1] + 40
            if "ambient_humidity" in profile:
                self.qmc.ambient_humidity = profile["ambient_humidity"]
            if "ambient_pressure" in profile:
                self.qmc.ambient_pressure = profile["ambient_pressure"]
            if "moisture_greens" in profile:
                self.qmc.moisture_greens = profile["moisture_greens"]
            else:
                self.qmc.moisture_greens = 0.
            if "moisture_roasted" in profile:
                self.qmc.moisture_roasted = profile["moisture_roasted"]
            else:
                self.qmc.moisture_roasted = 0.
            # only load annotations position if the temperature mode did not change
            if "anno_positions" in profile and self.qmc.mode == m:
                self.qmc.setAnnoPositions(profile["anno_positions"])
            if "flag_positions" in profile and self.qmc.mode == m:
                self.qmc.setFlagPositions(profile["flag_positions"])
            if "legendloc_pos" in profile:
                try:
                    # if available we transform the custom legend position back from data into axis coordinates
                    legendloc_pos_data = numpy.array(profile["legendloc_pos"])
                    axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                    data_to_axis = axis_to_data.inverted()
                    pos = data_to_axis.transform(legendloc_pos_data)
                    self.qmc.legendloc_pos = (pos[0],pos[1])
                except:
                    pass
            
# we load external programs only from app settings
#            if "externalprogram" in profile:
#                self.ser.externalprogram = d(profile["externalprogram"])
#            if "externaloutprogram" in profile:
#                self.ser.externaloutprogram = d(profile["externaloutprogram"])
            if "samplinginterval" in profile:
                # derive aw.qmc.deltaBTsamples from aw.qmc.deltaBTspan and the sampling interval of the profile
                self.qmc.profile_sampling_interval = profile["samplinginterval"]
                self.qmc.updateDeltaSamples()
            # Ramp/Soak Profiles
            if aw.pidcontrol.loadRampSoakFromProfile:
                if "svValues" in profile:
                    aw.pidcontrol.svValues = [int(x) for x in profile["svValues"]]
                if "svRamps" in profile:
                    aw.pidcontrol.svRamps = [int(x) for x in profile["svRamps"]]
                if "svSoaks" in profile:
                    aw.pidcontrol.svSoaks = [int(x) for x in profile["svSoaks"]]
            if "timeindex" in profile:
                self.qmc.timeindex = profile["timeindex"]
                if self.qmc.locktimex:
                    if self.qmc.timeindex[0] != -1:
                        self.qmc.startofx = self.qmc.timex[aw.qmc.timeindex[0]] + self.qmc.locktimex_start
                    else:
                        self.qmc.startofx = self.qmc.locktimex_start
            elif len(profile) > 0 and ("startend" in profile or "dryend" in profile or "cracks" in profile):
                ###########      OLD PROFILE FORMAT
                if "startend" in profile:
                    startend = [float(fl) for fl in profile["startend"]]
                else:
                    startend = [0.,0.,0.,0.]
                if "dryend" in profile:
                    dryend = profile["dryend"]
                else:
                    dryend = [0.,0.]
                if "cracks" in profile:
                    varC = [float(fl) for fl in profile["cracks"]]
                else:
                    varC = [0.,0.,0.,0.,0.,0.,0.,0.]
                times = []
                times.append(startend[0])
                times.append(dryend[0])
                times.append(varC[0])
                times.append(varC[2])
                times.append(varC[4])
                times.append(varC[6])
                times.append(startend[2])
                #convert to new profile
                self.qmc.timeindexupdate(times)
                ###########      END OLD PROFILE FORMAT
            # update phases if phases are set to auto ajusted
            if aw.qmc.phasesbuttonflag:
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            # ensure that timeindex has the proper length
            self.qmc.timeindex = self.qmc.timeindex + [0 for _ in range(8-len(self.qmc.timeindex))]
            # reset linecount caches
            aw.qmc.resetlinecountcaches()
            # try to reload background profile
            if (not quiet) and "backgroundpath" in profile and d(profile["backgroundpath"]) != "":
                self.qmc.backgroundpath = d(profile["backgroundpath"])
                if os.path.isfile(self.qmc.backgroundpath):
                    aw.loadbackground(u(self.qmc.backgroundpath))
                    aw.qmc.background = True
                    aw.qmc.timealign(redraw=False) # there will be a later redraw triggered that also recomputes the deltas
                else:
                    self.deleteBackground() # delete a loaded background if any
            aw.autoAdjustAxis()
            return True
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            # we don't report errors on settingsLoad
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate("Error Message", "Exception:",None) + " setProfile()",str(ex) + "@line " + str(exc_tb.tb_lineno))
            return False

    def weightVolumeDigits(self,v):
        if v >= 1000:
            return 1
        elif v >= 100:
            return 2
        elif v >= 10:
            return 3
        else:
            return 4

    def float2floatWeightVolume(self,v):
        d = self.weightVolumeDigits(v)
        return self.float2float(v,d)
    
    # the int n specifies the number of digits
    def float2float(self,f,n=1):
        if f is None:
            return None
        else:
            if n==0:
                if math.isnan(f):
                    return 0
                else:
                    return int(round(f))
            else:
                res = float(("%." + str(n) + "f")%f)
                if math.isnan(res):
                    return 0.0
                else:
                    return res

    # returns data that is computed by Artisan out of raw profile data using some formulas 
    # and displayed to users e.g. as part of the Report to users and stored along profiles to be used by external programs
    # in case a value cannot be computed the corresponding entry is missing in the resulting dict
    def computedProfileInformation(self):
        computedProfile = {}
        TP_time_idx = None
        DRY_time_idx = None
        try:
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
                computedProfile["CHARGE_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[0]])
                computedProfile["CHARGE_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[0]])
            else:
                start = 0
            ######### TP #########
            # calc TP_time_idx (index of TP; is None if unknown)
            TP_index = self.findTP() # could return -1
            if TP_index > 0 and len(self.qmc.timex) > 0:
                TP_time_idx = TP_index
            else:
                if len(self.qmc.timex) > 0:
                    TP_time_idx = 0
                else:
                    TP_time_idx = None
            if TP_time_idx:
                computedProfile["TP_time"] = self.float2float(self.qmc.timex[TP_time_idx] - start)
                computedProfile["TP_ET"] = self.float2float(self.qmc.temp1[TP_time_idx])
                computedProfile["TP_BT"] = self.float2float(self.qmc.temp2[TP_time_idx])
                if self.qmc.timeindex[6]:
                    relevant_ETs = self.qmc.temp1[TP_time_idx:self.qmc.timeindex[6]]
                    if relevant_ETs: # relevant_ETs might be the empty list!
                        computedProfile["MET"] = self.float2float(max(relevant_ETs))
            ######### DRY #########
            # calc DRY_time_idx (index of DRY; is None if unknown)
            if self.qmc.timeindex[1] and aw.qmc.phasesbuttonflag:
                #manual dryend available
                DRY_time_idx = self.qmc.timeindex[1]
            else:
                dryEndIndex = self.findDryEnd(TP_index)  # use TP_index to avoid recomputation of TP if it failed before
                #we use the dryEndIndex respecting the dry phase
                if dryEndIndex > 0 and dryEndIndex < len(self.qmc.timex):
                    DRY_time_idx = dryEndIndex 
                else:
                    DRY_time_idx = None
            if DRY_time_idx:
                computedProfile["DRY_time"] = self.float2float(self.qmc.timex[DRY_time_idx] - start)
                computedProfile["DRY_ET"] = self.float2float(self.qmc.temp1[DRY_time_idx])
                computedProfile["DRY_BT"] = self.float2float(self.qmc.temp2[DRY_time_idx])
            ######### FC #########
            if self.qmc.timeindex[2]:
                computedProfile["FCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[2]] - start)
                computedProfile["FCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[2]])
                computedProfile["FCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[2]])
            if self.qmc.timeindex[3]:
                computedProfile["FCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[3]] - start)
                computedProfile["FCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[3]])
                computedProfile["FCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[3]])
            ######### SC #########
            if self.qmc.timeindex[4]:
                computedProfile["SCs_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[4]] - start)
                computedProfile["SCs_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[4]])
                computedProfile["SCs_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[4]])
            if self.qmc.timeindex[5]:
                computedProfile["SCe_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[5]] - start)
                computedProfile["SCe_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[5]])
                computedProfile["SCe_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[5]])
            ######### DROP #########
            if self.qmc.timeindex[6]:
                computedProfile["DROP_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[6]] - start)
                computedProfile["DROP_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[6]])
                computedProfile["DROP_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[6]])
            ######### COOL #########
            if self.qmc.timeindex[7]:
                computedProfile["COOL_time"] = self.float2float(self.qmc.timex[self.qmc.timeindex[7]] - start)
                computedProfile["COOL_ET"] = self.float2float(self.qmc.temp1[self.qmc.timeindex[7]])
                computedProfile["COOL_BT"] = self.float2float(self.qmc.temp2[self.qmc.timeindex[7]])
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " computedProfileInformation() {0}").format(str(ex)),exc_tb.tb_lineno)        
        ######### Phases #########
        try:
            # we calcuate the statistics here as the profile might not have yet been rendered and thus the statistics are not yet computed
            _,statisticstimes = self.qmc.calcStatistics(TP_index)
            if statisticstimes[0]:
                computedProfile["totaltime"] = aw.float2float(statisticstimes[0],3)
            if statisticstimes[1]:
                computedProfile["dryphasetime"] = aw.float2float(statisticstimes[1],3)
            if statisticstimes[2]:
                computedProfile["midphasetime"] = aw.float2float(statisticstimes[2],3)
            if statisticstimes[3]:
                computedProfile["finishphasetime"] = aw.float2float(statisticstimes[3],3)
            if statisticstimes[4]:
                computedProfile["coolphasetime"] = aw.float2float(statisticstimes[4],3)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " computedProfileInformation() {0}").format(str(ex)),exc_tb.tb_lineno)
        ######### RoR ######### 
        try:
            if TP_time_idx and DRY_time_idx:
                ror = self.RoR(TP_time_idx,DRY_time_idx)
                computedProfile["dry_phase_ror"] = self.float2float(ror[0])
                computedProfile["mid_phase_ror"] = self.float2float(ror[1])
                computedProfile["finish_phase_ror"] = self.float2float(ror[2])
                if "TP_BT" in computedProfile and "TP_time" in computedProfile and "DROP_BT" in computedProfile and "DROP_time" in computedProfile and \
                    (computedProfile["DROP_time"]-computedProfile["TP_time"]) != 0:
                    computedProfile["total_ror"] = self.float2float(((computedProfile["DROP_BT"]-computedProfile["TP_BT"])/(computedProfile["DROP_time"]-computedProfile["TP_time"]))*60.)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " computedProfileInformation() {0}").format(str(ex)),exc_tb.tb_lineno)
        ######### ETBTarea #########
        try:
            ts,tse,tsb,_ = aw.ts(self.qmc.timeindex[0],self.qmc.timeindex[6])
            computedProfile["total_ts"] = self.float2float(ts,0)
            computedProfile["total_ts_ET"] = self.float2float(tse,0)
            computedProfile["total_ts_BT"] = self.float2float(tsb,0)
        except Exception:
            pass
        ######### AUC area #########
        try:
            _,_,tsb,_ = aw.ts()   
            computedProfile["AUC"] = self.float2float(tsb,0)
            computedProfile["AUCbegin"] = ""
            computedProfile["AUCbase"] = self.float2float(aw.qmc.AUCbase,0)
            computedProfile["AUCfromeventflag"] = int(aw.qmc.AUCbaseFlag)
            if (aw.qmc.AUCbegin == 0):
                computedProfile["AUCbegin"] = "CHARGE"
                if aw.qmc.AUCbaseFlag:  # base AUC is taken from BT at AUCbegin event
                    computedProfile["AUCbase"] = computedProfile["CHARGE_BT"]
            elif (aw.qmc.AUCbegin == 1):
                computedProfile["AUCbegin"] = "TP"
                if aw.qmc.AUCbaseFlag:  # base AUC is taken from BT at AUCbegin event
                    computedProfile["AUCbase"] = computedProfile["TP_BT"]
            elif (aw.qmc.AUCbegin == 2):
                computedProfile["AUCbegin"] = "DE"
                if aw.qmc.AUCbaseFlag:  # base AUC is taken from BT at AUCbegin event
                    computedProfile["AUCbase"] = computedProfile["DRY_BT"]
            elif (aw.qmc.AUCbegin == 3):
                computedProfile["AUCbegin"] = "FCs"
                if aw.qmc.AUCbaseFlag:  # base AUC is taken from BT at AUCbegin event
                    computedProfile["AUCbase"] = computedProfile["FCs_BT"]
        except Exception:
            pass
        try:
            _,_,ts1b,_ = aw.ts(self.qmc.timeindex[0],DRY_time_idx)
            computedProfile["dry_phase_AUC"] = self.float2float(ts1b,0)
        except Exception:
            pass
        try:
            _,_,ts2b,_ = aw.ts(DRY_time_idx,self.qmc.timeindex[2])
            computedProfile["mid_phase_AUC"] = self.float2float(ts2b,0)
        except Exception:
            pass
        try:
            _,_,ts3b,_ = aw.ts(self.qmc.timeindex[2],self.qmc.timeindex[6])
            computedProfile["finish_phase_AUC"] = self.float2float(ts3b,0)
        except Exception:
            pass
        ######### Weight, Volume, Loss, Gain, Density #########
        try:
            volumein = self.qmc.volume[0]
            volumeout = self.qmc.volume[1]
            weightin = self.qmc.weight[0]
            weightout = self.qmc.weight[1]
            weight_loss = self.weight_loss(weightin,weightout)
            volume_gain = self.volume_increase(volumein,volumeout)
            if weight_loss:
                computedProfile["weight_loss"] = self.float2float(weight_loss)
            if volume_gain:
                computedProfile["volume_gain"] = self.float2float(volume_gain)
            if self.qmc.moisture_greens and self.qmc.moisture_roasted:
                moisture_loss = self.qmc.moisture_greens - self.qmc.moisture_roasted
                computedProfile["moisture_loss"] = self.float2float(moisture_loss)
                if weight_loss:
                    computedProfile["organic_loss"] = self.float2float(weight_loss - moisture_loss)
            din = dout = 0
            # standardize unit of volume and weight to l and g
            if volumein != 0.0 and volumeout != 0.0:
                volumein = self.float2float(aw.convertVolume(volumein,aw.qmc.volume_units.index(aw.qmc.volume[2]),0),4) # in l
                volumeout = self.float2float(aw.convertVolume(volumeout,aw.qmc.volume_units.index(aw.qmc.volume[2]),0),4) # in l
            # store volume in l
            computedProfile["volumein"] = volumein
            computedProfile["volumeout"] = volumeout
            # store weight in kg
            if weightin != 0.0 and weightout != 0.0:
                weightin = self.float2float(aw.convertWeight(weightin,aw.qmc.weight_units.index(aw.qmc.weight[2]),0),1) # in g
                weightout = self.float2float(aw.convertWeight(weightout,aw.qmc.weight_units.index(aw.qmc.weight[2]),0),1) # in g
            computedProfile["weightin"] = weightin
            computedProfile["weightout"] = weightout
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                din = (weightin / volumein) 
                dout = (weightout / volumeout)
            if din > 0.:
                computedProfile["green_density"] = self.float2float(din,1)
            if dout > 0.:
                computedProfile["roasted_density"] = self.float2float(dout,1)
                
            if (aw.qmc.density[0] != 0.0 and aw.qmc.density[2] != 0.0):
                setdensity = aw.qmc.density[0] /  aw.qmc.density[2]
                setdensity = aw.convertWeight(aw.qmc.density[0],aw.qmc.weight_units.index(aw.qmc.density[1]),0) / aw.convertVolume(aw.qmc.density[2],aw.qmc.volume_units.index(aw.qmc.density[3]),0)
                computedProfile["set_density"] = self.float2float(setdensity,1)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " computedProfileInformation() {0}").format(str(ex)),exc_tb.tb_lineno)                
        ######### Humidity / Pressure #########
        try:
            if aw.qmc.moisture_greens != 0.0 and not math.isnan(aw.qmc.moisture_greens):
                computedProfile["moisture_greens"] = self.float2float(aw.qmc.moisture_greens)
            if aw.qmc.moisture_roasted != 0.0 and not math.isnan(aw.qmc.moisture_roasted):
                computedProfile["moisture_roasted"] = self.float2float(aw.qmc.moisture_roasted)
            if aw.qmc.ambient_humidity != 0.0 and not math.isnan(aw.qmc.ambient_humidity):
                computedProfile["ambient_humidity"] = self.float2float(aw.qmc.ambient_humidity)
            if aw.qmc.ambient_pressure != 0.0 and not math.isnan(aw.qmc.ambient_pressure):
                computedProfile["ambient_pressure"] = self.float2float(aw.qmc.ambient_pressure)
            if aw.qmc.ambientTemp != 0.0 and not math.isnan(aw.qmc.ambientTemp):
                computedProfile["ambient_temperature"] = self.float2float(aw.qmc.ambientTemp)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " computedProfileInformation() {0}").format(str(ex)),exc_tb.tb_lineno)
        ######### Similarity #########
        try:
            det,dbt = aw.curveSimilarity(aw.qmc.phases[1])
            if det is not None and not math.isnan(det):
                computedProfile["det"] = det
            if dbt is not None and not math.isnan(dbt):
                computedProfile["dbt"] = dbt
        except Exception:
            pass
        ######### RETURN #########
        return computedProfile

    #used by filesave()
    #wrap values in unicode(.) if and only if those are of type string
    def getProfile(self):
        try:
            profile = {}
            profile["version"] = str(__version__)
            profile["revision"] = str(__revision__)
            profile["build"] = str(__build__)
            os,os_version = self.get_os()
            profile["artisan_os"] = os
            profile["artisan_os_version"] = os_version
            profile["mode"] = self.qmc.mode
            profile["timeindex"] = self.qmc.timeindex
            profile["flavors"] = self.qmc.flavors
            profile["flavorlabels"] = [encodeLocal(fl) for fl in self.qmc.flavorlabels]
            profile["flavorstartangle"] = self.qmc.flavorstartangle
            profile["flavoraspect"] = self.qmc.flavoraspect
            profile["title"] = encodeLocal(self.qmc.title)
            
#PLUS
            if self.qmc.plus_store is not None:
                profile["plus_store"] = encodeLocal(self.qmc.plus_store)
                if self.qmc.plus_store_label is not None:
                    profile["plus_store_label"] = encodeLocal(self.qmc.plus_store_label)
            if self.qmc.plus_coffee is not None:
                profile["plus_coffee"] = encodeLocal(self.qmc.plus_coffee)
                if self.qmc.plus_coffee_label is not None:
                    profile["plus_coffee_label"] = encodeLocal(self.qmc.plus_coffee_label)
            if self.qmc.plus_blend_spec is not None:
                # we convert the internal blend dictionary specification to the external list specification
                profile["plus_blend_spec"] = plus.stock.blend2list(self.qmc.plus_blend_spec)
                profile["plus_blend_label"] = encodeLocal(self.qmc.plus_blend_label) 
                if self.qmc.plus_blend_spec_labels is not None:
                    profile["plus_blend_spec_labels"] = [encodeLocal(l) for l in self.qmc.plus_blend_spec_labels]
                        
            profile["beans"] = encodeLocal(self.qmc.beans)
            profile["weight"] = [self.qmc.weight[0],self.qmc.weight[1],encodeLocal(self.qmc.weight[2])]
            profile["volume"] = [self.qmc.volume[0],self.qmc.volume[1],encodeLocal(self.qmc.volume[2])]
            profile["density"] = [self.qmc.density[0],encodeLocal(self.qmc.density[1]),self.qmc.density[2],encodeLocal(self.qmc.density[3])]
            profile["density_roasted"] = [self.qmc.density_roasted[0],encodeLocal(self.qmc.density_roasted[1]),self.qmc.density_roasted[2],encodeLocal(self.qmc.density_roasted[3])]
            profile["roastertype"] = encodeLocal(self.qmc.roastertype)
            profile["machinesetup"] = encodeLocal(self.qmc.machinesetup)
            profile["operator"] = encodeLocal(self.qmc.operator)
            profile["drumspeed"] = self.qmc.drumspeed
            profile["heavyFC"] = self.qmc.heavyFC_flag
            profile["lowFC"] = self.qmc.lowFC_flag
            profile["lightCut"] = self.qmc.lightCut_flag
            profile["darkCut"] = self.qmc.darkCut_flag
            profile["drops"] = self.qmc.drops_flag
            profile["oily"] = self.qmc.oily_flag
            profile["uneven"] = self.qmc.uneven_flag
            profile["tipping"] = self.qmc.tipping_flag
            profile["scorching"] = self.qmc.scorching_flag
            profile["divots"] = self.qmc.divots_flag
            profile["whole_color"] = self.qmc.whole_color
            profile["ground_color"] = self.qmc.ground_color
            profile["color_system"] = self.qmc.color_systems[self.qmc.color_system_idx]
            profile["volumeCalcWeightIn"] = str(self.qmc.volumeCalcWeightInStr)
            profile["volumeCalcWeightOut"] = str(self.qmc.volumeCalcWeightOutStr)
            # write roastdate that respects locale and potential cannot be read in under a different locale (just for compatibility to older versions)
            try:
                profile["roastdate"] = encodeLocal(self.qmc.roastdate.date().toString())
            except Exception:
                pass
            # write ISO roast date
            try:
                profile["roastisodate"] = encodeLocal(self.qmc.roastdate.date().toString(Qt.ISODate))
            except Exception:
                pass
            # write roast time
            try:
                profile["roasttime"] = encodeLocal(self.qmc.roastdate.time().toString())
                profile["roastepoch"] = int(self.qmc.roastdate.toTime_t())
                profile["roasttzoffset"] = self.qmc.roasttzoffset
            except Exception:
                pass
            profile["roastbatchnr"] = self.qmc.roastbatchnr
            profile["roastbatchprefix"] = encodeLocal(u(self.qmc.roastbatchprefix))
            profile["roastbatchpos"] = self.qmc.roastbatchpos
            if self.qmc.roastUUID is None:
                self.qmc.roastUUID = uuid.uuid4().hex # generate UUID
            profile["roastUUID"] = self.qmc.roastUUID
            profile["beansize"] = str(self.qmc.beansize)
            profile["beansize_min"] = str(self.qmc.beansize_min)
            profile["beansize_max"] = str(self.qmc.beansize_max)
            profile["specialevents"] = self.qmc.specialevents
            profile["specialeventstype"] = self.qmc.specialeventstype
            profile["specialeventsvalue"] = self.qmc.specialeventsvalue
            profile["specialeventsStrings"] = [encodeLocal(ses) for ses in self.qmc.specialeventsStrings]
            profile["etypes"] = [encodeLocal(et) for et in self.qmc.etypes]
            profile["roastingnotes"] = encodeLocal(self.qmc.roastingnotes)
            profile["cuppingnotes"] = encodeLocal(self.qmc.cuppingnotes)
            profile["timex"] = [self.float2float(x,10) for x in self.qmc.timex]
            profile["temp1"] = [self.float2float(x,8) for x in self.qmc.temp1]
            profile["temp2"] = [self.float2float(x,8) for x in self.qmc.temp2]
            profile["phases"] = self.qmc.phases
            profile["zmax"] = int(self.qmc.zlimit)
            profile["zmin"] = int(self.qmc.zlimit_min)
            profile["ymax"] = int(self.qmc.ylimit)
            profile["ymin"] = int(self.qmc.ylimit_min)
            profile["xmin"] = float(self.qmc.startofx)
            profile["xmax"] = float(self.qmc.endofx)
            profile["ambientTemp"] = self.qmc.ambientTemp
            profile["ambient_humidity"] = self.qmc.ambient_humidity
            profile["ambient_pressure"] = self.qmc.ambient_pressure
            profile["moisture_greens"] = self.qmc.moisture_greens
            profile["greens_temp"] = self.qmc.greens_temp
            profile["moisture_roasted"] = self.qmc.moisture_roasted
            profile["extradevices"] = self.qmc.extradevices
            profile["extraname1"] = [encodeLocal(n) for n in self.qmc.extraname1]
            profile["extraname2"] = [encodeLocal(n) for n in self.qmc.extraname2]
            profile["extratimex"] = [[self.float2float(t,8) for t in x] for x in self.qmc.extratimex]
            profile["extratemp1"] = [[self.float2float(t,6) for t in x] for x in self.qmc.extratemp1]
            profile["extratemp2"] = [[self.float2float(t,6) for t in x] for x in self.qmc.extratemp2]
            profile["extramathexpression1"] = [encodeLocal(x) for x in self.qmc.extramathexpression1]
            profile["extramathexpression2"] = [encodeLocal(x) for x in self.qmc.extramathexpression2]
            profile["extradevicecolor1"] = [encodeLocal(x) for x in self.qmc.extradevicecolor1]
            profile["extradevicecolor2"] = [encodeLocal(x) for x in self.qmc.extradevicecolor2]
            profile["extramarkersizes1"] = self.qmc.extramarkersizes1
            profile["extramarkersizes2"] = self.qmc.extramarkersizes2
            profile["extramarkers1"] = [encodeLocal(x) for x in self.qmc.extramarkers1]
            profile["extramarkers2"] = [encodeLocal(x) for x in self.qmc.extramarkers2]
            profile["extralinewidths1"] = self.qmc.extralinewidths1
            profile["extralinewidths2"] = self.qmc.extralinewidths2
            profile["extralinestyles1"] = [encodeLocal(x) for x in self.qmc.extralinestyles1]
            profile["extralinestyles2"] = [encodeLocal(x) for x in self.qmc.extralinestyles2]
            profile["extradrawstyles1"] = [encodeLocal(x) for x in self.qmc.extradrawstyles1]
            profile["extradrawstyles2"] = [encodeLocal(x) for x in self.qmc.extradrawstyles2]
            profile["externalprogram"] = encodeLocal(self.ser.externalprogram)
            profile["externaloutprogram"] = encodeLocal(self.ser.externaloutprogram)
            profile["extraNoneTempHint1"] = self.qmc.extraNoneTempHint1
            profile["extraNoneTempHint2"] = self.qmc.extraNoneTempHint2
            #alarms
            profile["alarmflag"] = self.qmc.alarmflag
            profile["alarmguard"] = self.qmc.alarmguard
            profile["alarmnegguard"] = self.qmc.alarmnegguard
            profile["alarmtime"] = self.qmc.alarmtime
            profile["alarmoffset"] = self.qmc.alarmoffset
            profile["alarmcond"] = self.qmc.alarmcond
            profile["alarmsource"] = self.qmc.alarmsource
            profile["alarmtemperature"] = self.qmc.alarmtemperature
            profile["alarmaction"] = self.qmc.alarmaction
            profile["alarmbeep"] = self.qmc.alarmbeep
            profile["alarmstrings"] = [encodeLocal(x) for x in self.qmc.alarmstrings]
            # remember background profile path and UUID
            profile["backgroundpath"] = encodeLocal(self.qmc.backgroundpath)
            if self.qmc.backgroundUUID is not None:
                profile["backgroundUUID"] = self.qmc.backgroundUUID
            #write only:
            profile["samplinginterval"] = self.qmc.profile_sampling_interval
            profile["oversampling"] = self.qmc.oversampling
            profile["svValues"] = aw.pidcontrol.svValues
            profile["svRamps"] = aw.pidcontrol.svRamps
            profile["svSoaks"] = aw.pidcontrol.svSoaks
            try:
                ds = list(self.qmc.extradevices)
                ds.insert(0,self.qmc.device)
                profile["devices"] = [self.qmc.devices[d-1] for d in ds]
            except Exception as ex:
                pass
            profile["elevation"] = self.qmc.elevation
            profile["computed"] = self.computedProfileInformation()
            # add positions of main event annotations and custom event flags
            profile["anno_positions"] = self.qmc.getAnnoPositions()
            profile["flag_positions"] = self.qmc.getFlagPositions()
            if self.qmc.legend is not None and not isinstance(self.qmc.legend._loc, int):
                # if a legend is currently drawn and has a custom position we save its position in data coordinates
                try:
                    axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                    profile["legendloc_pos"] = axis_to_data.transform(self.qmc.legend._loc).tolist()
                except:
                    pass
            return profile
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " getProfile(): {0}").format(str(ex)),exc_tb.tb_lineno)
            return None

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_current_action(self,_=False):
        self.fileSave(self.curFile)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_new_action(self,_=False):
        self.fileSave(None)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_copy_action(self,_=False):
        self.fileSave(None,copy=True)
    
    #saves recorded profile in hard drive. Called from file menu 
    # returns True if file was saved successfully
    # if copy is True, a new UUID is generated to be saved along the file
    def fileSave(self,fname,copy=False):
        try:
            filename = fname
            if not filename:
                path = QDir()
                path.setPath(self.getDefaultPath())
                if aw.qmc.batchcounter > -1 and aw.qmc.roastbatchnr > 0 and self.qmc.autosaveprefix == "":
                    prefix = u(aw.qmc.batchprefix) + u(aw.qmc.roastbatchnr)
                else:
                    prefix = self.qmc.autosaveprefix
                fname = path.absoluteFilePath(self.generateFilename(prefix=prefix))
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Profile",None), path=fname)
            if filename:
                #write
                pf = self.getProfile()
                if pf:
                    # if the copy flag is set, we generate a new roastUUID
                    if copy:
                        pf["roastUUID"] = uuid.uuid4().hex # generate UUID

                    sync_record_hash = plus.controller.updateSyncRecordHashAndSync()
                    if sync_record_hash is not None:
                        # we add the hash over the sync record to be able to detect offline changes
                        pf["plus_sync_record_hash"] = encodeLocal(sync_record_hash)

                    # we save the file and set the filename
                    self.serialize(filename,pf)
                    self.sendmessage(QApplication.translate("Message","Profile saved", None))
                    if not copy:
                        self.setCurrentFile(filename)
                        aw.curFile = filename
                        self.qmc.fileClean()

                    if self.qmc.autosaveimage:
                        if ".alog" in filename:
                            filename = filename[0:-5]
                        if self.qmc.autosaveimageformat == "PDF":
                            self.saveVectorGraph(extension=".pdf",fname=filename)
                        elif self.qmc.autosaveimageformat == "SVG":
                            self.saveVectorGraph(extension=".svg",fname=filename)
                        elif self.qmc.autosaveimageformat == "CSV":
                            self.exportCSV(filename + ".csv")
                        elif self.qmc.autosaveimageformat == "JSON":
                            self.exportJSON(filename + ".json")
                        else:
                            self.resizeImg(0,1,self.qmc.autosaveimageformat,fname=filename)
                    return True
                else:
                    self.sendmessage(QApplication.translate("Message","Cancelled", None))
                    return False
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None))
                return False
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " filesave(): {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    def fileExport(self,msg,ext,dumper):
        try:
            filename = self.ArtisanSaveFileDialog(msg=msg,ext=ext)
            if filename:
                res = dumper(filename)
                if res:
                    self.sendmessage(QApplication.translate("Message","Readings exported", None))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None))
        except Exception as ex:
            aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " fileExport(): {0}").format(str(ex)))
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportExcel(self):
        self.fileExport(QApplication.translate("Message", "Export Excel",None),"*.xlsx",self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportCSV(self):
        self.fileExport(QApplication.translate("Message", "Export CSV",None),"*.csv",self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportJSON(self,_=False):
        self.fileExport(QApplication.translate("Message", "Export JSON",None),"*.json",self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportRoastLogger(self,_=False):
        self.fileExport(QApplication.translate("Message", "Export RoastLogger",None),"*.csv",self.exportRoastLogger)
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportPilot(self,_=False):
        self.fileExport(QApplication.translate("Message", "Export Probat Pilot",None),"*.xml",self.exportPilot)
    
    def fileConvert(self,ext,dumper):
        files = self.ArtisanOpenFilesDialog(ext="*.alog")
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate("Message", "Converting...",None), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = u(QFileInfo(f).fileName())
                        fconv = u(QDir(outdir).filePath(fname + u(ext)))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=True)
                            aw.qmc.redraw() # we need to redraw to ensure populated delta lines
                            dumper(fconv)
                        else:
                            aw.sendmessage(QApplication.translate("Message","Target file {0} exists. {1} not converted.", None).format(fconv,fname + u(ext)))
                    except Exception:
                        pass
                    i += 1
                    aw.qmc.fileClean()
                    aw.qmc.reset(soundOn=False)
                if loaded_profile:
                    self.loadFile(loaded_profile)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertExcel(self):
        self.fileConvert(".xlsx",self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertCSV(self,_=False):
        self.fileConvert(".csv",self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJSON(self,_=False):
        self.fileConvert(".json",self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertRoastLogger(self,_=False):
        self.fileConvert(".csv",self.exportRoastLogger)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPilot(self,_=False):
        self.fileConvert(".xml",self.exportPilot)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPNG(self,_=False):
        self.fileConvertBITMAP("PNG")

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJPEG(self,_=False):
        self.fileConvertBITMAP("JPEG")

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertBMP(self,_=False):
        self.fileConvertBITMAP("BMP")

    def fileConvertBITMAP(self,filetype="PNG"):
        files = self.ArtisanOpenFilesDialog(ext="*.alog")
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                fileext = ".png"
                if filetype == "JPEG":
                    fileext = ".jpg"
                elif filetype == "BMP":
                    fileext = ".bmp"
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate("Message", "Converting...",None), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = u(QFileInfo(f).fileName())
                        fconv = u(QDir(outdir).filePath(fname + u(fileext)))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=True)
                            self.qmc.redraw()
                            self.image = aw.qmc.grab()
                            if filetype in ["JPEG","BMP"]:
                                # transparences are not supported by those file types and are rendered in black by default.
                                white_img = QPixmap(self.image.size())
                                white_img.fill() # fills by default with Qt.white
                                painter = QPainter(white_img)
                                painter.drawPixmap(0,0,self.image.width(),self.image.height(),self.image)
                                self.image = white_img
                                painter.end()
                                del painter
                            self.image.save(fconv,filetype)
                        else:
                            aw.sendmessage(QApplication.translate("Message","Target file {0} exists. {1} not converted.", None).format(fconv,fname + u(fileext)))                        
                    except:
                        pass
                    i += 1
                    aw.qmc.fileClean()
                    aw.qmc.reset(soundOn=False)
                if loaded_profile:
                    self.loadFile(loaded_profile)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None
    
    @pyqtSlot()
    def fileConvertSVG(self):
        self.fileConvertIMG(".svg")

    @pyqtSlot()
    def fileConvertPDF(self):
        self.fileConvertIMG(".pdf")
    
    def fileConvertIMG(self,ext):
        files = self.ArtisanOpenFilesDialog(ext="*.alog")
        if files and len(files) > 0:
            outdir = self.ArtisanExistingDirectoryDialog()
            progress = QProgressDialog(QApplication.translate("Message", "Converting...",None), None, 0, len(files), self)
            progress.setCancelButton(None)
            progress.setWindowModality(Qt.WindowModal)
            progress.setAutoClose(True)
            progress.show()
            i = 1
            flag_temp = aw.qmc.roastpropertiesflag
            for f in files:
                try:
                    progress.setValue(i)
                    QApplication.processEvents()
                    fname = u(QFileInfo(f).fileName())
                    fconv = u(QDir(outdir).filePath(fname + u(ext)))
                    if not os.path.exists(fconv):
                        aw.qmc.reset(redraw=False,soundOn=False)
                        self.setProfile(f,self.deserialize(f),quiet=True)
                        self.qmc.redraw()
                        aw.qmc.fig.savefig(fconv,transparent=True,facecolor='none', edgecolor='none') # transparent=True is need to get the delta curves and legend drawn
                    else:
                        aw.sendmessage(QApplication.translate("Message","Target file {0} exists. {1} not converted.", None).format(fconv,fname + u(ext)))
                except:
                    pass
                i += 1
                aw.qmc.reset(soundOn=False)
            aw.qmc.roastpropertiesflag = flag_temp
            progress.cancel()
            progress = None
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToFahrenheit(self,_=False):
        self.fileConverToTemp("F")
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToCelsius(self,_=False):
        self.fileConverToTemp("C")
        
    def fileConverToTemp(self,t):
        files = self.ArtisanOpenFilesDialog(ext="*.alog")
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                outdir = self.ArtisanExistingDirectoryDialog()
                progress = QProgressDialog(QApplication.translate("Message", "Converting...",None), None, 0, len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = aw.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = u(QFileInfo(f).fileName())
                        fconv = u(QDir(outdir).filePath(fname))
                        if not os.path.exists(fconv):
                            aw.qmc.reset(redraw=False,soundOn=False)
                            self.setProfile(f,self.deserialize(f),quiet=True)
                            aw.qmc.convertTemperature(t,True)
                            aw.fileSave(fconv)
                        else:
                            aw.sendmessage(QApplication.translate("Message","Target file {0} exists. {1} not converted.", None).format(fconv,fname))
                    except:
                        pass
                    i += 1
                    aw.qmc.fileClean()
                    aw.qmc.reset(soundOn=False)
                if loaded_profile:
                    self.loadFile(loaded_profile)
                aw.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                progress = None

    def fileImport(self,msg,loader,reset=False,ext="*"):
        try:
            filename = self.ArtisanOpenFileDialog(msg=msg,ext=ext)
            if filename:
                if reset:
                    aw.qmc.reset(True,False)
                loader(filename)
                self.sendmessage(QApplication.translate("Message","Readings imported", None))
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None))
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " fileImport(): {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportCSV(self,_=False):
        self.fileImport(QApplication.translate("Message", "Import CSV",None),self.importCSV,True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportJSON(self,_=False):
        self.fileImport(QApplication.translate("Message", "Import JSON",None),self.importJSON,True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportRoastLogger(self,_=False):
        self.fileImport(QApplication.translate("Message", "Import RoastLogger",None),self.importRoastLogger,True)

    #loads the settings at the start of application. See the oppposite closeEventSettings()
    def settingsLoad(self, filename=None):
        res = False
        try: 
            updateBatchCounter = True
            if filename is not None:
                settings = QSettings(filename,QSettings.IniFormat)
                if aw.qmc.neverUpdateBatchCounter or app.artisanviewerMode:
                    updateBatchCounter = False
                else:
                    settings.beginGroup("Batch")
                    if settings.contains("batchcounter"):
                        files_batchcounter = toInt(settings.value("batchcounter",aw.qmc.batchcounter))
                        if files_batchcounter != aw.qmc.batchcounter:
                            current_counter = str(aw.qmc.batchcounter)
                            files_counter = str(files_batchcounter)
                            if aw.qmc.batchcounter < 0:
                                string = QApplication.translate("Message","Your batch counter is currently turned off. Turn it on and set it to %s from the settings file to be imported?"%(files_counter), None)
                            elif files_batchcounter < 0:
                                string = QApplication.translate("Message","Your batch counter is set to %s. Turn it off as in the settings file to be imported?"%(current_counter), None)
                            else:
                                string = QApplication.translate("Message","Overwrite your current batch counter %s by %s from the settings file to be imported?"%(current_counter,files_counter), None)
                            reply = QMessageBox.question(aw,QApplication.translate("Message","Batch Counter", None),string,
                                    QMessageBox.Cancel |QMessageBox.No|QMessageBox.Yes)
                            if reply == QMessageBox.Cancel:
                                aw.sendmessage(QApplication.translate("Message","Load Settings canceled"))
                                return
                            elif reply == QMessageBox.No:
                                updateBatchCounter = False
                            else:
                                updateBatchCounter = True
                    settings.endGroup()
            else:
                settings = QSettings()
            if settings.contains("resetqsettings"):
                self.resetqsettings = toInt(settings.value("resetqsettings",self.resetqsettings))
                if self.resetqsettings:
                    self.resetqsettings = 0
                    if "canvas" in aw.qmc.palette:
                        aw.updateCanvasColors()
                    # remove window geometry settings
                    for s in ["RoastGeometry","FlavorProperties","CalculatorGeometry","EventsGeometry",
                        "BackgroundGeometry","LCDGeometry","DeltaLCDGeometry","ExtraLCDGeometry","PhasesLCDGeometry","AlarmsGeometry","PIDGeometry","DeviceAssignmentGeometry",
                        "TransformatorPosition"]:
                        settings.remove(s)
                    #
                    aw.setFonts()
                    self.qmc.redraw()
                    return  #don't load any more settings. They could be bad (corrupted). Stop here.
                    
            # we remember from which location we loaded the last settings file
            # to be able to update the batch counter in this file from incBatchCounter()/decBatchCounter()
            # but not for loading of settings fragments like themes or machines
            if filename:
                if updateBatchCounter:
                    settings.beginGroup("Batch")
                    if settings.contains("batchcounter"):
                        self.settingspath = filename
                    else:
                        self.settingspath = ""
                    settings.endGroup()
                else:
                    self.settingspath = ""
            else:
                # the neverUpdateBatchCounter flag is never changed on loading a settings file!
                settings.beginGroup("Batch")
                if settings.contains("neverUpdateBatchCounter"):
                    aw.qmc.neverUpdateBatchCounter = toInt(settings.value("neverUpdateBatchCounter",aw.qmc.neverUpdateBatchCounter))
                settings.endGroup()
            
            if filename is None and settings.contains("fullscreen"):
                self.full_screen_mode_active = bool(toBool(settings.value("fullscreen",self.full_screen_mode_active)))

            if filename is None and settings.contains("plus_account"):
                self.plus_account = settings.value("plus_account",self.plus_account)
                if settings.contains("plus_remember_credentials"):
                    self.plus_remember_credentials = bool(toBool(settings.value("plus_remember_credentials",self.plus_remember_credentials)))
                if settings.contains("plus_email"):
                    self.plus_email = settings.value("plus_email",self.plus_email)
                if settings.contains("plus_language"):
                    self.plus_language = settings.value("plus_language",self.plus_language)
                      
            #restore mode
            old_mode = self.qmc.mode
            self.qmc.mode = str(settings.value("Mode",self.qmc.mode))
            #convert modes only if needed comparing the new uploaded mode to the old one.
            #otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == "F" and old_mode == "C":
                self.qmc.fahrenheitMode()
            if self.qmc.mode == "C" and old_mode == "F":
                self.qmc.celsiusMode()
            #restore device
            settings.beginGroup("Device")
            if settings.contains("id"):
                self.qmc.device = toInt(settings.value("id",self.qmc.device))
            # Phidget configurations
            if settings.contains("phidget1048_types"):
                self.qmc.phidget1048_types = [toInt(x) for x in toList(settings.value("phidget1048_types",self.qmc.phidget1048_types))]
            if settings.contains("phidget1048_async"):
                self.qmc.phidget1048_async = [bool(toBool(x)) for x in toList(settings.value("phidget1048_async",self.qmc.phidget1048_async))]
                self.qmc.phidget1048_changeTriggers = [aw.float2float(toFloat(x)) for x in toList(settings.value("phidget1048_changeTriggers",self.qmc.phidget1048_changeTriggers))]
            if settings.contains("phidget1048_dataRate"):
                self.qmc.phidget1048_dataRate = toInt(settings.value("phidget1048_dataRate",self.qmc.phidget1048_dataRate))
            if settings.contains("phidget1046_gain"):
                self.qmc.phidget1046_gain = [toInt(x) for x in toList(settings.value("phidget1046_gain",self.qmc.phidget1046_gain))]
            if settings.contains("phidget1046_formula"):
                self.qmc.phidget1046_formula = [toInt(x) for x in toList(settings.value("phidget1046_formula",self.qmc.phidget1046_formula))]
            if settings.contains("phidget1046_async"):
                self.qmc.phidget1046_async = [bool(toBool(x)) for x in toList(settings.value("phidget1046_async",self.qmc.phidget1046_async))]
            if settings.contains("phidget1046_dataRate"):
                self.qmc.phidget1046_dataRate = toInt(settings.value("phidget1046_dataRate",self.qmc.phidget1046_dataRate))
            if settings.contains("phidget1045_async"):
                self.qmc.phidget1045_async = bool(toBool(settings.value("phidget1045_async",self.qmc.phidget1045_async)))
                self.qmc.phidget1045_changeTrigger = aw.float2float(toFloat(settings.value("phidget1045_changeTrigger",self.qmc.phidget1045_changeTrigger)))
            if settings.contains("phidget1045_emissivity"):
                self.qmc.phidget1045_emissivity = toDouble(settings.value("phidget1045_emissivity",self.qmc.phidget1045_emissivity))
            if settings.contains("phidget1045_dataRate"):
                self.qmc.phidget1045_dataRate = toInt(settings.value("phidget1045_dataRate",self.qmc.phidget1045_dataRate))
            if settings.contains("phidget1200_formula"):
                self.qmc.phidget1200_formula = toInt(settings.value("phidget1200_formula",self.qmc.phidget1200_formula))
                self.qmc.phidget1200_wire = toInt(settings.value("phidget1200_wire",self.qmc.phidget1200_wire))
                self.qmc.phidget1200_async = bool(toBool(settings.value("phidget1200_async",self.qmc.phidget1200_async)))
                self.qmc.phidget1200_changeTrigger = aw.float2float(toFloat(settings.value("phidget1200_changeTrigger",self.qmc.phidget1200_changeTrigger)))
                self.qmc.phidget1200_dataRate = toInt(settings.value("phidget1200_dataRate",self.qmc.phidget1200_dataRate))
            if settings.contains("phidgetDAQ1400_powerSupply"):
                self.qmc.phidgetDAQ1400_powerSupply = toInt(settings.value("phidgetDAQ1400_powerSupply",self.qmc.phidgetDAQ1400_powerSupply))
                self.qmc.phidgetDAQ1400_inputMode = toInt(settings.value("phidgetDAQ1400_inputMode",self.qmc.phidgetDAQ1400_inputMode))
            if settings.contains("phidgetRemoteFlag"):
                self.qmc.phidgetRemoteFlag = bool(toBool(settings.value("phidgetRemoteFlag",self.qmc.phidgetRemoteFlag)))
                self.qmc.phidgetServerID = toString(settings.value("phidgetServerID",self.qmc.phidgetServerID))
                self.qmc.phidgetPassword = toString(settings.value("phidgetPassword",self.qmc.phidgetPassword))
                if settings.contains("phidgetPort"):
                    self.qmc.phidgetPort = toInt(settings.value("phidgetPort",self.qmc.phidgetPort))
                if settings.contains("phidgetRemoteOnlyFlag"):
                    self.qmc.phidgetRemoteOnlyFlag = bool(toBool(settings.value("phidgetRemoteOnlyFlag",self.qmc.phidgetRemoteOnlyFlag)))
            if settings.contains("phidget1018_async"):
                self.qmc.phidget1018_async = [bool(toBool(x)) for x in toList(settings.value("phidget1018_async",self.qmc.phidget1018_async))]
                self.qmc.phidget1018_dataRates = [toInt(x) for x in toList(settings.value("phidget1018_dataRates",self.qmc.phidget1018_dataRates))]
                self.qmc.phidget1018_changeTriggers = [toInt(x) for x in toList(settings.value("phidget1018_changeTriggers",self.qmc.phidget1018_changeTriggers))]
            if settings.contains("phidget1018_ratio"):
                self.qmc.phidget1018_ratio = [bool(toBool(x)) for x in toList(settings.value("phidget1018_ratio",self.qmc.phidget1018_ratio))]
            if settings.contains("PIDbuttonflag"):
                self.qmc.PIDbuttonflag = bool(toBool(settings.value("PIDbuttonflag",self.qmc.PIDbuttonflag)))
            if settings.contains("Controlbuttonflag"):
                self.qmc.Controlbuttonflag = bool(toBool(settings.value("Controlbuttonflag",self.qmc.Controlbuttonflag)))
            if settings.contains("yoctoRemoteFlag"):
                self.qmc.yoctoRemoteFlag = bool(toBool(settings.value("yoctoRemoteFlag",self.qmc.yoctoRemoteFlag)))
                self.qmc.yoctoServerID = toString(settings.value("yoctoServerID",self.qmc.yoctoServerID))
            if settings.contains("YOCTO_emissivity"):
                self.qmc.YOCTO_emissivity = toDouble(settings.value("YOCTO_emissivity",self.qmc.YOCTO_emissivity))
            if settings.contains("YOCTO_async"):
                self.qmc.YOCTO_async = [bool(toBool(x)) for x in toList(settings.value("YOCTO_async",self.qmc.YOCTO_async))]
            if settings.contains("YOCTO_dataRate"):
                self.qmc.YOCTO_dataRate = toInt(settings.value("YOCTO_dataRate",self.qmc.YOCTO_dataRate))
            if settings.contains("ambient_temperature_device"):
                self.qmc.ambient_temperature_device = toInt(settings.value("ambient_temperature_device",self.qmc.ambient_temperature_device))
                self.qmc.ambient_humidity_device = toInt(settings.value("ambient_humidity_device",self.qmc.ambient_humidity_device))
                self.qmc.ambient_pressure_device = toInt(settings.value("ambient_pressure_device",self.qmc.ambient_pressure_device))
                self.qmc.elevation = toInt(settings.value("elevation",self.qmc.elevation))
            # activate CONTROL BUTTON
            aw.showControlButton()
            if settings.contains("controlETpid"):
                self.ser.controlETpid = [toInt(x) for x in toList(settings.value("controlETpid",self.ser.controlETpid))]
            if settings.contains("readBTpid"):
                self.ser.readBTpid = [toInt(x) for x in toList(settings.value("readBTpid",self.ser.readBTpid))]
            if settings.contains("arduinoETChannel"):
                self.ser.arduinoETChannel = s2a(toString(settings.value("arduinoETChannel",self.ser.arduinoETChannel)))
            if settings.contains("arduinoBTChannel"):
                self.ser.arduinoBTChannel = s2a(toString(settings.value("arduinoBTChannel",self.ser.arduinoBTChannel)))
            if settings.contains("arduinoATChannel"):
                self.ser.arduinoATChannel = s2a(toString(settings.value("arduinoATChannel",self.ser.arduinoATChannel)))
            if settings.contains("ArduinoFILT"):
                self.ser.ArduinoFILT = [toInt(x) for x in toList(settings.value("ArduinoFILT",self.ser.ArduinoFILT))]
            if settings.contains("useModbusPort"):
                self.ser.useModbusPort = bool(toBool(settings.value("useModbusPort",self.ser.useModbusPort)))
            if settings.contains("showFujiLCDs"):
                self.ser.showFujiLCDs = bool(toBool(settings.value("showFujiLCDs",self.ser.showFujiLCDs)))
            settings.endGroup()
            #restore x,y formating mode            
            if settings.contains("fmt_data_RoR"):
                self.qmc.fmt_data_RoR = bool(toBool(settings.value("fmt_data_RoR",self.qmc.fmt_data_RoR)))
            #restore playback aid
            if settings.contains("detectBackgroundEventTime"):
                self.qmc.detectBackgroundEventTime = toInt(settings.value("detectBackgroundEventTime",self.qmc.detectBackgroundEventTime))
            if settings.contains("backgroundReproduce"):
                self.qmc.backgroundReproduce = bool(toBool(settings.value("backgroundReproduce",self.qmc.backgroundReproduce)))
            if settings.contains("backgroundReproduceBeep"):
                self.qmc.backgroundReproduceBeep = bool(toBool(settings.value("backgroundReproduceBeep",self.qmc.backgroundReproduceBeep)))
            if settings.contains("backgroundPlaybackEvents"):
                self.qmc.backgroundPlaybackEvents = bool(toBool(settings.value("backgroundPlaybackEvents",self.qmc.backgroundPlaybackEvents)))
            if settings.contains("backgroundPlaybackDROP"):
                self.qmc.backgroundPlaybackDROP = bool(toBool(settings.value("backgroundPlaybackDROP",self.qmc.backgroundPlaybackDROP)))
            if settings.contains("replayType"):
                aw.qmc.replayType = toInt(settings.value("replayType",aw.qmc.replayType))
            #restore phases
            if settings.contains("Phases"):
                self.qmc.phases = [toInt(x) for x in toList(settings.value("Phases",self.qmc.phases))]
            if settings.contains("phasesbuttonflag"):
                self.qmc.phasesbuttonflag = bool(toBool(settings.value("phasesbuttonflag",self.qmc.phasesbuttonflag)))
            if settings.contains("phasesfromBackgroundflag"):
                self.qmc.phasesfromBackgroundflag = bool(toBool(settings.value("phasesfromBackgroundflag",self.qmc.phasesfromBackgroundflag)))
            if settings.contains("watermarks"):
                self.qmc.watermarksflag = bool(toBool(settings.value("watermarks",self.qmc.watermarksflag)))
            if settings.contains("phasesLCDs"):
                self.qmc.phasesLCDflag = bool(toBool(settings.value("phasesLCDs",self.qmc.phasesLCDflag)))
            if settings.contains("phasesLCDmode"):
                self.qmc.phasesLCDmode = toInt(settings.value("phasesLCDmode",self.qmc.phasesLCDmode))
            # Important - this must come after the code that restores phasesLCDmode 
            # Done this way with two variables to maintain forward and backward compatibility with settings since adding LCD mode by phase.
            if settings.contains("phasesLCDmode_l"):
                self.qmc.phasesLCDmode_l = [toInt(x) for x in toList(settings.value("phasesLCDmode_l",self.qmc.phasesLCDmode_l))]
            elif settings.contains("phasesLCDmode"):
                self.qmc.phasesLCDmode_l = [toInt(self.qmc.phasesLCDmode)]*3
            if settings.contains("phasesLCDmode_all"):
                self.qmc.phasesLCDmode_all = [bool(toBool(x)) for x in toList(settings.value("phasesLCDmode_all",self.qmc.phasesLCDmode_all))]               
            if settings.contains("autoDry"):
                self.qmc.autoDRYflag = bool(toBool(settings.value("autoDry",self.qmc.autoDRYflag)))
            if settings.contains("autoFCs"):
                self.qmc.autoFCsFlag = bool(toBool(settings.value("autoFCs",self.qmc.autoFCsFlag)))
            #restore Events settings
            settings.beginGroup("events")
            if settings.contains("eventsbuttonflag"):
                self.eventsbuttonflag = toInt(settings.value("eventsbuttonflag",int(self.eventsbuttonflag)))
            if settings.contains("minieventsflag"):
                self.minieventsflag = toInt(settings.value("minieventsflag",int(self.minieventsflag)))
            if settings.contains("eventsGraphflag"):
                self.qmc.eventsGraphflag = toInt(settings.value("eventsGraphflag",int(self.qmc.eventsGraphflag)))
            if settings.contains("etypes"):
                self.qmc.etypes = toStringList(settings.value("etypes",self.qmc.etypes))
                # update minieditor event type ComboBox
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(self.qmc.etypes)
            if settings.contains("eventsshowflag"):
                self.qmc.eventsshowflag = toInt(settings.value("eventsshowflag",int(self.qmc.eventsshowflag)))
            if settings.contains("clampEvents"):
                self.qmc.clampEvents = bool(toBool(settings.value("clampEvents",self.qmc.clampEvents)))
            if settings.contains("renderEventsDescr"):
                self.qmc.renderEventsDescr = bool(toBool(settings.value("renderEventsDescr",self.qmc.renderEventsDescr)))
            if settings.contains("eventslabelschars"):
                self.qmc.eventslabelschars = toInt(settings.value("eventslabelschars",int(self.qmc.eventslabelschars)))
            if settings.contains("annotationsflag"):
                self.qmc.annotationsflag = toInt(settings.value("annotationsflag",int(self.qmc.annotationsflag)))
            if settings.contains("showeventsonbt"):
                self.qmc.showeventsonbt = bool(toBool(settings.value("showeventsonbt",self.qmc.showeventsonbt))) 
            if settings.contains("showEtypes"):
                self.qmc.showEtypes = [bool(toBool(x)) for x in toList(settings.value("showEtypes",self.qmc.showEtypes))]
            if settings.contains("autoChargeDrop"):
                self.qmc.autoChargeFlag = bool(toBool(settings.value("autoChargeDrop",False)))
                self.qmc.autoDropFlag = self.qmc.autoChargeFlag
            if settings.contains("autoCharge"):
                self.qmc.autoChargeFlag = bool(toBool(settings.value("autoCharge",self.qmc.autoChargeFlag)))
            if settings.contains("autoDrop"):
                self.qmc.autoDropFlag = bool(toBool(settings.value("autoDrop",self.qmc.autoDropFlag)))
            if settings.contains("markTP"):
                self.qmc.markTPflag = bool(toBool(settings.value("markTP",self.qmc.markTPflag)))
            if settings.contains("EvalueColor"):
                self.qmc.EvalueColor = list(map(str,list(toStringList(settings.value("EvalueColor",self.qmc.EvalueColor)))))
                aw.updateSliderColors()
                self.qmc.EvalueMarker = list(map(str,list(toStringList(settings.value("EvalueMarker",self.qmc.EvalueMarker)))))
            if settings.contains("EvalueTextColor"):
                self.qmc.EvalueTextColor = list(map(str,list(toStringList(settings.value("EvalueTextColor",self.qmc.EvalueTextColor)))))
                aw.updateSliderColors()
            if settings.contains("Evaluelinethickness"):
                self.qmc.Evaluelinethickness = [toInt(x) for x in toList(settings.value("Evaluelinethickness",self.qmc.Evaluelinethickness))]
                self.qmc.Evaluealpha = [toDouble(x) for x in toList(settings.value("Evaluealpha",self.qmc.Evaluealpha))]
            if settings.contains("EvalueMarkerSize"):
                self.qmc.EvalueMarkerSize = [toInt(x) for x in toList(settings.value("EvalueMarkerSize",self.qmc.EvalueMarkerSize))]
            if settings.contains("specialeventannotations"):
                self.qmc.specialeventannotations = list(map(str,list(toStringList(settings.value("specialeventannotations",self.qmc.specialeventannotations)))))
            if settings.contains("specialeventannovisibilities"):
                self.qmc.specialeventannovisibilities = [toInt(x) for x in toList(settings.value("specialeventannovisibilities",self.qmc.specialeventannovisibilities))]
            settings.endGroup()
            #restore statistics
            if settings.contains("Statistics"):
                self.qmc.statisticsflags = [toInt(x) for x in toList(settings.value("Statistics",self.qmc.statisticsflags))]
                # extend statisticsflag len to the full size (for backward compatibility)
                for i in range(6 - len(self.qmc.statisticsflags)):
                    self.qmc.statisticsflags.append(0)
            if settings.contains("AnalysisResultsLoc"):
                self.qmc.analysisresultsloc = [toFloat(x) for x in toList(settings.value("AnalysisResultsLoc",self.qmc.analysisresultsloc))]
            if settings.contains("SegmentResultsLoc"):
                self.qmc.segmentresultsloc = [toFloat(x) for x in toList(settings.value("SegmentResultsLoc",self.qmc.segmentresultsloc))]
            if settings.contains("analysisstartchoice"):
                self.qmc.analysisstartchoice = toInt(settings.value("analysisstartchoice",int()))
            if settings.contains("analysisoffset"):
                self.qmc.analysisoffset = toInt(settings.value("analysisoffset",int()))
            if settings.contains("curvefitstartchoice"):
                self.qmc.curvefitstartchoice = toInt(settings.value("curvefitstartchoice",int()))
            if settings.contains("curvefitoffset"):
                self.qmc.curvefitoffset = toInt(settings.value("curvefitoffset",int()))
            if settings.contains("segmentsamplesthreshold"):
                self.qmc.segmentsamplesthreshold = toInt(settings.value("segmentsamplesthreshold",int()))
            if settings.contains("segmentdeltathreshold"):
                self.qmc.segmentdeltathreshold = aw.float2float(toFloat(settings.value("segmentdeltathreshold",self.qmc.segmentdeltathreshold)),4)
            if settings.contains("AUCbegin"):
                self.qmc.AUCbegin = toInt(settings.value("AUCbegin",int()))
                self.qmc.AUCbase = toInt(settings.value("AUCbase",int()))
                self.qmc.AUCbaseFlag = bool(toBool(settings.value("AUCbaseFlag",self.qmc.AUCbaseFlag)))
                self.qmc.AUCtarget = toInt(settings.value("AUCtarget",int()))
                self.qmc.AUCtargetFlag = bool(toBool(settings.value("AUCtargetFlag",self.qmc.AUCtargetFlag)))
                self.qmc.AUCguideFlag = bool(toBool(settings.value("AUCguideFlag",self.qmc.AUCguideFlag)))
                self.qmc.AUClcdFlag = bool(toBool(settings.value("AUClcdFlag",self.qmc.AUClcdFlag)))
                self.qmc.AUCLCDmode = toInt(settings.value("AUCLCDmode",self.qmc.AUCLCDmode))
            if settings.contains("AUCshowFlag"):
                self.qmc.AUCshowFlag = bool(toBool(settings.value("AUCshowFlag",self.qmc.AUCshowFlag)))
            #restore ambient temperature source
            if settings.contains("AmbientTempSource"):
                aw.qmc.ambientTempSource = toInt(settings.value("AmbientTempSource",int()))
            #restore delay
            if settings.contains("Delay"):
                self.qmc.delay = max(self.qmc.min_delay,toInt(settings.value("Delay",int(self.qmc.delay))))
            else:
                #self.qmc.delay = self.qmc.default_delay
                pass
            # restore oversampling
            if settings.contains("Oversampling"):
                self.qmc.oversampling = bool(toBool(settings.value("Oversampling",self.qmc.oversampling)))
                aw.oversamplingAction.setChecked(aw.qmc.oversampling)
            # restore keepON flag
            if settings.contains("KeepON"):
                self.qmc.flagKeepON = bool(toBool(settings.value("KeepON",self.qmc.flagKeepON)))
            # restore extra event sampling interval
            if settings.contains("ExtraEventSamplingDelay"):
                self.qmc.extra_event_sampling_delay = toInt(settings.value("ExtraEventSamplingDelay",int(self.qmc.extra_event_sampling_delay)))
            #restore colors
            if settings.contains("Colors"):
                self.qmc.palette["canvas"] = 'None'  #revert the canvas element to default if it does not exist in the settings.
                for (k, v) in list(toMap(settings.value("Colors")).items()):
                    self.qmc.palette[str(k)] = s2a(toString(v))
                if "messages" in self.qmc.palette:
                    self.setLabelColor(aw.messagelabel,QColor(self.qmc.palette["messages"]))
                if "et" in self.qmc.palette:
                    self.setLabelColor(aw.label2,QColor(self.qmc.palette["et"]))
                if "bt" in self.qmc.palette:    
                    self.setLabelColor(aw.label3,QColor(self.qmc.palette["bt"]))
                if "deltaet" in self.qmc.palette:
                    self.setLabelColor(aw.label4,QColor(self.qmc.palette["deltaet"]))
                if "deltabt" in self.qmc.palette:
                    self.setLabelColor(aw.label5,QColor(self.qmc.palette["deltabt"]))
            if settings.contains("ETBColor"):
                self.qmc.backgroundmetcolor = s2a(toString(settings.value("ETBColor",self.qmc.backgroundmetcolor)))
            if settings.contains("BTBColor"):
                self.qmc.backgroundbtcolor = s2a(toString(settings.value("BTBColor",self.qmc.backgroundbtcolor)))
            if settings.contains("ETBdeltaColor"):
                self.qmc.backgrounddeltaetcolor = s2a(toString(settings.value("ETBdeltaColor",self.qmc.backgrounddeltaetcolor)))
            if settings.contains("BTBdeltaColor"):
                self.qmc.backgrounddeltabtcolor = s2a(toString(settings.value("BTBdeltaColor",self.qmc.backgrounddeltabtcolor)))
            if settings.contains("BackgroundAlpha"):
                self.qmc.backgroundalpha = min(0.5,aw.float2float(toFloat(settings.value("BackgroundAlpha",self.qmc.backgroundalpha))))
            if settings.contains("LCDColors"):
                for (k, v) in list(toMap(settings.value("LCDColors")).items()):
                    self.lcdpaletteB[str(k)] = s2a(toString(v))
            if settings.contains("LEDColors"):
                for (k, v) in list(toMap(settings.value("LEDColors")).items()):
                    self.lcdpaletteF[str(k)] = s2a(toString(v))
#?            self.qmc.palette["alpha"] = 'None'  #revert the canvas element to default if it does not exist in the settings.
            if settings.contains("Alphas"):
                for (k, v) in list(toMap(settings.value("Alphas")).items()):
                    self.qmc.alpha[str(k)] = (v)

            #restore colors
            self.lcd1.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["timer"],self.lcdpaletteB["timer"]))
            self.lcd2.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["et"],self.lcdpaletteB["et"]))
            self.lcd3.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["bt"],self.lcdpaletteB["bt"]))
            self.lcd4.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["deltaet"],self.lcdpaletteB["deltaet"]))
            self.lcd5.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["deltabt"],self.lcdpaletteB["deltabt"]))
            self.lcd6.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
            self.lcd7.setStyleSheet("QLCDNumber { border-radius:4; color: %s; background: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))

            if settings.contains("readingslcdsflags"):
                self.readingslcdsflags = [toInt(x) for x in toList(settings.value("readingslcdsflags",self.readingslcdsflags))]

            #restore flavors
            self.qmc.flavorlabels = toStringList(settings.value("Flavors",self.qmc.flavorlabels))
            self.qmc.flavors = [5.]*len(self.qmc.flavorlabels)
            if settings.contains("flavorstartangle"):
                self.qmc.flavorstartangle = toInt(settings.value("flavorstartangle",int(self.qmc.flavorstartangle)))
            #restore roast color system
            if settings.contains("colorsystem"):
                self.qmc.color_system_idx = toInt(settings.value("colorsystem",int(self.qmc.color_system_idx)))
            #restore extra background curve color and index
            settings.beginGroup("XT")
            if settings.contains("color"):
                self.qmc.backgroundxtcolor = s2a(toString(settings.value("color",self.qmc.backgroundxtcolor)))
            if settings.contains("index"):
                self.qmc.xtcurveidx = toInt(settings.value("index",int(self.qmc.xtcurveidx)))
            settings.endGroup()
            #restore units
            settings.beginGroup("Units")
            if settings.contains("weight"):
                self.qmc.weight[2] = s2a(toString(settings.value("weight",self.qmc.weight[2])))
                self.qmc.volume[2] = s2a(toString(settings.value("volume",self.qmc.volume[2])))
# density units are now fixed to g/l
#                self.qmc.density[1] = s2a(toString(settings.value("densityweight",self.qmc.density[1])))
#                self.qmc.density[3] = s2a(toString(settings.value("densityvolume",self.qmc.density[3])))
            if settings.contains("volumeCalcUnit"):
                self.qmc.volumeCalcUnit = aw.float2float(toFloat(settings.value("volumeCalcUnit",self.qmc.volumeCalcUnit)))
            settings.endGroup()
            settings.beginGroup("Tare")
            if settings.contains("names"):
                self.qmc.container_names = list(map(u,list(toStringList(settings.value("names",self.qmc.container_names)))))
            if settings.contains("weights"):
                self.qmc.container_weights = [toInt(x) for x in toList(settings.value("weights",self.qmc.container_weights))]
            if settings.contains("idx"):
                self.qmc.container_idx = toInt(settings.value("idx",int(self.qmc.container_idx)))
            settings.endGroup()
            #restore serial port
            settings.beginGroup("SerialPort")
            self.ser.comport = s2a(toString(settings.value("comport",self.ser.comport)))
            if settings.contains("baudrate"):
                self.ser.baudrate = toInt(settings.value("baudrate",int(self.ser.baudrate)))
            if settings.contains("bytesize"):
                self.ser.bytesize = toInt(settings.value("bytesize",self.ser.bytesize))
            if settings.contains("stopbits"):
                self.ser.stopbits = toInt(settings.value("stopbits",self.ser.stopbits))
            self.ser.parity = s2a(toString(settings.value("parity",self.ser.parity)))
            if settings.contains("timeout"):
                self.ser.timeout = aw.float2float(toFloat(settings.value("timeout",self.ser.timeout)))
            settings.endGroup()
            #restore s7 port
            settings.beginGroup("S7")
            if settings.contains("area"):
                self.s7.area = [toInt(x) for x in toList(settings.value("area",self.s7.area))]
                self.s7.area = self.s7.area + [0]*(max(0,aw.s7.channels - len(self.s7.area)))
                self.s7.db_nr = [toInt(x) for x in toList(settings.value("db_nr",self.s7.db_nr))]
                self.s7.db_nr = self.s7.db_nr + [1]*(max(0,aw.s7.channels - len(self.s7.db_nr)))
                self.s7.start = [toInt(x) for x in toList(settings.value("start",self.s7.start))]
                self.s7.start = self.s7.start + [0]*(max(0,aw.s7.channels - len(self.s7.start)))
                self.s7.type = [toInt(x) for x in toList(settings.value("type",self.s7.type))]
                self.s7.type = self.s7.type + [0]*(max(0,aw.s7.channels - len(self.s7.type)))
                self.s7.mode = [toInt(x) for x in toList(settings.value("mode",self.s7.mode))]
                self.s7.mode = self.s7.mode + [0]*(max(0,aw.s7.channels - len(self.s7.mode)))
                self.s7.div = [toInt(x) for x in toList(settings.value("div",self.s7.div))]
                self.s7.div = self.s7.div + [0]*(max(0,aw.s7.channels - len(self.s7.div)))
                self.s7.host = toString(settings.value("host",self.s7.host))
                self.s7.port = toInt(settings.value("port",self.s7.port))
                self.s7.rack = toInt(settings.value("rack",self.s7.rack))
                self.s7.slot = toInt(settings.value("slot",self.s7.slot))
            if settings.contains("PIDmultiplier"):
                self.s7.PID_area = toInt(settings.value("PID_area",self.s7.PID_area))
                self.s7.PID_db_nr = toInt(settings.value("PID_db_nr",self.s7.PID_db_nr))
                self.s7.PID_SV_register = toInt(settings.value("PID_SV_register",self.s7.PID_SV_register))
                self.s7.PID_p_register = toInt(settings.value("PID_p_register",self.s7.PID_p_register))
                self.s7.PID_i_register = toInt(settings.value("PID_i_register",self.s7.PID_i_register))
                self.s7.PID_d_register = toInt(settings.value("PID_d_register",self.s7.PID_d_register))
                self.s7.PID_OFF_action = s2a(toString(settings.value("PID_OFF_action",self.s7.PID_OFF_action)))
                self.s7.PID_ON_action = s2a(toString(settings.value("PID_ON_action",self.s7.PID_ON_action)))
                self.s7.PIDmultiplier = toInt(settings.value("PIDmultiplier",self.s7.PIDmultiplier))
                self.s7.SVmultiplier = toInt(settings.value("SVmultiplier",self.s7.SVmultiplier))
            settings.endGroup()
            #restore modbus port
            settings.beginGroup("Modbus")
            self.modbus.comport = s2a(toString(settings.value("comport",self.modbus.comport)))
            if settings.contains("baudrate"):
                self.modbus.baudrate = toInt(settings.value("baudrate",int(self.modbus.baudrate)))
            if settings.contains("bytesize"):
                self.modbus.bytesize = toInt(settings.value("bytesize",self.modbus.bytesize))
            if settings.contains("stopbits"):
                self.modbus.stopbits = toInt(settings.value("stopbits",self.modbus.stopbits))
            if settings.contains("parity"):
                self.modbus.parity = s2a(toString(settings.value("parity",self.modbus.parity)))
            if settings.contains("timeout"):
                self.modbus.timeout = aw.float2float(toFloat(settings.value("timeout",self.modbus.timeout)))
            if settings.contains("input1slave"):
                self.modbus.inputSlaves[0] = toInt(settings.value("input1slave",self.modbus.inputSlaves[0]))
            if settings.contains("input1register"):
                self.modbus.inputRegisters[0] = toInt(settings.value("input1register",self.modbus.inputRegisters[0]))
            if settings.contains("input2slave"):
                self.modbus.inputSlaves[1] = toInt(settings.value("input2slave",self.modbus.inputSlaves[1]))
            if settings.contains("input2register"):
                self.modbus.inputRegisters[1] = toInt(settings.value("input2register",self.modbus.inputRegisters[1]))
            if settings.contains("input3slave"):
                self.modbus.inputSlaves[2] = toInt(settings.value("input3slave",self.modbus.inputSlaves[2]))
            if settings.contains("input3register"):
                self.modbus.inputRegisters[2] = toInt(settings.value("input3register",self.modbus.inputRegisters[2]))
            if settings.contains("input4slave"):
                self.modbus.inputSlaves[3] = toInt(settings.value("input4slave",self.modbus.inputSlaves[3]))
            if settings.contains("input4register"):
                self.modbus.inputRegisters[3] = toInt(settings.value("input4register",self.modbus.inputRegisters[3]))
            if settings.contains("input5slave"):
                self.modbus.inputSlaves[4] = toInt(settings.value("input5slave",self.modbus.inputSlaves[4]))
            if settings.contains("input5register"):
                self.modbus.inputRegisters[4] = toInt(settings.value("input5register",self.modbus.inputRegisters[4]))
            if settings.contains("input6slave"):
                self.modbus.inputSlaves[5] = toInt(settings.value("input6slave",self.modbus.inputSlaves[5]))
            if settings.contains("input6register"):
                self.modbus.inputRegisters[5] = toInt(settings.value("input6register",self.modbus.inputRegisters[5]))
            if settings.contains("input7slave"):
                self.modbus.inputSlaves[6] = toInt(settings.value("input7slave",self.modbus.inputSlaves[6]))
            if settings.contains("input7register"):
                self.modbus.inputRegisters[6] = toInt(settings.value("input7register",self.modbus.inputRegisters[6]))
            if settings.contains("input8slave"):
                self.modbus.inputSlaves[7] = toInt(settings.value("input8slave",self.modbus.inputSlaves[7]))
            if settings.contains("input8register"):
                self.modbus.inputRegisters[7] = toInt(settings.value("input8register",self.modbus.inputRegisters[7]))
            if settings.contains("input1float"):
                self.modbus.inputFloats[0] = bool(toBool(settings.value("input1float",self.modbus.inputFloats[0])))
            if settings.contains("input1bcd"):
                self.modbus.inputBCDs[0] = bool(toBool(settings.value("input1bcd",self.modbus.inputBCDs[0])))
            if settings.contains("input1code"):
                self.modbus.inputCodes[0] = toInt(settings.value("input1code",self.modbus.inputCodes[0]))
            if settings.contains("input2float"):
                self.modbus.inputFloats[1] = bool(toBool(settings.value("input2float",self.modbus.inputFloats[1])))
            if settings.contains("input2bcd"):
                self.modbus.inputBCDs[1] = bool(toBool(settings.value("input2bcd",self.modbus.inputBCDs[1])))
            if settings.contains("input2code"):
                self.modbus.inputCodes[1] = toInt(settings.value("input2code",self.modbus.inputCodes[1]))
            if settings.contains("input3float"):
                self.modbus.inputFloats[2] = bool(toBool(settings.value("input3float",self.modbus.inputFloats[2])))
            if settings.contains("input3bcd"):
                self.modbus.inputBCDs[2] = bool(toBool(settings.value("input3bcd",self.modbus.inputBCDs[2])))
            if settings.contains("input3code"):
                self.modbus.inputCodes[2] = toInt(settings.value("input3code",self.modbus.inputCodes[2]))
            if settings.contains("input4float"):
                self.modbus.inputFloats[3] = bool(toBool(settings.value("input4float",self.modbus.inputFloats[3])))
            if settings.contains("input4bcd"):
                self.modbus.inputBCDs[3] = bool(toBool(settings.value("input4bcd",self.modbus.inputBCDs[3])))
            if settings.contains("input4code"):
                self.modbus.inputCodes[3] = toInt(settings.value("input4code",self.modbus.inputCodes[3]))
            if settings.contains("input5float"):
                self.modbus.inputFloats[4] = bool(toBool(settings.value("input5float",self.modbus.inputFloats[4])))
            if settings.contains("input5bcd"):
                self.modbus.inputBCDs[4] = bool(toBool(settings.value("input5bcd",self.modbus.inputBCDs[4])))
            if settings.contains("input5code"):
                self.modbus.inputCodes[4] = toInt(settings.value("input5code",self.modbus.inputCodes[4]))
            if settings.contains("input6float"):
                self.modbus.inputFloats[5] = bool(toBool(settings.value("input6float",self.modbus.inputFloats[5])))
            if settings.contains("input6bcd"):
                self.modbus.inputBCDs[5] = bool(toBool(settings.value("input6bcd",self.modbus.inputBCDs[5])))
            if settings.contains("input6code"):
                self.modbus.inputCodes[5] = toInt(settings.value("input6code",self.modbus.inputCodes[5]))
            if settings.contains("input7float"):
                self.modbus.inputFloats[6] = bool(toBool(settings.value("input7float",self.modbus.inputFloats[6])))
            if settings.contains("input7bcd"):
                self.modbus.inputBCDs[6] = bool(toBool(settings.value("input7bcd",self.modbus.inputBCDs[6])))
            if settings.contains("input7code"):
                self.modbus.inputCodes[6] = toInt(settings.value("input7code",self.modbus.inputCodes[6]))
            if settings.contains("input8float"):
                self.modbus.inputFloats[7] = bool(toBool(settings.value("input8float",self.modbus.inputFloats[7])))
            if settings.contains("input8bcd"):
                self.modbus.inputBCDs[7] = bool(toBool(settings.value("input8bcd",self.modbus.inputBCDs[7])))
            if settings.contains("input8code"):
                self.modbus.inputCodes[7] = toInt(settings.value("input8code",self.modbus.inputCodes[7]))
            if settings.contains("littleEndianFloats"):
                self.modbus.byteorderLittle = bool(toBool(settings.value("littleEndianFloats",self.modbus.byteorderLittle)))
            if settings.contains("wordorderLittle"):
                self.modbus.wordorderLittle = bool(toBool(settings.value("wordorderLittle",self.modbus.wordorderLittle)))
            if settings.contains("input1mode"):
                self.modbus.inputModes[0] = s2a(toString(settings.value("input1mode",self.modbus.inputModes[0])))
                self.modbus.inputModes[1] = s2a(toString(settings.value("input2mode",self.modbus.inputModes[1])))
                self.modbus.inputModes[2] = s2a(toString(settings.value("input3mode",self.modbus.inputModes[2])))
                self.modbus.inputModes[3] = s2a(toString(settings.value("input4mode",self.modbus.inputModes[3])))
                self.modbus.inputModes[4] = s2a(toString(settings.value("input5mode",self.modbus.inputModes[4])))
                self.modbus.inputModes[5] = s2a(toString(settings.value("input6mode",self.modbus.inputModes[5])))
                self.modbus.inputModes[6] = s2a(toString(settings.value("input7mode",self.modbus.inputModes[6])))
                self.modbus.inputModes[7] = s2a(toString(settings.value("input8mode",self.modbus.inputModes[7])))
            if settings.contains("input1div"):
                self.modbus.inputDivs[0] = toInt(settings.value("input1div",self.modbus.inputDivs[0]))
                self.modbus.inputDivs[1] = toInt(settings.value("input2div",self.modbus.inputDivs[1]))
                self.modbus.inputDivs[2] = toInt(settings.value("input3div",self.modbus.inputDivs[2]))
                self.modbus.inputDivs[3] = toInt(settings.value("input4div",self.modbus.inputDivs[3]))
                self.modbus.inputDivs[4] = toInt(settings.value("input5div",self.modbus.inputDivs[4]))
                self.modbus.inputDivs[5] = toInt(settings.value("input6div",self.modbus.inputDivs[5]))
                self.modbus.inputDivs[6] = toInt(settings.value("input7div",self.modbus.inputDivs[6]))
                self.modbus.inputDivs[7] = toInt(settings.value("input8div",self.modbus.inputDivs[7]))
            if settings.contains("PIDmultiplier"):
                self.modbus.PIDmultiplier = toInt(settings.value("PIDmultiplier",self.modbus.PIDmultiplier))
                self.modbus.SVmultiplier = toInt(settings.value("SVmultiplier",self.modbus.SVmultiplier))
            if settings.contains("PID_slave_ID"):
                self.modbus.PID_slave_ID = toInt(settings.value("PID_slave_ID",self.modbus.PID_slave_ID))
                self.modbus.PID_SV_register = toInt(settings.value("PID_SV_register",self.modbus.PID_SV_register))
                self.modbus.PID_p_register = toInt(settings.value("PID_p_register",self.modbus.PID_p_register))
                self.modbus.PID_i_register = toInt(settings.value("PID_i_register",self.modbus.PID_i_register))
                self.modbus.PID_d_register = toInt(settings.value("PID_d_register",self.modbus.PID_d_register))
            if settings.contains("PID_OFF_action"):
                self.modbus.PID_OFF_action = s2a(toString(settings.value("PID_OFF_action",self.modbus.PID_OFF_action)))
            if settings.contains("PID_ON_action"):
                self.modbus.PID_ON_action = s2a(toString(settings.value("PID_ON_action",self.modbus.PID_ON_action)))
            #restore MODBUS TCP/UDP settings
            if settings.contains("host"):
                self.modbus.type = toInt(settings.value("type",self.modbus.type))
                self.modbus.host = toString(settings.value("host",self.modbus.host))
                self.modbus.port = toInt(settings.value("port",self.modbus.port))
            settings.endGroup()
            #restore scale port
            settings.beginGroup("Scale")
            self.scale.device = toString(settings.value("device",self.scale.device))
            self.scale.comport = s2a(toString(settings.value("comport",self.scale.comport)))
            self.scale.baudrate = toInt(settings.value("baudrate",int(self.scale.baudrate)))
            self.scale.bytesize = toInt(settings.value("bytesize",self.scale.bytesize))
            self.scale.stopbits = toInt(settings.value("stopbits",self.scale.stopbits))
            self.scale.parity = s2a(toString(settings.value("parity",self.scale.parity)))
            self.scale.timeout = aw.float2float(toFloat(settings.value("timeout",self.scale.timeout)))
            settings.endGroup()
            #restore color port
            settings.beginGroup("Color")
            self.color.device = toString(settings.value("device",self.color.device))
            self.color.comport = s2a(toString(settings.value("comport",self.color.comport)))
            self.color.baudrate = toInt(settings.value("baudrate",int(self.color.baudrate)))
            self.color.bytesize = toInt(settings.value("bytesize",self.color.bytesize))
            self.color.stopbits = toInt(settings.value("stopbits",self.color.stopbits))
            self.color.parity = s2a(toString(settings.value("parity",self.color.parity)))
            self.color.timeout = aw.float2float(toFloat(settings.value("timeout",self.color.timeout)))
            settings.endGroup()
            #restore alarms
            settings.beginGroup("Alarms")
            if settings.contains("alarmtime"):
                self.qmc.alarmflag = [toInt(x) for x in toList(settings.value("alarmflag",self.qmc.alarmflag))]
                if settings.contains("alarmguard"):
                    self.qmc.alarmguard = [toInt(x) for x in toList(settings.value("alarmguard",self.qmc.alarmguard))]
                else:
                    self.qmc.alarmguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmnegguard"):
                    self.qmc.alarmnegguard = [toInt(x) for x in toList(settings.value("alarmnegguard",self.qmc.alarmnegguard))]
                else:
                    self.qmc.alarmnegguard = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmtime"):
                    self.qmc.alarmtime = [toInt(x) for x in toList(settings.value("alarmtime",self.qmc.alarmtime))]
                else:
                    self.qmc.alarmtime = [-1]*len(self.qmc.alarmflag)
                if settings.contains("alarmoffset"):
                    self.qmc.alarmoffset = [max(0,toInt(x)) for x in toList(settings.value("alarmoffset",self.qmc.alarmoffset))]
                else:
                    self.qmc.alarmoffset = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmcond"):
                    self.qmc.alarmcond = [toInt(x) for x in toList(settings.value("alarmcond",self.qmc.alarmcond))]
                else:
                    self.qmc.alarmcond = [1]*len(self.qmc.alarmflag)
                if settings.contains("alarmsource"):
                    self.qmc.alarmsource = [toInt(x) for x in toList(settings.value("alarmsource",self.qmc.alarmsource))]
                else:
                    self.qmc.alarmsource = [1]*len(self.qmc.alarmflag)
                if settings.contains("alarmtemperature"):
                    self.qmc.alarmtemperature = [toFloat(x) for x in toList(settings.value("alarmtemperature",self.qmc.alarmtemperature))]
                else:
                    self.qmc.alarmtemperature = [500.]*len(self.qmc.alarmflag)
                if settings.contains("alarmaction"):
                    self.qmc.alarmaction = [toInt(x) for x in toList(settings.value("alarmaction",self.qmc.alarmaction))]
                else:
                    self.qmc.alarmaction = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmbeep"):
                    self.qmc.alarmbeep = [toInt(x) for x in toList(settings.value("alarmbeep",self.qmc.alarmbeep))]
                else:
                    self.qmc.alarmbeep = [0]*len(self.qmc.alarmflag)
                if settings.contains("alarmstrings"):
                    self.qmc.alarmstrings = list(toStringList(settings.value("alarmstrings",self.qmc.alarmstrings)))
                else:
                    self.qmc.alarmstrings = [""]*len(self.qmc.alarmflag)
                self.qmc.alarmstate = [-1]*len(self.qmc.alarmflag)
                if settings.contains("loadAlarmsFromProfile"):
                    self.qmc.loadalarmsfromprofile = bool(toBool(settings.value("loadAlarmsFromProfile",self.qmc.loadalarmsfromprofile)))
                if settings.contains("loadAlarmsFromBackground"):
                    self.qmc.loadalarmsfrombackground = bool(toBool(settings.value("loadAlarmsFromBackground",self.qmc.loadalarmsfrombackground)))
                if settings.contains("alarmsfile"):
                    self.qmc.alarmsfile = toString(settings.value("alarmsfile",self.qmc.alarmsfile))
                if settings.contains("alarm_popup_timout"):
                    self.qmc.alarm_popup_timout = toInt(settings.value("alarm_popup_timout",aw.qmc.alarm_popup_timout))
                if settings.contains("alarmtablecolumnwidths"):
                    self.qmc.alarmtablecolumnwidths = [toInt(x) for x in toList(settings.value("alarmtablecolumnwidths",self.qmc.alarmtablecolumnwidths))]
            settings.endGroup()
            #restore TC4/Arduino PID settings
            settings.beginGroup("ArduinoPID")
            if settings.contains("pidOnCHARGE"):
                aw.pidcontrol.pidOnCHARGE = bool(toBool(settings.value("pidOnCHARGE",aw.pidcontrol.pidOnCHARGE)))
                aw.pidcontrol.loadRampSoakFromProfile = bool(toBool(settings.value("loadRampSoakFromProfile",aw.pidcontrol.loadRampSoakFromProfile)))
                aw.pidcontrol.svValues = [toInt(x) for x in toList(settings.value("svValues",aw.pidcontrol.svValues))]
                aw.pidcontrol.svRamps = [toInt(x) for x in toList(settings.value("svRamps",aw.pidcontrol.svRamps))]
                aw.pidcontrol.svSoaks = [toInt(x) for x in toList(settings.value("svSoaks",aw.pidcontrol.svSoaks))]
                aw.pidcontrol.svSlider = bool(toBool(settings.value("svSlider",aw.pidcontrol.svSlider)))
                aw.pidcontrol.svButtons = bool(toBool(settings.value("svButtons",aw.pidcontrol.svButtons)))
                aw.pidcontrol.svMode = toInt(settings.value("svMode",aw.pidcontrol.svMode))
                aw.pidcontrol.svLookahead = toInt(settings.value("svLookahead",aw.pidcontrol.svLookahead))
                aw.pidcontrol.dutySteps = toInt(settings.value("dutySteps",aw.pidcontrol.dutySteps))
                aw.pidcontrol.svSliderMin = toInt(settings.value("svSliderMin",aw.pidcontrol.svSliderMin))
                aw.pidcontrol.svSliderMax = toInt(settings.value("svSliderMax",aw.pidcontrol.svSliderMax))
                aw.pidcontrol.svValue = toInt(settings.value("svValue",aw.pidcontrol.svValue))
                
                aw.sliderSV.blockSignals(True)
                if settings.contains("dutyMin"):
                    aw.pidcontrol.dutyMin = toInt(settings.value("dutyMin",aw.pidcontrol.dutyMin))
                if settings.contains("dutyMax"):
                    aw.pidcontrol.dutyMax = toInt(settings.value("dutyMax",aw.pidcontrol.dutyMax))
                aw.sliderSV.blockSignals(False)
                    
                aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider)
                aw.pidcontrol.pidKp = toDouble(settings.value("pidKp",aw.pidcontrol.pidKp))
                aw.pidcontrol.pidKi = toDouble(settings.value("pidKi",aw.pidcontrol.pidKi))
                aw.pidcontrol.pidKd = toDouble(settings.value("pidKd",aw.pidcontrol.pidKd))
                aw.pidcontrol.pidSource = toInt(settings.value("pidSource",aw.pidcontrol.pidSource))
                aw.pidcontrol.pidCycle = toInt(settings.value("pidCycle",aw.pidcontrol.pidCycle))
                if settings.contains("pidPositiveTarget"):
                    aw.pidcontrol.pidPositiveTarget = toInt(settings.value("pidPositiveTarget",aw.pidcontrol.pidPositiveTarget))
                    aw.pidcontrol.pidNegativeTarget = toInt(settings.value("pidNegativeTarget",aw.pidcontrol.pidNegativeTarget))
                    aw.pidcontrol.invertControl = bool(toBool(settings.value("invertControl",aw.pidcontrol.invertControl)))
                if settings.contains("pOnE"):
                    aw.pidcontrol.pOnE = bool(toBool(settings.value("pOnE",aw.pidcontrol.pOnE)))
            settings.endGroup()
            
            #restore pid settings
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                if type(self.fujipid.PXR[key][0]) == type(float()):
                    self.fujipid.PXR[key][0] = toDouble(settings.value(key,self.fujipid.PXR[key][0]))
                elif type(self.fujipid.PXR[key][0]) == type(int()):
                    self.fujipid.PXR[key][0] = toInt(settings.value(key,self.fujipid.PXR[key][0]))
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                if type(self.fujipid.PXG4[key][0]) == type(float()):
                    self.fujipid.PXG4[key][0] = toDouble(settings.value(key,self.fujipid.PXG4[key][0]))
                elif type(self.fujipid.PXG4[key][0]) == type(int()):
                    self.fujipid.PXG4[key][0] = toInt(settings.value(key,self.fujipid.PXG4[key][0]))
            
            if self.fujipid.PXG4["selectsv"][0] < 1:
                self.fujipid.PXG4["selectsv"][0] = 1
            if settings.contains("followBackground"):
                self.fujipid.followBackground = bool(toBool(settings.value("followBackground",self.fujipid.followBackground)))
            if settings.contains("lookahead"):
                self.fujipid.lookahead = toInt(settings.value("lookahead",self.fujipid.lookahead))
            settings.endGroup()
            if settings.contains("deltaDTA"):
                settings.beginGroup("deltaDTA")
                for key in list(self.dtapid.dtamem.keys()):
                    if type(self.dtapid.dtamem[key][0]) == type(float()):
                        self.dtapid.dtamem[key][0] = toDouble(settings.value(key,self.dtapid.dtamem[key][0]))
                    elif type(self.dtapid.dtamem[key][0]) == type(int()):
                        self.dtapid.dtamem[key][0] = toInt(settings.value(key,self.dtapid.dtamem[key][0]))
                settings.endGroup()
            if settings.contains("filterDropOuts"):
                self.qmc.filterDropOuts = bool(toBool(settings.value("filterDropOuts",self.qmc.filterDropOuts)))
            if settings.contains("dropSpikes"):
                self.qmc.dropSpikes = bool(toBool(settings.value("dropSpikes",self.qmc.dropSpikes)))
#            if settings.contains("altSmoothing"):
#                self.qmc.altsmoothing = bool(toBool(settings.value("altSmoothing",self.qmc.altsmoothing)))
            if settings.contains("optimalSmoothing"):
                self.qmc.optimalSmoothing = bool(toBool(settings.value("optimalSmoothing",self.qmc.optimalSmoothing)))
            if settings.contains("swapETBT"):
                self.qmc.swapETBT = bool(toBool(settings.value("swapETBT",self.qmc.swapETBT)))
            if settings.contains("minmaxLimits"):
                self.qmc.minmaxLimits = bool(toBool(settings.value("minmaxLimits",self.qmc.minmaxLimits)))
                self.qmc.filterDropOut_tmin = toInt(settings.value("minLimit",self.qmc.filterDropOut_tmin))
                self.qmc.filterDropOut_tmax = toInt(settings.value("maxLimit",self.qmc.filterDropOut_tmax))
            settings.beginGroup("RoC")
            self.qmc.DeltaETflag = bool(toBool(settings.value("DeltaET",self.qmc.DeltaETflag)))
            self.qmc.DeltaBTflag = bool(toBool(settings.value("DeltaBT",self.qmc.DeltaBTflag)))
            self.qmc.deltaBTfilter = toInt(settings.value("deltafilter",self.qmc.deltaBTfilter))
            if settings.contains("deltaETfilter"):
                self.qmc.deltaETfilter = toInt(settings.value("deltaETfilter",self.qmc.deltaETfilter))
            else:
                self.qmc.deltaETfilter = self.qmc.deltaBTfilter
            if settings.contains("DeltaSpan"):
                self.qmc.deltaBTspan = toInt(settings.value("DeltaSpan",self.qmc.deltaBTspan))
                if settings.contains("DeltaETspan"):
                    self.qmc.deltaETspan = toInt(settings.value("DeltaETspan",self.qmc.deltaETspan))
                else:
                    self.qmc.deltaETspan = self.qmc.deltaBTspan
            self.qmc.LCDdecimalplaces = toInt(settings.value("LCDdecimalplaces",self.qmc.LCDdecimalplaces))
            if settings.contains("statisticsmode"):
                self.qmc.statisticsmode = toInt(settings.value("statisticsmode",self.qmc.statisticsmode))
            if settings.contains("DeltaETlcd"):
                self.qmc.DeltaETlcdflag = bool(toBool(settings.value("DeltaETlcd",self.qmc.DeltaETlcdflag)))
            if settings.contains("DeltaBTlcd"):
                self.qmc.DeltaBTlcdflag = bool(toBool(settings.value("DeltaBTlcd",self.qmc.DeltaBTlcdflag)))
            if settings.contains("swapdeltalcds"):
                self.qmc.swapdeltalcds = bool(toBool(settings.value("swapdeltalcds",self.qmc.swapdeltalcds)))
            settings.endGroup()   
            if settings.contains("curvefilter"):
                self.qmc.curvefilter = toInt(settings.value("curvefilter",self.qmc.curvefilter))
#            if settings.contains("smoothingwindowsize"):
#                self.qmc.smoothingwindowsize = toInt(settings.value("smoothingwindowsize",self.qmc.smoothingwindowsize))
            if settings.contains("ETcurve"):
                self.qmc.ETcurve = bool(toBool(settings.value("ETcurve",self.qmc.ETcurve)))
            if settings.contains("BTcurve"):
                self.qmc.BTcurve = bool(toBool(settings.value("BTcurve",self.qmc.BTcurve)))
            if settings.contains("ETlcd"):
                self.qmc.ETlcd = bool(toBool(settings.value("ETlcd",self.qmc.ETlcd)))
            if settings.contains("BTlcd"):
                self.qmc.BTlcd = bool(toBool(settings.value("BTlcd",self.qmc.BTlcd)))
            if settings.contains("swaplcds"):
                self.qmc.swaplcds = bool(toBool(settings.value("swaplcds",self.qmc.swaplcds)))
            settings.beginGroup("DefaultButtons")
            if settings.contains("buttonvisibility"):
                self.qmc.buttonvisibility = [toBool(x) for x in toList(settings.value("buttonvisibility"))]
            if settings.contains("buttonactions"):
                self.qmc.buttonactions = [toInt(x) for x in toList(settings.value("buttonactions"))]
            if settings.contains("buttonactionstrings"):
                self.qmc.buttonactionstrings = list(map(u,list(toStringList(settings.value("buttonactionstrings",self.qmc.buttonactionstrings)))))
            if settings.contains("extrabuttonactions"):
                self.qmc.extrabuttonactions = [toInt(x) for x in toList(settings.value("extrabuttonactions"))]
            if settings.contains("extrabuttonactionstrings"):
                self.qmc.extrabuttonactionstrings = list(map(str,list(toStringList(settings.value("extrabuttonactionstrings",self.qmc.extrabuttonactionstrings)))))
            if settings.contains("xextrabuttonactions"):
                self.qmc.xextrabuttonactions = [toInt(x) for x in toList(settings.value("xextrabuttonactions"))]
            if settings.contains("xextrabuttonactionstrings"):
                self.qmc.xextrabuttonactionstrings = list(map(str,list(toStringList(settings.value("xextrabuttonactionstrings",self.qmc.xextrabuttonactionstrings)))))
            settings.endGroup()
            self.qmc.transMappingMode = toInt(settings.value("transMappingMode",self.qmc.transMappingMode))
            settings.beginGroup("HUD")
            self.qmc.projectFlag = bool(toBool(settings.value("Projection",self.qmc.projectFlag)))
            self.qmc.projectionmode = toInt(settings.value("ProjectionMode",self.qmc.projectionmode))
            self.qmc.ETtarget = toInt(settings.value("ETtarget",self.qmc.ETtarget))
            self.qmc.BTtarget = toInt(settings.value("BTtarget",self.qmc.BTtarget))
            if settings.contains("ET2target"):
                self.qmc.ET2target = toInt(settings.value("ET2target",self.qmc.ET2target))
            if settings.contains("BT2target"):
                self.qmc.BT2target = toInt(settings.value("BT2target",self.qmc.BT2target))
            self.HUDfunction = toInt(settings.value("Mode",self.HUDfunction))
            if settings.contains("hudETpid"):
                self.qmc.hudETpid = [toInt(x) for x in toList(settings.value("hudETpid"))]
            if settings.contains("buttonFlag"):
                self.qmc.HUDbuttonflag = bool(toBool(settings.value("buttonFlag",self.qmc.HUDbuttonflag)))
                if self.qmc.HUDbuttonflag:
                    aw.button_18.setVisible(True)
                else:
                    aw.button_18.setVisible(False)
            if app.artisanviewerMode:
                aw.button_18.setVisible(False)
            settings.endGroup()
            settings.beginGroup("Style")
            if settings.contains("patheffects"):
                self.qmc.patheffects = toInt(settings.value("patheffects",self.qmc.patheffects))
            if settings.contains("graphstyle"):
                self.qmc.graphstyle = toInt(settings.value("graphstyle",self.qmc.graphstyle))
            if settings.contains("graphfont"):
                self.qmc.graphfont = toInt(settings.value("graphfont",self.qmc.graphfont))
            if settings.contains("ETname"):
                self.ETname = settings.value("ETname")
                self.label2.setText("<big><b>" + self.ETname + "</b></big>")
                self.label4.setText(deltaLabelBigPrefix + self.ETname + "</b></big>")
            else:
                self.ETname = u(QApplication.translate("Label", "ET", None))
            if settings.contains("BTname"):
                self.BTname = settings.value("BTname")
                self.label3.setText("<big><b>" + self.BTname + "</b></big>")
                self.label5.setText(deltaLabelBigPrefix + self.BTname + "</b></big>")
            else:
                self.BTname = u(QApplication.translate("Label", "BT", None))
            settings.endGroup()
            settings.beginGroup("Sound")
            self.soundflag = toInt(settings.value("Beep",self.soundflag))
            settings.endGroup()
            #loads max-min temp limits of graph
            settings.beginGroup("Axis")
            if settings.contains("loadAxisFromProfile"):
                self.qmc.loadaxisfromprofile = bool(toBool(settings.value("loadAxisFromProfile",self.qmc.loadaxisfromprofile)))
            try: # prevents some random exceptions in Windows!?
                self.qmc.startofx = toFloat(settings.value("xmin",self.qmc.startofx))
                self.qmc.endofx = toFloat(settings.value("xmax",self.qmc.endofx))
                #fixes Windows OS sometimes saving endofx as 0 
                if self.qmc.endofx < 60 or self.qmc.endofx > 1800:
                    self.qmc.endofx = 60
            except:
                pass
            self.qmc.ylimit = min(toInt(settings.value("ymax",self.qmc.ylimit)),self.qmc.ylimit_max)
            self.qmc.ylimit_min = max(min(toInt(settings.value("ymin",self.qmc.ylimit_min)),self.qmc.ylimit),self.qmc.ylimit_min_max)
            self.qmc.zlimit = min(toInt(settings.value("zmax",self.qmc.zlimit)),self.qmc.zlimit_max)
            self.qmc.zlimit_min = max(min(toInt(settings.value("zmin",self.qmc.zlimit_min)),self.qmc.zlimit),self.qmc.zlimit_min_max)
            if settings.contains("resetmaxtime"):
                self.qmc.resetmaxtime = toInt(settings.value("resetmaxtime",self.qmc.resetmaxtime))
            if settings.contains("lockmax"):
                self.qmc.fixmaxtime = bool(toBool(settings.value("lockmax",self.qmc.fixmaxtime)))
            if settings.contains("locktimex"):
                self.qmc.locktimex = bool(toBool(settings.value("locktimex",self.qmc.locktimex)))
            if settings.contains("autotimex"):
                self.qmc.autotimex = bool(toBool(settings.value("autotimex",self.qmc.autotimex)))
            if settings.contains("locktimex_start"):
                self.qmc.locktimex_start = toInt(settings.value("locktimex_start",self.qmc.locktimex_start))
            if settings.contains("locktimex_end"):
                self.qmc.locktimex_end = toInt(settings.value("locktimex_end",self.qmc.locktimex_end))
            if settings.contains("chargemintime"):
                self.qmc.chargemintime = toInt(settings.value("chargemintime",self.qmc.chargemintime))
            self.qmc.legendloc = toInt(settings.value("legendloc",self.qmc.legendloc))
            if settings.contains("temp_grid"):
                self.qmc.temp_grid = bool(toBool(settings.value("temp_grid",self.qmc.temp_grid)))
            if settings.contains("time_grid"):
                self.qmc.time_grid = bool(toBool(settings.value("time_grid",self.qmc.time_grid)))
            settings.endGroup()
            
            settings.beginGroup("RoastProperties")
            self.qmc.operator = toString(settings.value("operator",self.qmc.operator))
            self.qmc.roastertype = toString(settings.value("roastertype",self.qmc.roastertype))
            if settings.contains("machinesetup"):
                self.qmc.machinesetup = toString(settings.value("machinesetup",self.qmc.machinesetup))
            self.qmc.drumspeed = toString(settings.value("drumspeed",self.qmc.drumspeed))
#            self.qmc.density[2] = toDouble(settings.value("densitySampleVolume",self.qmc.density[2])) # fixed to 1l now
            if settings.contains("beansize"):
                self.qmc.beansize = toDouble(settings.value("beansize",self.qmc.beansize))
            if settings.contains("beansize_min"):
                self.qmc.beansize_min = toInt(settings.value("beansize_min",self.qmc.beansize_min))
            if settings.contains("beansize_max"):
                self.qmc.beansize_max = toInt(settings.value("beansize_max",self.qmc.beansize_max))
            if filename is None and settings.contains("plus_default_store"):
                self.qmc.plus_default_store = toString(settings.value("plus_default_store",self.qmc.plus_default_store))
            settings.endGroup()

            self.userprofilepath = toString(settings.value("profilepath",self.userprofilepath))
            if settings.contains("settingspath") and not filename:
                self.settingspath = toString(settings.value("settingspath",self.settingspath))
            if settings.contains("wheelpath"):
                self.wheelpath = toString(settings.value("wheelpath",self.wheelpath))
            if settings.contains("autosavepath"):
                self.qmc.autosavepath = toString(settings.value("autosavepath",self.qmc.autosavepath))
            if settings.contains("autosavealsopath"):
                self.qmc.autosavealsopath = toString(settings.value("autosavealsopath",self.qmc.autosavealsopath))
            if settings.contains("autosavealsopath"):
                self.simulatorpath = toString(settings.value("simulatorpath",self.simulatorpath))
            if settings.contains("externalprogram"):
                self.ser.externalprogram = toString(settings.value("externalprogram",self.ser.externalprogram))
            if settings.contains("externaloutprogram"):
                self.ser.externaloutprogram = toString(settings.value("externaloutprogram",self.ser.externaloutprogram))
            if settings.contains("externaloutprogramFlag"):
                self.ser.externaloutprogramFlag = bool(toBool(settings.value("externaloutprogramFlag",self.ser.externaloutprogramFlag)))
            settings.beginGroup("ExtraDev")
            if settings.contains("extradevices"):
                self.qmc.extradevices = [toInt(x) for x in toList(settings.value("extradevices",self.qmc.extradevices))]
                self.qmc.extraname1 = list(map(u,list(toStringList(settings.value("extraname1",self.qmc.extraname1)))))
                self.qmc.extraname2 = list(map(u,list(toStringList(settings.value("extraname2",self.qmc.extraname2)))))
                self.qmc.extramathexpression1 = list(map(str,list(toStringList(settings.value("extramathexpression1",self.qmc.extramathexpression1)))))
                self.qmc.extramathexpression2 = list(map(str,list(toStringList(settings.value("extramathexpression2",self.qmc.extramathexpression2)))))
                self.qmc.extradevicecolor1 = list(map(str,list(toStringList(settings.value("extradevicecolor1",self.qmc.extradevicecolor1)))))
                self.qmc.extradevicecolor2 = list(map(str,list(toStringList(settings.value("extradevicecolor2",self.qmc.extradevicecolor2)))))
                if settings.contains("extraLCDvisibility1"):
                    self.extraLCDvisibility1 = [toBool(x) for x in toList(settings.value("extraLCDvisibility1",self.extraLCDvisibility1))]
                if settings.contains("extraLCDvisibility2"):
                    self.extraLCDvisibility2 = [toBool(x) for x in toList(settings.value("extraLCDvisibility2",self.extraLCDvisibility2))]
                if settings.contains("extraCurveVisibility1"):
                    self.extraCurveVisibility1 = [toBool(x) for x in toList(settings.value("extraCurveVisibility1",self.extraCurveVisibility1))]
                if settings.contains("extraCurveVisibility2"):
                    self.extraCurveVisibility2 = [toBool(x) for x in toList(settings.value("extraCurveVisibility2",self.extraCurveVisibility2))]
                if settings.contains("extraDelta1"):
                    self.extraDelta1 = [toBool(x) for x in toList(settings.value("extraDelta1",self.extraDelta1))]
                if settings.contains("extraDelta2"):
                    self.extraDelta2 = [toBool(x) for x in toList(settings.value("extraDelta2",self.extraDelta2))]
                if settings.contains("extraFill1"):
                    self.extraFill1 = [toInt(x) for x in toList(settings.value("extraFill1",self.extraFill1))]
                if settings.contains("extraFill2"):
                    self.extraFill2 = [toInt(x) for x in toList(settings.value("extraFill2",self.extraFill2))]
            #create empty containers
            settings.endGroup()
            
            # ensure that extra list length are of the size of the extradevices:
            self.ensureCorrectExtraDeviceListLenght()
            
            #restore curve styles
            settings.beginGroup("CurveStyles")
            if settings.contains("BTlinestyle"):
                self.qmc.BTlinestyle = s2a(toString(settings.value("BTlinestyle",self.qmc.BTlinestyle)))
                self.qmc.BTdrawstyle = s2a(toString(settings.value("BTdrawstyle",self.qmc.BTdrawstyle)))
                if self.qmc.BTdrawstyle == '-':
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = max(0.1,aw.float2float(toFloat(settings.value("BTlinewidth",self.qmc.BTlinewidth))))
                self.qmc.BTmarker = s2a(toString(settings.value("BTmarker",self.qmc.BTmarker)))
                self.qmc.BTmarkersize = max(0.1,aw.float2float(toFloat(settings.value("BTmarkersize",self.qmc.BTmarkersize))))
                self.qmc.ETlinestyle = s2a(toString(settings.value("ETlinestyle",self.qmc.ETlinestyle)))
                self.qmc.ETdrawstyle = s2a(toString(settings.value("ETdrawstyle",self.qmc.ETdrawstyle)))
                if self.qmc.ETdrawstyle == '-':
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = max(0.1,aw.float2float(toFloat(settings.value("ETlinewidth",self.qmc.ETlinewidth))))
                self.qmc.ETmarker = s2a(toString(settings.value("ETmarker",self.qmc.ETmarker)))
                self.qmc.ETmarkersize = max(0.1,aw.float2float(toFloat(settings.value("ETmarkersize",self.qmc.ETmarkersize))))
                self.qmc.BTdeltalinestyle = s2a(toString(settings.value("BTdeltalinestyle",self.qmc.BTdeltalinestyle)))
                self.qmc.BTdeltadrawstyle = s2a(toString(settings.value("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle)))
                if self.qmc.BTdeltadrawstyle == '-':
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value("BTdeltalinewidth",self.qmc.BTdeltalinewidth))))
                self.qmc.BTdeltamarker = s2a(toString(settings.value("BTdeltamarker",self.qmc.BTdeltamarker)))
                self.qmc.BTdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value("BTdeltamarkersize",self.qmc.BTdeltamarkersize))))
                self.qmc.ETdeltalinestyle = s2a(toString(settings.value("ETdeltalinestyle",self.qmc.ETdeltalinestyle)))
                self.qmc.ETdeltadrawstyle = s2a(toString(settings.value("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle)))
                if self.qmc.ETdeltadrawstyle == '-':
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value("ETdeltalinewidth",self.qmc.ETdeltalinewidth))))
                self.qmc.ETdeltamarker = s2a(toString(settings.value("ETdeltamarker",self.qmc.ETdeltamarker)))
                self.qmc.ETdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value("ETdeltamarkersize",self.qmc.ETdeltamarkersize))))
                self.qmc.BTbacklinestyle = s2a(toString(settings.value("BTbacklinestyle",self.qmc.BTbacklinestyle)))
                self.qmc.BTbackdrawstyle = s2a(toString(settings.value("BTbackdrawstyle",self.qmc.BTbackdrawstyle)))
                if self.qmc.BTbackdrawstyle == '-':
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value("BTbacklinewidth",self.qmc.BTbacklinewidth))))
                self.qmc.BTbackmarker = s2a(toString(settings.value("BTbackmarker",self.qmc.BTbackmarker)))
                self.qmc.BTbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value("BTbackmarkersize",self.qmc.BTbackmarkersize))))
                self.qmc.ETbacklinestyle = s2a(toString(settings.value("ETbacklinestyle",self.qmc.ETbacklinestyle)))
                self.qmc.ETbackdrawstyle = s2a(toString(settings.value("ETbackdrawstyle",self.qmc.ETbackdrawstyle)))
                if self.qmc.ETbackdrawstyle == '-':
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value("ETbacklinewidth",self.qmc.ETbacklinewidth))))
                self.qmc.ETbackmarker = s2a(toString(settings.value("ETbackmarker",self.qmc.ETbackmarker)))
                self.qmc.ETbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value("ETbackmarkersize",self.qmc.ETbackmarkersize))))
                self.qmc.XTbacklinestyle = s2a(toString(settings.value("XTbacklinestyle",self.qmc.XTbacklinestyle)))
                self.qmc.XTbackdrawstyle = s2a(toString(settings.value("XTbackdrawstyle",self.qmc.XTbackdrawstyle)))
                if self.qmc.XTbackdrawstyle == '-':
                    self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.XTbacklinewidth = max(0.1,aw.float2float(toFloat(settings.value("XTbacklinewidth",self.qmc.XTbacklinewidth))))
                self.qmc.XTbackmarker = s2a(toString(settings.value("XTbackmarker",self.qmc.XTbackmarker)))
                self.qmc.XTbackmarkersize = max(0.1,aw.float2float(toFloat(settings.value("XTbackmarkersize",self.qmc.ETbackmarkersize))))
                self.qmc.extralinestyles1 = list(map(str,list(toStringList(settings.value("extralinestyles1",self.qmc.extralinestyles1)))))
                self.qmc.extralinestyles2 = list(map(str,list(toStringList(settings.value("extralinestyles2",self.qmc.extralinestyles2)))))
                self.qmc.extradrawstyles1 = list(map(str,list(toStringList(settings.value("extradrawstyles1",self.qmc.extradrawstyles1)))))
                self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default if s=='-' else s for s in self.qmc.extradrawstyles1]                                
                self.qmc.extradrawstyles2 = list(map(str,list(toStringList(settings.value("extradrawstyles2",self.qmc.extradrawstyles2)))))
                self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default if s=='-' else s for s in self.qmc.extradrawstyles2]                                                
                self.qmc.extralinewidths1 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value("extralinewidths1"))]
                self.qmc.extralinewidths2 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value("extralinewidths2"))]
                self.qmc.extramarkers1 = list(map(str,list(toStringList(settings.value("extramarkers1",self.qmc.extramarkers1)))))
                self.qmc.extramarkers2 = list(map(str,list(toStringList(settings.value("extramarkers2",self.qmc.extramarkers2)))))
                self.qmc.extramarkersizes1 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value("extramarkersizes1"))]
                self.qmc.extramarkersizes2 = [max(0.1,aw.float2float(toFloat(x))) for x in toList(settings.value("extramarkersizes2"))]
                self.qmc.BTBdeltalinestyle = s2a(toString(settings.value("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle)))
                self.qmc.BTBdeltadrawstyle = s2a(toString(settings.value("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle)))
                
                self.qmc.BTBdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth))))
                self.qmc.BTBdeltamarker = s2a(toString(settings.value("BTBdeltamarker",self.qmc.BTBdeltamarker)))
                self.qmc.BTBdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize))))
                self.qmc.ETBdeltalinestyle = s2a(toString(settings.value("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle)))
                self.qmc.ETBdeltadrawstyle = s2a(toString(settings.value("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle)))
                
                self.qmc.ETBdeltalinewidth = max(0.1,aw.float2float(toFloat(settings.value("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth))))
                self.qmc.ETBdeltamarker = s2a(toString(settings.value("ETBdeltamarker",self.qmc.ETBdeltamarker)))
                self.qmc.ETBdeltamarkersize = max(0.1,aw.float2float(toFloat(settings.value("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize))))
                                
                if settings.contains("devicetablecolumnwidths"):
                    self.qmc.devicetablecolumnwidths = [toInt(x) for x in toList(settings.value("devicetablecolumnwidths",self.qmc.devicetablecolumnwidths))]

            settings.endGroup()
            
            ndevices = len(self.qmc.extradevices)
            if ndevices != len(self.qmc.extralinestyles1) or \
               ndevices != len(self.qmc.extralinestyles2) or \
               ndevices != len(self.qmc.extradrawstyles1) or \
               ndevices != len(self.qmc.extradrawstyles2) or \
               ndevices != len(self.qmc.extralinewidths1) or \
               ndevices != len(self.qmc.extralinewidths2) or \
               ndevices != len(self.qmc.extramarkers1) or \
               ndevices != len(self.qmc.extramarkers2) or \
               ndevices != len(self.qmc.extramarkersizes1) or \
               ndevices != len(self.qmc.extramarkersizes2):
                self.qmc.extralinestyles1 = [self.qmc.linestyle_default]*ndevices
                self.qmc.extralinestyles2 = [self.qmc.linestyle_default]*ndevices
                self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default]*ndevices
                self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default]*ndevices
                self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default]*ndevices
                self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default]*ndevices
                self.qmc.extramarkers1 = [self.qmc.marker_default]*ndevices
                self.qmc.extramarkers2 = [self.qmc.marker_default]*ndevices
                self.qmc.extramarkersizes1 = [self.qmc.markersize_default]*ndevices
                self.qmc.extramarkersizes2 = [self.qmc.markersize_default]*ndevices
            self.qmc.extratemp1 = []
            self.qmc.extratemp2 = []
            self.qmc.extratimex = []
            self.qmc.extrastemp1 = []
            self.qmc.extrastemp2 = []
            for i in range(len(self.qmc.extradevices)):
                self.qmc.extratemp1.append([])
                self.qmc.extratemp2.append([])
                self.qmc.extratimex.append([])
                self.qmc.extrastemp1.append([])
                self.qmc.extrastemp2.append([])
                self.qmc.extractimex1.append([])
                self.qmc.extractimex2.append([])
                self.qmc.extractemp1.append([])
                self.qmc.extractemp2.append([])
            #extra LCDs and other LCDs visibility
            self.updateLCDproperties()
            # set extraLCD colors
            for i in range(len(self.qmc.extradevices)):
                self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
            # Extra com ports
            settings.beginGroup("ExtraComm")
            if settings.contains("extracomport"):
                self.extracomport = list(map(str,list(toStringList(settings.value("extracomport",self.extracomport)))))
                self.extrabaudrate = [toInt(x) for x in toList(settings.value("extrabaudrate",self.extrabaudrate))]
                self.extrabytesize = [toInt(x) for x in toList(settings.value("extrabytesize",self.extrabytesize))]
                self.extraparity = list(map(str,list(toStringList(settings.value("extraparity",self.extraparity)))))
                self.extrastopbits = [toInt(x) for x in toList(settings.value("extrastopbits",self.extrastopbits))]
                self.extratimeout = [aw.float2float(toFloat(x)) for x in toList(settings.value("extratimeout",self.extratimeout))]
                lenextraports = len(self.extracomport)
                self.extraser = [None]*lenextraports
                #populate aw.extraser
                for i in range(lenextraports):
                    self.extraser[i] = serialport()
                    self.extraser[i].comport = str(self.extracomport[i])
                    self.extraser[i].baudrate = self.extrabaudrate[i]
                    self.extraser[i].bytesize = self.extrabytesize[i]
                    self.extraser[i].parity = str(self.extraparity[i])
                    self.extraser[i].stopbits = self.extrastopbits[i]
                    self.extraser[i].timeout = self.extratimeout[i]
            settings.endGroup()
            if settings.contains("ChannelTares"):
                self.channel_tare_values = [toDouble(x) for x in toList(settings.value("ChannelTares",self.channel_tare_values))]
            if settings.contains("BTfunction"):
                self.qmc.BTfunction = s2a(toString(settings.value("BTfunction",self.qmc.BTfunction)))
            if settings.contains("ETfunction"):
                self.qmc.ETfunction = s2a(toString(settings.value("ETfunction",self.qmc.ETfunction)))
            if settings.contains("DeltaBTfunction"):
                self.qmc.DeltaBTfunction = s2a(toString(settings.value("DeltaBTfunction",self.qmc.DeltaBTfunction)))
                self.qmc.DeltaETfunction = s2a(toString(settings.value("DeltaETfunction",self.qmc.DeltaETfunction)))
            if settings.contains("plotcurves"):
                self.qmc.plotcurves = list(toStringList(settings.value("plotcurves",self.qmc.plotcurves)))
                self.qmc.plotcurvecolor = list(toStringList(settings.value("plotcurvecolor",self.qmc.plotcurvecolor)))
                for i in range(len(self.qmc.plotcurves)):
                    self.qmc.plotcurves[i] = str(self.qmc.plotcurves[i])
                    self.qmc.plotcurvecolor[i] = str(self.qmc.plotcurvecolor[i])
                #convert to 9 
                if len(self.qmc.plotcurves) == 6:
                    self.qmc.plotcurves += ["","",""]
                    self.qmc.plotcurvecolor += ["black","black","black"]
            settings.beginGroup("RoRlimits")
            if settings.contains("RoRlimitFlag"):
                self.qmc.RoRlimitFlag = bool(toBool(settings.value("RoRlimitFlag",self.qmc.RoRlimitFlag)))
                self.qmc.RoRlimit = toInt(settings.value("RoRlimit",self.qmc.RoRlimit))
                self.qmc.RoRlimitm = toInt(settings.value("RoRlimitm",self.qmc.RoRlimitm))
            settings.endGroup()
            settings.beginGroup("grid")
            if settings.contains("xgrid"):
                self.qmc.xgrid = toInt(settings.value("xgrid",self.qmc.xgrid))
                self.qmc.ygrid = max(10,toInt(settings.value("ygrid",self.qmc.ygrid)))
                self.qmc.zgrid = max(1,toInt(settings.value("zgrid",self.qmc.zgrid)))
                self.qmc.gridthickness = toInt(settings.value("gridthickness",self.qmc.gridthickness))
#                self.qmc.xrotation = toInt(settings.value("xrotation",self.qmc.xrotation))
                self.qmc.gridlinestyle = toInt(settings.value("gridlinestyle",self.qmc.gridlinestyle))
                self.qmc.gridalpha = toDouble(settings.value("gridalpha",self.qmc.gridalpha))
            settings.endGroup()
            if settings.contains("titleshowalways"):
                self.qmc.title_show_always = bool(toBool(settings.value("titleshowalways",aw.qmc.title_show_always)))
            if settings.contains("roastpropertiesflag"):
                self.qmc.roastpropertiesflag = toInt(settings.value("roastpropertiesflag",self.qmc.roastpropertiesflag))
            if settings.contains("roastpropertiesAutoOpenFlag"):
                self.qmc.roastpropertiesAutoOpenFlag = toInt(settings.value("roastpropertiesAutoOpenFlag",self.qmc.roastpropertiesAutoOpenFlag))
            if settings.contains("customflavorlabels"):
                self.qmc.customflavorlabels = list(map(u,list(toStringList(settings.value("customflavorlabels",self.qmc.customflavorlabels)))))
            #restore sliders
            settings.beginGroup("Sliders")
            if settings.contains("slidervisibilities"):
                self.eventslidervisibilities = [toInt(x) for x in toList(settings.value("slidervisibilities",self.eventslidervisibilities))]
                self.eventslideractions = [toInt(x) for x in toList(settings.value("slideractions",self.eventslideractions))]
                self.eventslidercommands = list(map(u,list(toStringList(settings.value("slidercommands",self.eventslidercommands)))))
                self.eventslideroffsets = [toDouble(x) for x in toList(settings.value("slideroffsets",self.eventslideroffsets))]
                self.eventsliderfactors = [toDouble(x) for x in toList(settings.value("sliderfactors",self.eventsliderfactors))]
            if settings.contains("slidermin"):
                self.eventslidermin = [toInt(x) for x in toList(settings.value("slidermin",self.eventslidermin))]
                self.eventslidermax = [toInt(x) for x in toList(settings.value("slidermax",self.eventslidermax))]
                aw.updateSliderMinMax()
            if settings.contains("eventslidersflags"):
                self.eventslidersflags = [toInt(x) for x in toList(settings.value("eventslidersflags",self.eventslidersflags))]
            if settings.contains("eventslidercoarse"):
                self.eventslidercoarse = [toInt(x) for x in toList(settings.value("eventslidercoarse",self.eventslidercoarse))]
            if settings.contains("eventslidertemp"):
                self.eventslidertemp = [toInt(x) for x in toList(settings.value("eventslidertemp",self.eventslidertemp))]
            if settings.contains("eventsliderunits"):
                self.eventsliderunits = list(map(u,list(toStringList(settings.value("eventsliderunits",self.eventsliderunits)))))
            if settings.contains("ModeTempSliders"):
                self.qmc.mode_tempsliders = str(settings.value("ModeTempSliders",self.qmc.mode_tempsliders))
            settings.endGroup()
            self.qmc.adjustTempSliders() # adjust min/max slider limits of temperature sliders to correspond to the current temp mode
            aw.slidersAction.setEnabled(any(aw.eventslidervisibilities) or aw.pidcontrol.svSlider)
            if app.artisanviewerMode:
                aw.slidersAction.setEnabled(False)
            #restore quantifier
            settings.beginGroup("Quantifiers")
            if settings.contains("quantifieractive"):
                self.eventquantifieractive = [toInt(x) for x in toList(settings.value("quantifieractive",self.eventquantifieractive))]
                self.eventquantifiersource = [toInt(x) for x in toList(settings.value("quantifiersource",self.eventquantifiersource))]
                self.eventquantifiermin = [toInt(x) for x in toList(settings.value("quantifiermin",self.eventquantifiermin))]
                self.eventquantifiermax = [toInt(x) for x in toList(settings.value("quantifiermax",self.eventquantifiermax))]
                if settings.contains("quantifiercoarse"):
                    self.eventquantifiercoarse = [toInt(x) for x in toList(settings.value("quantifiercoarse",self.eventquantifiercoarse))]
                    if settings.contains("clusterEventsFlag"):
                        self.clusterEventsFlag = bool(toBool(settings.value("clusterEventsFlag",aw.clusterEventsFlag)))
            settings.endGroup()
            settings.beginGroup("Batch")
            if settings.contains("batchcounter"):
                if updateBatchCounter:
                    aw.qmc.batchcounter = toInt(settings.value("batchcounter",aw.qmc.batchcounter))
                aw.qmc.batchprefix = toString(settings.value("batchprefix",aw.qmc.batchprefix))
                if filename is None:
                    # we do not load those two from setting files!
                    aw.qmc.batchsequence = toInt(settings.value("batchsequence",aw.qmc.batchsequence))
                    aw.qmc.lastroastepoch = toInt(settings.value("lastroastepoch",aw.qmc.lastroastepoch))
            settings.endGroup()
            self.computeLinespaces()
            self.updateSlidersProperties()
            #restore background profile settings
            settings.beginGroup("background")
            if settings.contains("backgrounddetails"):
                aw.qmc.backgroundDetails = bool(toBool(settings.value("backgrounddetails",aw.qmc.backgroundDetails)))
                aw.qmc.backgroundeventsflag = bool(toBool(settings.value("backgroundevents",aw.qmc.backgroundeventsflag)))
                aw.qmc.DeltaETBflag = bool(toBool(settings.value("DeltaETB",aw.qmc.DeltaETBflag)))
                aw.qmc.DeltaBTBflag = bool(toBool(settings.value("DeltaBTB",aw.qmc.DeltaBTBflag)))
                if settings.contains("alignEvent"):
                    aw.qmc.alignEvent = toInt(settings.value("alignEvent",aw.qmc.alignEvent))
                if settings.contains("movespeed"):
                    aw.qmc.backgroundmovespeed = toInt(settings.value("movespeed",aw.qmc.backgroundmovespeed))
            if settings.contains("ETBflag"):
                aw.qmc.backgroundETcurve = bool(toBool(settings.value("ETBflag",aw.qmc.backgroundETcurve)))
                aw.qmc.backgroundBTcurve = bool(toBool(settings.value("BTBflag",aw.qmc.backgroundBTcurve)))
            settings.endGroup()
            if settings.contains("autosaveflag"):
                self.qmc.autosaveflag = toInt(settings.value("autosaveflag",self.qmc.autosaveflag))
            if settings.contains("autosavepdf"):
                self.qmc.autosaveimage = bool(toBool(settings.value("autosavepdf",self.qmc.autosaveimage)))
            if settings.contains("autosaveimageformat"):
                self.qmc.autosaveimageformat = toString(settings.value("autosaveimageformat",self.qmc.autosaveimageformat))
            if settings.contains("autosaveprefix"):
                self.qmc.autosaveprefix = toString(settings.value("autosaveprefix",self.qmc.autosaveprefix))
            # WebLCDs            
            settings.beginGroup("WebLCDs")
            if settings.contains("active"):
                self.WebLCDs = bool(toBool(settings.value("active",self.WebLCDs)))
                self.WebLCDsPort = toInt(settings.value("port",self.WebLCDsPort))
                self.WebLCDsAlerts = bool(toBool(settings.value("alerts",self.WebLCDsAlerts)))
            settings.endGroup()
            if settings.contains("LargeLCDs"):
                self.LargeLCDsFlag = toBool(settings.value("LargeLCDs",self.LargeLCDsFlag))
            if self.LargeLCDsFlag:
                self.largeLCDs()
            if settings.contains("LargeDeltaLCDs"):
                self.LargeDeltaLCDsFlag = toBool(settings.value("LargeDeltaLCDs",self.LargeDeltaLCDsFlag))
            if self.LargeDeltaLCDsFlag:
                self.largeDeltaLCDs()
            if settings.contains("LargePIDLCDs"):
                self.LargePIDLCDsFlag = toBool(settings.value("LargePIDLCDs",self.LargePIDLCDsFlag))
            if self.LargePIDLCDsFlag:
                self.largePIDLCDs()
            if settings.contains("LargeExtraLCDs"):
                self.LargeExtraLCDsFlag = toBool(settings.value("LargeExtraLCDs",self.LargeExtraLCDsFlag))
            if self.LargeExtraLCDsFlag:
                self.largeExtraLCDs()
            if settings.contains("LargePhasesLCDs"):
                self.LargePhasesLCDsFlag = toBool(settings.value("LargePhasesLCDs",self.LargePhasesLCDsFlag))
            if self.LargePhasesLCDsFlag:
                self.largePhasesLCDs()
            # start server if needed
            if self.WebLCDs:
                self.startWebLCDs(force=True)
            #restore buttons
            settings.beginGroup("ExtraEventButtons")
            if settings.contains("extraeventsactions"):
                if settings.contains("buttonlistmaxlen"):
                    self.buttonlistmaxlen = toInt(settings.value("buttonlistmaxlen",self.buttonlistmaxlen))
                if settings.contains("extraeventsbuttonsflags"):
                    self.extraeventsbuttonsflags = [toInt(x) for x in toList(settings.value("extraeventsbuttonsflags",self.extraeventsbuttonsflags))]
                self.extraeventstypes = [toInt(x) for x in toList(settings.value("extraeventstypes",self.extraeventstypes))]
                self.extraeventsvalues = [toFloat(x) for x in toList(settings.value("extraeventsvalues",self.extraeventsvalues))]
                self.extraeventsactions = [toInt(x) for x in toList(settings.value("extraeventsactions",self.extraeventsactions))]
                self.extraeventsvisibility = [toInt(x) for x in toList(settings.value("extraeventsvisibility",self.extraeventsvisibility))]
                self.extraeventsactionstrings = list(toStringList(settings.value("extraeventsactionstrings",self.extraeventsactionstrings)))
                self.extraeventslabels = list(toStringList(settings.value("extraeventslabels",self.extraeventslabels)))
                self.extraeventsdescriptions= list(toStringList(settings.value("extraeventsdescriptions",self.extraeventsdescriptions)))
                if settings.contains("extraeventbuttoncolor"):
                    self.extraeventbuttoncolor = list(toStringList(settings.value("extraeventbuttoncolor",self.extraeventbuttoncolor)))
                    self.extraeventbuttontextcolor = list(toStringList(settings.value("extraeventbuttontextcolor",self.extraeventbuttontextcolor)))
                else:
                    self.extraeventbuttoncolor = ["yellow"]*len(self.extraeventstypes)
                    self.extraeventbuttontextcolor = ["black"]*len(self.extraeventstypes)
                if settings.contains("buttonpalette"):
                    self.buttonpalettemaxlen = [min(30,max(6,toInt(x))) for x in toList(settings.value("buttonpalettemaxlen",self.buttonpalettemaxlen))]
                    self.buttonpalette = toList(settings.value("buttonpalette",self.buttonpalette))
                    if self.buttonpalette is None:
                        self.buttonpalette = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]] # initialize empty palettes
                    else:
                        self.buttonpalette = self.buttonpalette[:10] # maximal 10 palettes are supported
                    for i in range(len(self.buttonpalette)):
                        if self.buttonpalette[i] is None:
                            self.buttonpalette[i] = []
                for i in range(len(self.extraeventsactionstrings)):
                    self.extraeventsactionstrings[i] = u(self.extraeventsactionstrings[i])
                    self.extraeventslabels[i] = u(self.extraeventslabels[i])
                    self.extraeventsdescriptions[i] = u(self.extraeventsdescriptions[i])
                    self.extraeventbuttoncolor[i] = str(self.extraeventbuttoncolor[i])
                    self.extraeventbuttontextcolor[i] = str(self.extraeventbuttontextcolor[i])
                if settings.contains("buttonpalette_shortcuts"):
                    self.buttonpalette_shortcuts = bool(toBool(settings.value("buttonpalette_shortcuts",self.buttonpalette_shortcuts)))
                if settings.contains("eventbuttontablecolumnwidths"):
                    self.eventbuttontablecolumnwidths = [toInt(x) for x in toList(settings.value("eventbuttontablecolumnwidths",self.eventbuttontablecolumnwidths))] 
                if settings.contains("buttonsize"):
                    self.buttonsize = toInt(settings.value("buttonsize",self.buttonsize))
            settings.endGroup()
            # Extras more info            
            settings.beginGroup("ExtrasMoreInfo")
            if settings.contains("showmet"):
                self.qmc.showmet = bool(toBool(settings.value("showmet",self.qmc.showmet)))
            if settings.contains("statssummary"):
                self.qmc.statssummary = bool(toBool(settings.value("statssummary")))
                if self.qmc.statssummary:
                    self.savestatisticsAction.setEnabled(True)
                else:
                    self.savestatisticsAction.setEnabled(False)
            if settings.contains("statsmaxchrperline"):
                self.qmc.statsmaxchrperline = int(settings.value("statsmaxchrperline", aw.qmc.statsmaxchrperline))
            if settings.contains("showtimeguide"):
                self.qmc.showtimeguide = bool(toBool(settings.value("showtimeguide",self.qmc.showtimeguide)))
            settings.endGroup()
            
            # recent roasts
            if settings.contains("recentRoasts"):
                try:
                    rr = settings.value("recentRoasts",self.recentRoasts)
                    if rr is not None:
                        self.recentRoasts = rr
                    else:
                        self.recentRoasts = []
                    self.updateNewMenuRecentRoasts()
                except Exception:
                    pass
            
#            #update axis limits
#            if not self.qmc.locktimex:
#                self.qmc.startofx = self.qmc.chargemintime # self.qmc.locktimex_start
#                self.qmc.endofx = self.qmc.locktimex_end
#            if self.qmc.endofx < 1:
#                self.qmc.endofx = 60
                
            # used on startup to reload previous loaded profiles
            if settings.contains("lastLoadedProfile"):
                aw.lastLoadedProfile = toString(settings.value("lastLoadedProfile",aw.curFile))
            if settings.contains("lastLoadedBackground"):
                aw.lastLoadedBackground = toString(settings.value("lastLoadedBackground",aw.qmc.backgroundpath))
            
            #watermark image
            if settings.contains("logoimgalpha"):
                self.logoimgalpha = toFloat(settings.value("logoimgalpha"))
            if settings.contains("logoimgflag"):
                self.logoimgflag = bool(toBool(settings.value("logoimgflag", self.logoimgflag)))
            if settings.contains("logofilename"):
                self.logofilename = toString(settings.value("logofilename"))

            res = True
            
        except Exception:
            res = False
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(aw,QApplication.translate("Error Message", "Error",None),QApplication.translate("Error Message", "Exception:",None) + "  settingsLoad()  @line " + str(exc_tb.tb_lineno))

#--------------------------------
        try:
            
            if "canvas" in aw.qmc.palette:
                aw.updateCanvasColors()
            
            aw.setFonts() # this one triggers a redraw by default to establish the correct fonts
            # only after this the correct aspect ratio of the qmc canvas is set
            
            if len(self.logofilename) > 0:
                self.qmc.logoloadfile(self.logofilename)

            # set window appearances (style)
            if settings.contains("appearance"):
                try:
                    available = list(map(str, list(QStyleFactory.keys())))
                    i = list(map(lambda x:x.lower(),available)).index(toString(settings.value("appearance")))
                    app.setStyle(available[i])
                    aw.appearance = available[i].lower()
                except Exception:
                    pass
            
            # set dpi
            if filename is not None and settings.contains("dpi"):
                # if filename is None (ie. setting is not explicitly loaded from file, but from default location on app start),
                # the dpi is set on creating the FigureCanvas
                try:
                    if aw.dpi != toInt(settings.value("dpi",aw.dpi)):
                        aw.setdpi(toInt(settings.value("dpi",aw.dpi)),moveWindow=True)
                except Exception:
                    pass

            #restore geometry
            if settings.contains("Geometry"):
                self.restoreGeometry(settings.value("Geometry"))
            if not filename: # only if an external settings file is loaded
                FigureCanvas.updateGeometry(aw.stack)  #@UndefinedVariable
                
            #update visibility of main event button, extra event buttons and 
            self.applyStandardButtonVisibility()
            
            aw.updateExtraButtonsVisibility()
            
            #update individual visibility of each buttons
            self.realignbuttons()
            
            aw.updateSlidersVisibility() # update visibility of sliders based on the users preference
            aw.updateReadingsLCDsVisibility() # update visibility of reading LCD based on the users preference
            
            if filename is None and self.full_screen_mode_active:
                self.showFullScreen()
                if platf != 'Darwin':
                    aw.fullscreenAction.setChecked(True)

            if filename is None and self.plus_account is not None:
                try:
                    plus.controller.start(aw)
                except:
                    pass

#            QApplication.processEvents() # this one seems to be necessary in some cases to prevent a crash (especially on Mac Legacy builds)!?
            # but with this one in place, the window size is not properly set (just the position!?)

        except Exception:
            res = False
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self,QApplication.translate("Error Message", "Error",None),QApplication.translate("Error Message", "Exception:",None) + " settingsLoad()  @line " + str(exc_tb.tb_lineno))
        return res

    def startWebLCDs(self,force=False):
        try:
            if not self.WebLCDs or force:
                from artisanlib.weblcds import startWeb
                res = startWeb(
                    self.WebLCDsPort,
                    u(self.getResourcePath()),
                    ("&nbsp;&nbsp;-.-" if aw.qmc.LCDdecimalplaces else "&nbsp;--"),
                    aw.lcdpaletteF["timer"],
                    aw.lcdpaletteB["timer"],
                    aw.lcdpaletteF["bt"],
                    aw.lcdpaletteB["bt"],
                    aw.lcdpaletteF["et"],
                    aw.lcdpaletteB["et"],
                    aw.qmc.ETlcd,
                    aw.qmc.BTlcd)
                if res:
                    self.WebLCDs = True
                    return True
                else:
                    self.stopWebLCDs()
                    self.WebLCDs = False
                    return False
            else:
                return False
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " startWebLCDs() {0}").format(str(e)),exc_tb.tb_lineno)
            self.stopWebLCDs()
            self.WebLCDs = False
            return False
            
    def stopWebLCDs(self):
        try:
            from artisanlib.weblcds import stopWeb
            stopWeb()
            self.WebLCDs = False
        except Exception:
            pass

    def applyStandardButtonVisibility(self):
        if self.eventsbuttonflag:
            self.button_11.setVisible(True)
        else:
            self.button_11.setVisible(False)
        #set default button visibility
        aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
        aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
        aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
        aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
        aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
        aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
        aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
        aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))

    def getColor(self,line):
        c = line.get_color()
        if isinstance(c, (list, tuple)):
            c = mpl.colors.rgb2hex(c)
        return c
        
#    def fetchAxisLimits(self):
#        try:
## don't fetch the axis as one might be zoomed in and then those values overwrite the standard Artisan axis setting on leaving the
## figure options dialog without editing the axis limits. Not very intuitive!
##            # x-axis min/max (in standard units)
##            xmin, xmax = map(float, aw.qmc.ax.get_xlim())
##            aw.qmc.startofx = xmin
##            aw.qmc.endofx = xmax
##            # y-axis min/max
##            ymin, ymax = map(float, aw.qmc.ax.get_ylim())
##            aw.qmc.ylimit_min = ymin
##            aw.qmc.ylimit = ymax
#            # title            
#            aw.qmc.title = aw.qmc.ax.get_title() # this would include the batch number in the title leading to duplications!
#        except:
#            pass

    def fetchCurveStyles(self):
        try:
            if aw.qmc.l_temp1:
                self.qmc.ETlinestyle = aw.qmc.l_temp1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                # otherwise the drawingstyle cannot be set back to default!
                if self.qmc.ETlinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdrawstyle = aw.qmc.l_temp1.get_drawstyle()
                else:
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = aw.qmc.l_temp1.get_linewidth()
                m = aw.qmc.l_temp1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETmarker = m
                self.qmc.palette["et"] = self.getColor(aw.qmc.l_temp1)
            if aw.qmc.l_temp2:
                self.qmc.BTlinestyle = aw.qmc.l_temp2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTlinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdrawstyle = aw.qmc.l_temp2.get_drawstyle()
                else:
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = aw.qmc.l_temp2.get_linewidth()
                m = aw.qmc.l_temp2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTmarker = m
                self.qmc.BTmarkersize = aw.qmc.l_temp2.get_markersize()
                self.qmc.palette["bt"] = self.getColor(aw.qmc.l_temp2)
            if aw.qmc.l_delta1:
                self.qmc.ETdeltalinestyle = aw.qmc.l_delta1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdeltadrawstyle = aw.qmc.l_delta1.get_drawstyle()
                else:
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = aw.qmc.l_delta1.get_linewidth()
                m = aw.qmc.l_delta1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETdeltamarker = m
                self.qmc.ETdeltamarkersize = aw.qmc.l_delta1.get_markersize()
                self.qmc.palette["deltaet"] = self.getColor(aw.qmc.l_delta1)
            if aw.qmc.l_delta2:
                self.qmc.BTdeltalinestyle = aw.qmc.l_delta2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdeltadrawstyle = aw.qmc.l_delta2.get_drawstyle()
                else:
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = aw.qmc.l_delta2.get_linewidth()
                m = aw.qmc.l_delta2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTdeltamarker = m
                self.qmc.BTdeltamarkersize = aw.qmc.l_delta2.get_markersize()  
                self.qmc.palette["deltabt"] = self.getColor(aw.qmc.l_delta2)
            if aw.qmc.l_back1:
                self.qmc.ETbacklinestyle = aw.qmc.l_back1.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.ETbackdrawstyle = aw.qmc.l_back1.get_drawstyle()
                else:
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = aw.qmc.l_back1.get_linewidth()
                m = aw.qmc.l_back1.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETbackmarker = m                
                self.qmc.ETbackmarkersize = aw.qmc.l_back1.get_markersize()
                self.qmc.backgroundmetcolor = self.getColor(aw.qmc.l_back1)
            if aw.qmc.l_back2:
                self.qmc.BTbacklinestyle = aw.qmc.l_back2.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.BTbackdrawstyle = aw.qmc.l_back2.get_drawstyle()
                else:
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = aw.qmc.l_back2.get_linewidth()
                m = aw.qmc.l_back2.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTbackmarker = m                                
                self.qmc.BTbackmarkersize = aw.qmc.l_back2.get_markersize()
                self.qmc.backgroundbtcolor = self.getColor(aw.qmc.l_back2)
            if aw.qmc.l_back3:
                self.qmc.XTbacklinestyle = aw.qmc.l_back3.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.XTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.XTbackdrawstyle = aw.qmc.l_back3.get_drawstyle()
                else:
                    self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.XTbacklinewidth = aw.qmc.l_back3.get_linewidth()
                m = aw.qmc.l_back3.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.XTbackmarker = m                                
                self.qmc.XTbackmarkersize = aw.qmc.l_back3.get_markersize()
                self.qmc.backgroundxtcolor = self.getColor(aw.qmc.l_back3)
            if aw.qmc.l_delta1B:
                self.qmc.ETBdeltalinestyle = aw.qmc.l_delta1B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETBdeltadrawstyle = aw.qmc.l_delta1B.get_drawstyle()
                else:
                    self.qmc.ETBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETBdeltalinewidth = aw.qmc.l_delta1B.get_linewidth()
                m = aw.qmc.l_delta1B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.ETBdeltamarker = m                                
                self.qmc.ETBdeltamarkersize = aw.qmc.l_delta1B.get_markersize()
                self.qmc.backgrounddeltaetcolor = self.getColor(aw.qmc.l_delta1B)
            if aw.qmc.l_delta2B:
                self.qmc.BTBdeltalinestyle = aw.qmc.l_delta2B.get_linestyle()
                #hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTBdeltadrawstyle = aw.qmc.l_delta2B.get_drawstyle()
                else:
                    self.qmc.BTBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTBdeltalinewidth = aw.qmc.l_delta2B.get_linewidth()
                m = aw.qmc.l_delta2B.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.BTBdeltamarker = m
                self.qmc.BTBdeltamarkersize = aw.qmc.l_delta2B.get_markersize()
                self.qmc.backgrounddeltabtcolor = self.getColor(aw.qmc.l_delta2B)
            x1 = x2 = 0
            for i in range(len(aw.qmc.extradevices)):
                if aw.extraCurveVisibility1[i]:
                    l1 = aw.qmc.extratemp1lines[x1]
                    self.qmc.extralinestyles1[i] = l1.get_linestyle()
                    if self.qmc.extralinestyles1[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles1[i] = l1.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles1[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths1[i] = l1.get_linewidth()
                    m = l1.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers1[i] = m
                    self.qmc.extramarkersizes1[i] = l1.get_markersize()
                    aw.qmc.extradevicecolor1[i] = self.getColor(l1)
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(aw.qmc.extradevicecolor1[i]))
                    aw.qmc.extraname1[i] = l1.get_label()
                    x1 = x1 + 1
                if aw.extraCurveVisibility2[i]:
                    l2 = aw.qmc.extratemp2lines[x2]
                    self.qmc.extralinestyles2[i] = l2.get_linestyle()
                    if self.qmc.extralinestyles2[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles2[i] = l2.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles2[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths2[i] = l2.get_linewidth()
                    m = l2.get_marker()
                    if not isinstance(m, (int)):
                        self.qmc.extramarkers2[i] = m
                    self.qmc.extramarkersizes2[i] = l2.get_markersize()
                    aw.qmc.extradevicecolor2[i] = self.getColor(l2)
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(aw.qmc.extradevicecolor2[i]))
                    aw.qmc.extraname2[i] = l2.get_label()
                    x2 = x2 + 1
            if self.qmc.eventsGraphflag in [2,3,4]:
                m = self.qmc.l_eventtype1dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[0] = m
                m = self.qmc.l_eventtype2dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[1] = m
                m = self.qmc.l_eventtype3dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[2] = m
                m = self.qmc.l_eventtype4dots.get_marker()
                if not isinstance(m, (int)):
                    self.qmc.EvalueMarker[3] = m
                self.qmc.EvalueMarkerSize[0] = self.qmc.l_eventtype1dots.get_markersize()
                self.qmc.EvalueMarkerSize[1] = self.qmc.l_eventtype2dots.get_markersize()
                self.qmc.EvalueMarkerSize[2] = self.qmc.l_eventtype3dots.get_markersize()
                self.qmc.EvalueMarkerSize[3] = self.qmc.l_eventtype4dots.get_markersize()
                self.qmc.EvalueColor[0] = self.getColor(self.qmc.l_eventtype1dots)
                self.qmc.EvalueColor[1] = self.getColor(self.qmc.l_eventtype2dots)
                self.qmc.EvalueColor[2] = self.getColor(self.qmc.l_eventtype3dots)
                self.qmc.EvalueColor[3] = self.getColor(self.qmc.l_eventtype4dots)
                self.qmc.Evaluelinethickness[0] = self.qmc.l_eventtype1dots.get_linewidth()
                self.qmc.Evaluelinethickness[1] = self.qmc.l_eventtype2dots.get_linewidth()
                self.qmc.Evaluelinethickness[2] = self.qmc.l_eventtype3dots.get_linewidth()
                self.qmc.Evaluelinethickness[3] = self.qmc.l_eventtype4dots.get_linewidth()
                self.qmc.etypes[0] = self.qmc.l_eventtype1dots.get_label()
                self.qmc.etypes[1] = self.qmc.l_eventtype2dots.get_label()
                self.qmc.etypes[2] = self.qmc.l_eventtype3dots.get_label()
                self.qmc.etypes[3] = self.qmc.l_eventtype4dots.get_label()
        except Exception as e:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " fetchCurveStyles() {0}").format(str(e)),exc_tb.tb_lineno)

    #Saves the settings when closing application. See the oppposite settingsLoad()
    def closeEvent(self,event):
        res = self.closeApp()
        if res:
            event.accept()
        else:
            event.ignore()
            
    # returns OS name and version strings
    def get_os(self):
        try:
            if platform.system().startswith('Darwin'):
                return "Mac OS X", platform.mac_ver()[0]
            elif platform.system().startswith("Windows"):
                return "Windows", platform.release()
            elif sys.platform.startswith("Linux"):
                distr = platform.linux_distribution()
                return distr[0],distr[1]
            else:
                return "",""
        except:
            return "",""
    
    def closeEventSettings(self, filename=None):
        #save window geometry and position. See QSettings documentation.
        #This information is often stored in the system registry on Windows,
        #and in XML preferences files on Mac OS X. On Unix systems, in the absence of a standard,
        #many applications (including the KDE applications) use INI text files

        try:
            if filename is not None and filename:
                settings = QSettings(filename,QSettings.IniFormat)
            else:
                settings = QSettings()
            #save window geometry if not in fullscreen mode
            if filename is None or not (self.full_screen_mode_active or self.isFullScreen()):
                settings.setValue("Geometry",self.saveGeometry())
            
            if filename is None:
                settings.setValue("fullscreen", self.full_screen_mode_active or self.isFullScreen())
                settings.setValue("plus_account",self.plus_account)
                settings.setValue("plus_remember_credentials",self.plus_remember_credentials)
                settings.setValue("plus_email",self.plus_email)
                settings.setValue("plus_language",self.plus_language)
                
            #on OS X we prevent the reopening of windows
            # as done by defaults write com.google.code.p.Artisan NSQuitAlwaysKeepsWindows -bool false
            # resulting in the entry <key>NSQuitAlwaysKeepsWindows</key><false/> in the app settings 
            # file com.google.code.p.Artisan.plist under ~/Library/Preferences/
            if sys.platform.startswith("darwin"):
                settings.setValue("NSQuitAlwaysKeepsWindows",False)
            #save mode
            settings.setValue("Mode",self.qmc.mode)
            #save system
            settings.beginGroup("System")
            settings.setValue("artisan_version",__version__)
            settings.setValue("artisan_revision",__revision__)
            settings.setValue("artisan_build",__build__)
            os,os_version = self.get_os()
            settings.setValue("artisan_os",os)
            settings.setValue("artisan_os_version",os_version)
            settings.endGroup()
            #save device
            settings.beginGroup("Device")
            settings.setValue("id",self.qmc.device)
            settings.setValue("phidget1048_types",self.qmc.phidget1048_types)
            settings.setValue("phidget1048_async",self.qmc.phidget1048_async)
            settings.setValue("phidget1048_changeTriggers",self.qmc.phidget1048_changeTriggers)
            settings.setValue("phidget1048_dataRate",self.qmc.phidget1048_dataRate)
            settings.setValue("phidget1046_async",self.qmc.phidget1046_async)
            settings.setValue("phidget1046_gain",self.qmc.phidget1046_gain)
            settings.setValue("phidget1046_formula",self.qmc.phidget1046_formula)
            settings.setValue("phidget1046_dataRate",self.qmc.phidget1046_dataRate)
            settings.setValue("phidget1045_async",self.qmc.phidget1045_async)
            settings.setValue("phidget1045_changeTrigger",self.qmc.phidget1045_changeTrigger)
            settings.setValue("phidget1045_emissivity",self.qmc.phidget1045_emissivity)
            settings.setValue("phidget1045_dataRate",self.qmc.phidget1045_dataRate)
            settings.setValue("phidget1200_formula",self.qmc.phidget1200_formula)
            settings.setValue("phidget1200_wire",self.qmc.phidget1200_wire)
            settings.setValue("phidget1200_async",self.qmc.phidget1200_async)
            settings.setValue("phidget1200_changeTrigger",self.qmc.phidget1200_changeTrigger)
            settings.setValue("phidget1200_dataRate",self.qmc.phidget1200_dataRate)
            settings.setValue("phidgetDAQ1400_powerSupply",self.qmc.phidgetDAQ1400_powerSupply)
            settings.setValue("phidgetDAQ1400_inputMode",self.qmc.phidgetDAQ1400_inputMode)
            settings.setValue("phidgetRemoteFlag",self.qmc.phidgetRemoteFlag)
            settings.setValue("phidgetServerID",self.qmc.phidgetServerID)
            settings.setValue("phidgetPassword",self.qmc.phidgetPassword)
            settings.setValue("phidgetPort",self.qmc.phidgetPort)
            settings.setValue("phidgetRemoteOnlyFlag",self.qmc.phidgetRemoteOnlyFlag)
            settings.setValue("phidget1018_async",self.qmc.phidget1018_async)
            settings.setValue("phidget1018_ratio",self.qmc.phidget1018_ratio)
            settings.setValue("phidget1018_dataRates",self.qmc.phidget1018_dataRates)
            settings.setValue("phidget1018_changeTriggers",self.qmc.phidget1018_changeTriggers)
            settings.setValue("controlETpid",self.ser.controlETpid)
            settings.setValue("readBTpid",self.ser.readBTpid)
            settings.setValue("arduinoETChannel",self.ser.arduinoETChannel)
            settings.setValue("arduinoBTChannel",self.ser.arduinoBTChannel)
            settings.setValue("arduinoATChannel",self.ser.arduinoATChannel)
            settings.setValue("ArduinoFILT",self.ser.ArduinoFILT)
            settings.setValue("useModbusPort",self.ser.useModbusPort)
            settings.setValue("showFujiLCDs",self.ser.showFujiLCDs)
            settings.setValue("PIDbuttonflag",self.qmc.PIDbuttonflag)
            settings.setValue("Controlbuttonflag",self.qmc.Controlbuttonflag)
            settings.setValue("yoctoRemoteFlag",self.qmc.yoctoRemoteFlag)
            settings.setValue("yoctoServerID",self.qmc.yoctoServerID)
            settings.setValue("YOCTO_emissivity",self.qmc.YOCTO_emissivity)
            settings.setValue("YOCTO_async",self.qmc.YOCTO_async)
            settings.setValue("YOCTO_dataRate",self.qmc.YOCTO_dataRate)
            settings.setValue("ambient_temperature_device",self.qmc.ambient_temperature_device)
            settings.setValue("ambient_humidity_device",self.qmc.ambient_humidity_device)
            settings.setValue("ambient_pressure_device",self.qmc.ambient_pressure_device)
            settings.setValue("elevation",self.qmc.elevation)
            settings.endGroup()
            settings.setValue("fmt_data_RoR",self.qmc.fmt_data_RoR)
            settings.setValue("detectBackgroundEventTime",self.qmc.detectBackgroundEventTime)
            settings.setValue("backgroundReproduce",self.qmc.backgroundReproduce)
            settings.setValue("backgroundReproduceBeep",self.qmc.backgroundReproduceBeep)
            settings.setValue("backgroundPlaybackEvents",self.qmc.backgroundPlaybackEvents)
            settings.setValue("backgroundPlaybackDROP",self.qmc.backgroundPlaybackDROP)
            settings.setValue("replayType",self.qmc.replayType)
            settings.setValue("Phases",self.qmc.phases)
            #save phasesbuttonflag
            settings.setValue("phasesbuttonflag",self.qmc.phasesbuttonflag)
            settings.setValue("phasesfromBackgroundflag",self.qmc.phasesfromBackgroundflag)
            #save phases watermarks flag
            settings.setValue("watermarks",self.qmc.watermarksflag)
            #save phases LCDs on recording flag
            settings.setValue("phasesLCDs",self.qmc.phasesLCDflag)
            settings.setValue("phasesLCDmode",self.qmc.phasesLCDmode)
            settings.setValue("phasesLCDmode_l", self.qmc.phasesLCDmode_l)
            settings.setValue("phasesLCDmode_all", self.qmc.phasesLCDmode_all)
            #phase triggered DRY and FCs
            settings.setValue("autoDry",self.qmc.autoDRYflag)
            settings.setValue("autoFCs",self.qmc.autoFCsFlag)
            #save statistics
            settings.setValue("Statistics",self.qmc.statisticsflags)
            settings.setValue("AnalysisResultsLoc",aw.qmc.analysisresultsloc)
            settings.setValue("SegmentResultsLoc",aw.qmc.segmentresultsloc)
            settings.setValue("analysisstartchoice",aw.qmc.analysisstartchoice)
            settings.setValue("analysisoffset",aw.qmc.analysisoffset)
            settings.setValue("curvefitstartchoice",aw.qmc.curvefitstartchoice)
            settings.setValue("curvefitoffset",aw.qmc.curvefitoffset)
            settings.setValue("segmentsamplesthreshold",aw.qmc.segmentsamplesthreshold)
            settings.setValue("segmentdeltathreshold",aw.qmc.segmentdeltathreshold)
            #save AUC
            settings.setValue("AUCbegin",self.qmc.AUCbegin)
            settings.setValue("AUCbase",self.qmc.AUCbase)
            settings.setValue("AUCbaseFlag",self.qmc.AUCbaseFlag)
            settings.setValue("AUCtarget",self.qmc.AUCtarget)
            settings.setValue("AUCtargetFlag",self.qmc.AUCtargetFlag)
            settings.setValue("AUCguideFlag",self.qmc.AUCguideFlag)
            settings.setValue("AUClcdFlag",self.qmc.AUClcdFlag)
            settings.setValue("AUCLCDmode",self.qmc.AUCLCDmode)
            settings.setValue("AUCshowFlag",self.qmc.AUCshowFlag)
            #save Events settings
            settings.beginGroup("events")
            settings.setValue("eventsbuttonflag",self.eventsbuttonflag)
            settings.setValue("minieventsflag",self.minieventsflag)
            settings.setValue("eventsGraphflag",self.qmc.eventsGraphflag)
            # we only store etype names if they have been modified by the user to allow automatic translations otherwise
            if ((self.qmc.etypes[0] != QApplication.translate("ComboBox", "Air",None)) or
                (self.qmc.etypes[1] != QApplication.translate("ComboBox", "Drum",None)) or
                (self.qmc.etypes[2] != QApplication.translate("ComboBox", "Damper",None)) or
                (self.qmc.etypes[3] != QApplication.translate("ComboBox", "Burner",None))):
                settings.setValue("etypes",self.qmc.etypes)                
            else:   
                settings.remove("etypes")
            settings.setValue("eventsshowflag",self.qmc.eventsshowflag)
            settings.setValue("clampEvents",self.qmc.clampEvents)
            settings.setValue("renderEventsDescr",self.qmc.renderEventsDescr)
            settings.setValue("eventslabelschars",self.qmc.eventslabelschars)
            settings.setValue("annotationsflag",self.qmc.annotationsflag)
            settings.setValue("showeventsonbt",self.qmc.showeventsonbt)
            settings.setValue("showEtypes",self.qmc.showEtypes)            
            settings.setValue("autoCharge",self.qmc.autoChargeFlag)
            settings.setValue("autoDrop",self.qmc.autoDropFlag)
            settings.setValue("markTP",self.qmc.markTPflag)
            settings.setValue("EvalueColor",self.qmc.EvalueColor)
            settings.setValue("EvalueTextColor",self.qmc.EvalueTextColor)
            settings.setValue("EvalueMarker",self.qmc.EvalueMarker)
            settings.setValue("Evaluelinethickness",self.qmc.Evaluelinethickness)
            settings.setValue("EvalueMarkerSize",self.qmc.EvalueMarkerSize)
            settings.setValue("Evaluealpha",self.qmc.Evaluealpha)
            settings.setValue("specialeventannotations", self.qmc.specialeventannotations)
            settings.setValue("specialeventannovisibilities", self.qmc.specialeventannovisibilities)
            settings.endGroup()
            #save ambient temperature source
            settings.setValue("AmbientTempSource",aw.qmc.ambientTempSource)
            #save delay (sampling interval)
            settings.setValue("Delay",self.qmc.delay)
            # save oversampling
            settings.setValue("Oversampling",self.qmc.oversampling)
            # save keepON flag
            settings.setValue("KeepON",self.qmc.flagKeepON)
            # save extra event sampling interval
            settings.setValue("ExtraEventSamplingDelay",self.qmc.extra_event_sampling_delay)
            #save colors
            settings.setValue("Colors",self.qmc.palette)
            settings.setValue("Alphas",self.qmc.alpha)
            settings.setValue("LCDColors",self.lcdpaletteB)
            settings.setValue("LEDColors",self.lcdpaletteF)
            settings.setValue("ETBColor",self.qmc.backgroundmetcolor)
            settings.setValue("BTBColor",self.qmc.backgroundbtcolor)
            settings.setValue("ETBdeltaColor",self.qmc.backgrounddeltaetcolor)
            settings.setValue("BTBdeltaColor",self.qmc.backgrounddeltabtcolor)
            settings.setValue("BackgroundAlpha",self.qmc.backgroundalpha)
            #save readings LCDs status flags
            settings.setValue("readingslcdsflags",self.readingslcdsflags)
            #save flavors
            settings.setValue("Flavors",self.qmc.flavorlabels)
            settings.setValue("flavorstartangle",self.qmc.flavorstartangle)
            #save roast color system
            settings.setValue("colorsystem",self.qmc.color_system_idx)
            #soundflag
            settings.setValue("sound",self.soundflag)
            #watermark image
            settings.setValue("logofilename", self.logofilename)
            settings.setValue("logoimgalpha", self.logoimgalpha)
            settings.setValue("logoimgflag", self.logoimgflag)
            settings.beginGroup("Tare")
            settings.setValue("names",self.qmc.container_names)
            settings.setValue("weights",self.qmc.container_weights)
            settings.setValue("idx",self.qmc.container_idx)
            settings.endGroup()            
            #save serial port
            settings.beginGroup("SerialPort")
            settings.setValue("comport",self.ser.comport)
            settings.setValue("baudrate",self.ser.baudrate)
            settings.setValue("bytesize",self.ser.bytesize)
            settings.setValue("stopbits",self.ser.stopbits)
            settings.setValue("parity",self.ser.parity)
            settings.setValue("timeout",self.ser.timeout)
            settings.endGroup()
            #save s7 port
            settings.beginGroup("S7")
            settings.setValue("area",self.s7.area)
            settings.setValue("db_nr",self.s7.db_nr)
            settings.setValue("start",self.s7.start)
            settings.setValue("type",self.s7.type)
            settings.setValue("mode",self.s7.mode)
            settings.setValue("div",self.s7.div)
            settings.setValue("host",self.s7.host)
            settings.setValue("port",self.s7.port)
            settings.setValue("rack",self.s7.rack)
            settings.setValue("slot",self.s7.slot)
            settings.setValue("PID_area",self.s7.PID_area)
            settings.setValue("PID_db_nr",self.s7.PID_db_nr)
            settings.setValue("PID_SV_register",self.s7.PID_SV_register)
            settings.setValue("PID_p_register",self.s7.PID_p_register)
            settings.setValue("PID_i_register",self.s7.PID_i_register)
            settings.setValue("PID_d_register",self.s7.PID_d_register)
            settings.setValue("PID_OFF_action",self.s7.PID_OFF_action)
            settings.setValue("PID_ON_action",self.s7.PID_ON_action)
            settings.setValue("PIDmultiplier",self.s7.PIDmultiplier)
            settings.setValue("SVmultiplier",self.s7.SVmultiplier)
            settings.endGroup()
            #save modbus port
            settings.beginGroup("Modbus")
            settings.setValue("comport",self.modbus.comport)
            settings.setValue("baudrate",self.modbus.baudrate)
            settings.setValue("bytesize",self.modbus.bytesize)
            settings.setValue("stopbits",self.modbus.stopbits)
            settings.setValue("parity",self.modbus.parity)
            settings.setValue("timeout",self.modbus.timeout)
            settings.setValue("PID_slave_ID",self.modbus.PID_slave_ID)
            settings.setValue("PID_SV_register",self.modbus.PID_SV_register)
            settings.setValue("PID_p_register",self.modbus.PID_p_register)
            settings.setValue("PID_i_register",self.modbus.PID_i_register)
            settings.setValue("PID_d_register",self.modbus.PID_d_register)
            settings.setValue("PID_OFF_action",self.modbus.PID_OFF_action)
            settings.setValue("PID_ON_action",self.modbus.PID_ON_action)
            settings.setValue("input1slave",self.modbus.inputSlaves[0])
            settings.setValue("input1register",self.modbus.inputRegisters[0])
            settings.setValue("input1float",self.modbus.inputFloats[0])
            settings.setValue("input1bcd",self.modbus.inputBCDs[0])
            settings.setValue("input1code",self.modbus.inputCodes[0])
            settings.setValue("input1div",self.modbus.inputDivs[0])
            settings.setValue("input1mode",self.modbus.inputModes[0])
            settings.setValue("input2slave",self.modbus.inputSlaves[1])
            settings.setValue("input2register",self.modbus.inputRegisters[1])
            settings.setValue("input2float",self.modbus.inputFloats[1])
            settings.setValue("input2bcd",self.modbus.inputBCDs[1])
            settings.setValue("input2code",self.modbus.inputCodes[1])
            settings.setValue("input2div",self.modbus.inputDivs[1])
            settings.setValue("input2mode",self.modbus.inputModes[1])
            settings.setValue("input3slave",self.modbus.inputSlaves[2])
            settings.setValue("input3register",self.modbus.inputRegisters[2])
            settings.setValue("input3float",self.modbus.inputFloats[2])
            settings.setValue("input3bcd",self.modbus.inputBCDs[2])
            settings.setValue("input3code",self.modbus.inputCodes[2])
            settings.setValue("input3div",self.modbus.inputDivs[2])
            settings.setValue("input3mode",self.modbus.inputModes[2])
            settings.setValue("input4slave",self.modbus.inputSlaves[3])
            settings.setValue("input4register",self.modbus.inputRegisters[3])
            settings.setValue("input4float",self.modbus.inputFloats[3])
            settings.setValue("input4bcd",self.modbus.inputBCDs[3])
            settings.setValue("input4code",self.modbus.inputCodes[3])
            settings.setValue("input4div",self.modbus.inputDivs[3])
            settings.setValue("input4mode",self.modbus.inputModes[3])
            settings.setValue("input5slave",self.modbus.inputSlaves[4])
            settings.setValue("input5register",self.modbus.inputRegisters[4])
            settings.setValue("input5float",self.modbus.inputFloats[4])
            settings.setValue("input5bcd",self.modbus.inputBCDs[4])
            settings.setValue("input5code",self.modbus.inputCodes[4])
            settings.setValue("input5div",self.modbus.inputDivs[4])
            settings.setValue("input5mode",self.modbus.inputModes[4])
            settings.setValue("input6slave",self.modbus.inputSlaves[5])
            settings.setValue("input6register",self.modbus.inputRegisters[5])
            settings.setValue("input6float",self.modbus.inputFloats[5])
            settings.setValue("input6bcd",self.modbus.inputBCDs[5])
            settings.setValue("input6code",self.modbus.inputCodes[5])
            settings.setValue("input6div",self.modbus.inputDivs[5])
            settings.setValue("input6mode",self.modbus.inputModes[5])
            settings.setValue("input7slave",self.modbus.inputSlaves[6])
            settings.setValue("input7register",self.modbus.inputRegisters[6])
            settings.setValue("input7float",self.modbus.inputFloats[6])
            settings.setValue("input7bcd",self.modbus.inputBCDs[6])
            settings.setValue("input7code",self.modbus.inputCodes[6])
            settings.setValue("input7div",self.modbus.inputDivs[6])
            settings.setValue("input7mode",self.modbus.inputModes[6])
            settings.setValue("input8slave",self.modbus.inputSlaves[7])
            settings.setValue("input8register",self.modbus.inputRegisters[7])
            settings.setValue("input8float",self.modbus.inputFloats[7])
            settings.setValue("input8bcd",self.modbus.inputBCDs[7])
            settings.setValue("input8code",self.modbus.inputCodes[7])
            settings.setValue("input8div",self.modbus.inputDivs[7])
            settings.setValue("input8mode",self.modbus.inputModes[7])

            settings.setValue("PIDmultiplier",self.modbus.PIDmultiplier)
            settings.setValue("SVmultiplier",self.modbus.SVmultiplier)
            settings.setValue("littleEndianFloats",self.modbus.byteorderLittle)
            settings.setValue("wordorderLittle",self.modbus.wordorderLittle)
            settings.setValue("type",self.modbus.type)
            settings.setValue("host",self.modbus.host)
            settings.setValue("port",self.modbus.port)
            settings.endGroup()
            #save scale port
            settings.beginGroup("Scale")
            settings.setValue("device",self.scale.device)
            settings.setValue("comport",self.scale.comport)
            settings.setValue("baudrate",self.scale.baudrate)
            settings.setValue("bytesize",self.scale.bytesize)
            settings.setValue("stopbits",self.scale.stopbits)
            settings.setValue("parity",self.scale.parity)
            settings.setValue("timeout",self.scale.timeout)
            settings.endGroup()
            #save color port
            settings.beginGroup("Color")
            settings.setValue("device",self.color.device)
            settings.setValue("comport",self.color.comport)
            settings.setValue("baudrate",self.color.baudrate)
            settings.setValue("bytesize",self.color.bytesize)
            settings.setValue("stopbits",self.color.stopbits)
            settings.setValue("parity",self.color.parity)
            settings.setValue("timeout",self.color.timeout)
            settings.endGroup()
            #save pid settings (only key and value[0])
            settings.beginGroup("ArduinoPID")
            settings.setValue("pidOnCHARGE",aw.pidcontrol.pidOnCHARGE)
            settings.setValue("loadRampSoakFromProfile",aw.pidcontrol.loadRampSoakFromProfile)
            settings.setValue("svValues",aw.pidcontrol.svValues)
            settings.setValue("svRamps",aw.pidcontrol.svRamps)
            settings.setValue("svSoaks",aw.pidcontrol.svSoaks)
            settings.setValue("svSlider",aw.pidcontrol.svSlider)
            settings.setValue("svButtons",aw.pidcontrol.svButtons)
            settings.setValue("svMode",aw.pidcontrol.svMode)
            settings.setValue("svLookahead",aw.pidcontrol.svLookahead)
            settings.setValue("dutySteps",aw.pidcontrol.dutySteps)
            settings.setValue("svSliderMin",aw.pidcontrol.svSliderMin)
            settings.setValue("svSliderMax",aw.pidcontrol.svSliderMax)
            settings.setValue("svValue",aw.pidcontrol.svValue)
            settings.setValue("dutyMin",aw.pidcontrol.dutyMin)
            settings.setValue("dutyMax",aw.pidcontrol.dutyMax)
            settings.setValue("pidKp",aw.pidcontrol.pidKp)
            settings.setValue("pidKi",aw.pidcontrol.pidKi)
            settings.setValue("pidKd",aw.pidcontrol.pidKd)
            settings.setValue("pidSource",aw.pidcontrol.pidSource)
            settings.setValue("pidCycle",aw.pidcontrol.pidCycle)
            settings.setValue("pidPositiveTarget",aw.pidcontrol.pidPositiveTarget)
            settings.setValue("pidNegativeTarget",aw.pidcontrol.pidNegativeTarget)
            settings.setValue("invertControl",aw.pidcontrol.invertControl)
            settings.setValue("pOnE",aw.pidcontrol.pOnE)
            settings.endGroup()
            settings.beginGroup("PXR")
            for key in list(self.fujipid.PXR.keys()):
                settings.setValue(key,self.fujipid.PXR[key][0])
            settings.endGroup()
            settings.beginGroup("PXG4")
            for key in list(self.fujipid.PXG4.keys()):
                settings.setValue(key,self.fujipid.PXG4[key][0])
            settings.setValue("followBackground",self.fujipid.followBackground)
            settings.setValue("lookahead",self.fujipid.lookahead)
            settings.endGroup()
            settings.beginGroup("deltaDTA")
            for key in list(self.dtapid.dtamem.keys()):
                settings.setValue(key,self.dtapid.dtamem[key][0])
            settings.endGroup()
            settings.setValue("filterDropOuts",self.qmc.filterDropOuts)
            settings.setValue("dropSpikes",self.qmc.dropSpikes)
#            settings.setValue("altSmoothing",self.qmc.altsmoothing)
            settings.setValue("optimalSmoothing",self.qmc.optimalSmoothing)
            settings.setValue("swapETBT",self.qmc.swapETBT)
            settings.setValue("minmaxLimits",self.qmc.minmaxLimits)
            settings.setValue("minLimit",self.qmc.filterDropOut_tmin)
            settings.setValue("maxLimit",self.qmc.filterDropOut_tmax)
            settings.beginGroup("RoC")
            settings.setValue("DeltaET",self.qmc.DeltaETflag)
            settings.setValue("DeltaBT",self.qmc.DeltaBTflag)
            settings.setValue("DeltaETlcd",self.qmc.DeltaETlcdflag)
            settings.setValue("DeltaBTlcd",self.qmc.DeltaBTlcdflag)
            settings.setValue("deltaETfilter",self.qmc.deltaETfilter)
            settings.setValue("deltafilter",self.qmc.deltaBTfilter)
            settings.setValue("DeltaETspan",self.qmc.deltaETspan)
            settings.setValue("DeltaSpan",self.qmc.deltaBTspan)
            settings.setValue("LCDdecimalplaces",self.qmc.LCDdecimalplaces)
            settings.setValue("statisticsmode",self.qmc.statisticsmode)
            settings.setValue("swapdeltalcds",self.qmc.swapdeltalcds)
            settings.endGroup()
            settings.setValue("curvefilter",self.qmc.curvefilter)
#            settings.setValue("smoothingwindowsize",self.qmc.smoothingwindowsize)
            settings.setValue("ETcurve",self.qmc.ETcurve)
            settings.setValue("BTcurve",self.qmc.BTcurve)
            settings.setValue("ETlcd",self.qmc.ETlcd)
            settings.setValue("BTlcd",self.qmc.BTlcd)
            settings.setValue("swaplcds",self.qmc.swaplcds)
            settings.beginGroup("DefaultButtons")
            settings.setValue("buttonvisibility",self.qmc.buttonvisibility)
            settings.setValue("buttonactions",self.qmc.buttonactions)
            settings.setValue("buttonactionstrings",self.qmc.buttonactionstrings)
            settings.setValue("extrabuttonactions",self.qmc.extrabuttonactions)
            settings.setValue("extrabuttonactionstrings",self.qmc.extrabuttonactionstrings)
            settings.setValue("xextrabuttonactions",self.qmc.xextrabuttonactions)
            settings.setValue("xextrabuttonactionstrings",self.qmc.xextrabuttonactionstrings)
            settings.endGroup()
            settings.setValue("transMappingMode",self.qmc.transMappingMode)
            settings.beginGroup("HUD")
            settings.setValue("Projection",self.qmc.projectFlag)
            settings.setValue("ProjectionMode",self.qmc.projectionmode)
            settings.setValue("ETtarget",self.qmc.ETtarget)
            settings.setValue("BTtarget",self.qmc.BTtarget)
            settings.setValue("ET2target",self.qmc.ET2target)
            settings.setValue("BT2target",self.qmc.BT2target)
            settings.setValue("Mode",self.HUDfunction)
            settings.setValue("hudETpid",self.qmc.hudETpid)
            settings.setValue("buttonFlag",self.qmc.HUDbuttonflag)
            settings.endGroup()
            settings.beginGroup("Style")
            settings.setValue("patheffects",self.qmc.patheffects)
            settings.setValue("graphstyle",self.qmc.graphstyle)
            settings.setValue("graphfont",self.qmc.graphfont)
            settings.setValue("ETname", self.ETname)
            settings.setValue("BTname", self.BTname)
            settings.endGroup()
            settings.beginGroup("Sound")
            settings.setValue("Beep",self.soundflag)
            settings.endGroup()
            settings.beginGroup("Axis")
            settings.setValue("loadAxisFromProfile",self.qmc.loadaxisfromprofile)
            settings.setValue("xmin",self.qmc.startofx)
            settings.setValue("xmax",self.qmc.endofx)
            settings.setValue("ymax",self.qmc.ylimit)
            settings.setValue("ymin",self.qmc.ylimit_min)
            settings.setValue("zmax",self.qmc.zlimit)
            settings.setValue("zmin",self.qmc.zlimit_min)
            settings.setValue("resetmaxtime",self.qmc.resetmaxtime)
            settings.setValue("lockmax",self.qmc.fixmaxtime)
            settings.setValue("locktimex",self.qmc.locktimex)
            settings.setValue("autotimex",self.qmc.autotimex)
            settings.setValue("locktimex_start",self.qmc.locktimex_start)
            settings.setValue("locktimex_end",self.qmc.locktimex_end)
            settings.setValue("legendloc",self.qmc.legendloc)
            settings.setValue("chargemintime",self.qmc.chargemintime)
            settings.setValue("temp_grid",self.qmc.temp_grid)
            settings.setValue("time_grid",self.qmc.time_grid)
            settings.endGroup()
            settings.beginGroup("RoastProperties")
            settings.setValue("drumspeed",self.qmc.drumspeed)
            settings.setValue("operator",self.qmc.operator)
            settings.setValue("roastertype",self.qmc.roastertype)
            settings.setValue("machinesetup",self.qmc.machinesetup)
#            settings.setValue("densitySampleVolume",self.qmc.density[2]) # fixed to 1l now
            settings.setValue("beansize",self.qmc.beansize)
            settings.setValue("beansize_min",self.qmc.beansize_min)
            settings.setValue("beansize_max",self.qmc.beansize_max)
            if filename is None:
                settings.setValue("plus_default_store",self.qmc.plus_default_store)
            settings.endGroup()
            settings.beginGroup("XT")
            settings.setValue("color",self.qmc.backgroundxtcolor)
            settings.setValue("index",self.qmc.xtcurveidx)
            settings.endGroup()
            settings.beginGroup("Units")
            settings.setValue("weight",self.qmc.weight[2])
            settings.setValue("volume",self.qmc.volume[2])
            settings.setValue("densityweight",self.qmc.density[1])
            settings.setValue("densityvolume",self.qmc.density[3])
            settings.setValue("volumeCalcUnit",self.qmc.volumeCalcUnit)
            settings.endGroup()
            #save alarms
            settings.beginGroup("Alarms")
            settings.setValue("alarmflag",self.qmc.alarmflag)  
            settings.setValue("alarmguard",self.qmc.alarmguard)
            settings.setValue("alarmnegguard",self.qmc.alarmnegguard)
            settings.setValue("alarmtime",self.qmc.alarmtime)
            settings.setValue("alarmoffset",self.qmc.alarmoffset)
            settings.setValue("alarmcond",self.qmc.alarmcond)
            settings.setValue("alarmsource",self.qmc.alarmsource)
            settings.setValue("alarmtemperature",self.qmc.alarmtemperature)
            settings.setValue("alarmaction",self.qmc.alarmaction)
            settings.setValue("alarmbeep",self.qmc.alarmbeep)
            settings.setValue("alarmstrings",self.qmc.alarmstrings)
            settings.setValue("loadAlarmsFromProfile",self.qmc.loadalarmsfromprofile)
            settings.setValue("loadAlarmsFromBackground",self.qmc.loadalarmsfrombackground)
            settings.setValue("alarmsfile",self.qmc.alarmsfile)
            settings.setValue("alarm_popup_timout",self.qmc.alarm_popup_timout)
            settings.setValue("alarmtablecolumnwidths",self.qmc.alarmtablecolumnwidths)
            settings.endGroup()
            settings.setValue("profilepath",self.userprofilepath)
            settings.setValue("settingspath",self.settingspath)
            settings.setValue("wheelpath",self.wheelpath)
            settings.setValue("autosavepath",self.qmc.autosavepath)
            settings.setValue("autosavealsopath",self.qmc.autosavealsopath)
            settings.setValue("simulatorpath",self.simulatorpath)
            settings.setValue("externalprogram",self.ser.externalprogram)
            settings.setValue("externaloutprogram",self.ser.externaloutprogram)
            settings.setValue("externaloutprogramFlag",self.ser.externaloutprogramFlag)
            #save extra devices
            settings.beginGroup("ExtraDev")
            settings.setValue("extradevices",self.qmc.extradevices)
            settings.setValue("extradevicecolor1",self.qmc.extradevicecolor1)
            settings.setValue("extradevicecolor2",self.qmc.extradevicecolor2)
            settings.setValue("extraname1",self.qmc.extraname1)
            settings.setValue("extraname2",self.qmc.extraname2)
            settings.setValue("extramathexpression1",self.qmc.extramathexpression1)
            settings.setValue("extramathexpression2",self.qmc.extramathexpression2)
            settings.setValue("extraLCDvisibility1",self.extraLCDvisibility1)
            settings.setValue("extraLCDvisibility2",self.extraLCDvisibility2)
            settings.setValue("extraCurveVisibility1",self.extraCurveVisibility1)
            settings.setValue("extraCurveVisibility2",self.extraCurveVisibility2)
            settings.setValue("extraDelta1",self.extraDelta1)
            settings.setValue("extraDelta2",self.extraDelta2)
            settings.setValue("extraFill1",self.extraFill1)
            settings.setValue("extraFill2",self.extraFill2)
            settings.endGroup()
            #save extra serial comm ports settings
            settings.beginGroup("ExtraComm")
            settings.setValue("extracomport",self.extracomport)
            settings.setValue("extrabaudrate",self.extrabaudrate)
            settings.setValue("extrabytesize",self.extrabytesize)
            settings.setValue("extraparity",self.extraparity)
            settings.setValue("extrastopbits",self.extrastopbits)
            settings.setValue("extratimeout",self.extratimeout)
            settings.endGroup()
            settings.setValue("ChannelTares",self.channel_tare_values)
            settings.setValue("BTfunction",self.qmc.BTfunction)
            settings.setValue("ETfunction",self.qmc.ETfunction)
            settings.setValue("DeltaBTfunction",self.qmc.DeltaBTfunction)
            settings.setValue("DeltaETfunction",self.qmc.DeltaETfunction)
            settings.setValue("resetqsettings",self.resetqsettings)
            settings.setValue("plotcurves",self.qmc.plotcurves)
            settings.setValue("plotcurvecolor",self.qmc.plotcurvecolor)
            #curve styles 
            settings.beginGroup("CurveStyles")
            settings.setValue("BTlinestyle",self.qmc.BTlinestyle)
            settings.setValue("BTdrawstyle",self.qmc.BTdrawstyle)
            settings.setValue("BTlinewidth",self.qmc.BTlinewidth)
            settings.setValue("BTmarker",self.qmc.BTmarker)
            settings.setValue("BTmarkersize",self.qmc.BTmarkersize)
            settings.setValue("ETlinestyle",self.qmc.ETlinestyle)
            settings.setValue("ETdrawstyle",self.qmc.ETdrawstyle)
            settings.setValue("ETlinewidth",self.qmc.ETlinewidth)
            settings.setValue("ETmarker",self.qmc.ETmarker)
            settings.setValue("ETmarkersize",self.qmc.ETmarkersize)
            settings.setValue("BTdeltalinestyle",self.qmc.BTdeltalinestyle)
            settings.setValue("BTdeltadrawstyle",self.qmc.BTdeltadrawstyle)
            settings.setValue("BTdeltalinewidth",self.qmc.BTdeltalinewidth)
            settings.setValue("BTdeltamarker",self.qmc.BTdeltamarker)
            settings.setValue("BTdeltamarkersize",self.qmc.BTdeltamarkersize)
            settings.setValue("ETdeltalinestyle",self.qmc.ETdeltalinestyle)
            settings.setValue("ETdeltadrawstyle",self.qmc.ETdeltadrawstyle)
            settings.setValue("ETdeltalinewidth",self.qmc.ETdeltalinewidth)
            settings.setValue("ETdeltamarker",self.qmc.ETdeltamarker)
            settings.setValue("ETdeltamarkersize",self.qmc.ETdeltamarkersize)
            settings.setValue("BTbacklinestyle",self.qmc.BTbacklinestyle)
            settings.setValue("BTbackdrawstyle",self.qmc.BTbackdrawstyle)
            settings.setValue("BTbacklinewidth",self.qmc.BTbacklinewidth)
            settings.setValue("BTbackmarker",self.qmc.BTbackmarker)
            settings.setValue("BTbackmarkersize",self.qmc.BTbackmarkersize)
            settings.setValue("ETbacklinestyle",self.qmc.ETbacklinestyle)
            settings.setValue("ETbackdrawstyle",self.qmc.ETbackdrawstyle)
            settings.setValue("ETbacklinewidth",self.qmc.ETbacklinewidth)
            settings.setValue("ETbackmarker",self.qmc.ETbackmarker)
            settings.setValue("ETbackmarkersize",self.qmc.ETbackmarkersize)
            settings.setValue("XTbacklinestyle",self.qmc.XTbacklinestyle)
            settings.setValue("XTbackdrawstyle",self.qmc.XTbackdrawstyle)
            settings.setValue("XTbacklinewidth",self.qmc.XTbacklinewidth)
            settings.setValue("XTbackmarker",self.qmc.XTbackmarker)
            settings.setValue("XTbackmarkersize",self.qmc.XTbackmarkersize)
            settings.setValue("BTBdeltalinestyle",self.qmc.BTBdeltalinestyle)
            settings.setValue("BTBdeltadrawstyle",self.qmc.BTBdeltadrawstyle)
            settings.setValue("BTBdeltalinewidth",self.qmc.BTBdeltalinewidth)
            settings.setValue("BTBdeltamarker",self.qmc.BTBdeltamarker)
            settings.setValue("BTBdeltamarkersize",self.qmc.BTBdeltamarkersize)
            settings.setValue("ETBdeltalinestyle",self.qmc.ETBdeltalinestyle)
            settings.setValue("ETBdeltadrawstyle",self.qmc.ETBdeltadrawstyle)
            settings.setValue("ETBdeltalinewidth",self.qmc.ETBdeltalinewidth)
            settings.setValue("ETBdeltamarker",self.qmc.ETBdeltamarker)
            settings.setValue("ETBdeltamarkersize",self.qmc.ETBdeltamarkersize)
            settings.setValue("extralinestyles1",self.qmc.extralinestyles1)
            settings.setValue("extralinestyles2",self.qmc.extralinestyles2)
            settings.setValue("extradrawstyles1",self.qmc.extradrawstyles1)
            settings.setValue("extradrawstyles2",self.qmc.extradrawstyles2)
            settings.setValue("extralinewidths1",self.qmc.extralinewidths1)
            settings.setValue("extralinewidths2",self.qmc.extralinewidths2)
            settings.setValue("extramarkers1",self.qmc.extramarkers1)
            settings.setValue("extramarkers2",self.qmc.extramarkers2)
            settings.setValue("extramarkersizes1",self.qmc.extramarkersizes1)
            settings.setValue("extramarkersizes2",self.qmc.extramarkersizes2)
            settings.setValue("devicetablecolumnwidths",self.qmc.devicetablecolumnwidths)
            settings.endGroup()
            #background settings
            settings.beginGroup("background")
            settings.setValue("backgrounddetails",aw.qmc.backgroundDetails)
            settings.setValue("backgroundevents",aw.qmc.backgroundeventsflag)
            settings.setValue("movespeed",aw.qmc.backgroundmovespeed)
            settings.setValue("DeltaETB",aw.qmc.DeltaETBflag)
            settings.setValue("DeltaBTB",aw.qmc.DeltaBTBflag)
            settings.setValue("alignEvent",aw.qmc.alignEvent)
            settings.setValue("ETBflag",aw.qmc.backgroundETcurve)
            settings.setValue("BTBflag",aw.qmc.backgroundBTcurve)
            settings.endGroup()
            settings.setValue("autosaveflag",self.qmc.autosaveflag)
            settings.setValue("autosavepdf",self.qmc.autosaveimage)
            settings.setValue("autosaveimageformat",self.qmc.autosaveimageformat)
            settings.setValue("autosaveprefix",self.qmc.autosaveprefix)
            settings.beginGroup("WebLCDs")
            settings.setValue("active",self.WebLCDs)
            settings.setValue("port",self.WebLCDsPort)
            settings.setValue("alerts",self.WebLCDsAlerts)
            settings.endGroup()
            settings.setValue("LargeLCDs",self.LargeLCDsFlag)
            settings.setValue("LargeDeltaLCDs",self.LargeDeltaLCDsFlag)
            settings.setValue("LargePIDLCDs",self.LargePIDLCDsFlag)
            settings.setValue("LargeExtraLCDs",self.LargeExtraLCDsFlag)
            settings.setValue("LargePhasesLCDs",self.LargePhasesLCDsFlag)
            #custom event buttons
            settings.beginGroup("ExtraEventButtons")
            settings.setValue("buttonlistmaxlen",self.buttonlistmaxlen)
            settings.setValue("extraeventstypes",self.extraeventstypes)
            settings.setValue("extraeventsvalues",self.extraeventsvalues)
            settings.setValue("extraeventsactionstrings",self.extraeventsactionstrings)
            settings.setValue("extraeventsactions",self.extraeventsactions)
            settings.setValue("extraeventsdescriptions",self.extraeventsdescriptions)
            settings.setValue("extraeventsvisibility",self.extraeventsvisibility)
            settings.setValue("extraeventslabels",self.extraeventslabels)
            settings.setValue("extraeventbuttoncolor",self.extraeventbuttoncolor)
            settings.setValue("extraeventbuttontextcolor",self.extraeventbuttontextcolor)
            settings.setValue("extraeventsbuttonsflags",self.extraeventsbuttonsflags)
            settings.setValue("buttonpalette",self.buttonpalette)
            settings.setValue("buttonpalettemaxlen",self.buttonpalettemaxlen)
            settings.setValue("buttonpalette_shortcuts",self.buttonpalette_shortcuts)
            settings.setValue("eventbuttontablecolumnwidths",self.eventbuttontablecolumnwidths)
            settings.setValue("buttonsize",self.buttonsize)
            settings.endGroup()
            settings.beginGroup("RoRlimits")
            settings.setValue("RoRlimitFlag",self.qmc.RoRlimitFlag)
            settings.setValue("RoRlimit",self.qmc.RoRlimit)
            settings.setValue("RoRlimitm",self.qmc.RoRlimitm)
            settings.endGroup()
            settings.beginGroup("grid")
            settings.setValue("xgrid",self.qmc.xgrid)
            settings.setValue("ygrid",self.qmc.ygrid)
            settings.setValue("zgrid",self.qmc.zgrid)
            settings.setValue("gridlinestyle",self.qmc.gridlinestyle)
            settings.setValue("gridthickness",self.qmc.gridthickness)
            settings.setValue("gridalpha",self.qmc.gridalpha)
#            settings.setValue("xrotation",self.qmc.xrotation)
            settings.endGroup()
            settings.beginGroup("Sliders")
            settings.setValue("slidervisibilities",self.eventslidervisibilities)
            settings.setValue("slideractions",self.eventslideractions)
            settings.setValue("slidercommands",self.eventslidercommands)
            settings.setValue("slideroffsets",self.eventslideroffsets)
            settings.setValue("sliderfactors",self.eventsliderfactors)
            settings.setValue("slidermin",self.eventslidermin)
            settings.setValue("slidermax",self.eventslidermax)
            settings.setValue("eventslidersflags",self.eventslidersflags)
            settings.setValue("eventslidercoarse",self.eventslidercoarse)
            settings.setValue("eventslidertemp",self.eventslidertemp)
            settings.setValue("eventsliderunits",self.eventsliderunits)
            settings.setValue("ModeTempSliders",self.qmc.mode_tempsliders)
            settings.endGroup()
            settings.beginGroup("Quantifiers")
            settings.setValue("quantifieractive",self.eventquantifieractive)
            settings.setValue("quantifiersource",self.eventquantifiersource)
            settings.setValue("quantifiermin",self.eventquantifiermin)
            settings.setValue("quantifiermax",self.eventquantifiermax)
            settings.setValue("quantifiercoarse",self.eventquantifiercoarse)
            settings.setValue("clusterEventsFlag",self.clusterEventsFlag)
            settings.endGroup()
            settings.setValue("titleshowalways",self.qmc.title_show_always)
            settings.setValue("roastpropertiesflag",self.qmc.roastpropertiesflag)
            settings.setValue("roastpropertiesAutoOpenFlag",self.qmc.roastpropertiesAutoOpenFlag)
            settings.setValue("customflavorlabels",self.qmc.customflavorlabels)
            settings.beginGroup("Batch")
            settings.setValue("batchcounter",self.qmc.batchcounter)
            settings.setValue("batchsequence",self.qmc.batchsequence)
            settings.setValue("batchprefix",self.qmc.batchprefix)
            settings.setValue("lastroastepoch",self.qmc.lastroastepoch)
            settings.setValue("neverUpdateBatchCounter",self.qmc.neverUpdateBatchCounter)
            settings.endGroup()
            settings.beginGroup("ExtrasMoreInfo")
            settings.setValue("showmet",self.qmc.showmet)
            settings.setValue("statssummary",self.qmc.statssummary)
            settings.setValue("statsmaxchrperline", self.qmc.statsmaxchrperline)
            settings.setValue("showtimeguide",self.qmc.showtimeguide)
            settings.endGroup()
            try:
                settings.setValue("appearance",aw.appearance)
            except:
                pass
            settings.setValue("dpi",aw.dpi)
            
            settings.setValue("recentRoasts",self.recentRoasts)
            
            if aw.curFile and filename is None:
                settings.setValue("lastLoadedProfile",aw.curFile)
            else:
                settings.setValue("lastLoadedProfile","")
            if aw.qmc.backgroundpath and filename is None:
                settings.setValue("lastLoadedBackground",aw.qmc.backgroundpath)
            else:
                settings.setValue("lastLoadedBackground","")
                

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info() 
            QMessageBox.information(aw,QApplication.translate("Error Message", "Error",None),QApplication.translate("Error Message", "Exception:",None) + " closeEvent()  @line " + str(exc_tb.tb_lineno))

    def closeEventSettings_theme(self, filename=None):
        try:
            if filename:
                settings = QSettings(filename,QSettings.IniFormat)
            else:
                settings = QSettings()
            #save Events settings
            settings.beginGroup("events")
            settings.setValue("EvalueColor",self.qmc.EvalueColor)
            settings.setValue("EvalueTextColor",self.qmc.EvalueTextColor)
            settings.setValue("EvalueMarker",self.qmc.EvalueMarker)
            settings.setValue("Evaluelinethickness",self.qmc.Evaluelinethickness)
            settings.setValue("EvalueMarkerSize",self.qmc.EvalueMarkerSize)
            settings.setValue("Evaluealpha",self.qmc.Evaluealpha)
            settings.endGroup()
            #save phases watermarks flag
            settings.setValue("watermarks",self.qmc.watermarksflag)
            #save colors
            settings.setValue("Colors",self.qmc.palette)
            settings.setValue("Alphas",self.qmc.alpha)
            settings.setValue("LCDColors",self.lcdpaletteB)
            settings.setValue("LEDColors",self.lcdpaletteF)
            settings.setValue("ETBColor",self.qmc.backgroundmetcolor)
            settings.setValue("BTBColor",self.qmc.backgroundbtcolor)
            settings.setValue("ETBdeltaColor",self.qmc.backgrounddeltaetcolor)
            settings.setValue("BTBdeltaColor",self.qmc.backgrounddeltabtcolor)
            settings.setValue("BackgroundAlpha",self.qmc.backgroundalpha)
            settings.beginGroup("XT")
            settings.setValue("color",self.qmc.backgroundxtcolor)
            settings.setValue("index",self.qmc.xtcurveidx)
            settings.endGroup()
            settings.beginGroup("grid")
            settings.setValue("gridalpha",self.qmc.gridalpha)
            settings.endGroup()

        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info() 
            QMessageBox.information(aw,QApplication.translate("Error Message", "Error",None),QApplication.translate("Error Message", "Exception:",None) + " closeEvent()  @line " + str(exc_tb.tb_lineno))

    def updateExtraLCDvisibility(self):
        n = len(self.qmc.extradevices)
        for i in range(n):
            if i < aw.nLCDS:
                if self.extraLCDvisibility1[i]:
                    if i < len(self.qmc.extraname1):
                        l1 = "<b>" + self.qmc.extraname1[i] + "</b>"
                        try:
                            l1 = l1.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3])
                        except:
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel1[i].setText(l1)
                        self.setLabelColor(self.extraLCDlabel1[i],QColor(self.qmc.extradevicecolor1[i]))
                    self.extraLCDframe1[i].setVisible(True)
                    self.extraLCD1[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe1[i].setVisible(False)
                if self.extraLCDvisibility2[i]:
                    if i < len(self.qmc.extraname2):
                        l2 = "<b>" + self.qmc.extraname2[i] + "</b>"
                        try:
                            l2 = l2.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3])
                        except:
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel2[i].setText(l2)
                        self.setLabelColor(self.extraLCDlabel2[i],QColor(self.qmc.extradevicecolor2[i]))
                    self.extraLCDframe2[i].setVisible(True)
                    self.extraLCD2[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(self.lcdpaletteF["sv"],self.lcdpaletteB["sv"]))
                else:
                    self.extraLCDframe2[i].setVisible(False)
        #hide the rest (just in case)
        for i in range(n,aw.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)

    def stopActivities(self):
        if self.full_screen_mode_active:
            if platf != 'Darwin':
                aw.fullscreenAction.setChecked(False)
            self.showNormal()
        if aw.qmc.device == 53:
            from artisanlib.hottop import stopHottop
            stopHottop()
        if aw.qmc.flagon:
            aw.qmc.ToggleMonitor()
        if aw.WebLCDs:
            aw.stopWebLCDs()
            aw.WebLCDs = True # to ensure they are started again on restart
        if self.LargeLCDsFlag and self.largeLCDs_dialog:
            tmp_LargeLCDs = self.LargeLCDsFlag # we keep the state to properly store it in the settings
            self.largeLCDs_dialog.close()
            self.LargeLCDsFlag = tmp_LargeLCDs
        if self.LargeDeltaLCDsFlag and self.largeDeltaLCDs_dialog:
            tmp_LargeLCDs = self.LargeDeltaLCDsFlag # we keep the state to properly store it in the settings
            self.largeDeltaLCDs_dialog.close()
            self.LargeDeltaLCDsFlag = tmp_LargeLCDs
        if self.LargePIDLCDsFlag and self.largePIDLCDs_dialog:
            tmp_LargeLCDs = self.LargePIDLCDsFlag # we keep the state to properly store it in the settings
            self.largePIDLCDs_dialog.close()
            self.LargePIDLCDsFlag = tmp_LargeLCDs
        if self.LargeExtraLCDsFlag and self.largeExtraLCDs_dialog:
            tmp_LargeLCDs = self.LargeExtraLCDsFlag # we keep the state to properly store it in the settings
            self.largeExtraLCDs_dialog.close()
            self.LargeExtraLCDsFlag = tmp_LargeLCDs
        if self.LargePhasesLCDsFlag and self.largePhasesLCDs_dialog:
            tmp_LargeLCDs = self.LargePhasesLCDsFlag # we keep the state to properly store it in the settings
            self.largePhasesLCDs_dialog.close()
            self.LargePhasesLCDsFlag = tmp_LargeLCDs
        # now wait until the current sampling thread is terminated
        while aw.qmc.flagsamplingthreadrunning:
            QApplication.processEvents()
            libtime.sleep(.1)
        if self.ser.R1 is not None:
            self.ser.R1 = None
        try:
            self.closeserialports()
        except Exception:
            pass
        try:
            aw.qmc.closePhidgetOUTPUTs()
        except Exception:
            pass
        aw.qmc.stopPhidgetManager()
    
    # returns True if confirmed, False if canceled by the user
    def closeApp(self):
        aw.quitAction.setEnabled(False)
        try:
            if aw.qmc.checkSaved(): # if not canceled
                flagKeepON = aw.qmc.flagKeepON
                aw.qmc.flagKeepON = False # temporarily turn keepOn off
                self.stopActivities()
                aw.qmc.flagKeepON = flagKeepON
                self.closeEventSettings()
                gc.collect()
                QApplication.exit()
                return True
            else:
                aw.quitAction.setEnabled(True)
                return False
        except:
            aw.quitAction.setEnabled(True)
            return False

    def closeserialports(self):
        # close main instrument port
        aw.ser.closeport()
        # close extra device ports
        for i in range(len(aw.extraser)):
            try:
                if aw.extraser[i].SP.isOpen():
                    aw.extraser[i].SP.close()
                    libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port get's disabled
            except Exception:
                pass
        # close modbus port
        aw.modbus.disconnect()
        # close s7 port
        aw.s7.disconnect()
        # close scale port
        try:
            if aw.scale:
                aw.scale.closeport()
        except Exception:
            pass
        # close color meter port
        try:
            if aw.color:
                aw.color.closeport()
        except Exception:
            pass

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileQuit(self,_=False):
        self.closeApp()

    @pyqtSlot()
    @pyqtSlot(bool)
    def filePrint(self,_=False):
        image = aw.qmc.grab().toImage()

        if image.isNull():
            return
        if self.printer is None:
            self.printer = QPrinter(QPrinter.HighResolution)
            self.printer.setCreator("Artisan")
        form = QPrintDialog(self.printer, self)
        if form.exec_():
            painter = QPainter(self.printer)
            rect = painter.viewport()
            size = image.size()
            size.scale(rect.size(), Qt.KeepAspectRatio)
            painter.setViewport(rect.x(), rect.y(), size.width(),size.height())
            painter.setWindow(image.rect()) #scale to fit page
            if isinstance(image, QPixmap):
                painter.drawPixmap(0,0,image)
            else:
                painter.drawImage(0, 0, image)
            painter.end()
            del painter
                
    # takes a production data generated by profileProductionData(profile) and extracts the following as keyed string values in a dict:
    #  . "id"
    #  . "time"
    #  . "datetime" (epoch, not a string!)
    #  . "title"
    #  . "beans"
    #  . "weight_in"
    #  . "weight_out"
    #  . "weight_loss"
    #  . "weight_in_num" (numeric in g)
    #  . "weight_out_num" (numeric in g)
    #  . "weight_loss_num" (numeric in %)
    def productionData2string(self,data,units=True):
        res = {}
        # id (prefix+nr)
        res["nr"] = u(data["batchnr"])
        res["id"] = ((u(data["batchprefix"]) + u(data["batchnr"])) if (data["batchnr"] != 0) else "")
        # title
        res["title"] = data["title"]
        # date and time
        res["time"] = ""
        res["date"] = ""
        if not "roastdate" in data or not data["roastdate"]:
            data["roastdate"] = QDateTime(QDate.currentDate()) # we just take the local time
        res["datetime"] = data["roastdate"].toPyDateTime() # toMSecsSinceEpoch()
        date = data["roastdate"].date()
        time = data["roastdate"].time()
        if date:
            res["time"] = u(date.toString("yy-MM-dd")) # Qt.SystemLocaleShortDate, Qt.ISODate
        if time:
            res["time"] += u(" " + time.toString("HH:mm")) # Qt.SystemLocaleShortDate, Qt.ISODate
        # beans
        res["beans"] = data["beans"]
        # weight
        if "weight" in data:
            w = data["weight"]
            unit = aw.qmc.weight[2]
            wi = aw.convertWeight(w[0],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index(unit))
            wo = aw.convertWeight(w[1],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index(unit))
            if unit in ["Kg","lb","oz"]:
                res["weight_in"] = '{0:.2f}'.format(wi)
                res["weight_out"] = '{0:.2f}'.format(wo)
            else:
                res["weight_in"] = '{0:.0f}'.format(wi)
                res["weight_out"] = '{0:.0f}'.format(wo)
            un = aw.qmc.weight[2].lower()
            loss = aw.weight_loss(w[0],w[1])
            if loss < 100 and loss > 0:
                res["weight_loss"] = '{0:.1f}'.format(loss)
            else:
                res["weight_loss"] = ""
            res["weight_in_num"] = aw.convertWeight(w[0],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index("g"))
            res["weight_out_num"] = aw.convertWeight(w[1],aw.qmc.weight_units.index(w[2]),aw.qmc.weight_units.index("g"))
            res["weight_loss_num"] = loss
            if units:
                if wi > 0:
                    res["weight_in"] += un
                if wo > 0:
                    res["weight_out"] += un
                if loss < 100 and loss > 0:
                    res["weight_loss"] += "%"
        else:
            res["weight_in"] = ""
            res["weight_out"] = ""
            res["weight_loss"] = ""
            res["weight_in_num"] = 0
            res["weight_out_num"] = 0
            res["weight_loss_num"] = 0
        return res
        
    def productionData2htmlentry(self,data):
        HTML_REPORT_TEMPLATE = u("""<tr>
<td sorttable_customkey=\"$batch_num\">$batch</td>
<td>$time</td>
<td>$title</td>
<td>$beans</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$out_num\">$weightout</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
</tr>""")
        ds = self.productionData2string(data,units=False)
        batch_html = ds["id"]
        time_html = ds["time"]
        title_html = ds["title"]
        beans_html = ds["beans"]
        try:
            if "roastUUID" in data and data["roastUUID"] is not None and data["roastUUID"] != "":
                uuid = data["roastUUID"]
                if plus.register.getPath(uuid):
                    #batch_html = '<a href="artisan://roast/{0}">{1}</a>'.format(uuid,batch_html)
                    title_html = '<a href="artisan://roast/{0}">{1}</a>'.format(uuid,title_html)
                if bool(plus.sync.getSync(uuid)):
                    time_html = '<a href="{0}" target="_blank">{1}</a>'.format(plus.util.roastLink(uuid),time_html)
                if "plus_coffee" in data and data["plus_coffee"] is not None and data["plus_coffee"] != "":
                    beans_html = '<a href="{0}" target="_blank">{1}</a>'.format(plus.util.coffeeLink(data["plus_coffee"]),beans_html)
        except:
            pass
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            batch_num = ds["nr"],
            batch = batch_html,
            time = time_html,
            title = title_html,
            beans = beans_html,
            weightin = ds["weight_in"],
            weightout = ds["weight_out"],
            weightloss = ds["weight_loss"],
            in_num = '{0:.0f}'.format(ds["weight_in_num"]),
            out_num = '{0:.0f}'.format(ds["weight_out_num"]),
            loss_num = '{0:.2f}'.format(ds["weight_loss_num"]),
        )
        
    # extracts the following from a give profile dict in a new dict:
    #  . "batchprefix": string
    #  . "batchnr": int
    #  . "title": string
    #  . "roastdate": QDateTime
    #  . "beans": string
    #  . "weight": [<weight-in>:float,<weight-out>:float,<units>: string] or None
    def profileProductionData(self,profile):
        res = {}
        # id ("prefix+nr (sequence)")
        if "roastbatchprefix" in profile:
            res["batchprefix"] = d(profile["roastbatchprefix"])
        else:
            res["batchprefix"] = ""
        # batch number
        if "roastbatchnr" in profile:
            res["batchnr"] = int(profile["roastbatchnr"])
        else:
            res["batchnr"] = 0
        # UUID
        if "roastUUID" in profile:
            res["roastUUID"] = profile["roastUUID"]
        # plus_coffee
        if "plus_coffee" in profile:
            res["plus_coffee"] = profile["plus_coffee"]
        # title
        if "title" in profile:
            res["title"] = d(profile["title"])
        else:
            res["title"] = ""
        # date and time
        res["roastdate"] = None
        if "roastdate" in profile:
            try:
                date = QDate.fromString(d(profile["roastdate"]))
                if "roasttime" in profile:
                    try:
                        time = QTime.fromString(d(profile["roasttime"]))
                        res["roastdate"] = QDateTime(date,time)
                    except Exception:
                        res["roastdate"] = QDateTime(date)
                else:
                    res["roastdate"] = QDateTime(date)
            except Exception:
                pass
        if "roastisodate" in profile:
            try:
                date = QDate.fromString(d(profile["roastisodate"]), Qt.ISODate)
                if "roasttime" in profile:
                    try:
                        time = QTime.fromString(d(profile["roasttime"]))
                        res["roastdate"] = QDateTime(date,time)
                    except Exception:
                        res["roastdate"] = QDateTime(date)
                else:
                    res["roastdate"] = QDateTime(date)
            except Exception:
                pass
        # beans
        if "beans" in profile:
            res["beans"] = d(profile["beans"])
        else:
            res["beans"] = ""
        # weight
        if "weight" in profile:
            res["weight"] = [profile["weight"][0],profile["weight"][1],d(profile["weight"][2])]
        return res

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionReport(self,_=False):
        # get profile filenames
        files = self.reportFiles()
        try:
            if files and len(files) > 0:
                profiles = [self.deserialize(f) for f in files]
                # let's sort by isodate
                profiles = sorted(profiles, 
                    key=lambda p: (QDateTime(QDate.fromString(p["roastisodate"], Qt.ISODate),QTime.fromString(p["roasttime"])).toMSecsSinceEpoch()
                         if "roastisodate" in p and "roasttime" in p else 0))
                with open(u(self.getResourcePath() + 'report-template.htm'), 'r') as myfile:
                    HTML_REPORT_TEMPLATE=myfile.read()
                entries = ""
                total_in = 0 
                total_out = 0
                unit = aw.qmc.weight[2]
                # collect data
                c = 1
                for p in profiles:
                    d = self.profileProductionData(p)
                    last_unit = d["weight"][2]
                    total_in += aw.convertWeight(d["weight"][0],aw.qmc.weight_units.index(last_unit),aw.qmc.weight_units.index(unit))
                    total_out += aw.convertWeight(d["weight"][1],aw.qmc.weight_units.index(last_unit),aw.qmc.weight_units.index(unit))
                    entries += self.productionData2htmlentry(d) + "\n"
                    c += 1
                
                html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                    title = u(QApplication.translate("HTML Report Template", "Roast Batches", None)),
                    entries = entries,
                    total_in = ('{0:.2f}'.format(total_in) if unit in ["Kg","lb", "oz"] else '{0:.0f}'.format(total_in)),
                    total_out = ('{0:.2f}'.format(total_out) if unit in ["Kg","lb", "oz"] else '{0:.0f}'.format(total_out)),
                    total_loss = '{0:.1f}'.format(aw.weight_loss(total_in,total_out)),
                    resources = u(self.getResourcePath()),
                    batch = u(QApplication.translate("HTML Report Template", "Batch", None)),
                    time = u(QApplication.translate("HTML Report Template", "Date", None)),
                    profile = u(QApplication.translate("Label", "Title", None)),
                    beans = u(QApplication.translate("HTML Report Template", "Beans", None)),
                    weightin = u(QApplication.translate("HTML Report Template", "In", None)),
                    weightout = u(QApplication.translate("HTML Report Template", "Out", None)),
                    loss = u(QApplication.translate("HTML Report Template", "Loss", None)),
                    sum = u(QApplication.translate("HTML Report Template", "SUM", None)),
                    unit = unit.lower()
                )
                    
                f = None
                try:
                    tmpdir = u(QDir.tempPath() + "/")
                    filename = u(QDir(tmpdir).filePath("ProductionReport.html"))
                    try:
                        os.remove(filename)
                    except OSError:
                        pass
                    f = codecs.open(filename, 'w', encoding='utf-8')
                    for i in range(len(html)):
                        f.write(html[i])
                    f.close()
                    if platf == 'Darwin':
                        full_path = "file://" + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                    else:
                        full_path = "file:///" + filename # Explorer refuses to start otherwise
                    QDesktopServices.openUrl(QUrl(full_path, QUrl.TolerantMode)) 
                    
                except IOError as e:
                    aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " productionReport() {0}").format(str(e)))
                finally:
                    if f:
                        f.close()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " productionReport() {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveStatistics(self,_=False):
        try:
            aw.qmc.redraw()
            QApplication.processEvents()
            # 0. MPL coordinate systems & transformations: 
            #   https://matplotlib.org/3.1.1/tutorials/advanced/transforms_tutorial.html
            # 1.get bounding box in axis cooridnates
            try:
                rect_extents = aw.qmc.stats_summary_rect.get_bbox()
            except Exception as e:
                aw.sendmessage(QApplication.translate("Message","No statistics found", None))
                return
            # 2. convert those to display coordinates
            rect_extents_display = aw.qmc.ax.transData.transform(rect_extents)
            # 3. convert display coordinates to figure-inches
            rect_extents_bbox_inches = aw.qmc.fig.dpi_scale_trans.inverted().transform(rect_extents_display)
            # 4. generate
            rect_bbox_inches =  mpl.transforms.Bbox.from_extents(rect_extents_bbox_inches)
            # 5. fig.save
            # MPL 3.1.1 does not properly handle saving pdf on Windows when figure dpi not 72.  Maybe fixed in a future version.
            # ref: https://github.com/matplotlib/matplotlib/issues/15497#issuecomment-548072609
            if platf == 'Windows':
                ext = "*.png"
            else:
                ext = "*.pdf"
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Statistics",None), ext=ext)
            if filename:
                aw.qmc.fig.set_tight_layout(False)
                aw.qmc.fig.savefig(filename,bbox_inches=rect_bbox_inches,pad_inches=0)
                aw.qmc.fig.set_tight_layout(aw.qmc.tight_layout_params)
                aw.sendmessage(QApplication.translate("Message","Statistics Saved",None))

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " saveStatistics() {0}").format(str(e)),exc_tb.tb_lineno)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def productionCSVReport(self,_=False):
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg="Export CSV",ext="*.csv")
            if filename:
                try:
                    # write header
                    import csv
                    outfile = open(filename, 'w',newline="")
                    writer= csv.writer(outfile,delimiter='\t')
                    writer.writerow(["batch","time","profile","beans","in (g)","out (g)"])
                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            d = self.productionData2string(self.profileProductionData(self.deserialize(p)),units=False)
                            writer.writerow([
                                s2a(d["id"]),
                                s2a(d["time"]),
                                s2a(d["title"]),
                                s2a(d["beans"]),
                                '{0:.3f}'.format(d["weight_in_num"]), # str(d["weight_in_num"]),  
                                '{0:.3f}'.format(d["weight_out_num"]), # str(d["weight_out_num"]),
                                ])
                            c += 1
                        except:
                            pass
                    # close file
                    outfile.close()
                except:
                    pass
                    
    def excel_date(self,date_time):
        delta = date_time - datetime.datetime(1899, 12, 30)
        return float(delta.days  - 1462) + (float(delta.seconds) / 86400)

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionExcelReport(self,_=False):
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg="Export Excel",ext="*.xlsx")
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook
                    #from openpyxl.compat import range  # @UnusedImport
                    #from openpyxl.cell import get_column_letter
                    from openpyxl.utils.cell import get_column_letter  # @UnusedImport 
                    from openpyxl.styles import Font, Fill  # @UnusedImport
                    wb = Workbook()
                    ws = wb.active # wb.create_sheet()
                    ws.title = u(QApplication.translate("HTML Report Template", "Production Report",None)) 
                    
                    bf = Font(bold=True)
                    unit = aw.qmc.weight[2]
                    
                    # write header
                    ws['A1'] = u(QApplication.translate("HTML Report Template", "Batch",None))
                    ws['A1'].font = bf
                    ws['B1'] = u(QApplication.translate("HTML Report Template", "Time",None)) 
                    ws['B1'].font = bf
                    ws.column_dimensions['B'].width = 18
                    ws['C1'] = u(QApplication.translate("HTML Report Template", "Profile",None)) 
                    ws['C1'].font = bf 
                    ws.column_dimensions['C'].width = 25
                    ws['D1'] = u(QApplication.translate("HTML Report Template", "Beans",None)) 
                    ws['D1'].font = bf 
                    ws.column_dimensions['D'].width = 25
                    ws['E1'] = u(QApplication.translate("HTML Report Template", "In",None)) + " (" + u(unit.lower()) + ")"
                    ws['E1'].font = bf 
                    ws['F1'] = u(QApplication.translate("HTML Report Template", "Out",None)) + " (" + u(unit.lower()) + ")"
                    ws['F1'].font = bf
                    ws['G1'] = u(QApplication.translate("HTML Report Template", "Loss",None))
                    ws['G1'].font = bf 

                    def avgFormat(c,r1,r2):
                        e1 = "{1}{0}".format(c,r1)
                        e2 ="{1}{0}".format(c,r2)
                        return '=IF(' + e1 + '=0,0,(' + e1 + ' - ' + e2 + ') / ' + e1 + ')'
                    
                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            raw_data = self.profileProductionData(self.deserialize(p))
                            c += 1
                            d = self.productionData2string(raw_data,units=False)
                            ws['A{0}'.format(c)] = d["id"]
                            ws['B{0}'.format(c)] = QDateTime(d["datetime"]).toPyDateTime()
                            ws['B{0}'.format(c)].number_format = 'YYYY-MM-DD HH:MM'
                            ws['C{0}'.format(c)] = d["title"]
                            ws['D{0}'.format(c)] = d["beans"]
                            w_in = aw.convertWeight(raw_data["weight"][0],aw.qmc.weight_units.index(raw_data["weight"][2]),aw.qmc.weight_units.index(unit))
                            w_out = aw.convertWeight(raw_data["weight"][1],aw.qmc.weight_units.index(raw_data["weight"][2]),aw.qmc.weight_units.index(unit))                            
                            ws['E{0}'.format(c)] = w_in
                            if unit in["Kg","lb","oz"]:
                                num_format = '0.00'
                            else:
                                num_format = '0'
                            ws['E{0}'.format(c)].number_format = num_format
                            ws['F{0}'.format(c)] = w_out
                            ws['F{0}'.format(c)].number_format = num_format
                            ws['G{0}'.format(c)] = avgFormat(c,"E","F")
                            ws['G{0}'.format(c)].number_format = '0.0%'
                        except Exception as e:
#                            import traceback
#                            traceback.print_exc(file=sys.stdout)
                            pass
                    # write trailer
                    if c > 1:
                        ws['A{0}'.format(c+1)] = u(QApplication.translate("HTML Report Template", "SUM", None))
                        ws['A{0}'.format(c+1)].font = bf 
                        ws['E{0}'.format(c+1)] = "=SUM(E2:E{0})".format(c)
                        ws['E{0}'.format(c+1)].font = bf 
                        ws['E{0}'.format(c+1)].number_format = num_format
                        ws['F{0}'.format(c+1)] = "=SUM(F2:F{0})".format(c)
                        ws['F{0}'.format(c+1)].font = bf 
                        ws['F{0}'.format(c+1)].number_format = num_format
                        ws['G{0}'.format(c+1)] = avgFormat(c+1,"E","F")
                        ws['G{0}'.format(c+1)].font = bf 
                        ws['G{0}'.format(c+1)].number_format = '0.0%'
                    wb.save(filename)
                    aw.sendmessage(QApplication.translate("Message","Excel Production Report exported to {0}", None).format(filename))
                except Exception as e:
#                    import traceback
#                    traceback.print_exc(file=sys.stdout)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " productionExcelReport() {0}").format(str(e)),exc_tb.tb_lineno)
                    pass

    # extracts the following from a give profile dict in a new dict:
    #  . "temp_unit": string (temperature unit, F or C)
    #  . "timex" : [] array of sample times
    #  . "temp2" : [] array of temperatures
    #  . "charge_temp": int
    #  . "FCs_time": int (in seconds)
    #  . "FCs_temp": string
    #  . "DROP_time": int (in seconds)
    #  . "DROP_temp": string
    #  . "DRY_percent": float (first phase percentage)
    #  . "MAI_percent": float (second phase percentage)
    #  . "DEV_percent": float (third phase percentage)
    #  . "DRY_time": int (in seconds) 
    #  . "MAI_time": int (in seconds) 
    #  . "DEV_time": int (in seconds) 
    #  . "AUC": int
    #  . "color": int
    #  . "cup": int
    def profileRankingData(self,profile):
        res = {}
        # temp_unit
        res["temp_unit"] = profile["mode"]
        timex = profile["timex"]
        res["timex"] = timex
        timeindex = profile["timeindex"]
        res["charge_idx"] = (timeindex[0] if timeindex[0] > -1 else 0)
        res["drop_idx"] = (timeindex[6] if timeindex[6] > 0 else len(timex))
        bt = profile["temp2"]        
        res["temp"] = bt
        # charge_temp
        if timeindex[0] > -1:
            start = timex[timeindex[0]]
            res["charge_temp"] = bt[timeindex[0]]
        else:
            start = 0
        if timeindex[2] > 0:
            # FCs_time
            res["FCs_time"] = timex[timeindex[2]] - start
            # FCs_temp
            res["FCs_temp"] = bt[timeindex[2]]
        if timeindex[6] > 0:
            # DROP_time
            res["DROP_time"] = timex[timeindex[6]] - start
            # DROP_temp
            res["DROP_temp"] = bt[timeindex[6]]
        if len(timex) > timeindex[6]:
            total_time = (timex[timeindex[6]] - start)
        else:
            total_time = 0
        # DRY_time
        if timeindex[1] > 0:
            # DRY_time
            dry_time = timex[timeindex[1]] - start
            # DRY_percent
            if total_time > 0:
                res["DRY_percent"] = (dry_time/total_time) * 100.
            else:
                res["DRY_percent"] = 0
            res["DRY_time"] = dry_time
        # MAI_time
        if timeindex[1] > 0 and timeindex[2] > 0:
            # MAI_time
            mai_time = timex[timeindex[2]] - timex[timeindex[1]]
            # MAI_percent
            if total_time > 0:
                res["MAI_percent"] = (mai_time/total_time) * 100.
            else:
                res["MAI_percent"] = 0
            res["MAI_time"] = mai_time
        if timeindex[2] > 0 and timeindex[6] > 0:
            # DEV_time
            dev_time = timex[timeindex[6]] - timex[timeindex[2]]
            # DEV_percent
            if total_time > 0:
                res["DEV_percent"] = (dev_time/total_time) * 100.
            else:
                res["DEV_percent"] = 0
            res["DEV_time"] = dev_time
        # AUC
        if "computed" in profile:
            comp = profile["computed"]
            if "AUC" in comp:
                res["AUC"] = comp["AUC"]
        # color
        if "ground_color" in profile:
            res["color"] = profile["ground_color"]
        # cup
        if "flavors" in profile:
            res["cupping"] = self.cuppingSum(profile["flavors"])
        return res
        
        
    # takes ranking data generated by profileRankingData(profile) and extracts the following as keyed string values in a dict:
    #  . "charge_temp"
    #  . "FCs_time"
    #  . "FCs_temp"
    #  . "DROP_time"
    #  . "DROP_temp"
    #  . "DRY_percent"
    #  . "MAI_percent"
    #  . "DEV_percent"
    #  . "AUC"
    #  . "color"
    #  . "cupping"
    def rankingData2string(self,data,units=True):
        res = {}
        res["charge_temp_num"] = (aw.qmc.convertTemp(data["charge_temp"],(data["temp_unit"] if units else ""),aw.qmc.mode) if "charge_temp" in data else 0)
        res["charge_temp"] = self.formatTemp(data,"charge_temp",data["temp_unit"],units)
        res["FCs_time_num"] = (data["FCs_time"] if "FCs_time" in data else 0)
        res["FCs_time"] = (self.eventtime2string(data["FCs_time"]) if "FCs_time" in data else "")
        res["FCs_temp_num"] = (aw.qmc.convertTemp(data["FCs_temp"],(data["temp_unit"] if units else ""),aw.qmc.mode) if "FCs_temp" in data else 0)
        res["FCs_temp"] = self.formatTemp(data,"FCs_temp",data["temp_unit"],units)
        res["DROP_time_num"] = (data["DROP_time"] if "DROP_time" in data else 0)
        res["DROP_time"] = (self.eventtime2string(data["DROP_time"]) if "DROP_time" in data else "")
        res["DROP_temp_num"] = (aw.qmc.convertTemp(data["DROP_temp"],(data["temp_unit"] if units else ""),aw.qmc.mode) if "DROP_temp" in data else 0)
        res["DROP_temp"] = self.formatTemp(data,"DROP_temp",data["temp_unit"],units)
        res["color_num"] = (data["color"] if "color" in data else 0)
        res["color"] = (("#" if units else "" ) + str(data["color"]) if "color" in data and data["color"] != 0 else "")
        res["cupping"] = '{0:.2f}'.format(data["cupping"])
        res["DRY_percent_num"] = ('{0:.1f}'.format(data["DRY_percent"]) if "DRY_percent" in data else 0)
        res["DRY_percent"] = ('{0:.1f}'.format(data["DRY_percent"]) + ("%" if units else "") if "DRY_percent" in data else "")
        res["MAI_percent_num"] = ('{0:.1f}'.format(data["MAI_percent"]) if "MAI_percent" in data else 0)
        res["MAI_percent"] = ('{0:.1f}'.format(data["MAI_percent"]) + ("%" if units else "") if "MAI_percent" in data else "")
        res["DEV_percent_num"] = ('{0:.1f}'.format(data["DEV_percent"]) if "DEV_percent" in data else 0)
        res["DEV_percent"] = ('{0:.1f}'.format(data["DEV_percent"]) + ("%" if units else "") if "DEV_percent" in data else "")
        res["AUC_num"] = (data["AUC"] if "AUC" in data else 0)
        res["AUC"] = (data["AUC"] if "AUC" in data else "")
        return res
        
    def formatTemp(self,data,key,unit,units=True):
        if aw.qmc.LCDdecimalplaces:
            fmt = '{0:.1f}'
        else:
            fmt = '{0:.0f}'
        return (fmt.format(aw.qmc.convertTemp(data[key],unit,aw.qmc.mode)) + (aw.qmc.mode if units else "") if key in data else "")

    def rankingData2htmlentry(self,production_data,ranking_data,plot_color=None):
        HTML_REPORT_TEMPLATE = u("""<tr>
<td$color_code>$batch</td>
<td>$time</td>
<td>$title</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$charge_temp_num\">$charge_temp</td>
<td sorttable_customkey=\"$FCs_time_num\">$FCs_time</td>
<td sorttable_customkey=\"$FCs_temp_num\">$FCs_temp</td>
<td sorttable_customkey=\"$DROP_time_num\">$DROP_time</td>
<td sorttable_customkey=\"$DROP_temp_num\">$DROP_temp</td>
<td sorttable_customkey=\"$DRY_percent_num\">$DRY_percent</td>
<td sorttable_customkey=\"$MAI_percent_num\">$MAI_percent</td>
<td sorttable_customkey=\"$DEV_percent_num\">$DEV_percent</td>
<td sorttable_customkey=\"$AUC_num\">$AUC</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
<td sorttable_customkey=\"$color_num\">$color</td>
<td>$cupping</td>
</tr>""")
        pd = self.productionData2string(production_data,units=False)
        rd = self.rankingData2string(ranking_data,units=False)
        batch_td_color = ""
        if plot_color is not None:
            batch_color = [x * 100 for x in plot_color[0:3]]
            batch_color.append(0.7)
            batch_td_color = u(' style="background-color: rgba(' + '%,'.join(map(str, batch_color)) + ')"')
        batch_html = pd["id"]
        time_html = pd["time"]
        title_html = pd["title"]
        try:
            if "roastUUID" in production_data and production_data["roastUUID"] is not None:
                uuid = production_data["roastUUID"]
                if plus.register.getPath(uuid):
                    #batch_html = '<a href="artisan://roast/{0}">{1}</a>'.format(uuid,batch_html)
                    title_html = '<a href="artisan://roast/{0}">{1}</a>'.format(uuid,title_html)
                if bool(plus.sync.getSync(uuid)):
                    time_html = '<a href="{0}" target="_blank">{1}</a>'.format(plus.util.roastLink(uuid),time_html)
        except:
            pass
        weight_fmt = ('{0:.2f}' if aw.qmc.weight[2] in ["Kg", "lb", "oz"] else '{0:.0f}')
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            color_code = batch_td_color,
            batch = batch_html,
            time = time_html,
            title = title_html,
            in_num = weight_fmt.format(pd["weight_in_num"]),
            weightin = pd["weight_in"],
            charge_temp_num = '{0:.2f}'.format(rd["charge_temp_num"]),
            charge_temp = rd["charge_temp"],
            FCs_time_num = rd["FCs_time_num"],
            FCs_time = rd["FCs_time"],
            FCs_temp_num = '{0:.2f}'.format(rd["FCs_temp_num"]),
            FCs_temp = rd["FCs_temp"],
            DROP_time_num = rd["DROP_time_num"],
            DROP_time = rd["DROP_time"],
            DROP_temp_num = '{0:.2f}'.format(rd["DROP_temp_num"]),
            DROP_temp = rd["DROP_temp"],
            DRY_percent_num = rd["DRY_percent_num"],
            DRY_percent = rd["DRY_percent"],
            MAI_percent_num = rd["MAI_percent_num"],
            MAI_percent = rd["MAI_percent"],
            DEV_percent_num = rd["DEV_percent_num"],
            DEV_percent = rd["DEV_percent"],
            AUC_num = rd["AUC_num"],
            AUC = rd["AUC"],
            loss_num = '{0:.2f}'.format(pd["weight_loss_num"]),
            weightloss = pd["weight_loss"],
            color_num = str(rd["color_num"]),
            color = rd["color"],
            cupping = rd["cupping"],
        )

    def reportFiles(self):
        import zipfile
        import tempfile
        # get profile filenames
        selected_files = self.ArtisanOpenFilesDialog(ext="*.alog *.zip")      # added zip files
        files = []
        for f in selected_files:
            if zipfile.is_zipfile(f):
                zf = zipfile.ZipFile(f)
                ziptmpdir = tempfile.mkdtemp()
                zf.extractall(ziptmpdir)
                for n in zf.namelist():
                    nf = os.path.join(ziptmpdir,n)
                    if os.path.splitext(nf)[1] == ".alog":
                        files.append(nf)
            else: # a normal *.alog file
                files.append(f)
        return files
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingReport(self,_=False):
        # get profile filenames
        files = self.reportFiles()
        if files and len(files) > 0:
            cont = aw.qmc.reset(soundOn=False)
            if cont:
                profiles = [self.deserialize(f) for f in files]
                # let's sort by isodate
                profiles = sorted(profiles, 
                    key=lambda p: (QDateTime(QDate.fromString(p["roastisodate"], Qt.ISODate),QTime.fromString(p["roasttime"])).toMSecsSinceEpoch()
                         if "roastisodate" in p and "roasttime" in p else 0))
                with open(u(self.getResourcePath() + 'ranking-template.htm'), 'r') as myfile:
                    HTML_REPORT_TEMPLATE=myfile.read()
                entries = ""
                charges = 0
                charges_count = 0
                charges_temp = 0
                charges_temp_count = 0
                FCs_time = 0
                FCs_time_count = 0
                FCs_temp = 0
                FCs_temp_count = 0
                DROP_time = 0
                DROP_time_count = 0
                DROP_temp = 0
                DROP_temp_count = 0
                DRY_percent = 0
                DRY_percent_count = 0
                MAI_percent = 0
                MAI_percent_count = 0
                DEV_percent = 0
                DEV_percent_count = 0
                AUC = 0
                AUC_count = 0
                loss = 0
                loss_count = 0 
                colors = 0
                colors_count = 0
                cuppings = 0
                cuppings_count = 0
                handles = []
                labels = []
                timex_list = []
                stemp_list = []
                cl_list = []
                max_profiles = 20
                color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))  # @UndefinedVariable
                # collect data
                c = 1
                foreground_profile_path = aw.curFile  # @UndefinedVariable
                min_start_time = max_end_time = 0
                first_profile = True
                first_profile_event_time = 0
                max_drop_time = 0
                label_chr_nr = 0
                
                for p in profiles:
                    pd = self.profileProductionData(p)
                    c += 1
                    try:
                        cl = next(color) # here to keep colors in sync with the pct graph colors
                    except Exception as e:
                        color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))  # @UndefinedVariable
                        cl = next(color)
                    try:
                        rd = self.profileRankingData(p)
                    except Exception as e:
    #                        import traceback
    #                        traceback.print_exc(file=sys.stdout)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception (probably due to an empty profile):",None) + " rankingReport() {0}").format(str(e)),exc_tb.tb_lineno)
                        continue
                    i = aw.convertWeight(pd["weight"][0],aw.qmc.weight_units.index(pd["weight"][2]),aw.qmc.weight_units.index(aw.qmc.weight[2]))
                    #o = aw.convertWeight(pd["weight"][1],aw.qmc.weight_units.index(pd["weight"][2]),aw.qmc.weight_units.index(aw.qmc.weight[2]))
                    if i > 0:
                        charges += i
                        charges_count += 1
                    if "charge_temp" in rd:
                        charges_temp += aw.qmc.convertTemp(rd["charge_temp"],rd["temp_unit"],aw.qmc.mode)
                        charges_temp_count += 1
                    if "FCs_time" in rd:
                        FCs_time += rd["FCs_time"]
                        FCs_time_count += 1
                    if "FCs_temp" in rd:
                        FCs_temp += aw.qmc.convertTemp(rd["FCs_temp"],rd["temp_unit"],aw.qmc.mode)
                        FCs_temp_count += 1
                    if "DROP_time" in rd:
                        if rd["DROP_time"] > max_drop_time:
                            max_drop_time = rd["DROP_time"]
                        DROP_time += rd["DROP_time"]
                        DROP_time_count += 1
                    if "DROP_temp" in rd:
                        DROP_temp += aw.qmc.convertTemp(rd["DROP_temp"],rd["temp_unit"],aw.qmc.mode)
                        DROP_temp_count += 1
                    if "DRY_percent" in rd:
                        DRY_percent += rd["DRY_percent"]
                        DRY_percent_count += 1
                    if "MAI_percent" in rd:
                        MAI_percent += rd["MAI_percent"]
                        MAI_percent_count += 1
                    if "DEV_percent" in rd:
                        DEV_percent += rd["DEV_percent"]
                        DEV_percent_count += 1
                    # -- recompute AUC with actual settings
                    try:
                        AUCidx = max(0,aw.AUCstartidx(p["timeindex"],p["computed"]["TP_time"]))
                        if aw.qmc.AUCbaseFlag:
                            # we take the base temperature from the BT at st
                            rtbt = p["temp2"][AUCidx]
                        else:
                            rtbt = aw.qmc.AUCbase
                        rtbt = aw.qmc.convertTemp(rtbt,aw.qmc.mode,"C")
                        ed = min(len(p["timex"]),p["timeindex"][6])
                        BT_AUC = 0
                        for i in range(AUCidx,ed):
                            BT_AUC += self.calcAUC(rtbt,p["timex"],p["temp2"],i)
                        BT_AUC = int(round(BT_AUC/60.))
                        rd["AUC"] = BT_AUC
                    except:
                        pass
                    # -- 
                    if "AUC" in rd:
                        AUC += rd["AUC"]
                        AUC_count += 1
                        
                    if pd["weight"][0] > 0 and pd["weight"][1] > 0: 
                        l = aw.weight_loss(pd["weight"][0],pd["weight"][1])
                        if l < 100 and l > 0:
                            loss += l
                            loss_count += 1
                    if "color" in rd and rd["color"] > 0:
                        colors += rd["color"]
                        colors_count += 1
                    if rd["cupping"] > 0:
                        cuppings += rd["cupping"]
                        cuppings_count += 1
                    if len(profiles) > max_profiles:
                        entries += self.rankingData2htmlentry(pd,rd, cl) + "\n"
                    else:
                        # add BT curve to graph
                        try:
                            
                            if pd["batchnr"] > 0:
                                label = u(pd["batchprefix"]) + u(pd["batchnr"])
                            elif label_chr_nr < 26:
                                label = u(libstring.ascii_uppercase[label_chr_nr])
                                pd["batchnr"] = ""
                                pd["batchprefix"] = label
                                label_chr_nr = label_chr_nr + 1
                            # surpress default description
#                            if pd["title"] == QApplication.translate("Scope Title", "Roaster Scope",None):
#                                pd["title"] = ""
                            
                            entries += self.rankingData2htmlentry(pd,rd, cl) + "\n"
                            
                            temp = [aw.qmc.convertTemp(t,rd["temp_unit"],self.qmc.mode) for t in rd["temp"]]
                            timex = rd["timex"]       
                            stemp = self.qmc.smooth_list(timex,self.qmc.fill_gaps(temp),window_len=self.qmc.curvefilter,decay_smoothing=not aw.qmc.optimalSmoothing)
                            charge = max(0,rd["charge_idx"]) # start of visible data
                            drop = rd["drop_idx"] # end of visible data
                            stemp = numpy.concatenate(([None]*charge,stemp[charge:drop],[None]*(len(timex)-drop)))
                            timeindex = p["timeindex"]
                            if len(timex) > rd["charge_idx"]:
                                if first_profile:
                                # align with CHARGE
                                    delta = timex[rd["charge_idx"]]
                                    # store relative time of align event of first profile
                                    # CHARGE, DRY, FCs, FCe, SCs, SCe, DROP
                                    first_profile_event_time = delta # CHARGE
                                    for j in range(6,0,-1):
                                        if aw.qmc.alignEvent in [j] and timeindex[j]:
                                            first_profile_event_time = timex[timeindex[j]] - timex[rd["charge_idx"]]
                                            break
                                else:
                                    delta = timex[rd["charge_idx"]]
                                    for j in range(6,0,-1):
                                        if aw.qmc.alignEvent in [j] and timeindex[j]:
                                            delta = delta + (timex[timeindex[j]] - timex[rd["charge_idx"]] - first_profile_event_time)
                                            break
                            else:
                                delta = 0
                            timex = [t-delta for t in timex]
                            if len(timex) > charge:
                                min_start_time = min(min_start_time,timex[charge])
                            if len(timex) > drop:
                                max_end_time = max(max_end_time,timex[drop])
                            # cut-out only CHARGE to DROP
                            
                            labels.append(label)
                            timex_list.append(timex)
                            stemp_list.append(stemp)
                            cl_list.append(cl)
                            
                            if self.qmc.DeltaBTflag and self.qmc.delta_ax:
                                tx = numpy.array(timex)
                                cf = aw.qmc.curvefilter*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
                                t1 = self.qmc.smooth_list(timex,self.qmc.fill_gaps(temp),window_len=cf,decay_smoothing=not aw.qmc.optimalSmoothing)
                                if len(t1)>10 and len(tx) > 10:
                                    # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                                    RoR_start = min(rd["charge_idx"]+10,len(tx)-1)
                                    delta,_ = self.qmc.recomputeDeltas(tx,RoR_start,drop,t1,None,optimalSmoothing=aw.qmc.optimalSmoothing)
                                    if self.qmc.BTlinewidth > 1 and self.qmc.BTlinewidth == self.qmc.BTdeltalinewidth:
                                        dlinewidth = self.qmc.BTlinewidth-1 # we render the delta lines a bit thinner
                                        dlinestyle = self.qmc.BTdeltalinestyle
                                    else:
                                        dlinewidth = self.qmc.BTdeltalinewidth
                                        dlinestyle = self.qmc.BTdeltalinestyle
                                    trans = self.qmc.delta_ax.transData
                                    self.l_delta, = self.qmc.ax.plot(tx, delta,transform=trans,markersize=self.qmc.BTdeltamarkersize,marker=self.qmc.BTdeltamarker,
                                        sketch_params=None,path_effects=[],
                                        linewidth=dlinewidth,linestyle=dlinestyle,drawstyle=self.qmc.BTdeltadrawstyle,color=cl,alpha=0.7)
                                    
                            first_profile = False

                        except Exception as e:
    #                        import traceback
    #                        traceback.print_exc(file=sys.stdout)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " rankingReport() {0}").format(str(e)),exc_tb.tb_lineno)
                
                # draw BT curves on top of all others
                for i in range(len(timex_list)):
                    label = labels[i]
                    timex = timex_list[i]
                    stemp = stemp_list[i]
                    cl = cl_list[i]
                    self.l_temp, = self.qmc.ax.plot(timex,stemp,markersize=self.qmc.BTmarkersize,marker=self.qmc.BTmarker,
#                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.qmc.BTlinewidth+aw.qmc.patheffects,foreground=path_effects_color)],
                        sketch_params=None,path_effects=[],
                        linewidth=self.qmc.BTlinewidth,linestyle=self.qmc.BTlinestyle,drawstyle=self.qmc.BTdrawstyle,color=cl,label=label)
                    handles.append(self.l_temp)
                        
                tmpdir = u(QDir.tempPath() + "/")
                graph_image = ""
                graph_image_pct = ''
    
                prop = aw.mpl_fontproperties.copy()
                prop.set_size("x-small")
                        
                if len(profiles) > max_profiles:
                    QMessageBox.information(aw,QApplication.translate("Message", "Ranking Report",None),
                                              QApplication.translate("Message", "Ranking graphs are only generated up to {0} profiles",None).format(str(max_profiles)))
                else:
                    try:
                        
                        # remove annotations, lines and other artists from background profile
                        try:
                            for l in aw.qmc.l_annotations + aw.qmc.l_background_annotations:
                                if l:
                                    try:
                                        l.remove()
                                    except:
                                        pass
                            for l in [
                                    aw.qmc.l_back1,
                                    aw.qmc.l_back2,
                                    aw.qmc.l_back3,
                                    aw.qmc.l_delta1B,
                                    aw.qmc.l_delta2B
                                    ]:
                                if l:
                                    try:
                                        aw.qmc.ax.lines.remove(l)
                                    except:
                                        pass
                            for a in [
                                    aw.qmc.l_eventtype1dots,
                                    aw.qmc.l_eventtype2dots,
                                    aw.qmc.l_eventtype3dots,
                                    aw.qmc.l_eventtype4dots,
                                    aw.qmc.l_backgroundeventtype1dots,
                                    aw.qmc.l_backgroundeventtype2dots,
                                    aw.qmc.l_backgroundeventtype3dots,
                                    aw.qmc.l_backgroundeventtype4dots]:
                                if a:
                                    try:
                                        aw.qmc.ax.lines.remove(a)
                                    except:
                                        pass
                            
                            # we also have to remove those extra event annotations if in combo mode
                            if aw.qmc.eventsGraphflag == 4:
                                for child in aw.qmc.ax.get_children():
                                    if isinstance(child, matplotlib.text.Annotation):
                                        aw.qmc.ax.texts.remove(child)

                        except:
                            pass

                        aw.qmc.ax.set_xlim(min_start_time-15,max_end_time+15) # we adjust the min, max time scale to ensure all data is visible
                        graph_image = "roastlog-graph"
                        self.qmc.setProfileTitle("")
                        self.qmc.fig.suptitle("")
                        rcParams['path.effects'] = []
                        if len(handles) > 7:
                            ncol = int(math.ceil(len(handles)/4.))
                        elif len(handles) > 3:
                            ncol = int(math.ceil(len(handles)/2.))
                        else:
                            ncol = int(math.ceil(len(handles)))
                        self.qmc.ax.legend(handles,labels,loc=self.qmc.legendloc,ncol=ncol,fancybox=True,prop=prop,shadow=False)
                                
                        # Remove and update the logo image
                        try:
                            aw.qmc.ai.remove()
                            self.qmc.placelogoimage()
                        except:
                            pass

                        # generate graph
                        self.qmc.fig.set_tight_layout(False)
                        self.qmc.fig.canvas.draw()
                        # save graph                
                        graph_image = u(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + ".svg")))
                        try:
                            os.remove(graph_image)
                        except OSError:
                            pass
                        self.qmc.fig.set_tight_layout(self.qmc.tight_layout_params)
                        self.qmc.fig.savefig(graph_image,transparent=True)
                            
                        #add some random number to force HTML reloading
                        graph_image = path2url(graph_image)
                        graph_image = graph_image + "?dummy=" + str(int(libtime.time()))
                        graph_image = "<img alt='roast graph' style=\"width:100%;\" src='" + graph_image + "'>"
    
    
                    except Exception as e:
    #                    import traceback
    #                    traceback.print_exc(file=sys.stdout)
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " rankingReport() {0}").format(str(e)),exc_tb.tb_lineno)
    
                try:
                    # Create a roast phase visualization graph
                    import matplotlib.pyplot as plt
    
                    fig_height = 3.2       # in inches when there are 10 profiles, will be scaled for number of profiles 
                    fig_width = 10         # in inches
    
                    # values that define the bars and spacing 
                    barspacer =  2     # vertical space between bars
                    barheight =  18    # height of each bar
                    textoffset = 6     # shifts text annotations upward to toward middle of the bar 
                    m = 10             # width of batch number field and drop time field 
                    g = 2              # gap
                    n = m + g          # start of horiz stacked bar
                    ind = 7            # width of color legend indicator
    
                    # setup the font 
                    if sys.platform.startswith("darwin") and darkdetect.isDark():
                        headerfontcolor = '#B2B2B2'
                    else:
                        headerfontcolor = '#707070'
                    fontcolor = '#303030'
                    lightfontcolor = 'grey'
                    prop.set_family(mpl.rcParams['font.family'])
    
                    # generate graph  ( not written to support MPL < v2.0 )
                    fig = plt.figure(figsize=(fig_width, (fig_height * len(profiles)/10 + 0.2)))
                    ax = fig.add_subplot(111, frameon=False)
                    plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
                    
                    # no grid or tick marks
                    ax.grid(False)
                    ax.axes.get_xaxis().set_ticks([])
                    ax.axes.get_yaxis().set_ticks([])
                    
                    # set graph xy limits
                    ylim = (barheight + barspacer) * (1 + len(profiles))
                    xlim = m+g+100+g+m +1
                    ax.set_ylim(0, ylim)
                    ax.set_xlim(0, xlim)
    
                    graph_image_pct = "roastlog-graph-pct"
    
                    i = len(profiles)   # bar counter 
    
                    # generate the legend at the top
                    facecolors = ('#00b950', '#ffb347', '#9f7960')
                    prop.set_size("medium")  
                    ax.broken_barh( [ (n, g),                         #Dry indicator
                                      (n+g+ind, g),                   #MAI indicator
                                      (n+g+ind+g+ind, g)              #DEV indicator
                                    ], 
                                    (i*(barheight + barspacer), barheight*0.75), facecolors=facecolors
                                  )                      
                    ax.text(    m/2,             i*(barheight + barspacer) + textoffset/3, 'Nr', ha='center', color=headerfontcolor, fontproperties=prop)
                    ax.text( 1+ n+g,             i*(barheight + barspacer) + textoffset/3, 'Dry', ha='left', color=headerfontcolor, fontproperties=prop)
                    ax.text( 1+ n+g+ind+g,       i*(barheight + barspacer) + textoffset/3, 'Mai', ha='left', color=headerfontcolor, fontproperties=prop)
                    ax.text( 1+ n+g+ind+g+ind+g, i*(barheight + barspacer) + textoffset/3, 'Dev', ha='left', color=headerfontcolor, fontproperties=prop)
                    ax.text(    n+100 + 10/2,    i*(barheight + barspacer) + textoffset/3, 'Drop', ha='center', color=headerfontcolor, fontproperties=prop)
                        
                    # generate the bar graph 
                    prop.set_size("small")  
                    color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))    # @UndefinedVariable  
                    label_chr_nr = 0
                    for p in profiles:
                        i -= 1
                        try:
                            cl = next(color), '#00b950', '#ffb347', '#9f7960'
                        except Exception as e:
                            color=iter(cm.tab20(numpy.linspace(0,1,max_profiles)))    # @UndefinedVariable
                            cl = next(color), '#00b950', '#ffb347', '#9f7960'
                        try:
                            rd = self.profileRankingData(p)
                        except Exception as e:
#                            import traceback
#                            traceback.print_exc(file=sys.stdout)
                            _, _, exc_tb = sys.exc_info()
                            aw.qmc.adderror((QApplication.translate("Error Message","Exception (probably due to an empty profile):",None) + " rankingReport() {0}").format(str(e)),exc_tb.tb_lineno)
                            i += 1   #avoid a blank line
                            continue
                        pd = self.profileProductionData(p)
                        if pd["batchnr"] > 0:
                            label = u(pd["batchprefix"]) + u(pd["batchnr"])[:8]
                        elif label_chr_nr < 26:
                            label = u(libstring.ascii_uppercase[label_chr_nr])
                            label_chr_nr = label_chr_nr + 1
                        else:
                            label = ""
                        if "DRY_percent" in rd and "MAI_percent" in rd and "DEV_percent" in rd:
                            ax.broken_barh( [ (0, m), 
                                              (n, rd["DRY_percent"]), 
                                              (n+rd["DRY_percent"], rd["MAI_percent"]), 
                                              (n+rd["DRY_percent"] + rd["MAI_percent"], rd["DEV_percent"]),
                                              (n+rd["DRY_percent"] + rd["MAI_percent"] + rd["DEV_percent"] + g, m*rd["DROP_time"]/max_drop_time)
                                            ], 
                                            (i*(barheight + barspacer), barheight), facecolors=cl
                                          )
                            ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + rd["DRY_percent"]/2,                                               i*(barheight + barspacer) + textoffset, str(round(rd["DRY_percent"],1)) + '%  ' + self.qmc.stringfromseconds(rd["DRY_time"]), ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + rd["DRY_percent"] + rd["MAI_percent"]/2,                           i*(barheight + barspacer) + textoffset, str(round(rd["MAI_percent"],1)) + '%  ' + self.qmc.stringfromseconds(rd["MAI_time"]), ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + rd["DRY_percent"] + rd["MAI_percent"] + rd["DEV_percent"]/2,       i*(barheight + barspacer) + textoffset, str(round(rd["DEV_percent"],1)) + '%  ' + self.qmc.stringfromseconds(rd["DEV_time"]), ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + rd["DRY_percent"] + rd["MAI_percent"] + rd["DEV_percent"] + g + 1, i*(barheight + barspacer) + textoffset, self.qmc.stringfromseconds(rd["DROP_time"]), ha='left', color=fontcolor, fontproperties=prop)
                        elif "DEV_percent" in rd:   # has FCs but no Dry event
                            cl = cl[0],'white',cl[3]     
                            missingDryevent = u(QApplication.translate("Message", "Profile missing Dry event",None))
                            ax.broken_barh( [ (0, m), 
                                              (n, 100 - rd["DEV_percent"]),
                                              (n+ 100 - rd["DEV_percent"], rd["DEV_percent"]),
                                              (n+ 100 + g, m*rd["DROP_time"]/max_drop_time)
                                            ], 
                                            (i*(barheight + barspacer), barheight), facecolors=cl
                                          )                      
                            ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + (100 - rd["DEV_percent"])/2,                                       i*(barheight + barspacer) + textoffset, missingDryevent, ha='center', color=lightfontcolor, fontproperties=prop)
                            ax.text( n + 100 - rd["DEV_percent"] + rd["DEV_percent"]/2,                     i*(barheight + barspacer) + textoffset, str(round(rd["DEV_percent"],1)) + '%  ' + self.qmc.stringfromseconds(rd["DEV_time"]), ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + 100 + g + 1, i*(barheight + barspacer) + textoffset, self.qmc.stringfromseconds(rd["DROP_time"]), ha='left', color=fontcolor, fontproperties=prop)
                        else:    # no useful events
                            if "DROP_time" in rd:
                                drop_time = rd["DROP_time"]
                            else:
                                drop_time = 0
                            cl = cl[0],'white'
                            missingPhaseevents = u(QApplication.translate("Message", "Profile missing phase events",None))
                            ax.broken_barh( [ (0, m),
                                              (n, 100),
                                              (n+ 100 + g, m*(0 if max_drop_time == 0 else drop_time/max_drop_time))
                                            ], 
                                            (i*(barheight + barspacer), barheight), facecolors=cl
                                          )                      
                            ax.text( m/2,                                                                   i*(barheight + barspacer) + textoffset, label, ha='center', color=fontcolor, fontproperties=prop)
                            ax.text( n + 100/2,                                                             i*(barheight + barspacer) + textoffset, missingPhaseevents, ha='center', color=lightfontcolor, fontproperties=prop)
                            ax.text( n + 100 + g + 1, i*(barheight + barspacer) + textoffset, self.qmc.stringfromseconds(drop_time), ha='left', color=fontcolor, fontproperties=prop)
                    
                    # save graph
                    graph_image_pct = u(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image_pct + ".svg")))
                    try:
                        os.remove(graph_image_pct)
                    except OSError:
                        pass
                    fig.savefig(graph_image_pct,transparent=True)
                    #add some random number to force HTML reloading
                    graph_image_pct = path2url(graph_image_pct)
                    graph_image_pct = graph_image_pct + "?dummy=" + str(int(libtime.time()))
                    graph_image_pct = "<img alt='roast graph pct' style=\"width: 95%;\" src='" + graph_image_pct + "'>"

                except Exception as e:
#                    import traceback
#                    traceback.print_exc(file=sys.stdout)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " rankingReport() {0}").format(str(e)),exc_tb.tb_lineno)

                try:
                    # redraw original graph
                    if foreground_profile_path:
                        aw.loadFile(foreground_profile_path)
                    if aw.qmc.backgroundpath:
                        aw.loadbackground(aw.qmc.backgroundpath)
                    self.qmc.redraw(recomputeAllDeltas=False)
                except:
                    pass

                weight_fmt = ('{0:.2f}' if aw.qmc.weight[2] in ["Kg", "lb", "oz"] else '{0:.0f}')
                html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                    resources = u(self.getResourcePath()),
                    title = u(QApplication.translate("HTML Report Template", "Roast Ranking", None)),
                    time = u(QApplication.translate("HTML Report Template", "Date", None)),
                    profile = u(QApplication.translate("Label", "Title", None)),
                    weightin = u(QApplication.translate("HTML Report Template", "In", None)),
                    weightloss = u(QApplication.translate("HTML Report Template", "Loss", None)),
                    colorHeader = u(QApplication.translate("HTML Report Template", "Color", None)),
                    weight_unit = aw.qmc.weight[2].lower(),
                    temp_unit = aw.qmc.mode,
                    entries = entries,
                    charges_avg = (weight_fmt.format(charges / charges_count) if charges_count > 0 and charges > 0 else ""),
                    charges_temp_avg = ('{0:.1f}'.format(charges_temp / charges_temp_count) if charges_temp > 0 and charges_temp_count > 0 else ""),
                    FCs_time_avg = (self.eventtime2string(FCs_time / FCs_time_count) if FCs_time > 0 and FCs_time_count > 0 else ""),
                    FCs_temp_avg = ('{0:.1f}'.format(FCs_temp / FCs_temp_count) if FCs_temp > 0 and FCs_temp_count > 0 else ""),
                    DROP_time_avg = (self.eventtime2string(DROP_time / DROP_time_count) if DROP_time > 0 and DROP_time_count > 0 else ""),
                    DROP_temp_avg = ('{0:.1f}'.format(DROP_temp / DROP_temp_count) if DROP_temp > 0 and DROP_temp_count > 0 else ""),
                    DRY_percent_avg = ('{0:.1f}'.format(DRY_percent / DRY_percent_count) if DRY_percent > 0 and DRY_percent_count > 0 else ""),
                    MAI_percent_avg = ('{0:.1f}'.format(MAI_percent / MAI_percent_count) if MAI_percent > 0 and MAI_percent_count > 0 else ""),
                    DEV_percent_avg = ('{0:.1f}'.format(DEV_percent / DEV_percent_count) if DEV_percent > 0 and DEV_percent_count > 0 else ""),
                    AUC_avg = ('{0:.1f}'.format(AUC / AUC_count) if AUC > 0 and AUC_count > 0 else ""),
                    loss_avg = ('{0:.1f}'.format(loss / loss_count) if loss_count > 0 and loss > 0 else ""),
                    colors_avg = ('{0:.1f}'.format(colors / colors_count) if colors > 0 and colors_count > 0 else ""),
                    cup_avg = ('{0:.2f}'.format(cuppings / cuppings_count) if cuppings > 0 and cuppings_count > 0 else ""),
                    graph_image=graph_image,
                    graph_image_pct=graph_image_pct
                )
                f = None
                try:
                    filename = u(QDir(tmpdir).filePath("RankingReport.html"))
                    try:
                        os.remove(filename)
                    except OSError:
                        pass
                    f = codecs.open(filename, 'w', encoding='utf-8')
                    for i in range(len(html)):
                        f.write(html[i])
                    f.close()
                    if platf == 'Darwin':
                        full_path = "file://" + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                    else:
                        full_path = "file:///" + filename # Explorer refuses to start otherwise
                    QDesktopServices.openUrl(QUrl(full_path, QUrl.TolerantMode)) 
                    
                except IOError as e:
                    aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " rankingReport() {0}").format(str(e)))
                finally:
                    if f:
                        f.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingCSVReport(self,_=False):        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg="Export CSV",ext="*.csv")
            if filename:
                try:
                    # write header
                    import csv
                    outfile = open(filename, 'w',newline="")
                    writer= csv.writer(outfile,delimiter='\t')
                    writer.writerow(["batch","time","profile","load (g)","charge (" + aw.qmc.mode + ")","FCs","FCs (" + aw.qmc.mode + ")","DROP","DROP (" + aw.qmc.mode + ")","DRY (%)","MAI (%)","DEV (%)","AUC","loss (%)","color","cup"])
                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            pd = self.productionData2string(self.profileProductionData(self.deserialize(p)),units=False)
                            c += 1
                            dct = self.profileRankingData(self.deserialize(p))
                            rd = self.rankingData2string(dct,units=False)
                            writer.writerow([
                                s2a(pd["id"]),
                                s2a(pd["time"]),
                                s2a(pd["title"]),
                                '{0:.3f}'.format(pd["weight_in_num"]), # str(pd["weight_in_num"]),                                  
                                ('{0:.1f}'.format(aw.qmc.convertTemp(dct["charge_temp"],dct["temp_unit"],aw.qmc.mode)) if "charge_temp" in dct else ""),
                                rd["FCs_time"],
                                ('{0:.1f}'.format(aw.qmc.convertTemp(dct["FCs_temp"],dct["temp_unit"],aw.qmc.mode)) if "FCs_temp" in dct else ""),
                                rd["DROP_time"],
                                ('{0:.1f}'.format(aw.qmc.convertTemp(dct["DROP_temp"],dct["temp_unit"],aw.qmc.mode)) if "DROP_temp" in dct else ""),
                                rd["DRY_percent"],
                                rd["MAI_percent"],
                                rd["DEV_percent"],
                                rd["AUC"],
                                str(pd["weight_loss"]),
                                rd["color"],
                                rd["cupping"],
                                ])
                        except Exception:
#                            import traceback
#                            traceback.print_exc(file=sys.stdout)
                            pass
                    # close file
                    outfile.close()
                except Exception:
                    pass

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingExcelReport(self,_=False):
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg="Export Excel",ext="*.xlsx")
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook
                    #from openpyxl.compat import range  # @UnusedImport
                    #from openpyxl.cell import get_column_letter
                    from openpyxl.utils.cell import get_column_letter  # @UnusedImport
                    from openpyxl.styles import Font, Fill # @UnusedImport
                    wb = Workbook()
                    ws = wb.active # wb.create_sheet()
                    ws.title = u(QApplication.translate("HTML Report Template", "Production Report",None)) 
                    
                    bf = Font(bold=True)
                    unit = aw.qmc.weight[2]
                    
                    # write header
                    ws['A1'] = u(QApplication.translate("HTML Report Template", "Batch",None))
                    ws['A1'].font = bf
                    ws['B1'] = u(QApplication.translate("HTML Report Template", "Time",None)) 
                    ws['B1'].font = bf
                    ws.column_dimensions['B'].width = 18
                    ws['C1'] = u(QApplication.translate("HTML Report Template", "Profile",None)) 
                    ws['C1'].font = bf 
                    ws.column_dimensions['C'].width = 25
                    ws['D1'] = u(QApplication.translate("HTML Report Template", "Load",None)) + " (" + u(unit.lower()) + ")"
                    ws['D1'].font = bf
                    ws['E1'] = u(QApplication.translate("HTML Report Template", "Charge",None)) + " (" + u(aw.qmc.mode) + ")"
                    ws['E1'].font = bf 
                    ws['F1'] = u(QApplication.translate("HTML Report Template", "FCs",None)) 
                    ws['F1'].font = bf 
                    ws['G1'] = u(QApplication.translate("HTML Report Template", "FCs",None)) + " (" + u(aw.qmc.mode) + ")"
                    ws['G1'].font = bf
                    ws['H1'] = u(QApplication.translate("HTML Report Template", "DROP",None)) 
                    ws['H1'].font = bf
                    ws['I1'] = u(QApplication.translate("HTML Report Template", "DROP",None)) + " (" + u(aw.qmc.mode) + ")"
                    ws['I1'].font = bf
                    ws['J1'] = u(QApplication.translate("HTML Report Template", "DRY",None))
                    ws['J1'].font = bf
                    ws['K1'] = u(QApplication.translate("HTML Report Template", "MAI",None))
                    ws['K1'].font = bf
                    ws['L1'] = u(QApplication.translate("HTML Report Template", "DEV",None))
                    ws['L1'].font = bf
                    ws['M1'] = u(QApplication.translate("HTML Report Template", "AUC",None)) 
                    ws['M1'].font = bf
                    ws['N1'] = u(QApplication.translate("HTML Report Template", "Loss",None))
                    ws['N1'].font = bf
                    ws['O1'] = u(QApplication.translate("HTML Report Template", "Color",None)) 
                    ws['o1'].font = bf
                    ws['P1'] = u(QApplication.translate("HTML Report Template", "Cup",None)) 
                    ws['P1'].font = bf
                    
                    # write data
                    c = 1
                    for p in profiles:
                        try:
                            raw_data = self.profileProductionData(self.deserialize(p))
                            c += 1
                            rd = self.profileRankingData(self.deserialize(p))
                            d = self.productionData2string(raw_data,units=False)
                            
                            if "id" in d:
                                ws['A{0}'.format(c)] = d["id"]
                            if "datetime" in d:
                                ws['B{0}'.format(c)] = QDateTime(d["datetime"]).toPyDateTime()
                                ws['B{0}'.format(c)].number_format = 'YYYY-MM-DD HH:MM'
                            if "title" in d:
                                ws['C{0}'.format(c)] = d["title"]
                            if unit in ["Kg", "lb", "oz"]:
                                num_format = '0.00'
                            else:
                                num_format = '0'
                            if "weight" in raw_data:
                                w_in = aw.convertWeight(raw_data["weight"][0],aw.qmc.weight_units.index(raw_data["weight"][2]),aw.qmc.weight_units.index(unit))
                                w_out = aw.convertWeight(raw_data["weight"][1],aw.qmc.weight_units.index(raw_data["weight"][2]),aw.qmc.weight_units.index(unit))
                                ws['D{0}'.format(c)] = w_in
                                ws['D{0}'.format(c)].number_format = num_format
                            else:
                                w_in = 0
                                w_out = 0                                
                            if "charge_temp" in rd and "temp_unit" in rd:
                                ws['E{0}'.format(c)] = aw.qmc.convertTemp(rd["charge_temp"],rd["temp_unit"],aw.qmc.mode)
                                ws['E{0}'.format(c)].number_format = ("0.0" if aw.qmc.LCDdecimalplaces else "0")
                            if "FCs_time" in rd:
                                h,m = divmod(rd["FCs_time"],60)
                                dt = datetime.time(int(h),int(m),0)
                                ws['F{0}'.format(c)] = dt
                                ws['F{0}'.format(c)].number_format = 'H:MM'
                            if "FCs_temp" in rd and "temp_unit" in rd:
                                ws['G{0}'.format(c)] = aw.qmc.convertTemp(rd["FCs_temp"],rd["temp_unit"],aw.qmc.mode)
                                ws['G{0}'.format(c)].number_format = ("0.0" if aw.qmc.LCDdecimalplaces else "0")
                            if "DROP_time" in rd:
                                h,m = divmod(rd["DROP_time"],60)
                                dt = datetime.time(int(h),int(m),0) # note that rounding h and m might lead to failure of .time() as round(59.99) = 60 which is >59 thus not accepeted by .time()
                                ws['H{0}'.format(c)] = dt
                                ws['H{0}'.format(c)].number_format = 'H:MM'
                            if "DROP_temp" in rd and "temp_unit" in rd:
                                ws['I{0}'.format(c)] = aw.qmc.convertTemp(rd["DROP_temp"],rd["temp_unit"],aw.qmc.mode)
                                ws['I{0}'.format(c)].number_format = ("0.0" if aw.qmc.LCDdecimalplaces else "0")
                            if "DRY_percent" in rd:
                                ws['J{0}'.format(c)] = rd["DRY_percent"]/100.
                                ws['J{0}'.format(c)].number_format = "0.0%"
                            if "MAI_percent" in rd:
                                ws['K{0}'.format(c)] = rd["MAI_percent"]/100.
                                ws['K{0}'.format(c)].number_format = "0.0%"
                            if "DEV_percent" in rd:
                                ws['L{0}'.format(c)] = rd["DEV_percent"]/100.
                                ws['L{0}'.format(c)].number_format = "0.0%"
                            if "AUC" in rd:
                                ws['M{0}'.format(c)] = rd["AUC"]
                                ws['M{0}'.format(c)].number_format = "0"
                            if w_in > 0 and w_out > 0:
                                ws['N{0}'.format(c)] = aw.weight_loss(w_in,w_out)/100.
                                ws['N{0}'.format(c)].number_format = "0.0%"
                            if "color" in rd and rd["color"] and rd["color"] > 0:
                                ws['O{0}'.format(c)] = rd["color"]
                                #ws['O{0}'.format(c)].number_format = "0"
                            if "cupping" in rd:
                                ws['P{0}'.format(c)] = rd["cupping"]
                                ws['P{0}'.format(c)].number_format = "0.00"          
                        except Exception as e:
#                            import traceback
#                            traceback.print_exc(file=sys.stdout)
#                            _, _, exc_tb = sys.exc_info()
#                            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " rankingExcelReport() {0}").format(str(e)),exc_tb.tb_lineno)
                            pass
                    # write trailer
                    if c > 1:
                        def avgFormat(c,s,e):
                            rng = "{0}{1}:{0}{2}".format(c,s,e)
                            return '=IF(SUMPRODUCT(--(' + rng + '<>""))=0,"",AVERAGE(' + rng + '))'
                        
                        ws['A{0}'.format(c+1)] = u(QApplication.translate("HTML Report Template", "AVG", None))
                        ws['A{0}'.format(c+1)].font = bf 
                        ws['D{0}'.format(c+1)] = avgFormat("D",2,c)
                        ws['D{0}'.format(c+1)].font = bf
                        ws['D{0}'.format(c+1)].number_format = num_format
                        ws['E{0}'.format(c+1)] = avgFormat("E",2,c)
                        ws['E{0}'.format(c+1)].font = bf
                        ws['E{0}'.format(c+1)].number_format = "0"
                        ws['F{0}'.format(c+1)] = avgFormat("F",2,c)
                        ws['F{0}'.format(c+1)].font = bf
                        ws['F{0}'.format(c+1)].number_format = 'H:MM'
                        ws['G{0}'.format(c+1)] = avgFormat("G",2,c)
                        ws['G{0}'.format(c+1)].font = bf
                        ws['G{0}'.format(c+1)].number_format = "0"
                        ws['H{0}'.format(c+1)] = avgFormat("H",2,c)
                        ws['H{0}'.format(c+1)].font = bf
                        ws['H{0}'.format(c+1)].number_format = 'H:MM'
                        ws['I{0}'.format(c+1)] = avgFormat("I",2,c)
                        ws['I{0}'.format(c+1)].font = bf
                        ws['I{0}'.format(c+1)].number_format = "0"
                        ws['J{0}'.format(c+1)] = avgFormat("J",2,c)
                        ws['J{0}'.format(c+1)].font = bf
                        ws['J{0}'.format(c+1)].number_format = "0.0%"
                        ws['K{0}'.format(c+1)] = avgFormat("K",2,c)
                        ws['K{0}'.format(c+1)].font = bf
                        ws['K{0}'.format(c+1)].number_format = "0.0%"
                        ws['L{0}'.format(c+1)] = avgFormat("L",2,c)
                        ws['L{0}'.format(c+1)].font = bf
                        ws['L{0}'.format(c+1)].number_format = "0.0%"
                        ws['M{0}'.format(c+1)] = avgFormat("M",2,c)
                        ws['M{0}'.format(c+1)].font = bf
                        ws['M{0}'.format(c+1)].number_format = "0"
                        ws['N{0}'.format(c+1)] = avgFormat("N",2,c)
                        ws['N{0}'.format(c+1)].font = bf
                        ws['N{0}'.format(c+1)].number_format = "0.0%"
                        ws['O{0}'.format(c+1)] = avgFormat("O",2,c)
                        ws['O{0}'.format(c+1)].font = bf
                        ws['O{0}'.format(c+1)].number_format = "0"
                        ws['P{0}'.format(c+1)] = avgFormat("P",2,c)
                        ws['P{0}'.format(c+1)].font = bf   
                        ws['P{0}'.format(c+1)].number_format = "0.00"
                    # close file
                    wb.save(filename)
                    aw.sendmessage(QApplication.translate("Message","Excel Ranking Report exported to {0}", None).format(filename))
                except Exception as e:
#                    import traceback
#                    traceback.print_exc(file=sys.stdout)
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " rankingExcelReport() {0}").format(str(e)),exc_tb.tb_lineno)
                    pass

    @pyqtSlot()
    @pyqtSlot(bool)
    def htmlReport(self,_=False):
        try:
            rcParams['path.effects'] = []
            with open(u(self.getResourcePath() + 'roast-template.htm'), 'r') as myfile:
                HTML_REPORT_TEMPLATE=myfile.read()
            beans_html = u(htmllib.escape(self.qmc.beans))
            if len(beans_html) > 43:
                beans_html = u(beans_html[:41] + "&hellip;")
                
            cp = aw.computedProfileInformation()
            
            if "CHARGE_ET" in cp and "CHARGE_BT" in cp:
                if self.qmc.mode == "F":
                    charge = u("BT %.0fF <br>ET %.0fF"%(cp["CHARGE_BT"],cp["CHARGE_ET"]))
                else:
                    charge = u("BT %.0f&deg;C <br>ET %.0f&deg;C"%(cp["CHARGE_BT"],cp["CHARGE_ET"]))
            else:
                charge = u("--")
            dryphase, midphase, finishphase, coolphase = self.phases2html(cp)
            etbta = u("--")
            #Dave new way of presenting AUC
            if ("AUC" in cp and cp["AUC"] != 0):
                etbta = u("%dC*min"%(cp["AUC"]))
                if ("AUCbegin" in cp and cp["AUCbegin"] != '' and "AUCbase" in cp):
                    etbta += u(" [%s,%d%s]"%(cp["AUCbegin"],cp["AUCbase"],self.qmc.mode))
                elif ("AUCbase" in cp):
                    etbta += u(" [%d]"%(cp["AUCbase"]))
            tmpdir = u(QDir.tempPath() + "/")
            graph_image = "roastlog-graph"
            graph_image = u(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + ".svg")))
            try:
                os.remove(graph_image)
            except OSError:
                pass
            
            org_patheffects = aw.qmc.patheffects
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                aw.qmc.patheffects = 0
            self.qmc.redraw(recomputeAllDeltas=False)
            
            self.qmc.fig.savefig(graph_image,transparent=True)
            #add some random number to force HTML reloading
            graph_image = path2url(graph_image)
            graph_image = graph_image + "?dummy=" + str(int(libtime.time()))
            
            #obtain flavor chart image
            self.qmc.flavorchart()
            flavor_image = "roastlog-flavor"
            flavor_image = u(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(flavor_image + ".svg")))
            try:
                os.remove(flavor_image)
            except OSError:
                pass
            self.qmc.fig.savefig(flavor_image,transparent=True)
            flavor_image = path2url(flavor_image)
            flavor_image = flavor_image + "?dummy=" + str(int(libtime.time()))
            #return screen to GRAPH profile mode
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                aw.qmc.patheffects = org_patheffects
            
            self.qmc.fig.clf() # remove the flavorchart artists
            self.qmc.redraw(recomputeAllDeltas=False)
            met = u("--")
            if "MET" in cp:
                met = "%.0f"%cp["MET"] + "&deg;" + self.qmc.mode
            ror = u("--")
            if "total_ror" in cp:
                ror = u("%d%s%s%s"%(cp["total_ror"],uchr(176),aw.qmc.mode,QApplication.translate("Label", "/m",None)))
            if "set_density" in cp:
                density = u("%.1fg/l (set)"%cp["set_density"])
            else:
                density = u("--")
            if  self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                weight = u(self.volume_weight2html(self.qmc.weight[0],self.qmc.weight[1],self.qmc.weight[2],cp["weight_loss"]))
            else:
                weight = u("--")
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0:
                volume = u(self.volume_weight2html(self.qmc.volume[0],self.qmc.volume[1],self.qmc.volume[2],cp["volume_gain"]))
            else:
                volume = u("--")
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0 and self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                degree = u(self.roast_degree(cp["weight_loss"]))
                if "set_density" in cp:
                    if "green_density" in cp and "roasted_density" in cp:
                        density = u("%.1fg/l (%s)<br>%.1fg/l (%s)"%(cp["green_density"],u(QApplication.translate("Label","greens")),cp["roasted_density"],u(QApplication.translate("Label","roasted"))))
                elif "green_density" in cp and "roasted_density" in cp:
                    density = u("%.1fg/l (%s)<br>%.1fg/l (%s)"%(cp["green_density"],u(QApplication.translate("Label","greens")),cp["roasted_density"],u(QApplication.translate("Label","roasted"))))
            else:
                degree = u("--")

            moisture = ""
            if "moisture_greens" in cp:
                moisture = u("%d%%"%cp["moisture_greens"])
                moisture += " (" + u(QApplication.translate("Label","greens")) + ")"
                if "moisture_roasted" in cp:
                    moisture += u("<br>")
            if "moisture_roasted" in cp:
                moisture += u("%d%%"%cp["moisture_roasted"])
                moisture += " (" + u(QApplication.translate("Label","roasted")) + ")"
                
            humidity = ""
            if "ambient_humidity" in cp:
                humidity += u("%d%%"%cp["ambient_humidity"])
                if "ambient_temperature" in cp:
                    humidity += u(" at %d%s"%(cp["ambient_temperature"],self.qmc.mode))
            else:
                if "ambient_temperature" in cp:
                    humidity += u("%d%s"%(cp["ambient_temperature"],self.qmc.mode))
            if "ambient_pressure" in cp:
                if len(humidity) != 0:
                    humidity += ", "
                humidity += u("%dhPa"%cp["ambient_pressure"])
            if len(humidity) == 0:
                humidity = u("--")
            if self.qmc.whole_color or self.qmc.ground_color:
                if self.qmc.whole_color:
                    wcolor = u(self.qmc.whole_color)
                else:
                    wcolor = u("--")
                if self.qmc.ground_color:
                    gcolor = u(self.qmc.ground_color)
                else:
                    gcolor = u("--")
                color = wcolor + u("/") + gcolor
                if self.qmc.color_system_idx:
                    color = color + u(" (" + self.qmc.color_systems[self.qmc.color_system_idx] + ")")
            else:
                color = u("--")
            if "det" in cp:
                cm = u("%.1f/%.1f" % (cp["det"],cp["dbt"])) + uchr(176) + aw.qmc.mode
            else:
                cm = u("--")
            if aw.qmc.titleB is None or aw.qmc.titleB == "":
                background_html = u("--")
            else:
                if aw.qmc.roastbatchnrB == 0:
                    titleB = u(aw.qmc.titleB)
                else:
                    titleB = aw.qmc.roastbatchprefixB + u(aw.qmc.roastbatchnrB) + u(" ") + u(aw.qmc.titleB)
                background_html = u(titleB)
            if aw.qmc.alarmsfile:
                alarms = u(os.path.basename(aw.qmc.alarmsfile))
            else:
                alarms = u("--")
            if aw.qmc.roastbatchnr == 0:
                batch = ""
            else:
                batch = u(aw.qmc.roastbatchprefix) + u(aw.qmc.roastbatchnr) + u(" ")
            datetime_html=u(self.qmc.roastdate.date().toString()) + ", " + u(self.qmc.roastdate.time().toString()[:-3])
            # add artisan or artisan.plus links to title, background and beans if possible
            title_html = u(htmllib.escape(batch)) + u(htmllib.escape(self.qmc.title))
            if aw.qmc.roastUUID is not None and aw.qmc.roastUUID != "":
                if plus.register.getPath(aw.qmc.roastUUID):
                    title_html = '<a href="artisan://roast/' + aw.qmc.roastUUID + '">' + title_html + "</a>"
                if bool(plus.sync.getSync(aw.qmc.roastUUID)):
                    datetime_html = '<a href="{0}" target="_blank">{1}</a>'.format(plus.util.roastLink(aw.qmc.roastUUID),datetime_html)
            if aw.qmc.background and aw.qmc.titleB is not None and aw.qmc.titleB != "" and aw.qmc.backgroundUUID is not None and plus.register.getPath(aw.qmc.backgroundUUID):
                background_html = '<a href="artisan://roast/' + aw.qmc.backgroundUUID + '">' + background_html + "</a>"
            if beans_html is not None and beans_html != "" and aw.qmc.plus_coffee is not None:
                beans_html = '<a href="{0}" target="_blank">{1}</a>'.format(plus.util.coffeeLink(aw.qmc.plus_coffee),beans_html)
                # note that blends are hard to link back as it requires to link component by component
            html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                title=title_html,
                titlecolor=QColor(aw.qmc.palette["title"]).name(),
                doc=u(QApplication.translate("HTML Report Template", "Roasting Report", None)),
                datatime_label=u(QApplication.translate("HTML Report Template", "Date:", None)),
                datetime=datetime_html, 
                beans_label=u(QApplication.translate("HTML Report Template", "Beans:", None)),
                beans=beans_html,
                weight_label=u(QApplication.translate("HTML Report Template", "Weight:", None)),
                weight=weight,
                degree_label=u(QApplication.translate("HTML Report Template", "Degree:", None)),
                degree=degree,
                volume_label=u(QApplication.translate("HTML Report Template", "Volume:", None)),
                volume=volume,
                roaster_label=u(QApplication.translate("HTML Report Template", "Roaster:", None)),
                roaster=u(htmllib.escape(self.qmc.roastertype)),
                operator_label=u(QApplication.translate("HTML Report Template", "Operator:", None)),
                operator=u(htmllib.escape(self.qmc.operator)),
                cup_label=u(QApplication.translate("HTML Report Template", "Cupping:", None)),
                cup=u(str(aw.float2float(self.cuppingSum(self.qmc.flavors)))),
                color_label=u(QApplication.translate("HTML Report Template", "Color:", None)),
                color=color,
                charge_label=u(QApplication.translate("HTML Report Template", "CHARGE:", None)),
                charge=charge,
                size_label=u(QApplication.translate("HTML Report Template", "Size:", None)),
                size=u("--" if aw.qmc.beansize == 0.0 else str(aw.qmc.beansize) + "mm"),
                density_label=u(QApplication.translate("HTML Report Template", "Density:", None)),
                density=density,
                moisture_label=u(QApplication.translate("HTML Report Template", "Moisture:", None)),
                moisture=moisture,
                humidity_label=u(QApplication.translate("HTML Report Template", "Ambient:", None)),
                humidity=humidity,
                TP_label=u(QApplication.translate("HTML Report Template", "TP:", None)),
                TP=self.event2html(cp,"TP_time","TP_BT"),
                DRY_label=u(QApplication.translate("HTML Report Template", "DRY:", None)),
                DRY=self.event2html(cp,"DRY_time","DRY_BT"),
                FCs_label=u(QApplication.translate("HTML Report Template", "FCs:", None)),
                FCs=self.event2html(cp,"FCs_time","FCs_BT"),
                FCe_label=u(QApplication.translate("HTML Report Template", "FCe:", None)),
                FCe=self.event2html(cp,"FCe_time","FCe_BT"),
                SCs_label=u(QApplication.translate("HTML Report Template", "SCs:", None)),
                SCs=self.event2html(cp,"SCs_time","SCs_BT"),
                SCe_label=u(QApplication.translate("HTML Report Template", "SCe:", None)),
                SCe=self.event2html(cp,"SCe_time","SCe_BT"),
                drop_label=u(QApplication.translate("HTML Report Template", "DROP:", None)),
                drop=self.event2html(cp,"DROP_time","DROP_BT"),
                cool_label=u(QApplication.translate("HTML Report Template", "COOL:", None)),
                cool=self.event2html(cp,"COOL_time",None,"DROP_time"),
                met_label=u(QApplication.translate("HTML Report Template", "MET:", None)),
                met=met,
                cm_label=u(QApplication.translate("HTML Report Template", "CM:", None)),
                cm=cm,
                dry_phase_label=u(QApplication.translate("HTML Report Template", "Drying:", None)),
                dry_phase=dryphase,
                mid_phase_label=u(QApplication.translate("HTML Report Template", "Maillard:", None)),
                mid_phase=midphase,
                finish_phase_label=u(QApplication.translate("HTML Report Template", "Finishing:", None)),
                finish_phase=finishphase,
                cool_phase_label=u(QApplication.translate("HTML Report Template", "Cooling:", None)),
                cool_phase=coolphase,
                background_label=u(QApplication.translate("HTML Report Template", "Background:", None)),
                background=background_html,
                alarms_label=u(QApplication.translate("HTML Report Template", "Alarms:", None)),
                alarms=alarms,
                ror_label=u(QApplication.translate("HTML Report Template", "RoR:", None)),
                ror= ror,
                etbta_label=u(QApplication.translate("HTML Report Template", "AUC:", None)),
                etbta=etbta,
                roasting_notes_label=(u(QApplication.translate("HTML Report Template", "Roasting Notes", None)) if self.qmc.roastingnotes != "" else ""),
                roasting_notes=self.note2html(self.qmc.roastingnotes),
                roast_attributes=self.roastattributes(),
                graph_image=graph_image,
                flavor_image=flavor_image,
                specialevents_label=u(QApplication.translate("HTML Report Template", "Events", None)),
                specialevents=self.specialevents2html(),
                cupping_notes_label=(u(QApplication.translate("HTML Report Template", "Cupping Notes", None)) if self.qmc.cuppingnotes != "" else ""),
                cupping_notes=self.note2html(self.qmc.cuppingnotes))
            f = None
            try:
                filename = u(QDir(tmpdir).filePath("Roastlog.html"))
                try:
                    os.remove(filename)
                except OSError:
                    pass
                f = codecs.open(filename, 'w', encoding='utf-8')
                for i in range(len(html)):
                    f.write(html[i])
                f.close()
                if platf == 'Darwin':
                    full_path = "file://" + filename # Safari refuses to load the javascript lib (sorttable) otherwise
                else:
                    full_path = "file:///" + filename # Explorer refuses to start otherwise
                QDesktopServices.openUrl(QUrl(full_path, QUrl.TolerantMode)) 
                
            except IOError as e:
                aw.qmc.adderror((QApplication.translate("Error Message", "IO Error:",None) + " htmlReport() {0}").format(str(e)))
            finally:
                if f:
                    f.close()
                # we only trigger a redraw if a watermark is displayed to fix its aspect ratio
                if aw.logofilename != "":
                    aw.qmc.redraw(recomputeAllDeltas=False)

        except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " htmlReport() {0}").format(str(e)),exc_tb.tb_lineno)

    # returns a string with all the activated roast attributes
    def roastattributes(self):
        res = []
        if aw.qmc.heavyFC_flag:
            res.append(u(QApplication.translate("CheckBox","Heavy FC", None)))
        if aw.qmc.lowFC_flag:
            res.append(u(QApplication.translate("CheckBox","Low FC", None)))
        if aw.qmc.lightCut_flag:
            res.append(u(QApplication.translate("CheckBox","Light Cut", None)))
        if aw.qmc.darkCut_flag:
            res.append(u(QApplication.translate("CheckBox","Dark Cut", None)))
        if aw.qmc.drops_flag:
            res.append(u(QApplication.translate("CheckBox","Drops", None)))
        if aw.qmc.oily_flag:
            res.append(u(QApplication.translate("CheckBox","Oily", None)))
        if aw.qmc.uneven_flag:
            res.append(u(QApplication.translate("CheckBox","Uneven", None)))
        if aw.qmc.tipping_flag:
            res.append(u(QApplication.translate("CheckBox","Tipping", None)))
        if aw.qmc.scorching_flag:
            res.append(u(QApplication.translate("CheckBox","Scorching", None)))
        if aw.qmc.divots_flag:
            res.append(u(QApplication.translate("CheckBox","Divots", None)))
        if len(res) > 0:
            return u("\n<center><pre>" + ', '.join(res) + "</pre></center>")
        else:
            return ""

    def cuppingSum(self,flavors):
        score = 0.
        nflavors = len(flavors)
        for i in range(nflavors):   
            score += flavors[i]
        score /= (nflavors)
        score *= 10.
        return score

    def volume_weight2html(self,amount,out,unit,change):
        if amount:
            return str(amount) + unit + "<br>" + str(out) + unit + " (" + "%.1f"%change + "%)"
        else:
            return "--"

    def phases2html(self,cp):
        dryphase = midphase = finishphase = coolphase = "--"
        if "totaltime" in cp:
            totaltime = cp["totaltime"]
            if totaltime:
                #dryphase
                if "dryphasetime" in cp:
                    dryphasetime = cp["dryphasetime"]
                    dryphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["dryphasetime"]),int(round(dryphasetime*100./totaltime)))
                    if "dry_phase_ror" in cp:
                        dryphase += "<br>%.1f%s%s/min"%(cp["dry_phase_ror"],uchr(176),aw.qmc.mode)
                    if "dry_phase_AUC" in cp:
                        dryphase += "<br>%dC*min"%(cp["dry_phase_AUC"])
                        if ("AUCbegin" in cp and cp["AUCbegin"] != '' and "AUCbase" in cp):
                            dryphase += u(" [%s,%d]"%(cp["AUCbegin"],round(cp["AUCbase"])))
                        elif ("AUCbase" in cp):
                            dryphase += u(" [%d]"%(round(cp["AUCbase"])))
#                    if "dryphaseeval" in cp:
#                        dryphase += "<br>" + d(cp["dryphaseeval"])
                #midphase
                if "midphasetime" in cp:
                    midphasetime = cp["midphasetime"]
                    midphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["midphasetime"]),int(round(midphasetime*100./totaltime)))
                    if "mid_phase_ror" in cp:
                        midphase += "<br>%.1f%s%s/min"%(cp["mid_phase_ror"],uchr(176),aw.qmc.mode)
                    if "mid_phase_AUC" in cp:
                        midphase += "<br>%dC*min"%(cp["mid_phase_AUC"])
                        if ("AUCbegin" in cp and cp["AUCbegin"] != '' and "AUCbase" in cp):
                            midphase += u(" [%s,%d]"%(cp["AUCbegin"],round(cp["AUCbase"])))
                        elif ("AUCbase" in cp):
                            midphase += u(" [%d]"%(round(cp["AUCbase"])))
#                    if "midphaseeval" in cp:
#                        midphase += "<br>" + d(cp["midphaseeval"])
                #finishphase
                if "finishphasetime" in cp:
                    finishphasetime = cp["finishphasetime"]
                    finishphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["finishphasetime"]),int(round(finishphasetime*100./totaltime)))
                    if "finish_phase_ror" in cp:
                        finishphase += "<br>%.1f%s%s/min"%(cp["finish_phase_ror"],uchr(176),aw.qmc.mode)
                    if "finish_phase_AUC" in cp:
                        finishphase += "<br>%dC*min"%(cp["finish_phase_AUC"])
                        if ("AUCbegin" in cp and cp["AUCbegin"] != '' and "AUCbase" in cp):
                            finishphase += u(" [%s,%d]"%(cp["AUCbegin"],round(cp["AUCbase"])))
                        elif ("AUCbase" in cp):
                            finishphase += u(" [%d]"%(round(cp["AUCbase"])))
#                    if "finishphaseeval" in cp:
#                        finishphase += "<br>" + d(cp["finishphaseeval"])
                #coolphase
                if "coolphasetime" in cp:
                    coolphasetime = cp["coolphasetime"]
                    coolphase = "%s (%d%%)"%(self.qmc.stringfromseconds(cp["coolphasetime"]),int(round(coolphasetime*100./totaltime)))
#                    if "coolphaseeval" in cp:
#                        coolphase += "<br>" + d(cp["coolphaseeval"])
        return dryphase, midphase, finishphase, coolphase

    def event2html(self,cp,time_key,BT_key=None,prev_time_key=None):
        res = "--"
        if prev_time_key and prev_time_key in cp and time_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key]) + " (" + self.qmc.stringfromseconds(cp[time_key] - cp[prev_time_key]) + "m)"
        elif time_key in cp and BT_key in cp:
            res = self.qmc.stringfromseconds(cp[time_key])+ " (%.0f"%cp[BT_key] + "&deg;" + self.qmc.mode + ")"
        return u(res)

    def specialevents2html(self):
        html = ""
        if self.qmc.specialevents and len(self.qmc.specialevents) > 0:
            html += u('<center>\n<table cellpadding="10" cellspacing="8">\n')
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
            else:
                start = 0
            # sort events by time/index
            sevents = sorted(zip(self.qmc.specialevents,range(len(self.qmc.specialevents))))
            seventsString = []
            seventsType = [] 
            seventsValue = []
            for i in range(len(sevents)):
                sorted_pos = sevents[i][1]
                seventsString.append(self.qmc.specialeventsStrings[sorted_pos])
                seventsType.append(self.qmc.specialeventstype[sorted_pos])
                seventsValue.append(self.qmc.specialeventsvalue[sorted_pos])
            for i in range(len(self.qmc.specialevents)):
                temps = ""
                if self.qmc.mode == "F":
                    formatString = "%.1fF"
                else:
                    formatString = "%.1f&deg;C"
                if self.qmc.temp1[sevents[i][0]] == -1 and self.qmc.temp2[sevents[i][0]] == -1:
                    temps += " -- "
                elif self.qmc.temp1[sevents[i][0]] == -1:
                    temps += formatString%self.qmc.temp2[sevents[i][0]]
                elif self.qmc.temp2[sevents[i][0]] == -1:
                    temps += formatString%self.qmc.temp1[sevents[i][0]]
                else:
                    temps += formatString%self.qmc.temp2[sevents[i][0]] + " / " + formatString%self.qmc.temp1[sevents[i][0]]
                html += ("<tr>"+
                     "\n<td>" + str(i+1) + "</td><td>" +
                     self.qmc.stringfromseconds(int(self.qmc.timex[sevents[i][0]] - start)) +
                     "</td><td align='right'>" + temps + "</td><td>" + seventsString[i] + ("</td></tr>\n" if seventsType[i] == 4 else ("</td><td>(" + u(self.qmc.etypesf(seventsType[i])) + " to " + self.qmc.eventsvalues(seventsValue[i]) + ")</td></tr>\n")))
            html += '</table>\n</center>'
        return u(html)

    def note2html(self,notes):
        notes_html = ""
        for i in range(len(notes)):
            if u(notes[i]) == 9:
                notes_html += u(" &nbsp&nbsp&nbsp&nbsp ")
            elif u(notes[i]) == "\n":
                notes_html += u("<br>\n")
            else:           
                notes_html += u(notes[i])
        if notes_html != "":
            notes_html = "<br>" + notes_html
        return notes_html

    #finds closest Bean Temperature in aw.qmc.temp2 given an input time. timex and temp2 always have same dimension
    def BTfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp2[i-1])           #return the BT temperature
        else:
            return 0.0

    #finds closest Environmental Temperature in aw.qmc.temp1 given an input time. timex and temp1 always have same dimension
    def ETfromseconds(self,seconds):
        if len(self.qmc.timex):
            #find when input time crosses timex
            for i in range(len(self.qmc.timex)):
                if self.qmc.timex[i] > seconds:
                    break
            return float(self.qmc.temp1[i-1])           #return the ET temperature
        else:
            return 0.0

    # converts times (values of timex) to indices
    def time2index(self,time):
        for i in range(len(self.qmc.timex)):
            if self.qmc.timex[i] >= time:
                if i > 0 and abs(time - self.qmc.timex[i]) > abs(time - self.qmc.timex[i-1]):
                    return int(i-1)
                else:
                    return int(i)
        return -1

    #returns the index of the lowest point in BT; return -1 if no such value found
    def findTP(self):
        return self.findTPint(aw.qmc.timeindex, aw.qmc.timex, aw.qmc.temp2)
        
    def findTPint(self,timeindex,timex,temp):
        TP = 1000
        idx = 0
        start = 0
        end = len(timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if timeindex[6]:
            EOR_index = timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if timeindex[2]:
            FCs_index = timeindex[2]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if timeindex[0] != -1:
            SOR_index = timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        for i in range(end - 1, start -1, -1):
            if temp[i] > 0 and temp[i] < TP:
                TP = temp[i]
                idx = i
        return idx

    #returns the index of the end of the dry phase (returns -1 if dry end cannot be determined)
    #if given, starts at TP_index and looks forward, otherwise it looks backwards from end of roast (EoR)
    #find index with smallest abs() difference between aw.qmc.phases[1] and BT (temp2)
    # phasesindex=1 => find DRY
    # phasesindex=2 => find FCs
    def findDryEnd(self,TP_index=None,phasesindex=1):
        sd = 1000
        nsd = 1000
        index = 0
        start = 0
        end = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if EOR_index > start and EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[2]
        if FCs_index > start and FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0] 
        if SOR_index > start and SOR_index < end:
            start = SOR_index
        # try to consider only indices from TP of roast on and not before
        TP = TP_index
        # if TP not yet computed, let's try to compute it
        if TP is None:
            TP = self.findTP()
        if TP > start and TP < end:
            start = TP
        for i in range(end -1, start -1, -1):
            nsd = abs(self.qmc.temp2[i]- self.qmc.phases[phasesindex])
            if nsd < sd:
                sd = nsd
                index = i
        return index

    def checkTop(self,offset,p0,p1,p2,p3,p4,p5):
#        print("->",p0,p1,p2,p3,p4,p5)
        d1 = p0 - p1
        d2 = p1 - p2
        #--
        d3 = p4 - p3
        d4 = p5 - p4
        dpre = (d1 + d2) / 2.0
        dpost = (d3 + d4) / 2.0
        if aw.qmc.mode == "C":
            f = 2.5
        else:
            f = 2.8 * 1.8
#        print("checkTop",d3 < .0,d4 < .0,abs(dpost),(offset + (f * abs(dpre))))
        if d3 < .0 and d4 < .0 and (abs(dpost) > (offset + (f * abs(dpre)))):
#            print(" => True")
            return True
        else:
#            print(" => False")
            return False
        
    
    # returns True if a BT break at i-2 is detected
    # idea:
    # . average delta before i-2 is not negative
    # . average delta after i-2 is negative and twice as high (absolute) as the one before
    def BTbreak(self,i,offset):
#        print("BTbreak",i,offset,self.qmc.temp2[i])
        res = 0
        if len(self.qmc.timex)>5 and i < len(self.qmc.timex):
            if self.checkTop(offset,self.qmc.temp2[i-5],self.qmc.temp2[i-4],self.qmc.temp2[i-3],self.qmc.temp2[i-2],self.qmc.temp2[i-1],self.qmc.temp2[i]):
                res = 3
            elif len(self.qmc.timex)>10 and self.checkTop(offset,self.qmc.temp2[i-10],self.qmc.temp2[i-8],self.qmc.temp2[i-6],self.qmc.temp2[i-4],self.qmc.temp2[i-2],self.qmc.temp2[i]):
                res = 6
        return res

    # this can be used to find the CHARGE index as well as the DROP index by using
    # 0 or the DRY index as start index, respectively
    def findBTbreak(self,start_index=0,end_index=0,offset=0.5):
        result = 0        
        # determine average deltaBT wrt. the two previous measurements
        # the deltaBT values wrt. the next two measurements must by twice as high and negative
        # then our current measurement is the one of CHARGE/DROP
        for i in range(start_index,len(self.qmc.timex)):
            if end_index and i > end_index:
                break
            if i>3:
                if aw.qmc.mode == "C":
                    o = offset
                else:
                    o = offset * 1.8
                b = self.BTbreak(i,o)
                if b > 0:
                    result = i + 1 - b
                    break
        return result
        
    # updates AUC guide (expected time to hit target AUC; aw.qmc.AUCguideTime) based on current AUC, target, base, and RoR
    def updateAUCguide(self):
        if (len(aw.qmc.delta2) > 0 and aw.qmc.delta2[-1] is not None and aw.qmc.delta2[-1] > 0 and # we have a positive BT RoR
            aw.qmc.TPalarmtimeindex is not None and  # we passed TP
            aw.qmc.AUCvalue > 0): # there is already some AUC available
            
            # so let's compute the AUCtarget
            if aw.qmc.AUCtargetFlag and aw.qmc.background and aw.qmc.AUCbackground > 0:
                # background AUC as target
                target = aw.qmc.AUCbackground
            else:
                # use target AUC as specified by the user
                target = aw.qmc.AUCtarget
            if target > 0 and target > aw.qmc.AUCvalue:
                # only recompute AUC guid if a sensible target exists and the AUC target is not reached
                # so let's compute the AUCbase
                if aw.qmc.AUCbegin == 0 and aw.qmc.timeindex[0] > -1: # start after CHARGE
                    idx = aw.qmc.timeindex[0]
                elif aw.qmc.AUCbegin == 1 and aw.qmc.TPalarmtimeindex: # start ater TP
                    idx = aw.qmc.TPalarmtimeindex
                elif aw.qmc.AUCbegin == 2 and aw.qmc.timeindex[1] > 0: # DRY END
                    idx = aw.qmc.timeindex[1]
                elif aw.qmc.AUCbegin == 3 and aw.qmc.timeindex[2] > 0: # FC START
                    idx = aw.qmc.timeindex[2]
                else:
                    idx = -1
                if idx > -1: # we passed the AUCbegin event
                    if aw.qmc.AUCbaseFlag:
                        # we take the base temperature from the BT at st
                        tbase = self.qmc.temp2[idx]
                    else:
                        tbase = aw.qmc.AUCbase
                    tbase = aw.qmc.convertTemp(tbase,aw.qmc.mode,"C")
                    if tbase > 0 and len(aw.qmc.temp2) > 0:
                        bt = aw.qmc.convertTemp(aw.qmc.temp2[-1],aw.qmc.mode,"C")
                        if bt > tbase:
                            # the time (in minutes) to reach the AUC target under the given base and current BT RoR
                            # is the positive root of the following equation
                            #   RoR/2*t^2 + (BT - base)*t + (AUCcurrent - AUCtarget) = 0
                            ror = aw.qmc.convertRoR(aw.qmc.delta2[-1],aw.qmc.mode,"C") # BT RoR
                            roots = [r for r in numpy.roots([ror/2.0,bt - tbase,aw.qmc.AUCvalue-target]) if r > 0]
                            if len(roots) > 0:
                                ts = aw.qmc.timeclock.elapsed()/1000.
                                aw.qmc.AUCguideTime = ts + roots[0]*60 # takes the first positive root and calculates the time in seconds until the target AUC is reached
                            if aw.qmc.l_AUCguide is not None:
                                if 0 < aw.qmc.AUCguideTime and aw.qmc.AUCguideTime < aw.qmc.endofx:
                                    aw.qmc.l_AUCguide.set_data([aw.qmc.AUCguideTime,aw.qmc.AUCguideTime], [aw.qmc.ylimit_min, aw.qmc.ylimit])
                                else:
                                    aw.qmc.l_AUCguide.set_data([],[])
    
    def AUCstartidx(self,timeindex,TPindex):
        if aw.qmc.AUCbegin == 0 and timeindex[0] > -1: # start after CHARGE
            idx = timeindex[0]
        elif aw.qmc.AUCbegin == 1 and TPindex: # start ater TP
            idx = TPindex
        elif aw.qmc.AUCbegin == 2 and timeindex[1] > 0: # DRY END
            idx = timeindex[1]
        elif aw.qmc.AUCbegin == 3 and timeindex[2] > 0: # FC START
            idx = timeindex[2]
        else:
            idx = -1
        return idx

    def thisAUC(self,idx,timex,temp,mode):
        if aw.qmc.AUCbaseFlag:
            # we take the base temperature from the BT at st
            tbase = temp[idx]
        else:
            tbase = aw.qmc.AUCbase
        tbase = aw.qmc.convertTemp(tbase,mode,"C")
        return self.calcAUC(tbase,timex,temp)/60.

    # updates the running AUC variables aw.qmc.AUCvalue and aw.qmc.AUCsinceFCs during recording
    def updateAUC(self):
        idx = self.AUCstartidx(aw.qmc.timeindex,aw.qmc.TPalarmtimeindex)
        if idx > -1: # we passed the AUCbegin event
            thisAUC = self.thisAUC(idx,self.qmc.timex,self.qmc.temp2,aw.qmc.mode)
            aw.qmc.AUCvalue += thisAUC
            if aw.qmc.timeindex[2] > 0:
                aw.qmc.AUCsinceFCs += thisAUC
            else:
                aw.qmc.AUCsinceFCs = 0
        else:
            aw.qmc.AUCvalue = 0
            aw.qmc.AUCsinceFCs = 0

    # calculates the area underneath the temp curve between the last two measurements
    #  base: the base temperature in C
    #  timex: the list of time points
    #  temp: the list of temperature values
    #  i: index relative to i-1 the area is calculated. If ommited, the last elements in the list are used
    #  temp2: if temp2 is given, then the area between temp1 and temp2 is calculated, assuming temp1>temp2, and the base is ignored
    # result is in C*seconds
    def calcAUC(self,base,timex,temp,i=-1,temp2=None):
        if len(timex) > 1 and len(temp) > 1 and (i==-1 or (i>0  and len(timex) > i and len(temp) > i)):
            # at least two readings available
            dt = (timex[i] - timex[i-1])
            t1 = aw.qmc.convertTemp(temp[i],aw.qmc.mode,"C")
            if t1 > 500:
                t1 = 0
            t2 = aw.qmc.convertTemp(temp[i-1],aw.qmc.mode,"C")
            if t2 > 500:
                t2 = 0
            ta = (max(0,t1) + max(0,t2)) / 2.0
            if temp2 is None or len(temp2) < 2 or (i != -1 and len(temp2) < i+1):
                return (max(0,ta-base) * dt)
            else:
                e1 = aw.qmc.convertTemp(temp2[i],aw.qmc.mode,"C")
                if e1 > 500:
                    e1 = 0
                e2 = aw.qmc.convertTemp(temp2[i-1],aw.qmc.mode,"C")
                if e2 > 500:
                    e2 = 0
                ea = (max(0,e1) + max(0,e2)) / 2.0
                return (max(0,ta - ea) * dt)
        else:
            return 0

    #calculate the AREA under BT and ET (always in C!)
    # from "start" to "end" (defaults to CHARGE to DROP)
    # and use "rt" as reference temperature (area above "rt" and below ET/BT)
    # if background=True, use the background time and temperature values
    # returns AUC(ET-BT), AUC(ET), AUC(BT), AUCbegin_idx
    def ts(self,start=None,end=None,tp=None,background=False):
        if background:
            timeindex = self.qmc.timeindexB[:]
            timex = self.qmc.timeB[:]
            temp1 = self.qmc.temp1B[:]
            temp2 = self.qmc.temp2B[:]
        else:
            timeindex = self.qmc.timeindex[:]
            timex = self.qmc.timex[:]
            temp1 = self.qmc.temp1[:]
            temp2 = self.qmc.temp2[:]
        return self.profileAUC(timeindex,timex,temp1,temp2,start,end,tp)
    
    def profileAUC(self,timeindex,timex,temp1,temp2,start=None,end=None,tp=None):
        delta = ET = BT = 0.0
        if (start == 0 and end == 0) or (start and (start < 0 or (start == 0 and timeindex[0] < 0))) or (len(timex) == 0):
            return 0,0,0,0
        else:
            try:
                if tp:
                    TP_index = tp
                else:
                    if aw.qmc.AUCbegin == 1:
                        if aw.qmc.TPalarmtimeindex:
                            TP_index = aw.qmc.TPalarmtimeindex
                        else:
                            TP_index = aw.findTPint(timeindex,timex,temp2)
                    else:
                        TP_index = -1
                
                if aw.qmc.AUCbegin == 0 and timeindex[0] > -1: # CHARGE
                    AUCbegin_idx = timeindex[0]
                elif aw.qmc.AUCbegin == 1 and TP_index > -1: # TP
                    AUCbegin_idx = TP_index
                elif aw.qmc.AUCbegin == 2 and timeindex[1] > 0: # DRY END
                    AUCbegin_idx = timeindex[1]
                elif aw.qmc.AUCbegin == 3 and timeindex[2] > 0: # FC START
                    AUCbegin_idx = timeindex[2]
                else:
                    AUCbegin_idx = 0

                if start is None:
                    st = AUCbegin_idx
                else:
                    st = start
                
                ed = min(len(timex),(end or timeindex[6]))
                
                if aw.qmc.AUCbaseFlag:
                    # we take the base temperature from the BT at st
                    rtet = temp1[AUCbegin_idx]
                    rtbt = temp2[AUCbegin_idx]
                else:
                    rtet = rtbt = aw.qmc.AUCbase
                rtet = aw.qmc.convertTemp(rtet,aw.qmc.mode,"C")
                rtbt = aw.qmc.convertTemp(rtbt,aw.qmc.mode,"C")

                for i in range(st,ed):
                    ET += self.calcAUC(rtet,timex,temp1,i)
                    BT += self.calcAUC(rtbt,timex,temp2,i)
                    delta += self.calcAUC(rtbt,timex,temp1,i,temp2)
            except Exception as e:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ts() {0}").format(str(e)),exc_tb.tb_lineno)
            return int(round(delta/60.)), int(round(ET/60.)), int(round(BT/60.)), AUCbegin_idx

    #Find rate of change of each phase. TP_index (by aw.findTP()) is the index of the TP and dryEndIndex that of the end of drying (by aw.findDryEnd())
    #Note: For the dryphase, the RoR for the dryphase is calculated for the segment starting from TP ending at DE
    def RoR(self,TP_index,dryEndIndex):
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        BTdrycross = None
        rc1 = rc2 = rc3 = 0.
        if dryEndIndex > -1 and dryEndIndex < len(self.qmc.temp2):
            BTdrycross = self.qmc.temp2[dryEndIndex]
        if BTdrycross and TP_index < 1000 and TP_index > -1 and dryEndIndex and TP_index < len(self.qmc.temp2):
            LP = self.qmc.temp2[TP_index]
            #avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[TP_index]
            if divisor:
                rc1 = ((BTdrycross - LP) / divisor)*60.
            else:
                rc1 = 0
        if self.qmc.timeindex[2]:
            if midphasetime and BTdrycross:
                rc2 = ((self.qmc.temp2[self.qmc.timeindex[2]] - BTdrycross)/midphasetime)*60.
            if finishphasetime:
                rc3 = ((self.qmc.temp2[self.qmc.timeindex[6]]- self.qmc.temp2[self.qmc.timeindex[2]])/finishphasetime)*60.
        return (rc1,rc2,rc3)

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewErrorLog(self,_=False):
        if self.error_dlg is None:
            self.error_dlg = errorDlg(self)
            self.error_dlg.setModal(False)
            self.error_dlg.show()
        self.error_dlg.raise_()
        self.error_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewSerialLog(self,_=False):
        if self.serial_dlg is None:
            self.serial_dlg = serialLogDlg(self)
            self.serial_dlg.setModal(False)
            self.serial_dlg.show()
        self.serial_dlg.raise_()
        self.serial_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewplatform(self,_=False):
        platformDLG = platformDlg(self)
        platformDLG.setModal(False)
        platformDLG.show()
        platformDLG.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewMessageLog(self,_=False):
        if self.message_dlg is None:
            self.message_dlg = messageDlg(self)
            self.message_dlg.setModal(False)
            self.message_dlg.show()
        self.message_dlg.raise_()
        self.message_dlg.activateWindow()
        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def helpAbout(self,_=False):
        coredevelopers = "<br>Rafael Cobo, Marko Luther, Dave Baxter &amp; Rui Paulo"
        contributors = u("<br>") + uchr(199) + u("etin Barut, Marcio Carnerio, Bradley Collins, ")
        contributors += u("Sebastien Delgrande, Kalle Deligeorgakis, Jim Gall, ")
        contributors += u("Frans Goddijn, Rich Helms, Kyle Iseminger, Ingo, ")
        contributors += u("Savvas Kiretsis, Lukas Kolbe, David Lahoz, ")
        contributors += u("Runar Ostnes, Carlos Pascual, Claudia Raddatz, ")
        contributors += u("Matthew Sewell, Bertrand Souville, Minoru Yoshida, ")
        contributors += u("Wa'il, Alex Fan, Piet Dijk, Rubens Gardelli, ")
        contributors += u("David Trebilcock, Zolt") + uchr(225) + u("n Kis, Miroslav Stankovic, ")
        contributors += u("Barrie Fairley, Ziv Sade, Nicholas Seckar, ")
        contributors += u("Morten M") + uchr(252) + u("nchow")
        contributors += u(", Andrzej Kie") + uchr(322) + u("basi") + uchr(324) + u("ski, Marco Cremonese, Josef Gander")
        contributors += u(", Paolo Scimone, Google, eightbit11, Phidgets, Hottop, Yoctopuce, Taras Prokopyuk")
        contributors += u(", Reiss Gunson (Londinium), Ram Evgi (Coffee-Tech), Rob Gardner, Jaroslav Tu") + uchr(269) + u("ek (doubleshot)")
        contributors += u(", Nick Watson, Azis Nawawi, Rit Multi, Joongbae Dave Cho (the Chambers), Probat, Andreas Bader, Dario Ernst")
        contributors += u(", Nicolas (Marvell Street Coffee Roasters), Randy (Buckeye Coffee), Moshe Spinell")
        contributors += u(", Morris Beume (Morris.Coffee), Michael Herbert, Bill (San Franciscan Roaster), Chistopher Feran")
        contributors += u(", Coffed, Bono Gargolov, Rodrigo Ramos (King Caf" + uchr(233) + "s), Nico Bigler, Saeed Abdinasab, Lewis Li, Fotis Lefas (Coffee Lovers, Editors & Trainers)<br>")
        box = QMessageBox(self)
        
        #create a html QString
        from scipy import __version__ as SCIPY_VERSION_STR
        from pymodbus import __version__ as PYMODBUS_VERSION_STR
        build = ""
        if __build__ != "0":
            build = " build " + __build__
        if app.artisanviewerMode:
            name = "ArtisanViewer"
        else:
            name = "Artisan"
        otherlibs = ""
        try:
            phidgetlibversion = PhidgetDriver.getLibraryVersion()
            otherlibs += ", " + phidgetlibversion
        except:
            pass
        try:
            yocto_version = YAPI.GetAPIVersion()
            otherlibs += ", Yoctopuce " + yocto_version
        except:
            pass
        box.about(self,
                QApplication.translate("About", "About",None),
                u("""<h2>{0} {1}{16} ({2})</h2>
                <p>
                <small>Python {3}, Qt {4}, PyQt {5}, Matplotlib {6}, NumPy {7}, SciPy {8}, pymodbus {13}{17}</small>
                </p>
                <p>{18}</p>
                <p><b>{9}</b><small>{10}</small></p>
                <p><b>{11}</b><small>{12}</small></p>
                <p><b>{14}</b><br><small>{15}</small></p>
                """).format(
                name,
                str(__version__),
                str(__revision__),
                platform.python_version(),
                qVersion(),
                PYQT_VERSION_STR,
                mpl.__version__,
                numpy.__version__,
                SCIPY_VERSION_STR,
                QApplication.translate("About", "Core Developers",None),
                coredevelopers,
                QApplication.translate("About", "Contributors",None),
                contributors,
                PYMODBUS_VERSION_STR,
                QApplication.translate("About", "License",None),
                '<a href="http://www.gnu.org/copyleft/gpl.html">GNU Public Licence (GPLv3.0)</a>',
                build,
                otherlibs,
                '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def showAboutQt(self,_=False):
        QApplication.instance().aboutQt()
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def helpHelp(self,_=False):
        QDesktopServices.openUrl(QUrl("https://artisan-scope.org/docs/quick-start-guide/", QUrl.TolerantMode))

    @pyqtSlot()
    @pyqtSlot(bool)
    def checkUpdate(self,_=False):
        try:
            update_url = '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'
            from requests import get as request_get
            r = request_get('https://api.github.com/repos/artisan-roaster-scope/artisan/releases/latest', timeout=(2,4))
            tag_name = r.json()['tag_name']
            latest = re.search(r"[\d\.]+",tag_name).group(0)
            if latest > __version__:
                update_str = QApplication.translate("About", "A new release is available.",None)
                update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/blob/master/wiki/ReleaseHistory.md">'
                update_str +=  QApplication.translate("About", "Show Change list",None)
                update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/releases/tag/' + str(tag_name) + '">'
                update_str +=  QApplication.translate("About", "Download Release",None) + str(' ') + str(tag_name)
            elif latest == __version__ :
                update_str = QApplication.translate("About", "You are using the latest release.",None)
            elif latest < __version__:
                update_str = QApplication.translate("About", "You are using a beta continuous build.",None)
                update_str += str('<br/>') + QApplication.translate("About", "You will see a notice here once a new official release is available.",None)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " checkUpdate() {0}").format(str(ex)),exc_tb.tb_lineno)
            update_str = QApplication.translate("About", "There was a problem retrieving the latest version information.  Please check your Internet connection, try again later, or check manually.",None)

        box = QMessageBox(self)
        box.about(self,
                QApplication.translate("About", "Update status",None),
                u("""<p>{0}</p>{1}""").format(update_str, update_url))

    def applicationscreenshot(self):
        imag = self.grab()
        fmt = 'png'
        initialPath = QDir.currentPath() + "/ArtisanScreenshot." + fmt
        fileName = u(QFileDialog.getSaveFileName(self, "Artisan ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))[0])
        if fileName:
            imag.save(fileName, fmt) 

    def desktopscreenshot(self):
        screen = QApplication.primaryScreen()
        imag = screen.grabWindow(QApplication.desktop().winId())
        fmt = 'png'
        initialPath = QDir.currentPath() + "/DesktopScreenshot." + fmt       
        fileName = u(QFileDialog.getSaveFileName(self, "Desktop ScreenShot",
                initialPath,
                "%s Files (*.%s);;All Files (*)"%(fmt.upper(),fmt))[0])
        if fileName:
            imag.save(fileName, fmt)
            
    @pyqtSlot()
    @pyqtSlot(bool)
    def oversampling(self,_=False):
        aw.qmc.oversampling = not aw.qmc.oversampling
        aw.oversamplingAction.setChecked(aw.qmc.oversampling)
        if aw.qmc.oversampling and self.qmc.delay < aw.qmc.oversampling_min_delay:
            QMessageBox.warning(aw,QApplication.translate("Message", "Warning",None),QApplication.translate("Message", 
            "Oversampling is only active with a sampling interval equal or larger than 3s.",None))
            
    @pyqtSlot()
    @pyqtSlot(bool)
    def calibratedelay(self,_=False):
        samplingDl = SamplingDlg(self)
        samplingDl.show()
        samplingDl.setFixedSize(samplingDl.size())

    @pyqtSlot()
    @pyqtSlot(bool)
    def setcommport(self,_=False):
        dialog = comportDlg(self)
        if dialog.exec_():
            # set serial port
            self.ser.comport = str(dialog.comportEdit.getSelection())
            self.ser.baudrate = int(str(dialog.baudrateComboBox.currentText()))              #int changes QString to int
            self.ser.bytesize = int(str(dialog.bytesizeComboBox.currentText()))
            self.ser.stopbits = int(str(dialog.stopbitsComboBox.currentText()))
            self.ser.parity = str(dialog.parityComboBox.currentText())
            self.ser.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.timeoutEdit.text()))))
            # set modbus port
            self.modbus.comport = str(dialog.modbus_comportEdit.getSelection())
            self.modbus.baudrate = int(str(dialog.modbus_baudrateComboBox.currentText()))              #int changes QString to int
            self.modbus.bytesize = int(str(dialog.modbus_bytesizeComboBox.currentText()))
            self.modbus.stopbits = int(str(dialog.modbus_stopbitsComboBox.currentText()))
            self.modbus.parity = str(dialog.modbus_parityComboBox.currentText())
            self.modbus.timeout = aw.float2float(toFloat(str(dialog.modbus_timeoutEdit.text())))
            self.modbus.PID_slave_ID = int(str(dialog.modbus_PIDslave_Edit.text()))
            self.modbus.PID_SV_register = int(str(dialog.modbus_SVregister_Edit.text()))
            self.modbus.PID_p_register = int(str(dialog.modbus_Pregister_Edit.text()))
            self.modbus.PID_i_register = int(str(dialog.modbus_Iregister_Edit.text()))
            self.modbus.PID_d_register = int(str(dialog.modbus_Dregister_Edit.text()))
            self.modbus.PID_OFF_action = s2a(toString(dialog.modbus_pid_off.text()))
            self.modbus.PID_ON_action = s2a(toString(dialog.modbus_pid_on.text()))
            
            for i in range(aw.modbus.channels):
                self.modbus.inputSlaves[i] = int(str(dialog.modbus_inputSlaveEdits[i].text()))
                self.modbus.inputRegisters[i] = int(str(dialog.modbus_inputRegisterEdits[i].text()))
                self.modbus.inputCodes[i] = int(str(dialog.modbus_inputCodes[i].currentText()))
                self.modbus.inputDivs[i] = dialog.modbus_inputDivs[i].currentIndex()
                self.modbus.inputModes[i] = str(dialog.modbus_inputModes[i].currentText())
                if dialog.modbus_inputDecodes[i].currentIndex() == 1:
                    self.modbus.inputFloats[i] = True
                    self.modbus.inputBCDs[i] = False
                elif dialog.modbus_inputDecodes[i].currentIndex() == 2:
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = True
                else:
                    self.modbus.inputFloats[i] = False
                    self.modbus.inputBCDs[i] = False
                    
            self.modbus.SVmultiplier = dialog.modbus_SVmultiplier.currentIndex()
            self.modbus.PIDmultiplier = dialog.modbus_PIDmultiplier.currentIndex()
            self.modbus.byteorderLittle = bool(dialog.modbus_littleEndianBytes.isChecked())
            self.modbus.wordorderLittle = bool(dialog.modbus_littleEndianWords.isChecked())
            self.modbus.type = int(dialog.modbus_type.currentIndex())
            self.modbus.host = str(dialog.modbus_hostEdit.text())
            try:
                self.modbus.port = int(str(dialog.modbus_portEdit.text()))
            except Exception:
                pass
            
            # S7 Setup
            self.s7.host = str(dialog.s7_hostEdit.text())
            self.s7.port = int(str(dialog.s7_portEdit.text()))
            self.s7.rack = int(str(dialog.s7_rackEdit.text()))
            self.s7.slot = int(str(dialog.s7_slotEdit.text()))
            for i in range(self.s7.channels):
                self.s7.area[i] = dialog.s7_areaCombos[i].currentIndex()
                self.s7.db_nr[i] = int(str(dialog.s7_dbEdits[i].text()))
                self.s7.start[i] = int(str(dialog.s7_startEdits[i].text()))
                self.s7.type[i] = dialog.s7_typeCombos[i].currentIndex()
                self.s7.div[i] = dialog.s7_divCombos[i].currentIndex()
                self.s7.mode[i] = dialog.s7_modeCombos[i].currentIndex()
            self.s7.PID_area = dialog.s7_PIDarea.currentIndex()
            self.s7.PID_db_nr = int(str(dialog.s7_PIDdb_nr_Edit.text()))
            self.s7.PID_SV_register = int(str(dialog.s7_SVregister_Edit.text()))
            self.s7.SVmultiplier = dialog.s7_SVmultiplier.currentIndex()
            self.s7.PIDmultiplier = dialog.s7_PIDmultiplier.currentIndex()
            self.s7.PID_p_register = int(str(dialog.s7_Pregister_Edit.text()))
            self.s7.PID_i_register = int(str(dialog.s7_Iregister_Edit.text()))
            self.s7.PID_d_register = int(str(dialog.s7_Dregister_Edit.text()))
            self.s7.PID_OFF_action = s2a(toString(dialog.s7_pid_off.text()))
            self.s7.PID_ON_action = s2a(toString(dialog.s7_pid_on.text()))
                
            # set scale port
            self.scale.device = str(dialog.scale_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.scale.comport = str(dialog.scale_comportEdit.getSelection())
            self.scale.baudrate = int(str(dialog.scale_baudrateComboBox.currentText()))              #int changes QString to int
            self.scale.bytesize = int(str(dialog.scale_bytesizeComboBox.currentText()))
            self.scale.stopbits = int(str(dialog.scale_stopbitsComboBox.currentText()))
            self.scale.parity = str(dialog.scale_parityComboBox.currentText())
            self.scale.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.scale_timeoutEdit.text()))))
            # set color port
            self.color.device = str(dialog.color_deviceEdit.currentText())                #unicode() changes QString to a python string
            self.color.comport = str(dialog.color_comportEdit.getSelection())
            self.color.baudrate = int(str(dialog.color_baudrateComboBox.currentText()))              #int changes QString to int
            self.color.bytesize = int(str(dialog.color_bytesizeComboBox.currentText()))
            self.color.stopbits = int(str(dialog.color_stopbitsComboBox.currentText()))
            self.color.parity = str(dialog.color_parityComboBox.currentText())
            self.color.timeout = aw.float2float(toFloat(aw.comma2dot(str(dialog.color_timeoutEdit.text()))))
            # deleteLater() will not work here as the dialog is still bound via the parent
            dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
            # the following will immedately release the memory dispite this parent link
            QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
            try:
                sip.delete(dialog)
                #print(sip.isdeleted(dialog))
            except:
                pass

    def toggleHottopControl(self):
        if self.HottopControlActive:
            self.HottopControlOff()
        else:
            self.HottopControlOn()
            
    def HottopControlOff(self):
        from artisanlib.hottop import releaseHottopControl
        res = releaseHottopControl()
        if res:
            if self.HottopControlActive:
                aw.sendmessage(QApplication.translate("Message","Hottop control turned off", None))
            self.HottopControlActive = False
            aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])
    
    def HottopControlOn(self):
        if aw.superusermode: # Hottop control mode can for now activated only in super user mode
            from artisanlib.hottop import takeHottopControl, setHottop, startHottop, isHottopLoopRunning
            if not isHottopLoopRunning():
                startHottop(0.6,aw.ser.comport,aw.ser.baudrate,aw.ser.bytesize,aw.ser.parity,aw.ser.stopbits,aw.ser.timeout)
            res = takeHottopControl()
            if res:
                setHottop(drum_motor=True)
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"])
                if not self.HottopControlActive:
                    aw.sendmessage(QApplication.translate("Message","Hottop control turned on", None))
                self.HottopControlActive = True
        else:
            QMessageBox.warning(aw,QApplication.translate("Message", "Warning",None),QApplication.translate("Message",
                "To control a Hottop you need to activate the super user mode via a right click on the timer LCD first!",None))
            
    @pyqtSlot(bool)
    def PIDcontrol(self,_=False):
        #FUJI/DELTA pid
        if self.qmc.device == 0 or self.qmc.device == 26:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.ControlModifier and self.qmc.device == 0:
                # a right-click on the Control button will toggle PID Standby on and off
                if (aw.ser.controlETpid[0] == 0 and aw.fujipid.PXR["runstandby"][0] == 0) or \
                    (aw.ser.controlETpid[0] == 1 and aw.ser.controlETpid[0] == 0):
                    # standby is off (=0), turn it on (=1)
                    aw.fujipid.setONOFFstandby(1)
                    aw.sendmessage(QApplication.translate("Message","PID Standby ON", None)) 
                elif (aw.ser.controlETpid[0] == 0 and aw.fujipid.PXR["runstandby"][0] == 1) or \
                    (aw.ser.controlETpid[0] == 1 and aw.ser.controlETpid[0] == 1):
                    # standby is on (=1), turn it off (=0)
                    aw.fujipid.setONOFFstandby(0)
                    aw.sendmessage(QApplication.translate("Message","PID Standby OFF", None)) 
            else:
                if self.ser.controlETpid[0] == 0:
                    dialog = PXG4pidDlgControl(self)
                elif self.ser.controlETpid[0] == 1:
                    dialog = PXRpidDlgControl(self)
                elif self.ser.controlETpid[0] == 2:
                    dialog = DTApidDlgControl(self)
                elif self.ser.controlETpid[0] == 4: # Fuji PXF
                    dialog = PXG4pidDlgControl(self)
                #modeless style dialog 
                dialog.setModal(False)
                dialog.show()
                dialog.setFixedSize(dialog.size())
                QApplication.processEvents()
        # Hottop
        elif self.qmc.device == 53:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.ControlModifier:
                dialog = PID_DlgControl(self)
                #modeless style dialog 
                dialog.show()
                #dialog.setFixedSize(dialog.size()) # this badly interacts with keeping the window gemetry in qsettings
            else:
                #self.pidcontrol.togglePID()
                self.toggleHottopControl()
        # all other devices
        else:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.ControlModifier:
                self.pidcontrol.togglePID()
            else:
                dialog = PID_DlgControl(self)
                #modeless style dialog 
                dialog.show()
#                dialog.setFixedSize(dialog.size())  # this badly interacts with keeping the window gemetry in qsettings

    @pyqtSlot()
    @pyqtSlot(bool)
    def deviceassigment(self,_=False):
        dialog = DeviceAssignmentDlg(self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def showstatistics(self,_=False):
        dialog = StatisticsDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def Windowconfig(self,_=False):
        dialog = WindowsDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def autosaveconf(self,_=False):
        dialog = autosaveDlg(self)
        dialog.show()
#        dialog.setFixedSize(dialog.size())

    @pyqtSlot()
    @pyqtSlot(bool)
    def batchconf(self,_=False):
        dialog = batchDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())

    @pyqtSlot()
    @pyqtSlot(bool)
    def calculator(self,_=False):
        dialog = calculatorDlg(self)
        dialog.setModal(False)
        dialog.show()
#        dialog.setFixedSize(dialog.size()) # setting this fixed size badly interacts with remembering the screen geometry in app settings
        QApplication.processEvents()
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def loadSettings_triggered(self,_=False):
        self.loadSettings()
    
    def loadSettings(self,fn=None,remember=True,reset=True):
        try:
            if fn:
                filename = fn
            else:
                filename = self.ArtisanOpenFileDialog()
            if filename:
                try:
                    aw.stopActivities()
                    res = aw.settingsLoad(filename)
                    if reset:
                        flag_temp = aw.qmc.roastpropertiesflag
                        aw.qmc.roastpropertiesflag = 1 # ensure that all roast properties are reset!
                        aw.qmc.reset(soundOn=False)
                        aw.qmc.roastpropertiesflag = flag_temp
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                        self.sendmessage(QApplication.translate("Message","Settings loaded {0}".format(aw.strippedName(filename)), None))
                    else:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                except Exception:
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentSettingList'))
                    try:
                        removeAll(files,filename)
                    except ValueError:
                        pass
                    settings.setValue('recentSettingList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentSettingActions()
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " loadSettings() {0}").format(str(ex)),exc_tb.tb_lineno)
        
    def updateRecentSettingActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentSettingList'))
        strippedNames = list(map(self.strippedName,files))
        numRecentSettings = min(len(files), self.MaxRecentFiles)
 
        for i in range(numRecentSettings):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = "&%s (%s)" % (strippedName, self.strippedDir(files[i]))
            else:
                text = "&%s" % strippedName
            self.recentSettingActs[i].setText(text)
            self.recentSettingActs[i].setData(files[i])
            self.recentSettingActs[i].setVisible(True)
 
        for j in range(numRecentSettings, self.MaxRecentFiles):
            self.recentSettingActs[j].setVisible(False)
 
    def openRecentSetting(self):
        action = self.sender()
        if action:
            fname = toString(action.data())
            if os.path.isfile(fname):
                self.loadSettings(fn=fname)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentSettingList'))
                try:
                    removeAll(files,fname)
                except ValueError:
                    pass
                settings.setValue('recentSettingList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentSettingActions()
                self.sendmessage(QApplication.translate("Message","Settings not found", None))
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def saveSettings(self,_=False):
        path = QDir()
        path.setPath(self.getDefaultPath())
        fname = path.absoluteFilePath(QApplication.translate("Message","artisan-settings", None))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Settings",None), path=fname, ext="*.aset")
        if filename:
            aw.settingspath = filename
            aw.closeEventSettings(filename)
            self.sendmessage(QApplication.translate("Message","Settings saved", None))
            # update recentSettings menu
            settings = QSettings()
            files = toStringList(settings.value('recentSettingList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            files.insert(0, filename)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentSettingList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentSettingActions()
        else:
            self.sendmessage(QApplication.translate("Message","Cancelled", None))

    def updateRecentThemeActions(self):
        settings = QSettings()
        files = toStringList(settings.value('recentThemeList'))
        files.sort()
        strippedNames = list(map(self.strippedName,files))
        numRecentThemes = min(len(files), self.MaxRecentFiles)
 
        for i in range(numRecentThemes):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = "&%s (%s)" % (strippedName, self.strippedDir(files[i]))
            else:
                text = "&%s" % strippedName
            self.recentThemeActs[i].setText(text)
            self.recentThemeActs[i].setData(files[i])
            self.recentThemeActs[i].setVisible(True)
 
        for j in range(numRecentThemes, self.MaxRecentFiles):
            self.recentThemeActs[j].setVisible(False)
 
    def openRecentTheme(self):
        action = self.sender()
        if action:
            fname = toString(action.data())
            if os.path.isfile(fname):
                self.loadSettings_theme(fn=fname)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentThemeList'))
                try:
                    removeAll(files,fname)
                except ValueError:
                    pass
                settings.setValue('recentThemeList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentThemeActions()
                self.sendmessage(QApplication.translate("Message","Settings not found", None))

    @pyqtSlot(bool)
    def saveSettings_theme(self,_=False):
        path = QDir()
        path.setPath(self.getDefaultPath())
        path.setPath(os.path.join(self.getResourcePath(),"Themes","User"))
        fname = path.absoluteFilePath(QApplication.translate("Message","artisan-theme", None))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message", "Save Theme",None), path=fname, ext="*.athm")
        if filename:
            aw.closeEventSettings_theme(filename)
            self.sendmessage(QApplication.translate("Message","Theme saved", None))
            # update recentTheme menu
            settings = QSettings()
            files = toStringList(settings.value('recentThemeList'))
            try:
                removeAll(files,filename)
            except ValueError:
                pass
            files.insert(0, filename)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentThemeList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentThemeActions()
            self.themeMenu.clear()
            self.populateThemeMenu()
        else:
            self.sendmessage(QApplication.translate("Message","Cancelled", None))
    
    @pyqtSlot(bool)
    def loadSettings_theme_Slot(self,_=False):
        self.loadSettings_theme()
    
    def loadSettings_theme(self,fn=None,remember=True,reset=False):
        try:
            if fn:
                filename = fn
            else:
                filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Theme",None),ext="*.athm")
            if filename:
                string = QApplication.translate("Message", "Load theme {0}?",None).format(os.path.basename(filename))
                reply = QMessageBox.question(aw,QApplication.translate("Message", "Adjust Theme Related Settings",None),string,
                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    return 
                try:
                    res = aw.settingsLoad(filename)
                    self.sendmessage(QApplication.translate("Message","Loaded theme {0}", None).format(filename))
                    if reset:
                        aw.qmc.reset(soundOn=False)
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                                self.sendmessage(QApplication.translate("Message","Theme loaded", None))
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                    else:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files,filename)
                        except ValueError:
                            pass
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                except Exception:
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentThemeList'))
                    try:
                        removeAll(files,filename)
                    except ValueError:
                        pass
                    settings.setValue('recentThemeList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentThemeActions()
                    self.themeMenu.clear()
                    self.populateThemeMenu()
            else:
                self.sendmessage(QApplication.translate("Message","Cancelled", None))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " loadSettings_theme() {0}").format(str(ex)),exc_tb.tb_lineno)
    

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeLCDs(self,_=False):
        if self.largeLCDs_dialog is None:
            self.largeLCDs_dialog = LargeMainLCDs()
            self.largeLCDs_dialog.setModal(False)
            self.LargeLCDsFlag = True
        if self.largeLCDs_dialog is not None:
            self.largeLCDs_dialog.show()
            self.largeLCDs_dialog.raise_()
            self.largeLCDs_dialog.activateWindow()
            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeDeltaLCDs(self,_=False):
        if self.largeDeltaLCDs_dialog is None:
            self.largeDeltaLCDs_dialog = LargeDeltaLCDs()
            self.largeDeltaLCDs_dialog.setModal(False)
            self.LargeDeltaLCDsFlag = True
        if self.largeDeltaLCDs_dialog is not None:
            self.largeDeltaLCDs_dialog.show()
            self.largeDeltaLCDs_dialog.raise_()
            self.largeDeltaLCDs_dialog.activateWindow()
            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePIDLCDs(self,_=False):
        if self.largePIDLCDs_dialog is None:
            self.largePIDLCDs_dialog = LargePIDLCDs()
            self.largePIDLCDs_dialog.setModal(False)
            self.LargePIDLCDsFlag = True
        if self.largePIDLCDs_dialog is not None:
            self.largePIDLCDs_dialog.show()
            self.largePIDLCDs_dialog.raise_()
            self.largePIDLCDs_dialog.activateWindow()
            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeExtraLCDs(self,_=False):
        if self.largeExtraLCDs_dialog is None:
            self.largeExtraLCDs_dialog = LargeExtraLCDs()
            self.largeExtraLCDs_dialog.setModal(False)
            self.LargeExtraLCDsFlag = True
        if self.largeExtraLCDs_dialog is not None:
            self.largeExtraLCDs_dialog.show()
            self.largeExtraLCDs_dialog.raise_()
            self.largeExtraLCDs_dialog.activateWindow()
            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePhasesLCDs(self,_=False):
        if self.largePhasesLCDs_dialog is None:
            self.largePhasesLCDs_dialog = LargePhasesLCDs()
            self.largePhasesLCDs_dialog.setModal(False)
            self.LargePhasesLCDsFlag = True
            self.updatePhasesLCDs()
        if self.largePhasesLCDs_dialog is not None:
            self.largePhasesLCDs_dialog.show()
            self.largePhasesLCDs_dialog.raise_()
            self.largePhasesLCDs_dialog.activateWindow()
            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def graphwheel(self,_=False):
        if self.qmc.designerflag:
            self.stopdesigner()
        if self.wheeldialog == None:
            # remove the standard fig axis to trigger their recreation
            self.qmc.ax = None
            self.qmc.delta_ax = None
            self.wheeldialog = WheelDlg(self)
        if self.qmc.wheelflag:
            aw.redrawOnResize = True
            self.qmc.exitviewmode()
            aw.enableEditMenus()
            aw.showControls()
        else:
            aw.redrawOnResize = False
            aw.hideControls()
            aw.hideLCDs(False)
            aw.hideSliders(False)
            aw.hideExtraButtons()
            aw.disableEditMenus(wheel=True)
            aw.qmc.connectWheel()
            if aw.wheelpath and aw.wheelpath != "":
                try:
                    aw.loadWheel(aw.wheelpath)
                    self.wheeldialog.createdatatable()
                except Exception:
                    aw.settingspath = "" 
            aw.qmc.drawWheel()

    @pyqtSlot()
    @pyqtSlot(bool)
    def background(self,_=False):
        dialog = backgroundDlg(self)
        dialog.show()
        #dialog.setFixedSize(dialog.size())
        
    def deleteBackground(self):
        self.qmc.background = False
        self.qmc.backgroundprofile = None
        self.qmc.backgroundpath = ""
        self.qmc.backgroundUUID = None
        self.qmc.titleB = ""
        self.qmc.roastbatchnrB = 0
        self.qmc.roastbatchprefixB = ""
        self.qmc.roastbatchposB = 1
        self.qmc.temp1B, self.qmc.temp2B, self.qmc.temp1BX, self.qmc.temp2BX, self.qmc.timeB = [],[],[],[],[]
        self.qmc.stemp1B,self.qmc.stemp2B,self.qmc.stemp1BX,self.qmc.stemp2BX = [],[],[],[] # smoothed versions of the background courves
        self.qmc.extraname1B,self.qmc.extraname2B = [],[]
        self.qmc.backgroundEvents, self.qmc.backgroundEtypes = [],[]
        self.qmc.backgroundEvalues, self.qmc.backgroundEStrings,self.qmc.backgroundFlavors = [],[],[]
        self.qmc.timeindexB = [-1,0,0,0,0,0,0,0]
        self.qmc.backmoveflag = 1
        self.qmc.TP_time_B = -1
        self.qmc.TP_time_B_loaded = -1
        self.qmc.AUCbackground = -1
        self.qmc.l_background_annotations = []
        self.qmc.analysisresultsstr = ""

    @pyqtSlot()
    @pyqtSlot(bool)
    def switchETBT(self,_=False):
        t2 = aw.qmc.temp2
        aw.qmc.temp2 = aw.qmc.temp1
        aw.qmc.temp1 = t2
        aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
        aw.qmc.fileDirty()
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def switch(self,_=False):
        if aw.qmc.checkSaved() == False:
            return
        try:
            foreground_profile_path = aw.curFile
            background_profile_path = aw.qmc.backgroundpath
            if background_profile_path:
            # load background into foreground
                aw.loadFile(background_profile_path)
            # if there is a plotter generated background curve bring it to the foreground 
            elif len(aw.qmc.temp1B) > 2:
                _timex  = aw.qmc.timeB[:]
                _temp1 = aw.qmc.temp1B[:]
                _temp2 = aw.qmc.temp2B[:]
                # use foreground events if the background has no CHARGE 
                if aw.qmc.timeindexB[0] == -1:
                    _timeindex = aw.qmc.timeindex[:]
                else:
                    _timeindex = aw.qmc.timeindexB[:]
                # clear the background
                aw.deleteBackground

                flag_temp = aw.qmc.roastpropertiesflag
                aw.qmc.roastpropertiesflag = 1 # ensure that all roast properties are reset!
                aw.qmc.reset(soundOn=False)
                aw.qmc.roastpropertiesflag = flag_temp
                aw.qmc.timex = _timex[:]
                aw.qmc.temp1 = _temp1[:]
                aw.qmc.temp2 = _temp2[:]
                aw.qmc.timeindex = _timeindex[:]
                if not foreground_profile_path:
                    aw.qmc.redraw(recomputeAllDeltas=True)
                aw.qmc.fileDirty()
            else:
                # reset
                aw.qmc.reset(soundOn=False)
            if foreground_profile_path:
                # load foreground into background
                aw.loadbackground(u(foreground_profile_path))
                aw.qmc.background = True
                aw.qmc.timealign(redraw=True,recompute=True)
            else:
                # delete background
                self.deleteBackground()
            if foreground_profile_path or background_profile_path:
                aw.qmc.redraw(recomputeAllDeltas=True)
        except Exception:
            pass
#            import traceback
#            traceback.print_exc(file=sys.stdout)

    @pyqtSlot()
    @pyqtSlot(bool)
    def flavorchart(self,_=False):
        self.redrawOnResize = False # disable the redraw triggered on resize (eg. by hiding widgets) that replaces the logo icon
        self.hideControls()
        self.hideLCDs(False)
        self.hideSliders(False)
        self.hideExtraButtons()
        dialog = flavorDlg(self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def designerTriggered(self,_=False):
        if self.qmc.designerflag:
            self.stopdesigner()
        else:
            if aw.qmc.ai:
                aw.qmc.ai.remove()
            self.startdesigner()

    def startdesigner(self):
        self.qmc.designer()

    def stopdesigner(self):
        aw.enableEditMenus()
        self.qmc.convert_designer()

    @pyqtSlot()
    @pyqtSlot(bool)
    def editgraph(self,_=False):
        if self.editgraphdialog != False: # Roast Properties dialog is not blocked!
            self.editgraphdialog = editGraphDlg(self)
            self.editgraphdialog.show()
            self.editgraphdialog = None

    @pyqtSlot()
    @pyqtSlot(bool)
    def editphases(self,_=False):
        dialog = phasesGraphDlg(self)
        dialog.show()
        dialog.setFixedSize(dialog.size())
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def eventsconf(self,_=False):
        dialog = EventsDlg(self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def alarmconfig(self,_=False):
        if self.qmc.device != 18 or aw.simulator is not None:
            dialog = AlarmDlg(self)
            dialog.show()
        else:
            QMessageBox.information(aw,QApplication.translate("Message", "Alarm Config",None),
                                    QApplication.translate("Message", "Alarms are not available for device None",None))

    def switchLanguageFlag(self,locale,value):
        if locale == "en" or locale == "en_US":
            self.EnglishLanguage.setChecked(value)
        elif locale == "ar":
            self.ArabicLanguage.setChecked(value)
        elif locale == "de":
            self.GermanLanguage.setChecked(value)
        elif locale == "el":
            self.GreekLanguage.setChecked(value)
        elif locale == "es":
            self.SpanishLanguage.setChecked(value)
        elif locale == "fa":
            self.FarsiLanguage.setChecked(value)
        elif locale == "fi":
            self.FinishLanguage.setChecked(value)
        elif locale == "fr":
            self.FrenchLanguage.setChecked(value)
        elif locale == "he":
            self.HebrewLanguage.setChecked(value)
        elif locale == "hu":
            self.HungarianLanguage.setChecked(value)
        elif locale == "id":
            self.IndonesianLanguage.setChecked(value)
        elif locale == "it":
            self.ItalianLanguage.setChecked(value)
        elif locale == "ja":
            self.JapaneseLanguage.setChecked(value)
        elif locale == "ko":
            self.KoreanLanguage.setChecked(value)
        elif locale == "nl":
            self.DutchLanguage.setChecked(value)
        elif locale == "no":
            self.NorwegianLanguage.setChecked(value)
        elif locale == "pt":
            self.PortugueseLanguage.setChecked(value)
        elif locale == "pt_BR":
            self.PortugueseBrasilLanguage.setChecked(value)
        elif locale == "pl":
            self.PolishLanguage.setChecked(value)
        elif locale == "ru":
            self.RussianLanguage.setChecked(value)
        elif locale == "sv":
            self.SwedishLanguage.setChecked(value)
        elif locale == "th":
            self.ThaiLanguage.setChecked(value)
        elif locale == "tr":
            self.TurkishLanguage.setChecked(value)
        elif locale == "zh_CN":
            self.ChineseChinaLanguage.setChecked(value)
        elif locale == "zh_TW":
            self.ChineseTaiwanLanguage.setChecked(value)

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_ar(self,_=False):
        self.changelocale("ar")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_de(self,_=False):
        self.changelocale("de")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_el(self,_=False):
        self.changelocale("el")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_en(self,_=False):
        self.changelocale("en")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_es(self,_=False):
        self.changelocale("es")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_fa(self,_=False):
        self.changelocale("fa")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_fi(self,_=False):
        self.changelocale("fi")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_fr(self,_=False):
        self.changelocale("fr")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_he(self,_=False):
        self.changelocale("he")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_hu(self,_=False):
        self.changelocale("hu")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_id(self,_=False):
        self.changelocale("id")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_it(self,_=False):
        self.changelocale("it")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_ja(self,_=False):
        self.changelocale("ja")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_ko(self,_=False):
        self.changelocale("ko")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_nl(self,_=False):
        self.changelocale("nl")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_no(self,_=False):
        self.changelocale("no")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_pt(self,_=False):
        self.changelocale("pt")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_pt_BR(self,_=False):
        self.changelocale("pt_BR")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_pl(self,_=False):
        self.changelocale("pl")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_ru(self,_=False):
        self.changelocale("ru")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_sv(self,_=False):
        self.changelocale("sv")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_th(self,_=False):
        self.changelocale("th")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_tr(self,_=False):
        self.changelocale("tr")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_zh_CN(self,_=False):
        self.changelocale("zh_CN")

    @pyqtSlot()
    @pyqtSlot(bool)    
    def changelocale_zh_TW(self,_=False):
        self.changelocale("zh_TW")
                   
    def changelocale(self,languagelocale):
        if locale != languagelocale:
            string = QApplication.translate("Message","Switching the language needs a restart. Restart now?", None)
            reply = QMessageBox.warning(aw,QApplication.translate("Message","Restart", None),string,
                              QMessageBox.Cancel | QMessageBox.Yes)
            if reply == QMessageBox.Yes:
                # switch old flag off
                self.switchLanguageFlag(locale,False)
                # check if etypes are unmodified by user and in that case, remove etypes from settings to avoid overwriting of translations:
                # switch new flag on
                self.switchLanguageFlag(languagelocale,True)
                settings = QSettings()
                settings.setValue('locale', languagelocale)
                self.close()
            else:
                self.switchLanguageFlag(languagelocale,False)

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    def weight_loss(self,green,roasted):
        if float(green) == 0.0 or float(green) < float(roasted):
            return 0.
        else:
            return 100. * ((float(green) - float(roasted)) / float(green))
            
    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    def volume_increase(self,green, roasted):
        if float(roasted) == 0.0 or float(green) > float(roasted):
            return 0.
        else:
            return 100. * ((float(roasted) - float(green)) / float(green))

    # from RoastMagazine (corrected by substracting 1% based on experience)
    # http://www.roastmagazine.com/resources/Roasting101_Articles/Roast_SeptOct05_LightRoasting.pdf
    def roast_degree(self,percent):
        if percent < 13.5:
            return ""
        elif percent < 14.5:
            return u(QApplication.translate("Label", "City",None))
        elif percent < 15.5:
            return u(QApplication.translate("Label", "City+",None))
        elif percent < 16.5:
            return u(QApplication.translate("Label", "Full City",None))
        elif percent < 17.5:
            return u(QApplication.translate("Label", "Full City+",None))
        elif percent < 18.5:
            return u(QApplication.translate("Label", "Light French",None))
        else:
            return u(QApplication.translate("Label", "French",None))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK202(self,_=False):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K202 CSV",None))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T1unit","T2","T2unit"],delimiter='\t')
                zero_t = None
                roastdate = None
                unit = None
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDateTime(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                            self.qmc.roastdate = roastdate
                            self.qmc.roastepoch = self.qmc.roastdate.toTime_t()
                            self.qmc.roasttzoffset = 0
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
                        #set temperature mode
                        if not unit:
                            unit = item['T1unit']
                            if unit == "F" and self.qmc.mode == "C":
                                self.qmc.fahrenheitMode()
                            if unit == "C" and self.qmc.mode == "F":
                                self.qmc.celsiusMode()
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                        self.qmc.temp1.append(float(item['T1'].replace(',','.')))
                        self.qmc.temp2.append(float(item['T2'].replace(',','.')))
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate("Message","K202 file loaded successfully", None))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " importK202(): {0}").format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " importK202(): {0}").format(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importK202() {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK204(self,_=False):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import K204 CSV",None))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                csvReader = csv.DictReader(csvFile,["Date","Time","T1","T2","T3","T4"],delimiter='\t')
                zero_t = None
                roastdate = None
                # we add an extra device if needed
                if len(self.qmc.extradevices) == 0:
                    self.addDevice()
                for item in csvReader:
                    try:
                        #set date
                        if not roastdate:
                            roastdate = QDateTime(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                            self.qmc.roastdate = roastdate
                            self.qmc.roastepoch = self.qmc.roastdate.toTime_t()
                            self.qmc.roasttzoffset = 0
                        #set zero
                        if not zero_t:
                            date = QDate.fromString(item['Date'],"dd'.'MM'.'yyyy")
                            zero = QDateTime()
                            zero.setDate(date)
                            zero.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                            zero_t = zero.toTime_t()
    # The K204 export does not contain a trace of the temperature mode.
    # We have to assume here that the mode was set correctly before the import.
                        #add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'],"dd'.'MM'.'yyyy"))
                        dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                        tx = float(dt.toTime_t() - zero_t)
                        self.qmc.timex.append(tx)
                        t1 = float(item['T1'].replace(',','.'))
                        if t1 > 800 or t1 < 0.0:
                            t1 = 0.0
                        self.qmc.temp1.append(t1)
                        t2 = float(item['T2'].replace(',','.'))
                        if t2 > 800 or t2 < 0.0:
                            t2 = 0.0
                        self.qmc.temp2.append(t2)
                        if len(self.qmc.extradevices) > 0:
                            self.qmc.extratimex[0].append(tx)
                            t3 = float(item['T3'].replace(',','.'))
                            if t3 > 800 or t3 < 0.0:
                                t3 = 0.0
                            self.qmc.extratemp1[0].append(t3)
                            t4 = float(item['T4'].replace(',','.'))
                            if t4 > 800 or t4 < 0.0:
                                t2 = 0.0
                            self.qmc.extratemp2[0].append(t4)
                    except ValueError:
                        pass
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate("Message","K204 file loaded successfully", None))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " importK204(): {0}").format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " importK204(): {0}").format(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importK204() {0}").format(str(ex)),exc_tb.tb_lineno)

    # normalize xml tags and attributs to lower case
    def normalize_tags(self,root):
        root.tag = root.tag.lower()
        for child in root:
            self.normalize_tags(child)
    def normalize_attr(self,root):
        for attr,value in root.attrib.items():
            norm_attr = attr.lower()
            if norm_attr != attr:
                root.set(norm_attr,value)
                root.attrib.pop(attr)
        for child in root:
            self.normalize_attr(child)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importPilot(self,_=False):
        try:
            try:
                import xml.etree.cElementTree as ET
            except ImportError:
                import xml.etree.ElementTree as ET
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import Probat Recipe", None))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                tree = ET.ElementTree(file=filename)
                root = tree.getroot()
                self.normalize_tags(root) # normalize tags to lower case
                self.normalize_attr(root) # normalize attributes to lower case
                
                if root.tag == "history":
                    date = root.find("historydate")
                    time = root.find("historytime")
                    if date is not None and time is not None:
                        aw.qmc.roastdate = QDateTime(QDate.fromString(date.text,"M/d/yyyy"),QTime.fromString(time.text,"h:mm AP"))
  
                title = root.find("roasttype")
                if title is None:
                    aw.qmc.title = u(os.path.basename(filename))
                else:
                    aw.qmc.title = u(title.text)
                    
                beans = root.find("coffeetype")
                if beans is not None:
                    if beans.text is not None:
                        aw.qmc.beans = u(beans.text)
                                        
                roaster = root.find("roaster")
                if roaster is not None:
                    if roaster.text is not None:
                        aw.qmc.roastertype = u(roaster.text)
                    
                chargestr = root.find("charge")
                if chargestr is None:
                    chargestr = root.find("chargingcapacity")
                if chargestr is not None: # contains floating point number; default unit Kg
                    try:
                        aw.qmc.weight[0] = float(chargestr.text)
                        aw.qmc.weight[2] = "Kg"
                    except:
                        pass
                        
                dischargestr = root.find("dischargingcapacity")
                if dischargestr is not None: # contains floating point number; default unit Kg
                    try:
                        aw.qmc.weight[1] = float(dischargestr.text)
                        aw.qmc.weight[2] = "Kg"
                    except:
                        pass
                        
                colorstr = root.find("coffeecolor")
                if colorstr is not None:
                    c = None
                    if colorstr.text is not None:
                        for e in colorstr.text.strip().split():
                            try:
                                c = int(e)
                                break
                            except:
                                pass
                    if c:
                        aw.qmc.ground_color = c
                        
                notes = root.find("notes")
                if notes is not None:
                    if notes.text is not None:
                        self.qmc.roastingnotes = u(notes.text)

                recipedata = None
                historydata = None
                recipedata = tree.find('recipedata')
                if recipedata is not None:
                    m = recipedata.get("temp_unit")
                else:    
                    m = tree.find('recipedata_temp_unit')
                    if m is not None:
                        m = m.text
                if m is None:
                    historydata = tree.find('historydata')
                    if historydata is not None:
                        m = historydata.get("temp_unit")
                    else:
                        m = tree.find('historydata_temp_unit')
                        if m is not None:
                            m = m.text
                if m is not None:
                    m = m.lower()
                    if m == "c" and self.qmc.mode == "F":
                        self.qmc.celsiusMode()
                    elif m == "f" and self.qmc.mode == "C":
                        self.qmc.fahrenheitMode()
                        
                # add extra device if needed
                for _ in range(max(0,1 - len(self.qmc.extradevices))):
                    self.addDevice()
                if self.qmc.extraname1[0] == "Extra 1":
                    self.qmc.extraname1[0] = "Burner" 
                
                diagrampoints = None
                if recipedata is not None:
                    diagrampoints = tree.find('recipedata/diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('historydata')
                last_timez = 0
                if diagrampoints is not None:
                    for elem in diagrampoints.findall("data"):
                        time_entry = elem.find("time")
                        if time_entry is None:
                            time_entry = elem.find("stime")
                        if time_entry is None or time_entry.text is None:
                            last_timez = last_timez + 1
                            timez = last_timez
                        else:
                            timez = float(self.qmc.stringtoseconds(time_entry.text))
                            last_timez = timez
                        self.qmc.timex.append(timez)
                        self.qmc.temp1.append(-1)
                        temp_entry = elem.find("temperature")
                        if temp_entry is None:
                            temp_entry = elem.find("ntemperature")
                        bt = temp_entry.text
                        bt = bt.replace(",",".")
                        self.qmc.temp2.append(float(bt))
                        self.qmc.extratimex[0].append(timez)
                        burner_entry = elem.find("burnercapacity")
                        if burner_entry is None:
                            burner_entry = elem.find("nburnercapacity")
                        burner = burner_entry.text
                        burner = burner.replace(",",".")
                        self.qmc.extratemp1[0].append(float(burner))
                        self.qmc.extratemp2[0].append(-1)

                # set CHARGE and DROP
                self.qmc.timeindex[0] = 0
                self.qmc.timeindex[6] = len(self.qmc.timex) - 1
                    
                if recipedata is not None:
                    switchpoints = tree.find('recipedata/switchpoints')
                else:
                    switchpoints = tree.find('switchpoints')
                if switchpoints is not None:
                    for elem in switchpoints.findall("data"):
                        time_entry = elem.find("time")
                        if time_entry is None:
                            time_entry = elem.find("stime")
                        time = float(self.qmc.stringtoseconds(time_entry.text))
                        self.qmc.specialevents.append(self.qmc.time2index(time))
                        self.qmc.specialeventstype.append(3)
                        burner_entry = elem.find("burnercapacity")
                        if burner_entry is None:
                            burner_entry = elem.find("nburnercapacity")
                        self.qmc.specialeventsvalue.append(self.qmc.str2eventsvalue(burner_entry.text))
                        self.qmc.specialeventsStrings.append("")
                        
                aw.autoAdjustAxis()
                
                self.sendmessage(QApplication.translate("Message","Probat Pilot data imported successfully", None))
                self.qmc.redraw()
                aw.qmc.fileDirty()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " importPilot(): {0}").format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " importPilot(): {0}").format(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.sendmessage(QApplication.translate("Message","Import Probat Pilot failed", None))
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importPilot() {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importBullet(self,_=False):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import Aillio Roastime JSON", None))
            if len(filename) == 0:
                return
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            from json import load as json_load
            obj = json_load(infile)
            infile.close()
            if not self.qmc.reset():
                return
            self.qmc.celsiusMode()
            self.qmc.drumspeed = ""
            bt = obj["beanTemperature"]
            dt = obj["drumTemperature"]
            try:
                ex = obj["exitTemperature"]
            except:
                ex = None
            sr = obj["sampleRate"]
            tx = [x*1.0/sr for x in range(len(bt))]
            
            # add extra device if exitTemperatures are given and this extra device is not configured
            try:
                if ex is not None and ex != [] and aw.qmc.extraname1 != ['Exhaust'] and (len(aw.qmc.extraname2) < 2 or aw.qmc.extraname2[2] != "Exhaust"):
                    string = u(QApplication.translate("Message","To load this profile the extra devices configuration needs to be changed.\nContinue?", None))
                    reply = QMessageBox.question(aw,QApplication.translate("Message", "Found a different number of curves",None),string,QMessageBox.Yes|QMessageBox.Cancel)
                    if reply == QMessageBox.Yes:
                        if self.qmc.reset(redraw=False): # operation not canceled by the user in the save dirty state dialog
                            if len(self.qmc.extradevices) > 0:
                                aw.resetExtraDevices()
                            aw.addDevice()
                            aw.qmc.resetlinecountcaches()
                            aw.qmc.extraname1[0] = "Exhaust"
                            aw.extraCurveVisibility1[0] = toBool(True)
                            aw.extraCurveVisibility2[0] = toBool(False)
                            aw.extraDelta1[0] = toBool(False)
                            aw.extraDelta2[0] = toBool(False)
                            aw.extraFill1[0] = 0
                            aw.extraFill2[0] = 0
                        else:
                            return False
                    else:
                        return False
            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " importBullet(): {0}").format(str(e)),exc_tb.tb_lineno)

            if len(tx) == len(bt) == len(dt):
                self.qmc.roastertype = "Aillio Bullet R1"
                try:
                    self.qmc.operator = u(obj["roastMasterName"])
                except:
                    pass
                try:
                    d = obj["dateTime"] # RFC 3339 date time
                    self.qmc.roastdate = QDateTime.fromString(d,Qt.ISODate)
                except:
                    pass
                self.qmc.timex = tx
                self.qmc.temp1 = dt
                self.qmc.temp2 = bt
                
                # initialize all extra curves with -1
                for x in range(len(self.qmc.extradevices)):
                    self.qmc.extratimex[x] = tx
                    self.qmc.extratemp1[x] = [-1]*len(tx)
                    self.qmc.extratemp2[x] = [-1]*len(tx)

                # add exhaust data to first/third extra device
                if ex is not None and ex != [] and len(self.qmc.extradevices) > 0:
                    if len(aw.qmc.extraname2) >= 2 and aw.qmc.extraname2[2] == "Exhaust":
                        self.qmc.extratemp2[2] = ex
                    else:
                        self.qmc.extratemp1[0] = ex

                try:
                    self.qmc.title = obj["beanName"]
                except:
                    pass
                try:
                    self.qmc.beans = obj["bean"]["beanName"]
                except:
                    pass
                self.qmc.ground_color = int(round(obj["agtron"]))
                if "Agtron" in self.qmc.color_systems:
                    self.qmc.color_system_idx = self.qmc.color_systems.index("Agtron")
                else:
                    self.qmc.color_system_idx = 0
                wunit = self.qmc.weight_units.index(self.qmc.weight[2])
                if wunit in [1,3]: # turn Kg into g, and lb into oz
                    wunit = wunit -1
                self.qmc.weight = [obj["weightGreen"],obj["weightRoasted"],self.qmc.weight_units[wunit]]
                self.qmc.ambientTemp = obj["ambient"]
                self.qmc.ambient_humidity = obj["humidity"]
                self.qmc.roastingnotes = obj["comments"]
                self.qmc.roastbatchnr = obj["roastNumber"]
                
                dropIdx = 0
                if len(tx) > 0:
                    dropIdx = len(tx) - 1
                aw.qmc.timeindex = [0,0,0,0,0,0,dropIdx,0]
                labels = ["indexYellowingStart","indexFirstCrackStart","indexFirstCrackEnd","indexSecondCrackStart","indexSecondCrackEnd"]
                for i in range(1,6):
                    try:
                        idx = obj[labels[i-1]]
                        # RoastTime seems to interpret all index values 1 based, while Artisan takes the 0 based approach. We substruct 1
                        if idx > 1:
                            aw.qmc.timeindex[i] = idx - 1
                    except:
                        pass
                try:
                    for j in range(len(aw.qmc.timeindex)):
                        if aw.qmc.timeindex[j] >= len(tx):
                            aw.qmc.timeindex[j] = 0
                            aw.sendmessage(QApplication.translate("Message","Warning! Deleted an event that occurs after the end of profile.", None))
                except:
                    pass
                try:
                    eventtypes = ["blowerSetting","drumSpeedSetting","--","inductionPowerSetting"]
                    for j in range(len(eventtypes)):
                        eventname = eventtypes[j]
                        if eventname != "--":
                            last = None
                            ip = obj[eventname]
                            for i in range(len(ip)):
                                v = ip[i]+1
                                if last is None or last != v:
                                    aw.qmc.specialevents.append(i)
                                    aw.qmc.specialeventstype.append(j)
                                    aw.qmc.specialeventsvalue.append(v)
                                    aw.qmc.specialeventsStrings.append("")
                                    last = v
                    aw.orderEvents()
                except:
                    pass
                aw.autoAdjustAxis()
                self.qmc.redraw()
                aw.sendmessage(QApplication.translate("Message","Imported {0}", None).format(u(filename)))
            else:
                aw.sendmessage(QApplication.translate("Message","Unable to import. Inconsistent number of samples", None))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " self.importBullet(): {0}").format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " self.importBullet(): {0}").format(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " self.importBullet() {0}").format(str(ex)),exc_tb.tb_lineno)
    
    def importExternal(self,extractor,message,extension):
        try:
            filename = self.ArtisanOpenFileDialog(msg=message,ext=extension)
            if len(filename) == 0:
                return
            res = aw.qmc.reset(redraw=False,soundOn=False)
            if res:
                obj = extractor(filename)
                res = self.setProfile(filename,obj)

            if res:
                self.qmc.backmoveflag = 1 # this ensures that an already loaded profile gets aligned to the one just loading
                #update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                # profiles was adjusted, ensure that it does not overwrite the original file on saving
                self.qmc.fileDirty()
                self.curFile = None
                #Plot everything
                self.qmc.redraw()
                message = u(QApplication.translate("Message","{0}  imported ", None).format(u(filename)))
                self.sendmessage(message)

        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " {1}: {0}").format(str(ex),message))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " {1}: {0}").format(str(ex),message))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " {1} {0}").format(str(ex),message),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importCropster(self,_=False):
        self.importExternal(extractProfileCropsterXLS,QApplication.translate("Message","Import Cropster XLS", None),"*.xls")

    @pyqtSlot()
    @pyqtSlot(bool)
    def importGiesen(self,_=False):
        self.importExternal(extractProfileGiesenCSV,QApplication.translate("Message","Import Giesen CSV", None),"*.csv")

    @pyqtSlot()
    @pyqtSlot(bool)
    def importIkawa(self,_=False):
        self.importExternal(extractProfileIkawaCSV,QApplication.translate("Message","Import IKAWA CSV", None),"*.csv")

    @pyqtSlot()
    @pyqtSlot(bool)
    def importHH506RA(self,_=False):
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Import HH506RA CSV", None))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.ReadOnly):
                    raise IOError(str(f.errorString()))
                import csv
                import io
                csvFile = io.open(filename, 'r', encoding='utf-8')
                data = csv.reader(csvFile,delimiter='\t')
                #read file header
                header = next(data)
                zero = QDateTime()
                date = QDateTime(QDate.fromString(header[0].split('Date:')[1],"yyyy'/'MM'/'dd"))
                self.qmc.roastdate = date
                self.qmc.roastepoch = self.qmc.roastdate.toTime_t()
                self.qmc.roasttzoffset = 0
                zero.setDate(date)
                zero.setTime(QTime.fromString(header[1].split('Time:')[1],"hh':'mm':'ss"))
                zero_t = zero.toTime_t()
                #read column headers
                fields = next(data)
                unit = None
                #read data
                for row in data:
                    items = list(zip(fields, row))
                    item = {}
                    for (name, value) in items:
                        item[name] = value.strip()
                    #set temperature mode
                    if not unit:
                        unit = item['Unit']
                        if unit == "F" and self.qmc.mode == "C":
                            self.qmc.fahrenheitMode()
                        if unit == "C" and self.qmc.mode == "F":
                            self.qmc.celsiusMode()
                    #add one measurement
                    dt = QDateTime()
                    dt.setDate(QDate.fromString(item['Date'],"yyyy'/'MM'/'dd"))
                    dt.setTime(QTime.fromString(item['Time'],"hh':'mm':'ss"))
                    self.qmc.timex.append(float(dt.toTime_t() - zero_t))
                    self.qmc.temp1.append(float(item['T1']))
                    self.qmc.temp2.append(float(item['T2']))
                csvFile.close()
                #swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x,y:x + y, self.qmc.temp2)) > freduce(lambda x,y:x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                aw.autoAdjustAxis()
                self.sendmessage(QApplication.translate("Message","HH506RA file loaded successfully", None))
                self.qmc.redraw()
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " importHH506RA(): {0}").format(str(ex)))
        except ValueError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " importHH506RA(): {0}").format(str(ex)))
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importHH506RA() {0}").format(str(ex)),exc_tb.tb_lineno)

    #checks or creates directory structure
    def dirstruct(self):
        currentdir = QDir().current()     #selects the current dir
        if not currentdir.exists(QApplication.translate("Directory","profiles", None)):
            currentdir.mkdir(QApplication.translate("Directory","profiles",None))
        #check/create 'other' directory inside profiles/
        otherpath = u(QApplication.translate("Directory","profiles", None) + "/" + QApplication.translate("Directory","other", None))
        if not currentdir.exists(otherpath):
            currentdir.mkdir(otherpath)
        #find current year,month
        date =  QDate.currentDate()
        #check / create year dir 
        yearpath = u(QApplication.translate("Directory","profiles", None) + "/" + str(date.year()))
        if not currentdir.exists(yearpath):
            currentdir.mkdir(yearpath)
        #check /create month dir to store profiles
        monthpath = u(QApplication.translate("Directory","profiles", None) + "/" + str(date.year()) + "/" + str(date.month()))
        if not currentdir.exists(monthpath):
            currentdir.mkdir(monthpath)
        if len(self.profilepath) == 0:
            self.profilepath = monthpath

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1(self,_=False):
        self.resizeImg(0,1)
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_JPEG(self,_=False):
        self.resizeImg(0,1,"JPEG")
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_BMP(self,_=False):
        self.resizeImg(0,1,"BMP")
        
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_1200_1(self,_=False):
        self.resizeImg(1200,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_800_1(self,_=False):
        self.resizeImg(800,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_700_1(self,_=False):
        self.resizeImg(700,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_620_1(self,_=False):
        self.resizeImg(620,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_600_1(self,_=False):
        self.resizeImg(600,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_500_1(self,_=False):
        self.resizeImg(500,1)
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_SVG(self,_=False):
        self.saveVectorGraph(extension=".svg")
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_PDF(self,_=False):
        self.saveVectorGraph(extension=".pdf")
    
    #resizes and saves graph to a new width w 
    def resizeImg(self,w,transformationmode,filetype="PNG",fname=""):
        try:
            fileext = ".png"
            if filetype == "JPEG":
                fileext = ".jpg"
            elif filetype == "BMP":
                fileext = ".bmp"
            if fname == "" or fname is None:
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as", None) + filetype,ext="*"+fileext)
            else:
                filename = fname
            if filename:
                self.image = aw.qmc.grab()
                if w != 0:
                    self.image = self.image.scaledToWidth(w,transformationmode)
                
                if not filename.endswith(fileext):
                    filename += fileext
                    
                if filetype in ["JPEG","BMP"]:
                    # transparences are not supported by those file types and are rendered in black by default.
                    white_img = QPixmap(self.image.size())
                    white_img.fill() # fills by default with Qt.white
                    painter = QPainter(white_img)
                    painter.drawPixmap(0,0,self.image.width(),self.image.height(),self.image)
                    self.image = white_img
                    painter.end()
                    del painter
                self.image.save(filename,filetype)
                
                x = self.image.width()
                y = self.image.height()
                self.sendmessage(QApplication.translate("Message","{0}  size({1},{2}) saved", None).format(str(filename),str(x),str(y)))
            
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " resize() {0}").format(str(ex)))

    def saveVectorGraph(self,extension=".pdf",fname=""):
        try: 
            if fname == "" or fname is None:
                if extension == ".pdf":
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as PDF", None),ext=extension, path=fname)
                else:
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Graph as SVG", None),ext=extension, path=fname)
            else:
                filename = fname
            if filename:
                if extension not in filename:
                    filename += extension
                aw.qmc.fig.savefig(filename,transparent=(aw.qmc.palette["canvas"] is None or aw.qmc.palette["canvas"]=='None'),facecolor=str(aw.qmc.palette["canvas"]),edgecolor=None) # transparent=True is need to get the delta curves and legend drawn
                aw.qmc.updateBackground() # that redraw is needed to avoid the "transparent flicker"
                                
                self.sendmessage(QApplication.translate("Message","{0} saved", None).format(str(filename)))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " saveVectorGraph() {0}").format(str(ex)))

    #displays Dialog for the setting of the HUD
    @pyqtSlot()
    @pyqtSlot(bool)
    def hudset(self,_=False):
        hudDl = HUDDlg(self)
        hudDl.show()
        hudDl.setFixedSize(hudDl.size())

    def showHUDmetrics(self):
        if self.qmc.hudresizeflag:
            self.qmc.refreshHUD()
            self.qmc.hudresizeflag = False
        if len(self.qmc.temp2) > 1:  #Need this because viewProjections use rate of change (two values needed)
            ETreachTime,BTreachTime,ET2reachTime,BT2reachTime = self.qmc.getTargetTime()
            if ETreachTime > 0 and ETreachTime < 2000:
                text1 = u(QApplication.translate("Label","{0} to reach ET {1}", None).format(self.qmc.stringfromseconds(int(ETreachTime)),str(self.qmc.ETtarget) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text1 = text1 + u(QApplication.translate("Label"," at {0}", None).format(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ETreachTime))))
            else:
                text1 = u(QApplication.translate("Label","{0} to reach ET {1}", None).format("xx:xx",str(self.qmc.ETtarget) + self.qmc.mode))
            if ET2reachTime > 0 and ET2reachTime < 2000:
                text2 = u(QApplication.translate("Label","{0} to reach ET {1}", None).format(self.qmc.stringfromseconds(int(ET2reachTime)),str(self.qmc.ET2target) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text2 = text2 + u(QApplication.translate("Label"," at {0}", None).format(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+ET2reachTime))))
            else:
                text2 = u(QApplication.translate("Label","{0} to reach ET {1}", None).format("xx:xx",str(self.qmc.ET2target) + self.qmc.mode))
                
            if BTreachTime > 0 and BTreachTime < 2000:    
                text3 = u(QApplication.translate("Label","{0} to reach BT {1}", None).format(self.qmc.stringfromseconds(int(BTreachTime)),str(self.qmc.BTtarget) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text3 = text3 + u(QApplication.translate("Label"," at {0}", None).format(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BTreachTime))))
            else:
                text3 = u(QApplication.translate("Label","{0} to reach BT {1}", None).format("xx:xx",str(self.qmc.BTtarget) + self.qmc.mode))
            if BT2reachTime > 0 and BT2reachTime < 2000:
                text4 = u(QApplication.translate("Label","{0} to reach BT {1}", None).format(self.qmc.stringfromseconds(int(BT2reachTime)),str(self.qmc.BT2target) + self.qmc.mode))
                if self.qmc.timeindex[0] > -1:
                    text4 = text4 + u(QApplication.translate("Label"," at {0}", None).format(self.qmc.stringfromseconds(int(self.qmc.timex[-1] - self.qmc.timex[self.qmc.timeindex[0]]+BT2reachTime))))        
            else:
                text4 = u(QApplication.translate("Label","{0} to reach BT {1}", None).format("xx:xx",str(self.qmc.BT2target) + self.qmc.mode))
            ####  Phase Texts #####
            phasetext1 = "" # lower textline
            phasetext2 = "" # higher textline
            if self.qmc.timeindex[2]: # after FCs
                FCs_time = self.qmc.timex[self.qmc.timeindex[2]]
                if self.qmc.timeindex[6]: # after DROP
                    afterFCs = self.qmc.timex[self.qmc.timeindex[6]] - FCs_time
                else:
                    afterFCs = self.qmc.timex[-1] - FCs_time
                phasetext1 = u(QApplication.translate("Label","{0} after FCs", None).format(self.qmc.stringfromseconds(int(afterFCs))))
            if self.qmc.timeindex[3]: # after FCe
                FCe_time = self.qmc.timex[self.qmc.timeindex[3]]
                if self.qmc.timeindex[6]: # after DROP
                    afterFCe = self.qmc.timex[self.qmc.timeindex[6]] - FCe_time
                else:
                    afterFCe = self.qmc.timex[-1] - FCe_time
                phasetext2 = u(QApplication.translate("Label","{0} after FCe", None).format(self.qmc.stringfromseconds(int(afterFCe))))
                if self.qmc.timeindex[2]:
                    phasetext2 = phasetext2 + u(" (") + u(self.qmc.stringfromseconds(int(FCe_time - self.qmc.timex[self.qmc.timeindex[2]]))) + u(" FC)")
            ####   ET pid    ######
            error = self.qmc.ETtarget - self.qmc.temp1[-1]
            differror = error - self.qmc.pidpreviouserror
            difftime = self.qmc.timex[-1] - self.qmc.timex[-2]
            if not difftime: difftime = 0.01
            proportionalterm = self.qmc.hudETpid[0]*error
            integralterm = self.qmc.hudETpid[1]*differror*difftime
            derivativeterm = self.qmc.hudETpid[2]*differror/difftime
            self.qmc.pidpreviouserror = error
            MV = proportionalterm + integralterm + derivativeterm   # Manipulated Variable
            if MV > 100.:MV = 100.
            elif MV < 0.:MV = 0.
            MVV = int(round(MV))
            pidstring = "ET pid = %i "%MVV
            ##### end of ET pid
            img = self.qmc.grab()            
            Wwidth = self.qmc.size().width()
            Wheight = self.qmc.size().height()
            #Draw begins
            p = QPainter(img)
            p.setOpacity(0.8)
            p.setPen(QColor("slategrey"))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/4.5),u(text1))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/5.3),u(text2))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/6.6),u(text3))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/8.5),u(text4))
            #draw pid
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3),u(pidstring))
            p.drawRect(Wwidth/7+140, Wheight - Wheight/3-12, 100, 12)
            p.fillRect(Wwidth/7+140, Wheight - Wheight/3-12, MVV, 12, QColor("pink"))
            delta = u(QApplication.translate("Label","ET - BT = {0}", None).format("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1])))
            p.drawText(QPoint(Wwidth/7,Wheight - Wheight/3.5),u(delta))
            #draw phase texts
            p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/6),u(phasetext1))
            p.drawText(QPoint(Wwidth/2 + 100,Wheight - Wheight/8),u(phasetext2))
            p.end()
            self.HUD.setPixmap(img)

    def showHUDthermal(self):
        if self.qmc.hudresizeflag:
            self.qmc.refreshHUD()
            self.qmc.hudresizeflag = False
        if len(self.qmc.temp2) > 0:
            img = self.qmc.grab()
            p = QPainter(img)
            Wwidth= self.qmc.size().width()
            Wheight = self.qmc.size().height()
            p.setOpacity(1)
            p.setPen(QColor(96,255,237)) #color the rectangle the same as HUD button
            p.drawRect(10,10, Wwidth - 20, Wheight - 20)
            if self.qmc.mode == "F" and self.qmc.temp1:
                ETradius = int(self.qmc.temp1[-1]/3)
                BTradius = int(self.qmc.temp2[-1]/3)
            elif self.qmc.mode == "C" and self.qmc.temp1:
                ETradius = int(self.qmc.fromCtoF(self.qmc.temp1[-1]/3))
                BTradius = int(self.qmc.fromCtoF(self.qmc.temp2[-1]/3))
            else:
                ETradius = 50
                BTradius = 50
            Tradius = 300
            p.setOpacity(0.5)
            g = QRadialGradient(Wwidth/2, Wheight/2, ETradius)
            beanbright =  100 - ETradius
            if beanbright < 0: beanbright = 0
            g.setColorAt(0.0, QColor(240,255,beanbright))  #bean center
            g.setColorAt(.5, Qt.yellow)
            g.setColorAt(.8, Qt.red)
            g.setColorAt(1.,QColor("lightgrey"))
            p.setBrush(QBrush(g))
            #draw thermal circle
            p.setPen(0)
            p.drawEllipse(Wwidth/2 -Tradius/2 , Wheight/2 - Tradius/2 , Tradius,Tradius)
            #draw ET circle
            p.setBrush(0)
            p.setPen(QColor("black"))
            p.drawEllipse(Wwidth/2 -ETradius/2 , Wheight/2 - ETradius/2 , ETradius,ETradius)
            #draw BT circle
            p.drawEllipse(Wwidth/2 -BTradius/2 , Wheight/2 - BTradius/2 , BTradius,BTradius)
            delta = QApplication.translate("Label","ET - BT = {0}{1}", None).format("%.1f"%(self.qmc.temp1[-1] - self.qmc.temp2[-1]),self.qmc.mode)
            p.setFont(QFont('Utopia', 14, -1))
            p.drawText(QPoint(Wwidth/2,Wheight/2),u(delta))
            p.end()
            self.HUD.setPixmap(img)

    #used by WheelGraphDlg()
    #wrap values in unicode(.) if and only if those are of type string
    def getWheelGraph(self):
        wheel = {}
        #convert labels to unicode
        for i in range(len(self.qmc.wheelnames)):
            for x in range(len(self.qmc.wheelnames[i])):
                self.qmc.wheelnames[i][x]= u(self.qmc.wheelnames[i][x])
        #two dimension lists
        wheel["wheelnames"] = self.qmc.wheelnames
        wheel["segmentlengths"] = self.qmc.segmentlengths
        wheel["segmentsalpha"] = self.qmc.segmentsalpha
        wheel["wradii"] = self.qmc.wradii
        wheel["startangle"] = self.qmc.startangle
        wheel["projection"] = self.qmc.projection
        wheel["wheeltextsize"] = self.qmc.wheeltextsize 
        wheel["wheelcolor"] = self.qmc.wheelcolor
        wheel["wheelparent"] = self.qmc.wheellabelparent
        wheel["wheeledge"] = self.qmc.wheeledge
        wheel["wheellinewidth"] = self.qmc.wheellinewidth
        wheel["wheellinecolor"] = self.qmc.wheellinecolor
        wheel["wheeltextcolor"] = self.qmc.wheeltextcolor
        wheel["wheelaspect"] = self.qmc.wheelaspect
        return wheel

    def loadWheel(self,filename):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                wheel = self.deserialize(filename)
                self.qmc.wheelnames = wheel["wheelnames"]
                self.qmc.segmentlengths = wheel["segmentlengths"]
                self.qmc.segmentsalpha = wheel["segmentsalpha"]
                self.qmc.wradii = wheel["wradii"]
                self.qmc.startangle = wheel["startangle"]
                self.qmc.projection = wheel["projection"]
                self.qmc.wheeltextsize = wheel["wheeltextsize"] 
                self.qmc.wheelcolor = wheel["wheelcolor"]
                self.qmc.wheellabelparent = wheel["wheelparent"]
                self.qmc.wheeledge = wheel["wheeledge"]
                self.qmc.wheellinewidth = wheel["wheellinewidth"]
                self.qmc.wheellinecolor = wheel["wheellinecolor"]
                if "wheeltextcolor" in wheel:
                    self.qmc.wheeltextcolor = wheel["wheeltextcolor"]
                if "wheelaspect" in wheel:
                    self.qmc.wheelaspect = wheel["wheelaspect"]
                else:
                    self.qmc.wheelaspect = 1.0
                message =QApplication.translate("Message","Wheel {0} loaded", None).format(str(filename))
                self.sendmessage(message)
            else:
                message = QApplication.translate("Message","Invalid Wheel graph format", None)
                self.sendmessage(message)
                return
#            message =QApplication.translate("Message","Wheel Graph openend succesfully", None)
#            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " loadWheel() {0}").format(str(ex)),exc_tb.tb_lineno)
            return
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Value Error:", None) + " loadWheel() {0}").format(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None) + " loadWheel() {0}").format(str(ex)),exc_tb.tb_lineno)
            return
        finally:
            if f:
                f.close()
    
    def standardButtonsVisibility(self):
        if aw.lowerbuttondialog.isVisible():
            aw.lowerbuttondialog.setVisible(False)
            aw.messagelabel.setVisible(False)
        else:
            aw.lowerbuttondialog.setVisible(True)
            aw.messagelabel.setVisible(True)

    def toggleextraeventrows(self):
        if aw.extrabuttondialogs.isVisible():
            aw.hideExtraButtons()
        else:
            aw.showExtraButtons()

    def clearBoxLayout(self,layout):
        while layout.count(): 
            item = layout.takeAt(0)
            widget = item.widget() 
            if widget is not None: 
                widget.deleteLater()
                         
    #orders extra event buttons based on max number of buttons
    def realignbuttons(self):
        #clear buttons
        self.clearBoxLayout(self.e1buttonbarLayout)
        self.clearBoxLayout(self.e2buttonbarLayout)
        self.clearBoxLayout(self.e3buttonbarLayout)
        self.clearBoxLayout(self.e4buttonbarLayout)
        
        self.extraeventbuttonround = []

        self.buttonlist = []
        self.buttonStates = []
        #hide all extra button rows
        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)

        row1count = 0
        row2count = 0
        row3count = 0
        row4count = 0
        
        for i in range(len(self.extraeventstypes)):
            
            # next button in this group is hidden
            next_hidden = (i%self.buttonlistmaxlen < self.buttonlistmaxlen -1 and  # at least one more places in the group 
                    i+1 < len(self.extraeventstypes) and # there is one more button
                    not self.extraeventsvisibility[i+1]) # and the next one is hidden
            # previous button in this group is hidden
            prev_hidden = (i%self.buttonlistmaxlen > 0 and # at least one previous place in this group
                    i > 0 and # there is more than one button in total
                    not self.extraeventsvisibility[i-1]) # and the previous one is hidden

            if (i%self.buttonlistmaxlen) == 0: # left-most button in the row
                if i == len(self.extraeventstypes)-1 or next_hidden:
                    # a singleton button in a one element bar
                    self.extraeventbuttonround.append(3)
                else:
                    # the left-most button in this bar
                    self.extraeventbuttonround.append(1)
            elif ((i%self.buttonlistmaxlen) < self.buttonlistmaxlen-1) and i != len(self.extraeventstypes)-1:
                # a button in the middle of this bar
                if prev_hidden and next_hidden:
                    # we round both sides
                    self.extraeventbuttonround.append(3)
                elif prev_hidden:
                    # we start a new rounded-group
                    self.extraeventbuttonround.append(1)
                elif next_hidden:
                    self.extraeventbuttonround.append(2)
                else:
                    # squared button
                    self.extraeventbuttonround.append(0)
            else:
                # the right-most button in this bar
                if prev_hidden:
                    self.extraeventbuttonround.append(3)
                else:
                    self.extraeventbuttonround.append(2)

            p = QPushButton()
            p.setAutoDefault(False)
            p.setStyleSheet(self.extraEventButtonStyle(i))
            p.setMinimumHeight([self.standard_button_tiny_height,self.standard_button_small_height,self.standard_button_height][aw.buttonsize])
            
            p.setCursor(QCursor(Qt.PointingHandCursor))
            
            l = self.extraeventslabels[i]
            # event type et
            et = self.extraeventstypes[i]
            if et > 4:
                et = et - 5
            if et < 4:
                l = l.replace("\\t",self.qmc.etypes[et])
            p.setText(l)
            p.setFocusPolicy(Qt.NoFocus)
            p.clicked.connect(self.recordextraevent_slot)
            self.buttonlist.append(p)
            self.buttonStates.append(0)
            #add button to row
            if row1count < self.buttonlistmaxlen:
                self.e1buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e1buttonbarLayout.addSpacing(5)
                row1count += 1
            elif row2count < self.buttonlistmaxlen:
                self.e2buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e2buttonbarLayout.addSpacing(5)
                row2count += 1
            elif row3count < self.buttonlistmaxlen:
                self.e3buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e3buttonbarLayout.addSpacing(5)
                row3count += 1
            else:
                self.e4buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e4buttonbarLayout.addSpacing(5)
                row4count += 1
        if self.e1buttonbarLayout.count() > 0:
            self.e1buttondialog.setVisible(True)
            self.e1buttonbarLayout.insertStretch(0)
            self.e1buttonbarLayout.insertStretch(self.e1buttonbarLayout.count())
        if self.e2buttonbarLayout.count() > 0:
            self.e2buttondialog.setVisible(True)
            self.e2buttonbarLayout.insertStretch(0)
            self.e2buttonbarLayout.insertStretch(self.e2buttonbarLayout.count())
        if self.e3buttonbarLayout.count() > 0:
            self.e3buttondialog.setVisible(True)
            self.e3buttonbarLayout.insertStretch(0)
            self.e3buttonbarLayout.insertStretch(self.e3buttonbarLayout.count())
        if self.e4buttonbarLayout.count() > 0:
            self.e4buttondialog.setVisible(True)
            self.e4buttonbarLayout.insertStretch(0)
            self.e4buttonbarLayout.insertStretch(self.e4buttonbarLayout.count())
        self.settooltip()
        aw.buttonsAction.setEnabled(bool(len(aw.extraeventslabels) > 0))
        if app.artisanviewerMode:
            aw.buttonsAction.setEnabled(False)
        self.update_extraeventbuttons_visibility()

    #assigns tooltips to extra event buttons
    def settooltip(self):
        for i in range(len(self.buttonlist)):
            try:
                tip = u(QApplication.translate("Tooltip","<b>Label</b>= ", None)) + u(self.extraeventslabels[i]) + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Description </b>= ", None)) + u(self.extraeventsdescriptions[i]) + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Type </b>= ", None)) + u(self.qmc.etypesf(self.extraeventstypes[i])) + "<br>"
                if self.extraeventstypes[i] != 4: # no tips for 4: no event type set
                    tip += u(QApplication.translate("Tooltip","<b>Value </b>= ", None)) + u(aw.qmc.eventsvalues(self.extraeventsvalues[i])) + "<br>"
                    #+ u(int(round((self.extraeventsvalues[i]-1)*10.)))  + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Documentation </b>= ", None)) + u(self.extraeventsactionstrings[i]) + "<br>"
                tip += u(QApplication.translate("Tooltip","<b>Button# </b>= ", None)) + str(i+1)
                self.buttonlist[i].setToolTip(tip)
            except:
                pass

    def update_extraeventbuttons_visibility(self):
        for i in range(len(self.buttonlist)):
            try:
                if self.extraeventsvisibility[i]:
                    self.buttonlist[i].setVisible(True)
                else:
                    self.buttonlist[i].setVisible(False)
            except:
                pass

    #transfers current buttons to a palette number
    def transferbuttonsto(self,pindex):
        copy = []
        copy.append(self.extraeventstypes[:])
        copy.append(self.extraeventsvalues[:])
        copy.append(self.extraeventsactions[:])
        copy.append(self.extraeventsvisibility[:])
        copy.append(self.extraeventsactionstrings[:])
        copy.append(self.extraeventslabels[:])
        copy.append(self.extraeventsdescriptions[:])
        copy.append(self.extraeventbuttoncolor[:])
        copy.append(self.extraeventbuttontextcolor[:])
        # added slider settings
        copy.append(self.eventslidervisibilities[:])
        copy.append(self.eventslideractions[:])
        copy.append(self.eventslidercommands[:])
        copy.append(self.eventslideroffsets[:])
        copy.append(self.eventsliderfactors[:])
        # added quantifier settings
        copy.append(self.eventquantifieractive[:])
        copy.append(self.eventquantifiersource[:])
        copy.append(self.eventquantifiermin[:])
        copy.append(self.eventquantifiermax[:])
        copy.append(self.eventquantifiercoarse[:])
        # added slider min/max
        copy.append(self.eventslidermin[:])
        copy.append(self.eventslidermax[:])
        # added slider coarse
        copy.append(self.eventslidercoarse[:])
        # added slider temp
        copy.append(self.eventslidertemp[:])
        # added slider unit
        copy.append(self.eventsliderunits[:])
              
        self.buttonpalette[pindex] = copy[:]
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen
        self.sendmessage(QApplication.translate("Message","Buttons copied to Palette #%i"%(pindex), None))

    #restores a palette number to current buttons
    def setbuttonsfrom(self,pindex):
        copy = self.buttonpalette[pindex][:]
        if len(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            # added slider settings
            if len(copy)>9 and len(copy[9]) == 4:
                self.eventslidervisibilities = copy[9][:]
            else:
                self.eventslidervisibilities = [0,0,0,0]
            if len(copy)>10 and len(copy[10]) == 4:
                self.eventslideractions = copy[10][:]
            else:
                self.eventslideractions = [0,0,0,0]
            if len(copy)>11 and len(copy[11]) == 4:
                self.eventslidercommands = copy[11][:]
            else:
                self.eventslidercommands = ["","","",""]
            if len(copy)>12 and len(copy[12]) == 4:
                self.eventslideroffsets = copy[12][:]
            else:
                self.eventslideroffsets = [0,0,0,0]
            if len(copy)>13 and len(copy[13]) == 4:
                self.eventsliderfactors = copy[13][:]
            else:
                self.eventsliderfactors = [1.0,1.0,1.0,1.0]
                
            if len(copy)>14 and len(copy[14]) == 4:
                self.eventquantifieractive = copy[14][:]
            else:
                self.eventquantifieractive = [0,0,0,0]
            if len(copy)>15 and len(copy[15]) == 4:
                self.eventquantifiersource = copy[15][:]
            else:
                self.eventquantifiersource = [0,0,0,0]
            if len(copy)>16 and len(copy[16]) == 4:
                self.eventquantifiermin = copy[16][:]
            else:
                self.eventquantifiermin = [0,0,0,0]
            if len(copy)>17 and len(copy[17]) == 4:
                self.eventquantifiermax = copy[17][:]
            else:
                self.eventquantifiermax = [100,100,100,100]
            if len(copy)>18 and len(copy[18]) == 4:
                self.eventquantifiercoarse = copy[18][:]
            else:
                self.eventquantifiercoarse = [0,0,0,0]
            if len(copy)>19 and len(copy[19]) == 4:
                self.eventslidermin = copy[19][:]
            else:
                self.eventslidermin = [0,0,0,0]
            if len(copy)>20 and len(copy[20]) == 4:
                self.eventslidermax = copy[20][:]
            else:
                self.eventslidermax = [100,100,100,100]
            if len(copy)>21 and len(copy[21]) == 4:
                self.eventslidercoarse = copy[21][:]
            else:
                self.eventslidercoarse = [0,0,0,0]
            if len(copy)>22 and len(copy[22]) == 4:
                self.eventslidertemp = copy[22][:]
            else:
                self.eventslidertemp = [0,0,0,0]
            if len(copy)>23 and len(copy[23]) == 4:
                self.eventsliderunits = copy[23][:]
            else:
                self.eventsliderunits = ["","","",""]
                
            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            self.realignbuttons()
            self.updateSlidersProperties()
            self.lastbuttonpressed = -1
            self.sendmessage(QApplication.translate("Message","Palette #%i restored"%(pindex), None))
            return 1  #success
        else:
            self.sendmessage(QApplication.translate("Message","Palette #%i empty"%(pindex), None))
            return 0  #failed

    def encodeTreeStrings(self,tree):
        return self.mapTree(tree,encodeLocal)
  
    def decodeTreeStrings(self,tree):
        return self.mapTree(tree,d)

    def mapTree(self,tree,f):
        if isinstance(tree,(list,tuple)):
            return [self.mapTree(e,f) for e in tree]
        elif stringp(tree):
            return f(tree)
        else:
            return tree

    def backuppaletteeventbuttons(self,pal,maxlen):
        palette = {}
        #convert labels to unicode
        for i in range(len(pal)):
            key = str(i)
            palette[key] = self.encodeTreeStrings(pal[i])
        palette["maxlen"] = maxlen
        try:
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Palettes",None),ext="*.apal") 
            if filename:
                #write
                self.serialize(filename,palette)
                self.sendmessage(QApplication.translate("Message","Palettes saved",None))
        except IOError as ex:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None) + " backuppaletteeventbuttons(): {0}").format(str(ex)))
            return

    def getPalettes(self,filename,pal):
        maxlen = self.loadPalettes(filename,pal)
        if maxlen is not None:
            self.buttonpalettemaxlen = maxlen

    def loadPalettes(self,filename,pal):
        try:
            f = QFile(u(filename))
            if not f.open(QIODevice.ReadOnly):
                raise IOError(u(f.errorString()))
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == "{":
                f.close()
                palette = self.deserialize(filename)
                buttonpalettemaxlen = list(map(int,palette["maxlen"]))
                for i in range(10):  #10 palettes (0-9)
                    key = str(i)
                    nextpalette = [[], [], [], [], [], [], [], [], [], [], [], [], [], []]
                    palette[key] = self.decodeTreeStrings(palette[key])
                    if len(palette[key]):
                        for x in range(9):
                            if x < 4:
                                if x == 1:
                                    nextpalette[x] = list(map(float,palette[key][x]))     #  type double
                                else:
                                    nextpalette[x] = list(map(int,palette[key][x]))     #  type int
                            else:
                                nextpalette[x] = list(map(u,palette[key][x])) #  type unicode
                        # read in extended palette data containing slider settings:
                        if len(palette[key])==14:
                            nextpalette[9] = list(map(int,palette[key][9]))     #  type int
                            nextpalette[10] = list(map(int,palette[key][10]))   #  type int
                            nextpalette[11] = list(map(u,palette[key][11]))     #  type unicode
                            nextpalette[12] = list(map(int,palette[key][12]))   #  type int
                            nextpalette[13] = list(map(float,palette[key][13])) #  type double
                        else:
                            for k in range(9,14):
                                if len(pal[i]) == k+1:
                                    nextpalette[k] = pal[i][k]

                        if len(palette[key])==21:
                            nextpalette[14] = list(map(int,palette[key][14]))     #  type int
                            nextpalette[15] = list(map(int,palette[key][15]))     #  type int
                            nextpalette[16] = list(map(int,palette[key][16]))     #  type int
                            nextpalette[17] = list(map(int,palette[key][17]))     #  type int
                            nextpalette[18] = list(map(int,palette[key][18]))     #  type int
                            nextpalette[19] = list(map(int,palette[key][19]))     #  type int
                            nextpalette[20] = list(map(int,palette[key][20]))     #  type int
                        else:
                            for k in range(14,21):
                                if len(pal[i]) == k+1:
                                    nextpalette[k] = pal[i][k]
                                
                    pal[i] = nextpalette[:]
                return buttonpalettemaxlen
            else:
                message = QApplication.translate("Message","Invalid palettes file format", None)
                self.sendmessage(message)
                return None
            message =QApplication.translate("Message","Palettes loaded", None)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " loadPalettes() {0}").format(str(ex)),exc_tb.tb_lineno)
            return None
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None) + " loadPalettes() {0}").format(str(ex)),exc_tb.tb_lineno)
            return None

    def restorepaletteeventbuttons(self,pal):
        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Palettes",None),path=self.profilepath)
        if filename:
            self.getPalettes(filename,pal)

    def loadAlarms(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            from json import load as json_load
            alarms = json_load(infile)
            infile.close()
            aw.qmc.alarmflag = alarms["alarmflags"]
            aw.qmc.alarmguard = alarms["alarmguards"]
            aw.qmc.alarmnegguard = alarms["alarmnegguards"]
            aw.qmc.alarmtime = alarms["alarmtimes"]
            aw.qmc.alarmoffset = alarms["alarmoffsets"]
            aw.qmc.alarmcond = alarms["alarmconds"]
            aw.qmc.alarmsource = alarms["alarmsources"]
            aw.qmc.alarmtemperature = alarms["alarmtemperatures"]
            aw.qmc.alarmaction = alarms["alarmactions"]
            aw.qmc.alarmbeep = alarms["alarmbeep"]
            aw.qmc.alarmstrings = alarms["alarmstrings"]
            message =QApplication.translate("Message","Alarms loaded", None)
            self.sendmessage(message)
        except IOError as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:", None) + " loadAlarms() {0}").format(str(ex)),exc_tb.tb_lineno)
            return
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()  
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:", None) + " loadAlarms() {0}").format(str(ex)),exc_tb.tb_lineno)
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesALL(self,_=False):
        self.analysisfitCurves(-1)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesLN(self,_=False):
        self.analysisfitCurves(0)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX2(self,_=False):
        self.analysisfitCurves(2)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX3(self,_=False):
        self.analysisfitCurves(3)
    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesBkgnd(self,_=False):
        self.analysisfitCurves(4)
    @pyqtSlot()
    @pyqtSlot(bool)
    def clearResults(self,_=False):
        aw.qmc.redraw(recomputeAllDeltas=True)
    
    def analysisfitCurves(self, exp=-1):
        # exp == 0 -> ln(), 1 -> unused, 2 -> quadratic, 3 -> cubic, 4 -> bkgnd, -1 -> all of 0,2,and 3 
        #check for finished roast
        if not (self.qmc.timeindex[0] > -1 and self.qmc.timeindex[6]):
            self.sendmessage(QApplication.translate("Error Message", "Analyze: no profile data available", None))
            return

        #Save the background annotations setting and then disable
        orig_backgroundDetails = self.qmc.backgroundDetails
        self.qmc.backgroundDetails = False
        
        #prevent accidental overwrite of the original file 
        self.qmc.fileDirty()
        self.curFile = None
                    
        # initialize progress dialog
        progress = QProgressDialog(QApplication.translate("Message", "Fitting curves...",None), None, 0, 3, self)
        progress.setCancelButton(None)
        progress.setWindowModality(Qt.WindowModal)
        progress.setAutoClose(True)
        progress.show()
        QApplication.processEvents()

        try:
            #initialize the results
            resultstr = ""

            #run all analysis in celsius
            if aw.qmc.mode == "F":
                restoreF = True
                self.qmc.convertTemperature("C", silent=True, setdefaultaxes=False)
                self.analysisRecomputeDeltas()
            else:
                restoreF = False

            chargetime = aw.qmc.timex[aw.qmc.timeindex[0]]
            
            #drytime is either the DRY event or as set in the Phases dialog
            if self.qmc.timeindex[1]:  
                #use the DRY event
                drytime = self.qmc.timex[self.qmc.timeindex[1] -1] #one sample before DE
            else:
                #use the phases dialog value
                i = self.findDryEnd(phasesindex=1)
                drytime = self.qmc.timex[i -1]  #one sample before DE
                
            #fcstime is either the FCs event or as set in the Phases dialog
            #NOTE - if phases time is used the deltaRoR @FCs will return zeros.
            if self.qmc.timeindex[2]:  
                #use the FCS event
                fcstime = self.qmc.timex[self.qmc.timeindex[2]]
            else:
                #use the phases dialog value
                i = self.findDryEnd(phasesindex=2)
                fcstime = self.qmc.timex[i]

            # set the interval of interest
            if self.qmc.analysisstartchoice == 1:   #120 sec before FCs
                analysis_starttime = fcstime - 120
            elif self.qmc.analysisstartchoice == 2: #Custom
                analysis_starttime = self.qmc.analysisoffset + chargetime
            else:                                   #DRY END
                analysis_starttime = drytime
            analysis_endtime = aw.qmc.timex[aw.qmc.timeindex[6]]

            # set the curve fit time
            if self.qmc.curvefitstartchoice == 1:   #120 sec before FCs
                curvefit_starttime = fcstime - 120
            elif self.qmc.curvefitstartchoice == 2: #Custom
                curvefit_starttime = self.qmc.curvefitoffset + chargetime
            else:
                curvefit_starttime = drytime
            curvefit_endtime = aw.qmc.timex[aw.qmc.timeindex[6]]

            # natural log needs a curve fit point sometime earlier than drytime.  Pick one after TP if it exists. Otherwise after CHARGE.
            tpidx = self.findTP()
            if tpidx > 1:
                tptime = self.qmc.timex[tpidx]
                curvefit_starttime_ln = .25 * (drytime - tptime) + tptime
            else:
                curvefit_starttime_ln = .33 * (drytime - chargetime) + chargetime

            # Parameters to curve fit the profile to the existing background.  Respects the background alignment set in the Background Dialog.
            if exp == 4:
                #check for finished background roast
                if not aw.qmc.background:
                    self.sendmessage(QApplication.translate("Error Message", "Analyze: no background profile data available", None))
                    return
                if not (self.qmc.timeindexB[0] > -1 and self.qmc.timeindexB[6]):
                    self.sendmessage(QApplication.translate("Error Message", "Analyze: background profile requires CHARGE and DROP events", None))
                    return

                # set curvefit_starttime to match analysis_starttime
                curvefit_starttime = analysis_starttime
                # set curvefit_starttime analysis_endtime to the earlier of DROP or background DROP 
                droptime = aw.qmc.timex[aw.qmc.timeindex[6]]
                droptimeB = aw.qmc.timeB[aw.qmc.timeindexB[6]]
                if droptime > droptimeB:
                    curvefit_endtime = droptimeB
                    analysis_endtime = droptimeB

            # curve fit results
            self.cfr = {} #use dict to allow more flexible expansion

            # background
            if exp == 4:
                res = self.analysisGetResults(exp=4, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                self.cfr["equ_background"] = QApplication.translate("Label","Bkgd",None)
                self.cfr["dbt_background"] = res["mse_BT"]
                self.cfr["dbdbt_background"] = res["mse_deltaBT"]
                self.cfr["r2_deltabt_background"] = res["r2_deltaBT"]
                self.cfr['ror_fcs_delta_background'] = res['ror_fcs_delta']
                self.cfr['ror_max_delta_background'] = res['ror_max_delta']
                self.cfr['ror_min_delta_background'] = res['ror_min_delta']
                self.cfr['ror_maxmin_delta_background'] = ("%4.1f%s%4.1f") % (res['ror_max_delta'], "/", res['ror_min_delta'])
                progress.setValue(3)
            # ln() or all
            if exp == 0 or exp == -1:
                res = self.analysisGetResults(exp=0, curvefit_starttime=curvefit_starttime_ln, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                self.cfr["equ_naturallog"] = res["equ"]
                self.cfr["dbt_naturallog"] = res["mse_BT"]
                self.cfr["dbdbt_naturallog"] = res["mse_deltaBT"]
                self.cfr["r2_deltabt_naturallog"] = res["r2_deltaBT"]
                self.cfr['ror_fcs_delta_naturallog'] = res['ror_fcs_delta']
                self.cfr['ror_max_delta_naturallog'] = res['ror_max_delta']
                self.cfr['ror_min_delta_naturallog'] = res['ror_min_delta']
                self.cfr['ror_maxmin_delta_naturallog'] = ("%4.1f%s%4.1f") % (res['ror_max_delta'], "/", res['ror_min_delta'])
                progress.setValue(1 if exp == -1 else 3)
            # cubic or all
            if exp == 3 or exp == -1:
                res = self.analysisGetResults(exp=3, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                self.cfr["equ_cubic"] = res["equ"]
                self.cfr["dbt_cubic"] = res["mse_BT"]
                self.cfr["dbdbt_cubic"] = res["mse_deltaBT"]
                self.cfr["r2_deltabt_cubic"] = res["r2_deltaBT"]
                self.cfr['ror_fcs_delta_cubic'] = res['ror_fcs_delta']
                self.cfr['ror_max_delta_cubic'] = res['ror_max_delta']
                self.cfr['ror_min_delta_cubic'] = res['ror_min_delta']
                self.cfr['ror_maxmin_delta_cubic'] = ("%4.1f%s%4.1f") % (res['ror_max_delta'], "/", res['ror_min_delta'])
                progress.setValue(2 if exp == -1 else 3)
            # quadratic or all
            if exp == 2 or exp == -1:
                res = self.analysisGetResults(exp=2, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)
                self.cfr["equ_quadratic"] = res["equ"]
                self.cfr["dbt_quadratic"] = res["mse_BT"]
                self.cfr["dbdbt_quadratic"] = res["mse_deltaBT"]
                self.cfr["r2_deltabt_quadratic"] = res["r2_deltaBT"]
                self.cfr['ror_fcs_delta_quadratic'] = res['ror_fcs_delta']
                self.cfr['ror_max_delta_quadratic'] = res['ror_max_delta']
                self.cfr['ror_min_delta_quadratic'] = res['ror_min_delta']
                self.cfr['ror_maxmin_delta_quadratic'] = ("%4.1f%s%4.1f") % (res['ror_max_delta'], "/", res['ror_min_delta'])
                progress.setValue(3)
            
            # build the results table
            tbl = prettytable.PrettyTable()
            tbl.field_names = [" ", 
                               QApplication.translate("Label","MSE BT",None), 
                               QApplication.translate("Label","RoR",None) +  " \u0394 " + QApplication.translate("Label","@FCs",None),
                               QApplication.translate("Label","Max+/Max- RoR",None) + " \u0394"] 
            tbl.float_format = "5.2"
            if "equ_background" in self.cfr:
                tbl.add_row([QApplication.translate("Label","Bkgnd",None), self.cfr["dbt_background"], self.cfr['ror_fcs_delta_background'], self.cfr['ror_maxmin_delta_background']])
            if "equ_quadratic" in self.cfr:
                tbl.add_row([QApplication.translate("Label","x",None) +"\u00b2", self.cfr["dbt_quadratic"], self.cfr['ror_fcs_delta_quadratic'], self.cfr['ror_maxmin_delta_quadratic']])
            if "equ_cubic" in self.cfr:
                tbl.add_row([QApplication.translate("Label","x",None) + "\u00b3", self.cfr["dbt_cubic"], self.cfr['ror_fcs_delta_cubic'], self.cfr['ror_maxmin_delta_cubic']])
            if "equ_naturallog" in self.cfr:
                tbl.add_row([QApplication.translate("Label","ln()",None), self.cfr["dbt_naturallog"], self.cfr['ror_fcs_delta_naturallog'], self.cfr['ror_maxmin_delta_naturallog']])
            resultstr = "Curve Fit Analysis\n"
            resultstr += tbl.get_string(sortby="MSE BT")
            
            self.cfr['segmentresultstr'] = res['segmentresultstr'] 
            
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " analysisfitCurves(): {0}").format(str(e)),exc_tb.tb_lineno)

        try:
            # convert back to Fahrenheit if the profile was converted to Celsius
            if restoreF:
                self.qmc.convertTemperature("F", silent=True, setdefaultaxes=False)
                self.analysisRecomputeDeltas()

            # create the results annotation and update the graph
            if len(resultstr) > 0:
                self.analysisShowResults(resultstr, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " analysisfitCurves(): {0}").format(str(e)),exc_tb.tb_lineno)

        progress.cancel()
        progress = None
        #restore the background annotations setting
        self.qmc.backgroundDetails = orig_backgroundDetails
    
    # returns True as first result if draggable text box artist is contained in the given events region and
    # and it is the one in the region with the highest z-order, otherwise False
    # a dict of properties is returned as second argument
    def draggable_text_box_picker(self,artist, evt):
        if self.segmentresultsanno is not None and self.analysisresultsanno is not None:
            # in case the analyzer boxes are displayed
            seg_contained,seg_prop = self.segmentresultsanno.contains(evt)
            ana_contained,ana_prop = self.analysisresultsanno.contains(evt)
            segment_zorder = self.segmentresultsanno.get_zorder()
            analysis_zorder = self.analysisresultsanno.get_zorder()
            if artist == self.segmentresultsanno:
                if  seg_contained and (not ana_contained or segment_zorder > analysis_zorder):
                    # a click on the segmentresult box, but not on the analysisresult box, or the segment box is in front
                    # ensure that the z-order of the segment box is higher than that of the analysis box as the bitblit brings the segment box to the front
                    self.segmentresultsanno.set_zorder(max(segment_zorder,analysis_zorder))
                    self.analysisresultsanno.set_zorder(min(segment_zorder,analysis_zorder))
                    return True, seg_prop
                else:
                    # no click on the the segment box, or the anlysis box is clicked too and in front
                    return False, {}
            elif artist == self.analysisresultsanno:
                if ana_contained and (not seg_contained or segment_zorder < analysis_zorder):
                    # a click on the analysisresult box, but not on the segmentresult box, or the analyzer box is in front
                    # ensure that the z-order of the analyse box is higher than that of the segment box as the bitblit brings the segment box to the front
                    self.segmentresultsanno.set_zorder(min(segment_zorder,analysis_zorder))
                    self.analysisresultsanno.set_zorder(max(segment_zorder,analysis_zorder))
                    return True, ana_prop
                else:
                    # no click on the the analysis box, or the segment box is clicked too and in front
                    return False, {}
            elif not seg_contained and not ana_contained:
                # neither of the two analyzer boxes was clicked, check the given artist is contained in the event region
                return artist.contains(evt)
            else:
                # one of the two analyzer boxes was clicked, we ignore all other artists that might be contained in the events region
                return False, {}
        else:
            # if analyzer boxes are not available we call the standard picker
            return artist.contains(evt)

    def analysisShowResults(self,resultstr="",redraw=True, curvefit_starttime=0, curvefit_endtime=0, analysis_starttime=0, analysis_endtime=0):
        if redraw:
            self.qmc.redraw(recomputeAllDeltas=True)
        if len(resultstr) == 0:
            resultstr = self.qmc.analysisresultsstr
        else:
            self.qmc.analysisresultsstr = resultstr
        try:
            # draw analysis mask
            a = aw.qmc.alpha["analysismask"]/2
            fc = aw.qmc.palette["analysismask"]
            z = 20
            self.qmc.ax.axvspan(aw.qmc.ax.get_xlim()[0], curvefit_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_endtime, aw.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0.975, ymax=1.00,  facecolor=fc, alpha=a, zorder=z)
            
            self.qmc.ax.axvspan(aw.qmc.ax.get_xlim()[0], analysis_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_endtime, aw.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0.975, ymax=1.00,  facecolor=fc, alpha=a, zorder=z)

            # show warning if the analysis starts earlier than curve fit
            if curvefit_starttime > analysis_starttime:
                string = QApplication.translate("Message","Warning: The start of the analysis interval of interest is earlier than the start of curve fitting.\nCorrect this on the Config>Curves>Analyze tab.", None)
                QMessageBox.warning(self,QApplication.translate("Message","Analysis earlier than Curve fit", None),string)

            #reset the annotation location if the origin is out of the screen
            for dim in self.qmc.analysisresultsloc:
                if dim >= 1 or dim <=0:
                    self.qmc.analysisresultsloc = self.qmc.analysisresultsloc_default

            # create the segement results annotation box
            a = aw.qmc.alpha["statsanalysisbkgnd"]
            fc = aw.qmc.palette["statsanalysisbkgnd"]
            tc = aw.labelBorW(fc)
            segmentresultstr = self.cfr['segmentresultstr']
            self.segmentresultsanno = self.qmc.ax.annotate(segmentresultstr, xy=self.qmc.segmentresultsloc, xycoords='axes fraction',
                       ha="left", va="center",
                       fontfamily='monospace',
                       fontsize='x-small',
                       color=tc,
                       zorder=30,
                       picker=False,
                       bbox=dict(boxstyle="round", fc=fc, alpha=a))
            try:
                self.segmentresultsanno.set_in_layout(False) # remove from tight_layout calculation
                self.segmentresultsanno.draggable(use_blit=True)
                self.segmentresultsanno.set_picker(self.draggable_text_box_picker)
            except: # set_in_layout not available in mpl<3.x
                pass
            self.segmentresultsannoid = self.qmc.fig.canvas.mpl_connect('button_release_event', self.qmc.onrelease)

            # create the analysis results annotation box
            a = aw.qmc.alpha["statsanalysisbkgnd"]
            fc = aw.qmc.palette["statsanalysisbkgnd"]
            tc = aw.labelBorW(fc)
            self.analysisresultsanno = self.qmc.ax.annotate(resultstr, xy=self.qmc.analysisresultsloc, xycoords='axes fraction',
                       ha="left", va="center",
                       fontfamily='monospace',
                       fontsize='x-small',
                       color=tc,
                       zorder=31,
                       picker=False,
                       bbox=dict(boxstyle="round", fc=fc, alpha=a))
            try:
                self.analysisresultsanno.set_in_layout(False) # remove from tight_layout calculation
                self.analysisresultsanno.draggable(use_blit=True)
                self.analysisresultsanno.set_picker(self.draggable_text_box_picker)
            except: # set_in_layout not available in mpl<3.x
                pass
            self.analysisresultsannoid = self.qmc.fig.canvas.mpl_connect('button_release_event', self.qmc.onrelease)
            self.qmc.fig.canvas.draw()

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " analysisShowResults(): {0}").format(str(e)),exc_tb.tb_lineno)

    def analysisGetResults(self,exp=2, curvefit_starttime=0, curvefit_endtime=0, analysis_starttime=0, analysis_endtime=0):

        res = {}  #use dict for the results
        
        if exp != 4:  #not using existing background so perform a curve fit that sets the background 
            res['equ'] = self.qmc.lnRegression(power=exp, curvefit_starttime=curvefit_starttime, curvefit_endtime=curvefit_endtime, plot=False)
            self.deleteBackground()
            self.setbackgroundequ(EQU=["",res['equ']],recomputeAllDeltas=True)  #redraw() called from setbackgroundequ()
        
        result = self.curveSimilarity2(exp=exp, analysis_starttime=analysis_starttime, analysis_endtime=analysis_endtime)

        retval = {**result, **res}
        return retval


    def analysisRecomputeDeltas(self):
        try:
            smooth=True
            sampling=False
            decay_smoothing_p = not aw.qmc.optimalSmoothing

            # we resample the temperatures to regular interval timestamps
            if aw.qmc.timeB is not None and aw.qmc.timeB:
                timeB_lin = numpy.linspace(aw.qmc.timeB[0],aw.qmc.timeB[-1],len(aw.qmc.timeB))
            else:
                timeB_lin = None
            # we resample the temperatures to regular interval timestamps
            if aw.qmc.timex is not None and aw.qmc.timex and len(aw.qmc.timex)>1:
                timex_lin = numpy.linspace(aw.qmc.timex[0],aw.qmc.timex[-1],len(aw.qmc.timex))
            else:
                timex_lin = None
            temp1_nogaps = aw.qmc.fill_gaps(aw.qmc.resizeList(aw.qmc.temp1,len(aw.qmc.timex)))
            temp2_nogaps = aw.qmc.fill_gaps(aw.qmc.resizeList(aw.qmc.temp2,len(aw.qmc.timex)))
                    
            if smooth or len(aw.qmc.stemp1) != len(aw.qmc.timex):
                if not aw.qmc.smooth_curves_on_recording and aw.qmc.flagon: # we don't smooth, but remove the dropouts
                    aw.qmc.stemp1 = temp1_nogaps
                else:
                    aw.qmc.stemp1 = aw.qmc.smooth_list(aw.qmc.timex,temp1_nogaps,window_len=aw.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
            if smooth or len(aw.qmc.stemp2) != len(aw.qmc.timex):
                if not aw.qmc.smooth_curves_on_recording and aw.qmc.flagon:  # we don't smooth, but remove the dropouts
                    aw.qmc.stemp2 = aw.qmc.fill_gaps(aw.qmc.temp2)
                else:
                    aw.qmc.stemp2 = aw.qmc.smooth_list(aw.qmc.timex,temp2_nogaps,window_len=aw.qmc.curvefilter,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)

            #populate background delta ET (aw.qmc.delta1B) and delta BT (aw.qmc.delta2B)
            # we populate temporary smoothed ET/BT data arrays
            cf = aw.qmc.curvefilter*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
            st1 = aw.qmc.smooth_list(aw.qmc.timeB,aw.qmc.fill_gaps(aw.qmc.temp1B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
            st2 = aw.qmc.smooth_list(aw.qmc.timeB,aw.qmc.fill_gaps(aw.qmc.temp2B),window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timeB_lin)
            # we start RoR computation 10 readings after CHARGE to avoid this initial peak
            if aw.qmc.timeindexB[0]>-1:
                RoRstart = min(aw.qmc.timeindexB[0]+10, len(aw.qmc.timeB)-1)
            else:
                RoRstart = -1
            if aw.qmc.background_profile_sampling_interval is None:
                dsET = None
            else:
                dsET = int(max(1,aw.qmc.deltaETspan / aw.qmc.background_profile_sampling_interval))
            if aw.qmc.background_profile_sampling_interval is None:
                dsBT = None
            else:
                dsBT = int(max(1,aw.qmc.deltaBTspan / aw.qmc.background_profile_sampling_interval))
            aw.qmc.delta1B, aw.qmc.delta2B = aw.qmc.recomputeDeltas(aw.qmc.timeB,RoRstart,aw.qmc.timeindexB[6],st1,st2,optimalSmoothing=not decay_smoothing_p,timex_lin=timeB_lin,deltaETsamples=dsET,deltaBTsamples=dsBT)

            #populate delta ET (aw.qmc.delta1) and delta BT (aw.qmc.delta2)
            cf = aw.qmc.curvefilter*2 # we smooth twice as heavy for PID/RoR calcuation as for normal curve smoothing
            decay_smoothing_p = not aw.qmc.optimalSmoothing or sampling or aw.qmc.flagon
            t1 = aw.qmc.smooth_list(aw.qmc.timex,temp1_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
            t2 = aw.qmc.smooth_list(aw.qmc.timex,temp2_nogaps,window_len=cf,decay_smoothing=decay_smoothing_p,a_lin=timex_lin)
            # we start RoR computation 10 readings after CHARGE to avoid this initial peak
            if aw.qmc.timeindex[0]>-1:
                RoR_start = min(aw.qmc.timeindex[0]+10, len(aw.qmc.timex)-1)
            else:
                RoR_start = -1
            aw.qmc.delta1, aw.qmc.delta2 = aw.qmc.recomputeDeltas(aw.qmc.timex,RoR_start,aw.qmc.timeindex[6],t1,t2,optimalSmoothing=not decay_smoothing_p,timex_lin=timex_lin)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " analysisRecomputeDeltas(): {0}").format(str(e)),exc_tb.tb_lineno)

    def setbackgroundequ(self,foreground=False, EQU=['',''],recomputeAllDeltas=False):
        # Check for incompatible vars from in the equations
        incompatiblevars = ["P","F","$","#"]
        error = ""
        for i in range(len(incompatiblevars)):
            if incompatiblevars[i] in EQU[0]:
                error = "P1: \n-%s\n\n[%s]"%(incompatiblevars[i],EQU[0])
            elif incompatiblevars[i] in EQU[1]:
                error = "P2: \n-%s\n\n[%s]"%(incompatiblevars[i],EQU[1])
                
        if error:
            string = QApplication.translate("Message","Incompatible variables found in %s"%error, None)
            QMessageBox.warning(self,QApplication.translate("Message","Assignment problem", None),string,
                                QMessageBox.Discard)
            
        else:
            try:
                equ = EQU[0]
                equ2 = EQU[1]
                if len(equ) or len(equ2):
                    aw.qmc.resetlines()
                    #create x range
                    if len(aw.qmc.timex) > 1:
                        x_range = aw.qmc.timex[:]
                        if not foreground and aw.qmc.timeindex[0] > -1:
                            toff = aw.qmc.timex[aw.qmc.timeindex[0]]
                        else:
                            toff = 0
                    else:
                        x_range = list(range(int(aw.qmc.startofx),int(aw.qmc.endofx)))
                        toff = 0
                    #create y range
                    y_range = []
                    y_range2 = []
                    for i in range(len(x_range)):
                        y_range.append(aw.qmc.eval_math_expression(equ,x_range[i],t_offset=toff))
                        y_range2.append(aw.qmc.eval_math_expression(equ2,x_range[i],t_offset=toff))
                        
                    #if foreground flag passed, set EQUs as ET BT instead of background
                    if foreground:
                        aw.qmc.timex = x_range[:]
                        aw.qmc.temp1 = y_range[:]
                        aw.qmc.temp2 = y_range2[:]
                        aw.qmc.redraw(recomputeAllDeltas=True)
                        #make extra devices not visible 
                        for x in range(len(aw.qmc.extradevices)):
                            aw.qmc.extratemp1[x] = [-1]*len(x_range)
                            aw.qmc.extratemp2[x] = [-1]*len(x_range)
                            aw.qmc.extratimex[x] = x_range[:]
                        aw.sendmessage(QApplication.translate("Message","Y1 = [%s] ; Y2 = [%s]"%(EQU[0],EQU[1]), None))

                    else:
                        aw.qmc.timeB = x_range[:]
                        aw.qmc.temp1B = y_range[:]
                        aw.qmc.stemp1B = y_range[:]
                        aw.qmc.temp2B = y_range2[:]
                        aw.qmc.stemp2B = aw.qmc.temp2B[:]
                        for i in range(8):
                            aw.qmc.timeindexB[i] = 0
                        aw.qmc.timeindexB[0] = -1
                        if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6]:
                            # we copy the CHARGE and DROP from the foreground to allow alignment
                            t1 = aw.qmc.timex[aw.qmc.timeindex[0]]
                            aw.qmc.timeindexB[0] = aw.qmc.backgroundtime2index(t1)
                            if aw.qmc.timeindex[1]:
                                t_DE = aw.qmc.timex[aw.qmc.timeindex[1]]
                                aw.qmc.timeindexB[1] = aw.qmc.backgroundtime2index(t_DE)
                            if aw.qmc.timeindex[2]:
                                t_FCs = aw.qmc.timex[aw.qmc.timeindex[2]]
                                aw.qmc.timeindexB[2] = aw.qmc.backgroundtime2index(t_FCs)
                            t2 = aw.qmc.timex[aw.qmc.timeindex[6]]
                            aw.qmc.timeindexB[6] = aw.qmc.backgroundtime2index(t2)
                        aw.qmc.background = True
                        aw.qmc.redraw(recomputeAllDeltas=recomputeAllDeltas)
                        aw.sendmessage(QApplication.translate("Message","B1 = [%s] ; B2 = [%s]"%(EQU[0],EQU[1]), None))

            except Exception as e:
                _, _, exc_tb = sys.exc_info()
                aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setbackgroundequ(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    @pyqtSlot(bool)
    def transform(self,_=False):
        dialog = profileTransformatorDlg(self)
        dialog.show()
    
    @pyqtSlot()
    @pyqtSlot(bool)
    def simulate(self,_=False):
        if bool(self.simulator):
            self.simulator = None
            aw.button_1.setStyleSheet(aw.pushbuttonstyles["OFF"])
            aw.button_2.setStyleSheet(aw.pushbuttonstyles["STOP"])
        else:
            try:
                filename = self.ArtisanOpenFileDialog(ext="*.alog",path=self.simulatorpath)
                if filename:
                    f = QFile(u(filename))
                    if not f.open(QFile.ReadOnly):
                        raise IOError(u(f.errorString()))
                    stream = QTextStream(f)
                    firstChar = stream.read(1)
                    if firstChar == "{":
                        f.close()
                        self.simulator = Simulator(self.deserialize(filename))
                        self.simulatorpath = filename
                        aw.button_1.setStyleSheet(aw.pushbuttonstyles_simulator["OFF"])
                        aw.button_2.setStyleSheet(aw.pushbuttonstyles_simulator["STOP"])
                    else:
                        self.sendmessage(QApplication.translate("Message","Invalid artisan format", None))
            except:
                pass
            self.simulatorAction.setChecked(bool(self.simulator))


########################################################################################
#####################  Artisan QDialog Subclass  #######################################
########################################################################################
    
class ArtisanDialog(QDialog):
    def __init__(self, parent=None):
        super(ArtisanDialog,self).__init__(parent)
        # IMPORTANT NOTE: if dialog items have to be access after it has been closed, this Qt.WA_DeleteOnClose attribute 
        # has to be set to False explicitly in its initializer (like in comportDlg) to avoid the early GC and one might
        # want to use a dialog.deleteLater() call to explicitly have the dialog and its widgets GCe
        # or rather use sip.delete(dialog) if the GC via .deleteLater() is prevented by a link to a parent object (parent not None)
        self.setAttribute(Qt.WA_DeleteOnClose, True)

#        if platf == 'Windows':
# setting those Windows flags could be the reason for some instabilities on Windows
#        #self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
#            windowFlags = self.windowFlags()
#        #windowFlags &= ~Qt.WindowContextHelpButtonHint # remove help button
#        #windowFlags &= ~Qt.WindowMaximizeButtonHint # remove maximise button
#        #windowFlags &= ~Qt.WindowMinMaxButtonsHint  # remove min/max combo
#        #windowFlags |= Qt.WindowMinimizeButtonHint  # Add minimize  button
#        windowFlags |= Qt.WindowSystemMenuHint  # Adds a window system menu, and possibly a close button
#            windowFlags |= Qt.WindowMinMaxButtonsHint  # add min/max combo
#            self.setWindowFlags(windowFlags)

        # configure standard dialog buttons
        self.dialogbuttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel,Qt.Horizontal)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setDefault(True)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setAutoDefault(True)
        self.dialogbuttons.button(QDialogButtonBox.Cancel).setDefault(False)
        self.dialogbuttons.button(QDialogButtonBox.Cancel).setAutoDefault(False)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocusPolicy(Qt.StrongFocus) # to add to tab focus switch
        if aw.locale not in aw.qtbase_locales:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setText(QApplication.translate("Button","OK", None))
            self.dialogbuttons.button(QDialogButtonBox.Cancel).setText(QApplication.translate("Button","Cancel",None))
        # add additional CMD-. shortcut to close the dialog
        self.dialogbuttons.button(QDialogButtonBox.Cancel).setShortcut(QKeySequence("Ctrl+."))
        # add additional CMD-W shortcut to close this dialog (ESC on Mac OS X)
        cancelAction = QAction(self, triggered=lambda _:self.dialogbuttons.rejected.emit())
        try:
            cancelAction.setShortcut(QKeySequence.Cancel)
        except:
            pass
        self.dialogbuttons.button(QDialogButtonBox.Cancel).addActions([cancelAction])

    def closeEvent(self,_):
        self.dialogbuttons.rejected.emit()

    def keyPressEvent(self,event):
        key = int(event.key())
        #uncomment next line to find the integer value of a key
        #print(key)
        #modifiers = QApplication.keyboardModifiers()
        modifiers = event.modifiers()
        if key == 16777216 or (key == 87 and modifiers == Qt.ControlModifier): #ESCAPE or CMD-W
            self.close()

class ArtisanResizeablDialog(ArtisanDialog):
    def __init__(self, parent=None):
        super(ArtisanResizeablDialog,self).__init__(parent)
        if platf == 'Windows':
            windowFlags = self.windowFlags()
            windowFlags |= Qt.WindowMinMaxButtonsHint  # add min/max combo
            self.setWindowFlags(windowFlags)


class ArtisanMessageBox(QMessageBox):
    def __init__(self, parent = None, title=None, text=None, timeout=0, modal=True):
        super(ArtisanMessageBox, self).__init__(parent)
        self.setWindowTitle(title)
        self.setText(text)
        self.setModal(modal)
        self.setIcon(QMessageBox.Information)
        self.setStandardButtons(QMessageBox.Ok)
        self.setDefaultButton(QMessageBox.Ok)
        self.timeout = timeout # configured timeout, defaults to 0 (no timeout)
        self.currentTime = 0 # counts seconds after timer start
        
    def showEvent(self,_):
        self.currentTime = 0
        if (self.timeout and self.timeout != 0):
            self.startTimer(1000)
    
    def timerEvent(self,_):
        self.currentTime = self.currentTime + 1
        if (self.currentTime >= self.timeout):
            self.done(0)


##########################################################################
#####################     SAMPLING DLG     ###############################
##########################################################################

class SamplingDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(SamplingDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Message","Sampling Interval", None))
        self.setModal(True)
        
        self.keepOnFlag = QCheckBox(QApplication.translate("Label","Keep ON", None))
        self.keepOnFlag.setFocusPolicy(Qt.NoFocus)
        self.keepOnFlag.setChecked(bool(aw.qmc.flagKeepON))
        
        self.interval = QDoubleSpinBox()
        self.interval.setSingleStep(1)
        self.interval.setValue(aw.qmc.delay/1000.)
        self.interval.setRange(aw.qmc.min_delay/1000.,40.)
        self.interval.setDecimals(1)
        self.interval.setAlignment(Qt.AlignRight)
        self.interval.setSuffix("s")
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.ok)
        self.dialogbuttons.rejected.connect(self.close)
        
        flagLayout = QHBoxLayout()
        flagLayout.addStretch()
        flagLayout.addWidget(self.keepOnFlag)  
        flagLayout.addStretch()
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(self.dialogbuttons)
        
        #incorporate layouts
        layout = QVBoxLayout()
        layout.addWidget(self.interval)
        layout.addLayout(flagLayout)
        layout.addStretch()
        layout.addLayout(buttonsLayout)
        layout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(layout) 
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()     
        
    def closeEvent(self,_):
        self.close()
        
    #cancel button
    @pyqtSlot()
    def close(self):
        self.reject()
    
    #ok button
    @pyqtSlot()
    def ok(self):
        if self.keepOnFlag.isChecked():
            aw.qmc.flagKeepON = True
        else:
            aw.qmc.flagKeepON = False
        aw.qmc.delay = int(self.interval.value()*1000.)
        if aw.qmc.delay < aw.qmc.default_delay:
            QMessageBox.warning(aw,QApplication.translate("Message", "Warning",None),QApplication.translate("Message", "A tight sampling interval might lead to instability on some machines. We suggest a minimum of 3s.",None))        
        self.accept()
        
    
##########################################################################
#####################     EXTRAS/HUD  EDIT DLG     #######################
##########################################################################

class HUDDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(HUDDlg,self).__init__(parent)
        
        self.setWindowTitle(QApplication.translate("Form Caption","Curves", None))
        self.setModal(True)

        self.helpdialog = None

        settings = QSettings()
        if settings.contains("HUDDlgGeometry"):
            self.restoreGeometry(settings.value("HUDDlgGeometry"))

        # keep old values to be restored on Cancel
        self.org_DeltaET = aw.qmc.DeltaETflag
        self.org_DeltaBT = aw.qmc.DeltaBTflag
        self.org_DeltaETlcd = aw.qmc.DeltaETlcdflag
        self.org_DeltaBTlcd = aw.qmc.DeltaBTlcdflag
        self.org_Projection = aw.qmc.projectFlag
        self.org_patheffects = aw.qmc.patheffects
        self.org_graphstyle = aw.qmc.graphstyle
        self.org_graphfont = aw.qmc.graphfont
        self.org_HUDbuttonflag = aw.qmc.HUDbuttonflag
        self.org_filterDropOuts = aw.qmc.filterDropOuts
        self.org_dropSpikes = aw.qmc.dropSpikes
        self.org_swapETBT = aw.qmc.swapETBT
        self.org_optimalSmoothing = aw.qmc.optimalSmoothing
        self.org_soundflag = aw.soundflag
        self.org_logoimgflag = aw.logoimgflag
        self.org_logoimgalpha = aw.logoimgalpha
        self.org_curvefilter = aw.qmc.curvefilter
        self.org_deltaETfilter = aw.qmc.deltaETfilter
        self.org_deltaBTfilter = aw.qmc.deltaBTfilter
        self.org_deltaBTspan = aw.qmc.deltaBTspan
        self.org_deltaETspan = aw.qmc.deltaETspan
        self.org_graphstyle = aw.qmc.graphstyle
        self.org_ETname = aw.ETname
        self.org_BTname = aw.BTname
        
        self.showHUDbutton = QCheckBox(QApplication.translate("Label", "HUD Button", None))
        self.showHUDbutton.setChecked(aw.qmc.HUDbuttonflag)
        self.showHUDbutton.setFocusPolicy(Qt.NoFocus)
        self.showHUDbutton.stateChanged.connect(self.showHUDbuttonToggle)
        ETLabel = QLabel(QApplication.translate("Label", "ET Target 1",None))
        ETLabel.setAlignment(Qt.AlignRight)
        BTLabel = QLabel(QApplication.translate("Label", "BT Target 1",None))
        BTLabel.setAlignment(Qt.AlignRight)        
        ET2Label = QLabel(QApplication.translate("Label", "ET Target 2",None))
        ET2Label.setAlignment(Qt.AlignRight)
        BT2Label = QLabel(QApplication.translate("Label", "BT Target 2",None))
        BT2Label.setAlignment(Qt.AlignRight)        
        modeLabel = QLabel(QApplication.translate("Label", "Mode",None))
        modeLabel.setAlignment(Qt.AlignRight)
        ETPIDLabel = QLabel(QApplication.translate("Label", "ET p-i-d 1",None))
        #delta ET
        self.DeltaET = QCheckBox()
        self.DeltaET.setChecked(aw.qmc.DeltaETflag)
        DeltaETlabel = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "ET",None))
        #delta BT
        self.DeltaBT = QCheckBox()
        self.DeltaBT.setChecked(aw.qmc.DeltaBTflag)
        DeltaBTlabel = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "BT",None))
        filterlabel = QLabel(QApplication.translate("Label", "Smoothing",None))
        #DeltaFilter holds the number of pads in filter
        self.DeltaETfilter = QSpinBox()
        self.DeltaETfilter.setSingleStep(1)
        self.DeltaETfilter.setRange(0,40)
        self.DeltaETfilter.setAlignment(Qt.AlignRight)
        self.DeltaETfilter.setValue(aw.qmc.deltaETfilter/2)
        self.DeltaETfilter.editingFinished.connect(self.changeDeltaETfilter)
        self.DeltaBTfilter = QSpinBox()
        self.DeltaBTfilter.setSingleStep(1)
        self.DeltaBTfilter.setRange(0,40)
        self.DeltaBTfilter.setAlignment(Qt.AlignRight)
        self.DeltaBTfilter.setValue(aw.qmc.deltaBTfilter/2)
        self.DeltaBTfilter.editingFinished.connect(self.changeDeltaBTfilter)

        self.OptimalSmoothingFlag = QCheckBox(QApplication.translate("CheckBox", "Optimal Smoothing Post Roast",None))
        self.OptimalSmoothingFlag.setToolTip(QApplication.translate("Tooltip", "Use an optimal smoothing algorithm (only applicable offline, after recording)", None))        
        self.OptimalSmoothingFlag.setChecked(aw.qmc.optimalSmoothing)
        self.OptimalSmoothingFlag.stateChanged.connect(self.changeOptimalSmoothingFlag)
        
        curvefilterlabel = QLabel(QApplication.translate("Label", "Smooth Curves",None))
        #Filter holds the number of pads in filter
        self.Filter = QSpinBox()
        self.Filter.setSingleStep(1)
        self.Filter.setRange(0,40)
        self.Filter.setAlignment(Qt.AlignRight)
        self.Filter.setValue(aw.qmc.curvefilter/2)
        self.Filter.editingFinished.connect(self.changeFilter)
        #filterspikes
        self.FilterSpikes = QCheckBox(QApplication.translate("CheckBox", "Smooth Spikes",None))
        self.FilterSpikes.setChecked(aw.qmc.filterDropOuts)
        self.FilterSpikes.stateChanged.connect(self.changeDropFilter)
        self.FilterSpikes.setFocusPolicy(Qt.NoFocus)
        #dropspikes
        self.DropSpikes = QCheckBox(QApplication.translate("CheckBox", "Drop Spikes",None))
        self.DropSpikes.setChecked(aw.qmc.dropSpikes)
        self.DropSpikes.stateChanged.connect(self.changeSpikeFilter)
        self.DropSpikes.setFocusPolicy(Qt.NoFocus)
        #min-max-limits
        self.MinMaxLimits = QCheckBox(QApplication.translate("CheckBox", "Limits",None))
        self.MinMaxLimits.setChecked(aw.qmc.minmaxLimits)
        self.MinMaxLimits.stateChanged.connect(self.changeMinMaxLimits)
        self.MinMaxLimits.setFocusPolicy(Qt.NoFocus)
        #swapETBT flag
        self.swapETBT = QCheckBox(QApplication.translate("Label", "ET", None) + " <-> " + QApplication.translate("Label", "BT", None))
        self.swapETBT.setChecked(aw.qmc.swapETBT)
        self.swapETBT.setFocusPolicy(Qt.NoFocus)
        self.swapETBT.stateChanged.connect(self.changeSwapETBT)
        #limits
        minlabel = QLabel(QApplication.translate("Label", "min",None))
        maxlabel = QLabel(QApplication.translate("Label", "max",None))
        self.minLimit = QSpinBox()
        self.minLimit.setRange(0,1000)    #(min,max)
        self.minLimit.setAlignment(Qt.AlignRight)
        self.minLimit.setMinimumWidth(80)
        self.minLimit.setValue(aw.qmc.filterDropOut_tmin)
        self.maxLimit = QSpinBox()
        self.maxLimit.setRange(0,1000)
        self.maxLimit.setAlignment(Qt.AlignRight)
        self.maxLimit.setMinimumWidth(80)
        self.maxLimit.setValue(aw.qmc.filterDropOut_tmax)
#        if aw.qmc.mode == "F":
#            self.minLimit.setSuffix(" F")
#            self.maxLimit.setSuffix(" F")
#        elif aw.qmc.mode == "C":
#            self.minLimit.setSuffix(" C")
#            self.maxLimit.setSuffix(" C")
        #show projection
        self.projectCheck = QCheckBox(QApplication.translate("CheckBox", "Projection",None))
        self.projectionmodeComboBox = QComboBox()
        self.projectionmodeComboBox.addItems([QApplication.translate("ComboBox","linear",None),
                                              QApplication.translate("ComboBox","newton",None)])
        self.projectionmodeComboBox.setCurrentIndex(aw.qmc.projectionmode)
        self.projectionmodeComboBox.currentIndexChanged.connect(self.changeProjectionMode)
        self.projectCheck.setChecked(aw.qmc.projectFlag)
        self.DeltaET.stateChanged.connect(self.changeDeltaET)         #toggle
        self.DeltaBT.stateChanged.connect(self.changeDeltaBT)         #toggle
        self.projectCheck.stateChanged.connect(self.changeProjection) #toggle
        
        deltaSpanLabel = QLabel(QApplication.translate("Label", "Delta Span",None))
        self.spanitems = range(1,31)
        self.deltaBTspan = QComboBox()
        self.deltaBTspan.addItems([str(i) + "s" for i in self.spanitems])
        try:
            self.deltaBTspan.setCurrentIndex(self.spanitems.index(aw.qmc.deltaBTspan))
        except Exception:
            pass
        self.deltaBTspan.currentIndexChanged.connect(self.changeDeltaBTspan)  #toggle
        self.deltaETspan = QComboBox()
        self.deltaETspan.addItems([str(i) + "s" for i in self.spanitems])
        try:
            self.deltaETspan.setCurrentIndex(self.spanitems.index(aw.qmc.deltaETspan))
        except Exception:
            pass
        self.deltaETspan.currentIndexChanged.connect(self.changeDeltaETspan)  #toggle

        self.modeComboBox = QComboBox()
        self.modeComboBox.setMaximumWidth(100)
        self.modeComboBox.setMinimumWidth(55)
        self.modeComboBox.addItems([QApplication.translate("ComboBox","metrics",None),
                                    QApplication.translate("ComboBox","thermal",None)])
        self.modeComboBox.setCurrentIndex(aw.HUDfunction)
        self.ETlineEdit = QLineEdit(str(aw.qmc.ETtarget))
        self.ETlineEdit.setAlignment(Qt.AlignRight)
        self.BTlineEdit = QLineEdit(str(aw.qmc.BTtarget))
        self.BTlineEdit.setAlignment(Qt.AlignRight)
        self.ETlineEdit.setValidator(QIntValidator(0, 1000, self.ETlineEdit))
        self.BTlineEdit.setValidator(QIntValidator(0, 1000, self.BTlineEdit))
        self.ETlineEdit.setMaximumWidth(60)
        self.BTlineEdit.setMaximumWidth(60)
        self.ET2lineEdit = QLineEdit(str(aw.qmc.ET2target))
        self.ET2lineEdit.setAlignment(Qt.AlignRight)
        self.BT2lineEdit = QLineEdit(str(aw.qmc.BT2target))
        self.BT2lineEdit.setAlignment(Qt.AlignRight)
        self.ET2lineEdit.setValidator(QIntValidator(0, 1000, self.ET2lineEdit))
        self.BT2lineEdit.setValidator(QIntValidator(0, 1000, self.BT2lineEdit))
        self.ET2lineEdit.setMaximumWidth(60)
        self.BT2lineEdit.setMaximumWidth(60)
        self.ETpidP = QLineEdit(str(aw.qmc.hudETpid[0]))
        self.ETpidP.setAlignment(Qt.AlignRight)
        self.ETpidI = QLineEdit(str(aw.qmc.hudETpid[1]))
        self.ETpidI.setAlignment(Qt.AlignRight)
        self.ETpidD = QLineEdit(str(aw.qmc.hudETpid[2]))
        self.ETpidD.setAlignment(Qt.AlignRight)
        self.ETpidP.setValidator(QIntValidator(0, 1000, self.ETpidP))
        self.ETpidI.setValidator(QIntValidator(0, 1000, self.ETpidI))
        self.ETpidD.setValidator(QIntValidator(0, 1000, self.ETpidD))
        self.ETpidP.setMaximumWidth(60)
        self.ETpidI.setMaximumWidth(60)
        self.ETpidD.setMaximumWidth(60)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.updatetargets)
        self.dialogbuttons.rejected.connect(self.close)

        hudLayout = QGridLayout()
        hudLayout.addWidget(BTLabel,0,0)
        hudLayout.addWidget(self.BTlineEdit,0,1)
        hudLayout.addWidget(BT2Label,0,2)
        hudLayout.addWidget(self.BT2lineEdit,0,3)
        hudLayout.addWidget(ETLabel,1,0)
        hudLayout.addWidget(self.ETlineEdit,1,1)
        hudLayout.addWidget(ET2Label,1,2)
        hudLayout.addWidget(self.ET2lineEdit,1,3)
        hudLayout.addWidget(ETPIDLabel,2,0)
        hudLayout.addWidget(self.ETpidP,2,1)
        hudLayout.addWidget(self.ETpidI,2,2)
        hudLayout.addWidget(self.ETpidD,2,3)
        hudLayout.addWidget(modeLabel,3,0)
        hudLayout.addWidget(self.modeComboBox,3,1)
        hudLayout.addWidget(self.showHUDbutton,3,3)
        rorBoxLayout = QHBoxLayout()
        rorBoxLayout.addWidget(self.DeltaET)
        rorBoxLayout.addWidget(DeltaETlabel)
        rorBoxLayout.addSpacing(15)
        rorBoxLayout.addWidget(self.DeltaBT)
        rorBoxLayout.addWidget(DeltaBTlabel)
        rorBoxLayout.addStretch()
        rorBoxLayout.addWidget(self.projectCheck)
        rorBoxLayout.addWidget(self.projectionmodeComboBox)
        self.DeltaETlcd = QCheckBox()
        self.DeltaETlcd.setChecked(aw.qmc.DeltaETlcdflag)
        DeltaETlcdLabel = QLabel(deltaLabelPrefix + QApplication.translate("Label", "ET",None))
        self.DeltaBTlcd = QCheckBox()
        self.DeltaBTlcd.setChecked(aw.qmc.DeltaBTlcdflag)
        self.swapdeltalcds = QCheckBox(QApplication.translate("CheckBox", "Swap",None))
        self.swapdeltalcds.setChecked(aw.qmc.swapdeltalcds)
        DeltaBTlcdLabel = QLabel(deltaLabelPrefix + QApplication.translate("Label", "BT",None))
        self.DecimalPlaceslcd = QCheckBox(QApplication.translate("CheckBox", "Decimal Places",None))
        self.DecimalPlaceslcd.setChecked(aw.qmc.LCDdecimalplaces)
        self.DeltaETlcd.stateChanged.connect(self.changeDeltaETlcd)         #toggle
        self.DeltaBTlcd.stateChanged.connect(self.changeDeltaBTlcd)         #toggle
        lcdsLayout = QHBoxLayout()
        lcdsLayout.addWidget(self.DeltaETlcd)
        lcdsLayout.addWidget(DeltaETlcdLabel)
        lcdsLayout.addSpacing(15)
        lcdsLayout.addWidget(self.DeltaBTlcd)
        lcdsLayout.addWidget(DeltaBTlcdLabel)
        lcdsLayout.addStretch()
        lcdsLayout.addWidget(self.swapdeltalcds)
        DeltaETfilterLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "ET",None))
        DeltaBTfilterLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "BT",None))
        sensitivityGrid = QGridLayout()
        sensitivityGrid.addWidget(DeltaETfilterLabel,0,1,Qt.AlignHCenter)
        sensitivityGrid.addWidget(DeltaBTfilterLabel,0,2,Qt.AlignHCenter)
        sensitivityGrid.addWidget(deltaSpanLabel,1,0)
        sensitivityGrid.addWidget(self.deltaETspan,1,1)
        sensitivityGrid.addWidget(self.deltaBTspan,1,2)
        sensitivityGrid.addWidget(filterlabel,2,0)
        sensitivityGrid.addWidget(self.DeltaETfilter,2,1)
        sensitivityGrid.addWidget(self.DeltaBTfilter,2,2)
        sensitivityLayout = QHBoxLayout()
        sensitivityLayout.addStretch()
        sensitivityLayout.addLayout(sensitivityGrid)
        sensitivityLayout.addStretch()
        
        spikesLayout = QHBoxLayout()
        spikesLayout.addWidget(curvefilterlabel)
        spikesLayout.addWidget(self.Filter)
        spikesLayout.addStretch()
        spikesLayout.addWidget(self.FilterSpikes)
        rorGroupLayout = QGroupBox(QApplication.translate("GroupBox","Rate of Rise Curves",None))
        rorGroupLayout.setLayout(rorBoxLayout)
        rorLCDGroupLayout = QGroupBox(QApplication.translate("GroupBox","Rate of Rise LCDs",None))
        rorLCDGroupLayout.setLayout(lcdsLayout)
        
        
        labelETDeltaFormula = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "ET Y(x)",None))
        labelBTDeltaFormula = QLabel(deltaLabelUTF8 + QApplication.translate("Label", "BT Y(x)",None))
        self.DeltaETfunctionedit = QLineEdit(str(aw.qmc.DeltaETfunction))
        self.DeltaBTfunctionedit = QLineEdit(str(aw.qmc.DeltaBTfunction))
        
        rorSymbolicFormulaLabelsLayout = QHBoxLayout()
        rorSymbolicFormulaLabelsLayout.addWidget(labelETDeltaFormula)
        rorSymbolicFormulaLabelsLayout.addWidget(labelBTDeltaFormula)
        rorSymbolicFormulaLayout = QHBoxLayout()
        rorSymbolicFormulaLayout.addWidget(self.DeltaETfunctionedit)
        rorSymbolicFormulaLayout.addWidget(self.DeltaBTfunctionedit)
        rorSymbolicFormulas = QVBoxLayout()
        rorSymbolicFormulas.addLayout(rorSymbolicFormulaLabelsLayout)
        rorSymbolicFormulas.addLayout(rorSymbolicFormulaLayout)
        
        rorSymbolicFormulaGroupLayout = QGroupBox(QApplication.translate("GroupBox","Rate of Rise Symbolic Assignments",None))
        rorSymbolicFormulaGroupLayout.setLayout(rorSymbolicFormulas)
        
        hudHBox = QHBoxLayout()
        hudHBox.addStretch()
        hudHBox.addLayout(hudLayout)
        hudHBox.addStretch()
        hudGroupLayout = QGroupBox(QApplication.translate("GroupBox","Head Up Display",None))
        hudGroupLayout.setLayout(hudHBox)  
        if app.artisanviewerMode:
            hudGroupLayout.setEnabled(False)
        rorRoRAlgo = QHBoxLayout()
        rorRoRAlgo.addWidget(self.OptimalSmoothingFlag) 
        rorRoRAlgo.addStretch()     
        inputFilter1 = QHBoxLayout()
        inputFilter1.addWidget(self.DropSpikes)
        inputFilter1.addStretch()
        inputFilter1.addWidget(self.swapETBT)
        inputFilter2 = QHBoxLayout()
        inputFilter2.addWidget(self.MinMaxLimits)
        inputFilter2.addStretch()
        inputFilter2.addWidget(minlabel)
        inputFilter2.addWidget(self.minLimit)
        inputFilter2.addSpacing(20)
        inputFilter2.addWidget(maxlabel)
        inputFilter2.addWidget(self.maxLimit)
        
        inputFilterVBox = QVBoxLayout()
        inputFilterVBox.addLayout(inputFilter1)
        inputFilterVBox.addLayout(inputFilter2) 
        inputFilterGroupLayout = QGroupBox(QApplication.translate("GroupBox","Input Filter",None))
        inputFilterGroupLayout.setLayout(inputFilterVBox)
        # Post Roast Group
        postRoastVBox = QVBoxLayout()
        postRoastVBox.addLayout(spikesLayout)
        postRoastGroupLayout = QGroupBox(QApplication.translate("GroupBox","Curve Filter",None))
        postRoastGroupLayout.setLayout(postRoastVBox)    
        #swapETBT flag
        self.rorFilter = QCheckBox(QApplication.translate("CheckBox", "Limits",None))
        self.rorFilter.setChecked(aw.qmc.RoRlimitFlag)
        self.rorFilter.setFocusPolicy(Qt.NoFocus)
        rorminlabel = QLabel(QApplication.translate("Label", "min",None))
        rormaxlabel = QLabel(QApplication.translate("Label", "max",None))
        self.rorminLimit = QSpinBox()
        self.rorminLimit.setRange(-999,999)    #(min,max)
        self.rorminLimit.setAlignment(Qt.AlignRight)
        self.rorminLimit.setMinimumWidth(80)
        self.rorminLimit.setValue(aw.qmc.RoRlimitm)
        self.rormaxLimit = QSpinBox()
        self.rormaxLimit.setRange(-999,999)
        self.rormaxLimit.setAlignment(Qt.AlignRight)
        self.rormaxLimit.setMinimumWidth(80)
        self.rormaxLimit.setValue(aw.qmc.RoRlimit)
        if aw.qmc.mode == "F":
            self.rorminLimit.setSuffix(" F/min")
            self.rormaxLimit.setSuffix(" F/min")
        elif aw.qmc.mode == "C":
            self.rorminLimit.setSuffix(" C/min")
            self.rormaxLimit.setSuffix(" C/min")
        rorFilterHBox = QHBoxLayout()
        rorFilterHBox.addWidget(self.rorFilter)
        rorFilterHBox.addStretch()
        rorFilterHBox.addWidget(rorminlabel)
        rorFilterHBox.addWidget(self.rorminLimit)
        rorFilterHBox.addSpacing(20)
        rorFilterHBox.addWidget(rormaxlabel)
        rorFilterHBox.addWidget(self.rormaxLimit)
        rorFilterVBox = QVBoxLayout()
        rorFilterVBox.addLayout(sensitivityLayout)
        rorFilterVBox.addLayout(rorRoRAlgo)  
        rorFilterVBox.addLayout(rorFilterHBox)
        rorFilterGroupLayout = QGroupBox(QApplication.translate("GroupBox","Rate of Rise Filter",None))
        rorFilterGroupLayout.setLayout(rorFilterVBox)
        # path effects
        effectslabel = QLabel(QApplication.translate("Label", "Path Effects",None))
        self.PathEffects = QSpinBox()
        self.PathEffects.setSingleStep(1)
        self.PathEffects.setRange(0,5)
        self.PathEffects.setAlignment(Qt.AlignRight)
        self.PathEffects.setValue(aw.qmc.patheffects)
        self.PathEffects.editingFinished.connect(self.changePathEffects)
        pathEffectsLayout = QHBoxLayout()
        pathEffectsLayout.addWidget(effectslabel)
        pathEffectsLayout.addWidget(self.PathEffects)
        pathEffectsLayout.addStretch()
        # graph style
        stylelabel = QLabel(QApplication.translate("Label", "Style",None))
        self.GraphStyle = QComboBox()
        self.GraphStyle.addItems([QApplication.translate("ComboBox","classic",None),
                                  QApplication.translate("ComboBox","xkcd",None)])
        self.GraphStyle.setCurrentIndex(aw.qmc.graphstyle)
        self.GraphStyle.currentIndexChanged.connect(self.changeGraphStyle)
        # graph font
        fontlabel = QLabel(QApplication.translate("Label", "Font",None))
        self.GraphFont = QComboBox()
        # no Comic on Linux!
        if platf == "Linux":
            self.GraphFont.addItems([QApplication.translate("ComboBox","Default",None),
                                      QApplication.translate("ComboBox","Humor",None)])
        else:
            self.GraphFont.addItems([QApplication.translate("ComboBox","Default",None),
                                      QApplication.translate("ComboBox","Humor",None),
                                      QApplication.translate("ComboBox","Comic",None)])
        self.GraphFont.setCurrentIndex(aw.qmc.graphfont)
        self.GraphFont.currentIndexChanged.connect(self.changeGraphFont)
        graphLayout = QHBoxLayout()
        graphLayout.addWidget(stylelabel)
        graphLayout.addWidget(self.GraphStyle)
        # styles group
#        stylesLayout = QVBoxLayout()
#        stylesLayout.addLayout(pathEffectsLayout)
#        stylesLayout.addLayout(graphLayout)
#        styleGroupLayout = QGroupBox(QApplication.translate("GroupBox","Look",None))
#        styleGroupLayout.setLayout(stylesLayout)
        #tab0
        tab0Layout = QVBoxLayout()
        tab0Layout.addWidget(rorGroupLayout)
        tab0Layout.addWidget(rorLCDGroupLayout)
        tab0Layout.addWidget(rorSymbolicFormulaGroupLayout)
        tab0Layout.addStretch()
        #tab1
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(inputFilterGroupLayout)
        tab1Layout.addWidget(postRoastGroupLayout)
        tab1Layout.addWidget(rorFilterGroupLayout)
        tab1Layout.addStretch()
        #tab11
        tab11Layout = QVBoxLayout()
        tab11Layout.addWidget(hudGroupLayout)
        tab11Layout.addStretch()
        #tab2
        #Equation plotter
        self.equlabel = QLabel(QApplication.translate("Label", "Y(x)",None))
        self.equc1label = QLabel(QApplication.translate("Label", "P1",None))
        self.equc2label = QLabel(QApplication.translate("Label", "P2",None))
        self.equc3label = QLabel(QApplication.translate("Label", "P3",None))
        self.equc4label = QLabel(QApplication.translate("Label", "P4",None))
        self.equc5label = QLabel(QApplication.translate("Label", "P5",None))
        self.equc6label = QLabel(QApplication.translate("Label", "P6",None))
        self.equc7label = QLabel(QApplication.translate("Label", "P7",None))
        self.equc8label = QLabel(QApplication.translate("Label", "P8",None))
        self.equc9label = QLabel(QApplication.translate("Label", "P9",None))
        self.equedit1 = QLineEdit(aw.qmc.plotcurves[0])
        self.equedit2 = QLineEdit(aw.qmc.plotcurves[1])
        self.equedit3 = QLineEdit(aw.qmc.plotcurves[2])
        self.equedit4 = QLineEdit(aw.qmc.plotcurves[3])
        self.equedit5 = QLineEdit(aw.qmc.plotcurves[4])
        self.equedit6 = QLineEdit(aw.qmc.plotcurves[5])
        self.equedit7 = QLineEdit(aw.qmc.plotcurves[6])
        self.equedit8 = QLineEdit(aw.qmc.plotcurves[7])
        self.equedit9 = QLineEdit(aw.qmc.plotcurves[8])
        self.equedit1.setSelection (0,0)
        self.equedit2.setSelection (0,0)
        self.equedit3.setSelection (0,0)
        self.equedit4.setSelection (0,0)
        self.equedit5.setSelection (0,0)
        self.equedit6.setSelection (0,0)
        self.equedit7.setSelection (0,0)
        self.equedit8.setSelection (0,0)
        self.equedit9.setSelection (0,0)

        color1Button = QPushButton(QApplication.translate("Button","Color",None))
        color1Button.setFocusPolicy(Qt.NoFocus)
        color1Button.clicked.connect(self.setcurvecolor0)
        color2Button = QPushButton(QApplication.translate("Button","Color",None))
        color2Button.setFocusPolicy(Qt.NoFocus)
        color2Button.clicked.connect(self.setcurvecolor1)
        color3Button = QPushButton(QApplication.translate("Button","Color",None))
        color3Button.setFocusPolicy(Qt.NoFocus)
        color3Button.clicked.connect(self.setcurvecolor2)
        color4Button = QPushButton(QApplication.translate("Button","Color",None))
        color4Button.setFocusPolicy(Qt.NoFocus)
        color4Button.clicked.connect(self.setcurvecolor3)
        color5Button = QPushButton(QApplication.translate("Button","Color",None))
        color5Button.setFocusPolicy(Qt.NoFocus)
        color5Button.clicked.connect(self.setcurvecolor4)
        color6Button = QPushButton(QApplication.translate("Button","Color",None))
        color6Button.setFocusPolicy(Qt.NoFocus)
        color6Button.clicked.connect(self.setcurvecolor5)
        color7Button = QPushButton(QApplication.translate("Button","Color",None))
        color7Button.setFocusPolicy(Qt.NoFocus)
        color7Button.clicked.connect(self.setcurvecolor6)
        color8Button = QPushButton(QApplication.translate("Button","Color",None))
        color8Button.setFocusPolicy(Qt.NoFocus)
        color8Button.clicked.connect(self.setcurvecolor7)
        color9Button = QPushButton(QApplication.translate("Button","Color",None))
        color9Button.setFocusPolicy(Qt.NoFocus)
        color9Button.clicked.connect(self.setcurvecolor8)
        self.equc1colorlabel = QLabel("  ")
        self.equc2colorlabel = QLabel("  ")
        self.equc3colorlabel = QLabel("  ")
        self.equc4colorlabel = QLabel("  ")
        self.equc5colorlabel = QLabel("  ")
        self.equc6colorlabel = QLabel("  ")
        self.equc7colorlabel = QLabel("  ")
        self.equc8colorlabel = QLabel("  ")
        self.equc9colorlabel = QLabel("  ")
        self.equc1colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[0])
        self.equc2colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[1])
        self.equc3colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[2])
        self.equc4colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[3])
        self.equc5colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[4])
        self.equc6colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[5])
        self.equc7colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[6])
        self.equc8colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[7])
        self.equc9colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[8])

        equdrawbutton = QPushButton(QApplication.translate("Button","Plot",None))
        equdrawbutton.setFocusPolicy(Qt.NoFocus)
        equdrawbutton.clicked.connect(self.plotequ)
        equshowtablebutton = QPushButton(QApplication.translate("Button","Data",None))
        equshowtablebutton.setFocusPolicy(Qt.NoFocus)
        equshowtablebutton.setToolTip(QApplication.translate("Tooltip","Shows data table of plots",None))
        equshowtablebutton.clicked.connect(self.equshowtable)
        self.equbackgroundbutton = QPushButton(QApplication.translate("Button","Background",None))
        self.equbackgroundbutton.setFocusPolicy(Qt.NoFocus)
        self.equbackgroundbutton.clicked.connect(self.setbackgroundequ1_slot)
        self.equvdevicebutton = QPushButton()       
        self.update_equbuttons()
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None))
        saveImgButton.clicked.connect(aw.resizeImg_0_1)
        helpcurveDialogButton = QDialogButtonBox()
        helpcurveButton = helpcurveDialogButton.addButton(QDialogButtonBox.Help)
        helpcurveButton.setFocusPolicy(Qt.NoFocus)
        if aw.locale not in aw.qtbase_locales:
            helpcurveButton.setText(QApplication.translate("Button","Help", None))
        helpcurveButton.clicked.connect(self.showSymbolicHelp)
        curve1Layout = QGridLayout()
        curve1Layout.setSpacing(5)
        curve1Layout.addWidget(self.equc1label,0,0)
        curve1Layout.addWidget(self.equedit1,0,1)
        curve1Layout.addWidget(self.equbackgroundbutton,0,2)
        curve1Layout.addWidget(color1Button,0,3)
        curve1Layout.addWidget(self.equc1colorlabel,0,4)
        curve1Layout.addWidget(self.equc2label,1,0)        
        curve1Layout.addWidget(self.equedit2,1,1)
        curve1Layout.addWidget(self.equvdevicebutton,1,2)
        curve1Layout.addWidget(color2Button,1,3)
        curve1Layout.addWidget(self.equc2colorlabel,1,4)
        plot1GroupBox = QGroupBox()
        plot1GroupBox.setLayout(curve1Layout)
        curveLayout = QGridLayout()
        curveLayout.setSpacing(5)
        curveLayout.addWidget(self.equc3label,0,0)
        curveLayout.addWidget(self.equedit3,0,1)
        curveLayout.addWidget(color3Button,0,2)
        curveLayout.addWidget(self.equc3colorlabel,0,3)
        curveLayout.addWidget(self.equc4label,1,0)
        curveLayout.addWidget(self.equedit4,1,1)
        curveLayout.addWidget(color4Button,1,2)
        curveLayout.addWidget(self.equc4colorlabel,1,3)
        curveLayout.addWidget(self.equc5label,2,0)
        curveLayout.addWidget(self.equedit5,2,1)
        curveLayout.addWidget(color5Button,2,2)
        curveLayout.addWidget(self.equc5colorlabel,2,3)
        curveLayout.addWidget(self.equc6label,3,0)
        curveLayout.addWidget(self.equedit6,3,1)
        curveLayout.addWidget(color6Button,3,2)
        curveLayout.addWidget(self.equc6colorlabel,3,3)
        curveLayout.addWidget(self.equc7label,4,0)
        curveLayout.addWidget(self.equedit7,4,1)
        curveLayout.addWidget(color7Button,4,2)
        curveLayout.addWidget(self.equc7colorlabel,4,3)
        curveLayout.addWidget(self.equc8label,5,0)
        curveLayout.addWidget(self.equedit8,5,1)
        curveLayout.addWidget(color8Button,5,2)
        curveLayout.addWidget(self.equc8colorlabel,5,3)
        curveLayout.addWidget(self.equc9label,6,0)
        curveLayout.addWidget(self.equedit9,6,1)
        curveLayout.addWidget(color9Button,6,2)
        curveLayout.addWidget(self.equc9colorlabel,6,3)
        curvebuttonlayout = QHBoxLayout()
        curvebuttonlayout.addWidget(equdrawbutton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(saveImgButton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(equshowtablebutton)
        curvebuttonlayout.addStretch()
        curvebuttonlayout.addWidget(helpcurveDialogButton)
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.equlabel)
        tab2Layout.addWidget(plot1GroupBox)
        tab2Layout.addLayout(curveLayout)
        tab2Layout.addLayout(curvebuttonlayout)
        tab2Layout.addStretch()
        ##### TAB 3
        self.interpCheck = QCheckBox(QApplication.translate("CheckBox","Show",None))
        self.interpCheck.setFocusPolicy(Qt.NoFocus)
        self.interpCheck.stateChanged.connect(self.interpolation) #toggle
        self.interpComboBox = QComboBox()
        self.interpComboBox.setMaximumWidth(100)
        self.interpComboBox.setMinimumWidth(55)
        self.interpComboBox.addItems([QApplication.translate("ComboBox","linear",None),
                                      QApplication.translate("ComboBox","cubic",None),
                                      QApplication.translate("ComboBox","nearest",None)])
        self.interpComboBox.setToolTip(QApplication.translate("Tooltip", "linear: linear interpolation\ncubic: 3rd order spline interpolation\nnearest: y value of the nearest point", None))
        self.interpComboBox.setFocusPolicy(Qt.NoFocus)
        self.interpComboBox.currentIndexChanged.connect(self.changeInterpolationMode)
#         'linear'  : linear interpolation
#         'cubic'   : 3rd order spline interpolation
#         'nearest' : take the y value of the nearest point
        self.univarCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None))
        self.univarCheck.setFocusPolicy(Qt.NoFocus)
        self.univarCheck.stateChanged.connect(self.univar) #toggle
        univarButton = QPushButton(QApplication.translate("Button","Info",None))
        univarButton.setFocusPolicy(Qt.NoFocus)
        univarButton.setMaximumSize(univarButton.sizeHint())
        univarButton.setMinimumSize(univarButton.minimumSizeHint())
        self.lnvarCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None))
        self.lnvarCheck.setFocusPolicy(Qt.NoFocus)
        self.lnvarCheck.stateChanged.connect(self.lnvar) #toggle
        self.lnresult = QLineEdit()
        self.lnresult.setReadOnly(True)
        self.lnresult.setStyleSheet("background-color:'lightgrey';")
        self.expvarCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None))
        self.expvarCheck.setFocusPolicy(Qt.NoFocus)
        self.expvarCheck.stateChanged.connect(self.expvar) #toggle
        self.expresult = QLineEdit()
        self.expresult.setReadOnly(True)
        self.expresult.setStyleSheet("background-color:'lightgrey';")
        self.expradiobutton1 = QRadioButton(u"x\xb2")
        self.expradiobutton1.setChecked(True)
        self.expradiobutton1.power = self.exppower = 2
        self.expradiobutton1.toggled.connect(self.expradiobuttonClicked)
        self.expradiobutton2 = QRadioButton(u"x\xb3")
        self.expradiobutton2.power = 3
        self.expradiobutton2.toggled.connect(self.expradiobuttonClicked)
        self.exptimeoffsetLabel = QLabel(QApplication.translate("Label", "Offset seconds from CHARGE", None))
        self.exptimeoffset = QLineEdit("180")   #default to 180 seconds past CHARGE
        self.exptimeoffset.editingFinished.connect(self.exptimeoffsetChanged) 
        
        self.analyzecombobox = QComboBox()
        self.analyzecomboboxLabel = QLabel(QApplication.translate("Label", "Start of Analyze interval of interest", None))
        self.analyzecombobox.addItems([QApplication.translate("ComboBox","DRY END",None),
                                       QApplication.translate("ComboBox","120 secs before FCs",None),
                                       QApplication.translate("ComboBox","Custom",None)])
        width = self.analyzecombobox.minimumSizeHint().width()
        self.analyzecombobox.setMinimumWidth(width)
        self.analyzecombobox.setToolTip(QApplication.translate("Tooltip", "Choose the start point of analysis interval of interest", None))
        self.analyzecombobox.setFocusPolicy(Qt.NoFocus)
        self.analyzecombobox.setCurrentIndex(aw.qmc.analysisstartchoice)
        self.analyzecombobox.currentIndexChanged.connect(self.changeAnalyzecombobox)
        self.analyzetimeoffsetLabel = QLabel(QApplication.translate("Label", "Custom offset seconds from CHARGE", None))
        self.analyzetimeoffset = QLineEdit(str(aw.qmc.analysisoffset))   #default to 180 seconds past CHARGE
        self.analyzetimeoffset.setMaximumWidth(100)
        self.analyzetimeoffset.setMinimumWidth(55)
        self.analyzetimeoffset.editingFinished.connect(self.analyzetimeoffsetChanged)
        if self.analyzecombobox.currentIndex() in [0,1]:
            self.analyzetimeoffset.setEnabled(False)
        else:
            self.analyzetimeoffset.setEnabled(True)
        self.segmentsamplesthresholdLabel = QLabel(QApplication.translate("Label", "Number of samples considered significant", None))
        self.segmentsamplesthreshold = QLineEdit(str(int(round(aw.qmc.segmentsamplesthreshold))))   #default
        self.segmentsamplesthreshold.setMaximumWidth(100)
        self.segmentsamplesthreshold.setMinimumWidth(55)
        self.segmentsamplesthreshold.editingFinished.connect(self.segmentsamplesthresholdChanged)
        self.segmentsamplesthreshold.setValidator(QIntValidator(0,50,self.segmentsamplesthreshold))
        self.segmentdeltathresholdLabel = QLabel(QApplication.translate("Label", "Delta RoR Actual-to-Fit considered significant", None))
        self.segmentdeltathreshold = QLineEdit(str(aw.qmc.segmentdeltathreshold))   #default
        self.segmentdeltathreshold.setMaximumWidth(100)
        self.segmentdeltathreshold.setMinimumWidth(55)
        self.segmentdeltathreshold.editingFinished.connect(self.segmentdeltathresholdChanged)

        self.curvefitcombobox = QComboBox()
        self.curvefitcomboboxLabel = QLabel(QApplication.translate("Label", "Start of Curve Fit window", None))
        self.curvefitcombobox.addItems([QApplication.translate("ComboBox","DRY END",None),
                                       QApplication.translate("ComboBox","120 secs before FCs",None),
                                       QApplication.translate("ComboBox","Custom",None)])
        width = self.curvefitcombobox.minimumSizeHint().width()
        self.curvefitcombobox.setMinimumWidth(width)
        self.curvefitcombobox.setToolTip(QApplication.translate("Tooltip", "Choose the start point of curve fitting", None))
        self.curvefitcombobox.setFocusPolicy(Qt.NoFocus)
        self.curvefitcombobox.setCurrentIndex(aw.qmc.curvefitstartchoice)
        self.curvefitcombobox.currentIndexChanged.connect(self.changeCurvefitcombobox)
        self.curvefittimeoffsetLabel = QLabel(QApplication.translate("Label", "Custom offset seconds from CHARGE", None))
        self.curvefittimeoffset = QLineEdit(str(aw.qmc.curvefitoffset))   #default to 180 seconds past CHARGE
        self.curvefittimeoffset.setMaximumWidth(100)
        self.curvefittimeoffset.setMinimumWidth(55)
        self.curvefittimeoffset.editingFinished.connect(self.curvefittimeoffsetChanged)
        if self.curvefitcombobox.currentIndex() in [0,1]:
            self.curvefittimeoffset.setEnabled(False)
        else:
            self.curvefittimeoffset.setEnabled(True)
        self.bkgndButton = QPushButton(QApplication.translate("Button","Create Background Curve",None))
        self.bkgndButton.setFocusPolicy(Qt.NoFocus)
        self.bkgndButton.setMaximumSize(self.bkgndButton.sizeHint())
        self.bkgndButton.setMinimumSize(self.bkgndButton.minimumSizeHint())
        self.bkgndButton.clicked.connect(self.fittoBackground)
        self.bkgndButton.setEnabled(False)
        polyfitdeglabel = QLabel(QApplication.translate("Label","deg",None))
        self.polyfitdeg = QSpinBox()
        self.polyfitdeg.setFocusPolicy(Qt.NoFocus)
        self.polyfitdeg.setRange(1,4)
        self.polyfitdeg.setAlignment(Qt.AlignRight)
        self.polyfitdeg.setMinimumWidth(20)
        # build list of available curves
        self.curves = []
        self.curvenames = []
        self.c1ComboBox = QComboBox()
        self.c2ComboBox = QComboBox()
        univarButton.clicked.connect(self.showunivarinfo)
        self.polyfitCheck = QCheckBox(QApplication.translate("CheckBox", "Show",None))
        self.polyfitCheck.setFocusPolicy(Qt.NoFocus)
        self.polyfitCheck.clicked.connect(self.polyfit) #toggle
        self.result = QLineEdit()
        self.result.setReadOnly(True)
        self.result.setStyleSheet("background-color:'lightgrey';")
        startlabel = QLabel(QApplication.translate("Label", "Start",None))
        endlabel = QLabel(QApplication.translate("Label", "End",None))
        self.startEdit = QLineEdit()
        self.startEdit.setMaximumWidth(60)
        self.startEdit.setAlignment(Qt.AlignRight)
        self.endEdit = QLineEdit()
        self.endEdit.setMaximumWidth(60)
        self.endEdit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.startEdit.setValidator(QRegExpValidator(regextime,self))
        self.startEdit.setText("00:00")
        self.endEdit.setValidator(QRegExpValidator(regextime,self))
        if len(aw.qmc.timex) > 0:
            self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[-1]))
        else:
            self.endEdit.setText("00:00")
        # calculate event list
        self.events = self.eventlist()
        self.eventAComboBox = QComboBox()
        self.eventAComboBox.addItems([""] + [i[0] for i in self.events])
        self.eventAComboBox.setCurrentIndex(0)
        self.eventAComboBox.currentIndexChanged.connect(self.calcEventRC)
        self.eventBComboBox = QComboBox()
        self.eventBComboBox.addItems([i[0] for i in self.events] + [""])
        self.eventBComboBox.setCurrentIndex(len(self.events))
        self.eventBComboBox.currentIndexChanged.connect(self.calcEventRC)
        tab3Layout = QVBoxLayout()
        interLayout = QHBoxLayout()
        interLayout.addWidget(self.interpCheck)
        interLayout.addStretch()
        interLayout.addWidget(self.interpComboBox)
        interGroupLayout = QGroupBox(QApplication.translate("GroupBox","Interpolate",None))
        interGroupLayout.setLayout(interLayout)
        uniLayout = QHBoxLayout()
        uniLayout.addWidget(self.univarCheck)
        uniLayout.addStretch()
        uniLayout.addWidget(univarButton)
        univarGroupLayout = QGroupBox(QApplication.translate("GroupBox","Univariate",None))
        univarGroupLayout.setLayout(uniLayout)
        lnLayout = QHBoxLayout()
        lnLayout.addWidget(self.lnvarCheck)
        lnLayout.addWidget(self.lnresult)
        lnVLayout = QVBoxLayout()
        lnVLayout.addLayout(lnLayout)
        lnVLayout.addStretch()
        lnvarGroupLayout = QGroupBox(QApplication.translate("GroupBox","ln()",None))
        lnvarGroupLayout.setLayout(lnVLayout)
        expHLayout1 = QHBoxLayout()        
        expHLayout1.addWidget(self.expvarCheck)
        expHLayout1.addWidget(self.expresult)        
        expHLayout2 = QHBoxLayout()        
        expHLayout2.addWidget(self.expradiobutton1)
        expHLayout2.addWidget(self.expradiobutton2)
        expHLayout2.addWidget(self.exptimeoffsetLabel)
        expHLayout2.addWidget(self.exptimeoffset)
        expHLayout2.addStretch()
        expLayout = QVBoxLayout()
        expLayout.addLayout(expHLayout2)
        expLayout.addLayout(expHLayout1)
        expLayout.addWidget(self.bkgndButton)
        expvarGroupLayout = QGroupBox(QApplication.translate("GroupBox","Exponent",None))
        expvarGroupLayout.setLayout(expLayout)
        polytimes = QHBoxLayout()
        polytimes.addWidget(startlabel)
        polytimes.addWidget(self.startEdit)
        polytimes.addWidget(self.eventAComboBox)
        polytimes.addStretch()
        polytimes.addWidget(self.eventBComboBox)
        polytimes.addWidget(self.endEdit)
        polytimes.addWidget(endlabel)
        polyCurves = QHBoxLayout()
        polyCurves.addWidget(self.c1ComboBox)
        polyCurves.addStretch()
        polyCurves.addWidget(self.c2ComboBox)
        polyLayout = QHBoxLayout()
        polyLayout.addWidget(self.polyfitCheck)
        polyLayout.addStretch()
        polyLayout.addWidget(polyfitdeglabel)
        polyLayout.addWidget(self.polyfitdeg)
        polyVLayout = QVBoxLayout()
        polyVLayout.addLayout(polyLayout)
        polyVLayout.addLayout(polytimes)
        polyVLayout.addLayout(polyCurves)
        polyVLayout.addWidget(self.result)
        polyfitGroupLayout = QGroupBox(QApplication.translate("GroupBox","Polyfit",None))
        polyfitGroupLayout.setLayout(polyVLayout)
        interUniLayout = QHBoxLayout()
        interUniLayout.addWidget(interGroupLayout)
        interUniLayout.addWidget(univarGroupLayout)
        lnvarexpvarLayout = QHBoxLayout()
        lnvarexpvarLayout.addWidget(lnvarGroupLayout)
        lnvarexpvarLayout.addWidget(expvarGroupLayout)
        tab3Layout.addLayout(interUniLayout)
        tab3Layout.addLayout(lnvarexpvarLayout)
        tab3Layout.addWidget(polyfitGroupLayout)
        tab3Layout.addStretch()
        ##### TAB 4
        analyzeHLayout1 = QHBoxLayout()
        analyzeHLayout1.addWidget(self.curvefitcomboboxLabel)
        analyzeHLayout1.addWidget(self.curvefitcombobox)
        analyzeHLayout1.addStretch()
        analyzeHLayout1.addWidget(self.curvefittimeoffsetLabel)
        analyzeHLayout1.addWidget(self.curvefittimeoffset)
        analyzeGroupLayout1 = QGroupBox(QApplication.translate("GroupBox","Curve Fit Options",None))
        analyzeGroupLayout1.setLayout(analyzeHLayout1)

        analyzeHLayout2 = QHBoxLayout()
        analyzeHLayout2.addWidget(self.analyzecomboboxLabel)
        analyzeHLayout2.addWidget(self.analyzecombobox)
        analyzeHLayout2.addStretch()
        analyzeHLayout2.addWidget(self.analyzetimeoffsetLabel)
        analyzeHLayout2.addWidget(self.analyzetimeoffset)
        analyzeGroupLayout2 = QGroupBox(QApplication.translate("GroupBox","Interval of Interest Options",None))
        analyzeGroupLayout2.setLayout(analyzeHLayout2)

        flcrVLayout1 = QVBoxLayout()
        flcrVLayout1.addWidget(self.segmentsamplesthresholdLabel)
        flcrVLayout1.addWidget(self.segmentsamplesthreshold)
        flcrVLayout2 = QVBoxLayout()
        flcrVLayout2.addWidget(self.segmentdeltathresholdLabel)
        flcrVLayout2.addWidget(self.segmentdeltathreshold)
        
        flcrHLayout = QHBoxLayout()
        flcrHLayout.addLayout(flcrVLayout1)
        flcrHLayout.addStretch()
        flcrHLayout.addLayout(flcrVLayout2)
        flcrGroupLayout = QGroupBox(QApplication.translate("GroupBox","Analyze Options",None))
        flcrGroupLayout.setLayout(flcrHLayout)
        tab4Layout = QVBoxLayout()
        tab4Layout.addWidget(analyzeGroupLayout1)
        tab4Layout.addWidget(analyzeGroupLayout2)
        tab4Layout.addWidget(flcrGroupLayout)
        tab4Layout.addStretch()
        ##### TAB 5
        self.styleComboBox = QComboBox()
        available = list(map(str, list(QStyleFactory.keys())))
        self.styleComboBox.addItems(available)
        self.styleComboBox.setFocusPolicy(Qt.NoFocus)
        try:
            #pylint: disable=E1102
            self.styleComboBox.setCurrentIndex(list(map(lambda x:x.lower(),available)).index(aw.appearance.lower()))
        except Exception:
            pass
        self.styleComboBox.currentIndexChanged.connect(self.setappearance)
        self.resolutionSpinBox = QSpinBox()
        self.resolutionSpinBox.setRange(40,300)
        self.resolutionSpinBox.setSingleStep(5)
        self.resolutionSpinBox.setValue(aw.dpi)
        self.resolutionSpinBox.setFocusPolicy(Qt.NoFocus)
        resButton = QPushButton(QApplication.translate("Button","Set",None))
        resButton.setFocusPolicy(Qt.NoFocus)
        resButton.clicked.connect(lambda _:self.changedpi())
        self.soundCheck = QCheckBox(QApplication.translate("CheckBox", "Beep",None))
        self.soundCheck.setChecked(aw.soundflag) 
        self.soundCheck.setFocusPolicy(Qt.NoFocus)
        self.soundCheck.stateChanged.connect(self.soundset) #toggle
        appLayout1 = QHBoxLayout()
        appLayout1.addLayout(pathEffectsLayout)
        appLayout1.addStretch()
        appLayout1.addWidget(self.soundCheck)
        appLayout1.addStretch()
        appLayout1.addWidget(self.styleComboBox)
        appLayout2 = QHBoxLayout()
        appLayout2.addLayout(graphLayout)
        appLayout2.addStretch()
        appLayout2.addWidget(fontlabel)
        appLayout2.addWidget(self.GraphFont)
        appLayout = QVBoxLayout()
        appLayout.addLayout(appLayout1)
        appLayout.addLayout(appLayout2)
        appearanceGroupWidget = QGroupBox(QApplication.translate("GroupBox","Appearance",None))
        appearanceGroupWidget.setLayout(appLayout)
        graphLabel = QLabel(QApplication.translate("Tab","Graph",None))
        setresLayout = QHBoxLayout()
        setresLayout.addWidget(self.DecimalPlaceslcd)
        setresLayout.addSpacing(25)
        setresLayout.addStretch()
        setresLayout.addWidget(graphLabel)
        setresLayout.addWidget(self.resolutionSpinBox)
        setresLayout.addWidget(resButton)
        resolutionGroupWidget = QGroupBox(QApplication.translate("GroupBox","Resolution",None))
        resolutionGroupWidget.setLayout(setresLayout)
        # tick
        # port
        self.WebLCDsURL = QLabel()
        self.WebLCDsURL.setOpenExternalLinks(True)
        self.WebLCDsFlag = QCheckBox()
        self.WebLCDsFlag.setChecked(aw.WebLCDs)
        self.WebLCDsFlag.setFocusPolicy(Qt.NoFocus)
        self.WebLCDsPortLabel = QLabel(QApplication.translate("Label", "Port", None))
        self.WebLCDsPort = QLineEdit(str(aw.WebLCDsPort))
        self.WebLCDsPort.setAlignment(Qt.AlignRight)
        self.WebLCDsPort.setValidator(QRegExpValidator(QRegExp(r"^[0-9]{1,4}$"),self))
        self.WebLCDsPort.setMaximumWidth(45)
        self.QRpic = QLabel() # the QLabel holding the QR code image
        if aw.WebLCDs:
            try:
                self.setWebLCDsURL()
            except:
                self.WebLCDsURL.setText("")
                self.QRpic.setPixmap(QPixmap())
                aw.WebLCDs = False
        else:
            self.WebLCDsURL.setText("")
            self.QRpic.setPixmap(QPixmap())
        self.WebLCDsAlerts = QCheckBox(QApplication.translate("CheckBox", "Alarm Popups",None))
        self.WebLCDsAlerts.setChecked(aw.WebLCDsAlerts)
        self.WebLCDsAlerts.setFocusPolicy(Qt.NoFocus)
        if not aw.WebLCDs:
            self.WebLCDsAlerts.setDisabled(True)
        self.WebLCDsAlerts.stateChanged.connect(self.toggleWebLCDsAlerts) #toggle
        self.WebLCDsPort.editingFinished.connect(self.changeWebLCDsPort)
        self.WebLCDsFlag.clicked.connect(self.toggleWebLCDs)
        WebLCDsLayout = QHBoxLayout()
        WebLCDsLayout.addWidget(self.WebLCDsFlag)
        WebLCDsLayout.addWidget(self.WebLCDsPortLabel)
        WebLCDsLayout.addWidget(self.WebLCDsPort)
        WebLCDsLayout.addStretch()
        WebLCDsLayout.addWidget(self.WebLCDsURL)
        WebLCDsVLayout = QVBoxLayout()
        WebLCDsVLayout.addWidget(self.WebLCDsAlerts)
        WebLCDsVLayout.addStretch()
        WebLCDsLayoutHLayout = QHBoxLayout()
        WebLCDsLayoutHLayout.addLayout(WebLCDsVLayout)
        WebLCDsLayoutHLayout.addStretch()
        WebLCDsLayoutHLayout.addWidget(self.QRpic)
        WebLCDsLayoutVLayout = QVBoxLayout()
        WebLCDsLayoutVLayout.addLayout(WebLCDsLayout)
        WebLCDsLayoutVLayout.addLayout(WebLCDsLayoutHLayout)
        WebLCDsGroupWidget = QGroupBox(QApplication.translate("GroupBox","WebLCDs",None))
        WebLCDsGroupWidget.setLayout(WebLCDsLayoutVLayout)

        # Renaming BT and ET
        self.renameETLabel = QLabel(QApplication.translate("Label", "ET", None))
        self.renameETLine = QLineEdit(aw.ETname)
        self.renameETLine.editingFinished.connect(self.renameET)
        self.renameBTLabel = QLabel(QApplication.translate("Label", "BT", None))
        self.renameBTLine = QLineEdit(aw.BTname)
        self.renameBTLine.editingFinished.connect(self.renameBT)
        renameLayout = QHBoxLayout()
        renameLayout.addWidget(self.renameETLabel)
        renameLayout.addWidget(self.renameETLine)
        renameLayout.addStretch()
        renameLayout.addWidget(self.renameBTLabel)
        renameLayout.addWidget(self.renameBTLine)
        renameGroupWidget = QGroupBox(QApplication.translate("GroupBox", "Rename ET and BT",None))
        renameGroupWidget.setLayout(renameLayout)
        #watermark image
        self.logopathedit = QLineEdit(aw.qmc.backgroundpath)
        self.logopathedit.setStyleSheet("background-color:'lightgrey';")
        self.logopathedit.setReadOnly(True)
        self.logopathedit.setFocusPolicy(Qt.NoFocus)
        self.logopathedit.setText(aw.logofilename)
        logoalphalabel = QLabel(QApplication.translate("Label","Opacity", None))
        self.logoalpha = MyQDoubleSpinBox()
        self.logoalpha.setDecimals(1)
        self.logoalpha.setSingleStep(0.5)
        self.logoalpha.setRange(0.,10.)
        self.logoalpha.setValue(aw.logoimgalpha)
        self.logoalpha.setMinimumWidth(50)
        self.logoalpha.setAlignment(Qt.AlignRight)
        self.logoalpha.editingFinished.connect(self.changelogoalpha)
        logoshowCheck = QCheckBox(QApplication.translate("CheckBox", "Hide Image During Roast",None))
        logoshowCheck.setChecked(aw.logoimgflag)
        logoshowCheck.setFocusPolicy(Qt.NoFocus)
        logoshowCheck.stateChanged.connect(self.changelogoshowCheck)
        loadButton = QPushButton(QApplication.translate("Button","Load", None))
        loadButton.setFocusPolicy(Qt.NoFocus)
        delButton = QPushButton(QApplication.translate("Button","Delete", None))
        delButton.setFocusPolicy(Qt.NoFocus)
        loadButton.clicked.connect(self.logofileload)
        delButton.clicked.connect(self.logofiledelete)
        logofileLayout = QHBoxLayout()
        logofileLayout.addWidget(self.logopathedit)
        logofileLayout.addWidget(logoalphalabel)
        logofileLayout.addWidget(self.logoalpha)
        logobuttonsLayout = QHBoxLayout()
        logobuttonsLayout.addWidget(loadButton)
        logobuttonsLayout.addWidget(delButton)
        logobuttonsLayout.addStretch()
        logobuttonsLayout.addWidget(logoshowCheck)
        logoLayout = QVBoxLayout()
        logoLayout.addLayout(logofileLayout)
        logoLayout.addLayout(logobuttonsLayout)
        logofileGroupWidget = QGroupBox(QApplication.translate("GroupBox", "Logo Image File",None))
        logofileGroupWidget.setLayout(logoLayout)
        tab5Layout = QVBoxLayout()
        tab5Layout.addWidget(appearanceGroupWidget)
        tab5Layout.addWidget(resolutionGroupWidget)
        tab5Layout.addWidget(WebLCDsGroupWidget)
        tab5Layout.addWidget(renameGroupWidget)
        tab5Layout.addStretch()
        tab5Layout.addWidget(logofileGroupWidget)
        tab5Layout.addStretch()

        ############################  TABS LAYOUT
        TabWidget = QTabWidget()
        C0Widget = QWidget()
        C0Widget.setLayout(tab0Layout)
        tab0Layout.setContentsMargins(10,10,10,10)
        C0Widget.setContentsMargins(0,10,0,10)
        TabWidget.addTab(C0Widget,QApplication.translate("Tab","RoR",None))
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        tab1Layout.setContentsMargins(10,10,10,10)
        C1Widget.setContentsMargins(0,10,0,10)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","Filters",None))
        C11Widget = QWidget()
        C11Widget.setLayout(tab11Layout)
        tab11Layout.setContentsMargins(10,10,10,10)
        C11Widget.setContentsMargins(0,10,0,10)
        TabWidget.addTab(C11Widget,QApplication.translate("Tab","HUD",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        tab2Layout.setContentsMargins(10,10,10,10)
        C2Widget.setContentsMargins(0,0,0,0)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Plotter",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        tab3Layout.setContentsMargins(10,10,10,10)
        C3Widget.setContentsMargins(0,0,0,0)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Math",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        tab4Layout.setContentsMargins(10,10,10,10)
        C3Widget.setContentsMargins(0,0,0,0)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Analyze",None))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        tab5Layout.setContentsMargins(10,10,10,10)
        C5Widget.setContentsMargins(0,10,0,0)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","UI",None))
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(self.dialogbuttons)
        #incorporate layouts
        Slayout = QVBoxLayout()
        Slayout.addWidget(TabWidget,1)
        Slayout.addStretch()
        Slayout.addLayout(buttonsLayout)
        Slayout.setSizeConstraint(QLayout.SetFixedSize)
        TabWidget.currentChanged.connect(self.tabSwitched)
        self.setLayout(Slayout)
        
        TabWidget.setContentsMargins(0,0,0,0)
        Slayout.setContentsMargins(5,15,5,5)
        Slayout.setSpacing(5)

        self.updatePlotterleftlabels()  
         
        self.startEdit.editingFinished.connect(self.polyfitcurveschanged)
        self.endEdit.editingFinished.connect(self.polyfitcurveschanged)
        self.polyfitdeg.valueChanged.connect(self.polyfitcurveschanged)
        self.c1ComboBox.currentIndexChanged.connect(self.polyfitcurveschanged)
        self.c2ComboBox.currentIndexChanged.connect(self.polyfitcurveschanged)
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    @pyqtSlot(bool)
    def fittoBackground(self,_):
        if len(self.expresult.text()) > 0:
            aw.deleteBackground
            self.setbackgroundequ1(mathequ=True)
            QApplication.processEvents()  #occasionally the fit curve remains showing.
            aw.qmc.redraw(recomputeAllDeltas=True)
            #self.updatetargets()  #accept and close dialog
        else:
            return
    
    @pyqtSlot(int)
    def changeAnalyzecombobox(self,i):
        aw.qmc.analysisstartchoice = i
        if i == 2:  # Custom
            self.analyzetimeoffset.setEnabled(True)
        else:
            self.analyzetimeoffset.setEnabled(False)
        return
        
    @pyqtSlot()
    def analyzetimeoffsetChanged(self):
        try:
            aw.qmc.analysisoffset = int(self.analyzetimeoffset.text())
        except:
            pass
        return
        
    @pyqtSlot(int)
    def changeCurvefitcombobox(self,i):
        aw.qmc.curvefitstartchoice = i
        if i == 2:  # Custom
            self.curvefittimeoffset.setEnabled(True)
        else:
            self.curvefittimeoffset.setEnabled(False)
        return
        
    @pyqtSlot()
    def segmentsamplesthresholdChanged(self):
        aw.qmc.segmentsamplesthreshold = int(self.segmentsamplesthreshold.text())
        return
        
    @pyqtSlot()
    def segmentdeltathresholdChanged(self):
        aw.qmc.segmentdeltathreshold = aw.float2float(toFloat(self.segmentdeltathreshold.text(),),4)
        return
        
    @pyqtSlot()
    def curvefittimeoffsetChanged(self):
        try:
            aw.qmc.curvefitoffset = int(self.curvefittimeoffset.text())
        except:
            pass
        return
        
    @pyqtSlot()
    def exptimeoffsetChanged(self):
        self.expvarCheck.setChecked(False)
        self.expvar(0)
        self.expvarCheck.setChecked(True)
        self.expvar(0)
    
    @pyqtSlot(bool)
    def expradiobuttonClicked(self,_=False):
        self.expradioButton = self.sender()
        if self.expradioButton.isChecked():
            self.exppower = self.expradioButton.power
            self.expvarCheck.setChecked(False)
            self.expvar(0)
            self.expvarCheck.setChecked(True)
            self.expvar(0)

    #watermark image
    @pyqtSlot(bool)
    def logofileload(self,_):
        aw.qmc.logoloadfile()
        self.logopathedit.setText(u(aw.logofilename))
        # note the logo is only visible after a full redraw
    
    @pyqtSlot(bool)
    def logofiledelete(self,_):
        self.logopathedit.setText("")
        aw.logofilename = ""
        aw.qmc.redraw(recomputeAllDeltas=False)
    
    @pyqtSlot()
    def changelogoalpha(self):
        aw.logoimgalpha = self.logoalpha.value()
        aw.qmc.redraw(recomputeAllDeltas=False)
    
    @pyqtSlot(int)
    def changelogoshowCheck(self,_):
        aw.logoimgflag = not aw.logoimgflag

    @pyqtSlot()
    def renameBT(self):
        aw.BTname = str(self.renameBTLine.text()).strip()
        if aw.BTname == "":
            aw.BTname = QApplication.translate("Label", "BT")
        aw.label3.setText("<big><b>" + aw.BTname + "</b></big>")
        aw.label5.setText(deltaLabelBigPrefix + aw.BTname + "</b></big>")

    @pyqtSlot()
    def renameET(self):
        aw.ETname = str(self.renameETLine.text()).strip()
        if aw.ETname == "":
            aw.ETname = QApplication.translate("Label", "ET")
        aw.label2.setText("<big><b>" + aw.ETname + "</b></big>")
        aw.label4.setText(deltaLabelBigPrefix + aw.ETname + "</b></big>")

    @pyqtSlot(int)
    def toggleWebLCDsAlerts(self,_):
        aw.WebLCDsAlerts = not aw.WebLCDsAlerts
    
    @pyqtSlot()
    def changeWebLCDsPort(self):
        aw.WebLCDsPort = int(str(self.WebLCDsPort.text()))
        
    def setWebLCDsURL(self):
        url_str = self.getWebLCDsURL()
        # set URL label
        self.WebLCDsURL.setText('<a href="' + url_str + '">' + url_str + '</a>')
        # set QR label 
        from artisanlib.qrcode import QRlabel
        qr = QRlabel(url_str)
        self.QRpic.setPixmap(qr.make_image().pixmap())
        
    def getWebLCDsURL(self):
        import socket
        localIP = [(s.connect(('8.8.8.8', 80)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]
        return 'http://' + str(localIP) + ':' + str(aw.WebLCDsPort) + '/artisan'

    @pyqtSlot(bool)
    def toggleWebLCDs(self,b):
        if b:
            try:
                res = aw.startWebLCDs()
                if not res:
                    self.WebLCDsPort.setDisabled(False)
                    self.WebLCDsURL.setText("")
                    self.QRpic.setPixmap(QPixmap())
                    self.WebLCDsFlag.setChecked(False)
                    self.WebLCDsAlerts.setDisabled(True)
                else:
                    self.setWebLCDsURL() # this might fail if socket cannot be established
                    self.WebLCDsAlerts.setDisabled(False)
                    self.WebLCDsPort.setDisabled(True)
                    self.WebLCDsFlag.setChecked(True)
            except Exception as e:
                aw.sendmessage(str(e))
                self.WebLCDsAlerts.setDisabled(True)
                self.WebLCDsFlag.setChecked(False)
                self.WebLCDsPort.setDisabled(False)
                self.WebLCDsURL.setText("")
                self.QRpic.setPixmap(QPixmap())
                aw.WebLCDs = False
        else:   
            self.WebLCDsAlerts.setDisabled(True)
            self.WebLCDsFlag.setChecked(False)
            self.WebLCDsPort.setDisabled(False)
            self.WebLCDsURL.setText("")
            self.QRpic.setPixmap(QPixmap())
            aw.stopWebLCDs()
    
    @pyqtSlot(int)
    def showHUDbuttonToggle(self,i):
        if i:
            aw.qmc.HUDbuttonflag = True
            if not app.artisanviewerMode:
                aw.button_18.setVisible(True)
        else:
            aw.qmc.HUDbuttonflag = False
            aw.button_18.setVisible(False)

    def changedpi(self):
        try:
            value = self.resolutionSpinBox.value()
            aw.setdpi(value)
            QApplication.processEvents()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " changedpi(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def setcurvecolor0(self,_=False):
        self.setcurvecolor(0)
    @pyqtSlot(bool)
    def setcurvecolor1(self,_=False):
        self.setcurvecolor(1)
    @pyqtSlot(bool)
    def setcurvecolor2(self,_=False):
        self.setcurvecolor(2)
    @pyqtSlot(bool)
    def setcurvecolor3(self,_=False):
        self.setcurvecolor(3)
    @pyqtSlot(bool)
    def setcurvecolor4(self,_=False):
        self.setcurvecolor(4)
    @pyqtSlot(bool)
    def setcurvecolor5(self,_=False):
        self.setcurvecolor(5)
    @pyqtSlot(bool)
    def setcurvecolor6(self,_=False):
        self.setcurvecolor(6)
    @pyqtSlot(bool)
    def setcurvecolor7(self,_=False):
        self.setcurvecolor(7)
    @pyqtSlot(bool)
    def setcurvecolor8(self,_=False):
        self.setcurvecolor(8)
        
    def setcurvecolor(self,x):
        try:
            colorf = aw.colordialog(QColor(aw.qmc.plotcurvecolor[x]))
            if colorf.isValid():
                colorname = str(colorf.name())
                aw.qmc.plotcurvecolor[x] = colorname
                #refresh right color labels
                self.equc1colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[0])
                self.equc2colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[1])
                self.equc3colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[2])
                self.equc4colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[3])
                self.equc5colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[4])
                self.equc6colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[5])
                self.equc7colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[6])
                self.equc8colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[7])
                self.equc9colorlabel.setStyleSheet("background-color:'%s';"%aw.qmc.plotcurvecolor[8])

            self.plotequ()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setcurvecolor(): {0}").format(str(e)),exc_tb.tb_lineno)

    def update_equbuttons(self):
        self.equvdevicebutton.setFocusPolicy(Qt.NoFocus)
        if len(aw.qmc.timex) < 2: # empty profile
            self.equvdevicebutton.setEnabled(True)
            self.equvdevicebutton.setText(QApplication.translate("Button","ET/BT",None))
            self.equvdevicebutton.setToolTip(QApplication.translate("Tooltip","Add P1 and P2 as ET and BT",None))
        else:
            self.equvdevicebutton.setText(QApplication.translate("Button","Create Virtual\nExtra Device",None))
            if len(aw.qmc.extradevices) < aw.nLCDS:  #not at maximimum of virtual devices
                self.equvdevicebutton.setEnabled(True)
                self.equvdevicebutton.setToolTip(QApplication.translate("Tooltip","Add P1 and P2 as:\n\n1 an Extra virtual device if a profile is loaded\n2 or ET and BT if profile is not loaded\n",None))
            else:
                self.equvdevicebutton.setEnabled(False)
                self.equvdevicebutton.setToolTip(QApplication.translate("Tooltip","No more Virtual Extra Devices available",None))
        if aw.qmc.flagon:
            self.equvdevicebutton.setEnabled(False)
            self.equvdevicebutton.setToolTip(QApplication.translate("Tooltip","Not available during recording",None))
            self.equbackgroundbutton.setEnabled(False)
            self.equbackgroundbutton.setToolTip(QApplication.translate("Tooltip","Not available during recording",None))
        else:
            self.equbackgroundbutton.setEnabled(True)
            self.equbackgroundbutton.setToolTip(QApplication.translate("Tooltip","Set P1 as ET background B1\nSet P2 as BT background B2\nNote: Erases all existing background curves.",None))                

        if self.equvdevicebutton.isEnabled():
            self.equvdevicebutton.clicked.connect(self.setvdevice)
        else:
            try:
                self.equvdevicebutton.disconnect()
            except:
                pass
   
    @pyqtSlot(bool)
    def setvdevice(self,_):
        # compute values
        if len(aw.qmc.timex) < 2: # empty profile
            # we use the background function to set it to ET/BT
            self.setbackgroundequ1(foreground=True)
        else:
            # Check for incompatible vars from in the equations
            EQU = [str(self.equedit1.text()),str(self.equedit2.text())]
            incompatiblevars = ["P","F","$","#"]
            error = ""
            for i in range(len(incompatiblevars)):
                if incompatiblevars[i] in EQU[0]:
                    error = "P1: \n-%s\n\n[%s]"%(incompatiblevars[i],EQU[0])
                elif incompatiblevars[i] in EQU[1]:
                    error = "P2: \n%-s\n\n[%s]"%(incompatiblevars[i],EQU[1])
                    
            if error:
                string = QApplication.translate("Message","Incompatible variables found in %s"%error, None)
                QMessageBox.warning(self,QApplication.translate("Message","Assignment problem", None),string,
                                    QMessageBox.Discard)
                
            else:
                for e in range(2):
                    #create y range
                    y_range = []
                    if aw.qmc.timeindex[0] > -1:
                        toff = aw.qmc.timex[aw.qmc.timeindex[0]]
                    else:
                        toff = 0
                    for i in range(len(aw.qmc.timex)):
                        y_range.append(aw.qmc.eval_math_expression(EQU[e],aw.qmc.timex[i],t_offset=toff))
                    if e:
                        extratemp2 = y_range
                    else:
                        extratemp1 = y_range
                # add device
                aw.addDevice() 
                aw.qmc.extradevices[-1] = 25
                
                # set colors
                aw.qmc.extradevicecolor1[-1] = aw.qmc.plotcurvecolor[0]
                aw.qmc.extradevicecolor2[-1] = aw.qmc.plotcurvecolor[1]
                # set expressions
                aw.qmc.extramathexpression1[-1] = str(self.equedit1.text())
                aw.qmc.extramathexpression2[-1] = str(self.equedit2.text())
                # set values
                aw.qmc.extratemp1[-1] = extratemp1
                aw.qmc.extratemp2[-1] = extratemp2
                aw.qmc.extratimex[-1] = aw.qmc.timex[:]
                # redraw
                aw.qmc.redraw(recomputeAllDeltas=False)

                aw.sendmessage(QApplication.translate("Message","New Extra Device: virtual: y1(x) =[%s]; y2(x)=[%s]"%(EQU[0],EQU[1]), None))

        aw.calcVirtualdevices()
        self.update_equbuttons()

    @pyqtSlot(bool)
    def equshowtable(self,_=False):        
        equdataDlg = equDataDlg(self)
        equdataDlg.resize(500, 500)
        equdataDlg.show()
        equdataDlg.activateWindow()

    @pyqtSlot(bool)
    def setbackgroundequ1_slot(self,_):
        self.setbackgroundequ1()
        
    def setbackgroundequ1(self,foreground=False, mathequ=False):
        EQU = [str(self.equedit1.text()),str(self.equedit2.text())]
        if mathequ:
            EQU = [str(""),str(self.expresult.text())]
        aw.qmc.analysisresultsstr = ""
        aw.setbackgroundequ(foreground=foreground, EQU=EQU)

    def updatePlotterleftlabels(self):
        if len(aw.qmc.plotterequationresults[0]):
            self.equc1label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc1label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[1]):
            self.equc2label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc2label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[2]):
            self.equc3label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc3label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[3]):
            self.equc4label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc4label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[4]):
            self.equc5label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc5label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[5]):
            self.equc6label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc6label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[6]):
            self.equc7label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc7label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[7]):
            self.equc8label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc8label.setStyleSheet("background-color:'transparent';")
        if len(aw.qmc.plotterequationresults[8]):
            self.equc9label.setStyleSheet("background-color:'lightgrey';")
        else:
            self.equc9label.setStyleSheet("background-color:'transparent';")


    # format = annotate(text,time,temp,size)
    # eg annotation = 'annotate(H,03:00,200,10)'
    def plotterannotation(self,annotation,cindex):      
        try:        
            annotation = annotation.strip()
            if len(annotation) > 20:
                annotation = annotation[9:]                # annotate(
                annotation = annotation[:len(annotation)-1] # )
                annvars = [e.strip() for e in annotation.split(',')]
                text = annvars[0]
                if aw.qmc.timeindex[0] != -1 and len(aw.qmc.timex):
                    time = float(aw.qmc.stringtoseconds(annvars[1])+ aw.qmc.timex[aw.qmc.timeindex[0]])
                else:
                    time = float(aw.qmc.stringtoseconds(annvars[1]))
                temp = float(annvars[2])
                fsize = 12
                try:
                    fsize = int(annvars[3])
                except:
                    pass
                anno = aw.qmc.ax.annotate(text, xy=(time,temp),xytext=(time,temp),alpha=5.,color=aw.qmc.plotcurvecolor[cindex],fontsize=fsize)
                try:
                    anno.set_in_layout(False)  # remove text annotations from tight_layout calculation
                except: # mpl before v3.0 do not have this set_in_layout() function
                    pass
            else:
                aw.qmc.plottermessage = QApplication.translate("Error Message","Plotter: incorrect syntax: annotate(text,time,temperature,fontsize)", None)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " annotate() syntax: {0}").format(str(e)),exc_tb.tb_lineno)

    def plotterb(self):
        try:
            aw.sendmessage("Dropping beans...")
            colorb = ["#996633","#4d2600","#4b4219","black","#4b3219","#996633","#281a0d"]
            for _ in range(3): # number of bean layers (each a randomly different color)
                x = aw.qmc.endofx*numpy.random.rand(aw.qmc.endofx/6)
                y = aw.qmc.ylimit*numpy.random.rand(aw.qmc.endofx/6)
                aw.qmc.ax.plot(x,y,'o',color=colorb[int(round(6*numpy.random.rand(1)[0]))])
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " plotterb() syntax: {0}").format(str(e)),exc_tb.tb_lineno)

    def plotterprogram(self,program,e):
        try:
            #remove enclosing brackets {}
            program = program[1:len(program)-1]
            
            #"if 2 > 1: a = \"OXXX\"; print a"
            p = compile(program,"a","exec")
            exec(p)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " plotterprogram(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def plotequ(self,_=False):
        try:
            aw.qmc.plotterstack = [0]*10
            aw.qmc.plottermessage = ""
            aw.clearMessageLine()

            aw.qmc.plotterequationresults = [[],[],[],[],[],[],[],[],[]]
            EQU = [str(self.equedit1.text()),str(self.equedit2.text()),
                   str(self.equedit3.text()),str(self.equedit4.text()),
                   str(self.equedit5.text()),str(self.equedit6.text()),
                   str(self.equedit7.text()),str(self.equedit8.text()),
                   str(self.equedit9.text())]
            aw.qmc.resetlines()

            commentoutplot = [0]*9      # "#" as first char does not evaluate plot nor show it. Allows to keep formula on window without eval (ie. long filters)
            hideplot = [0]*9            # "$" as first char evaluates plot but does not show it. Useful to hide intermediate results

            # 9 plots
            for e in range(9):
                eqs = EQU[e].strip()
                if eqs:
                    if eqs[0] == "$":
                        hideplot[e] = 1
                        eqs = eqs[1:] #removes "$"
                    if eqs[0] == "#":
                        commentoutplot[e] = 1
                    #commands
                    if len(eqs) > 10 and eqs[:9] == "annotate(":
                        commentoutplot[e] = 1
                        self.plotterannotation(eqs,e)
                    if len(eqs) > 4 and eqs[:5] == "beans":
                        commentoutplot[e] = 1
                        self.plotterb()
                    if eqs[0] == "{" and eqs[len(eqs)-1] == "}":
                        self.plotterprogram(eqs,e)

                    toff = 0
                    #create x range and set the time offset generated by CHARGE
                    if len(aw.qmc.timex):
                        x_range = aw.qmc.timex
                        if aw.qmc.timeindex[0] > -1:
                            toff = aw.qmc.timex[aw.qmc.timeindex[0]]
                    elif len(aw.qmc.timeB):
                        x_range = aw.qmc.timeB
                        if aw.qmc.timeindexB[0] > -1:
                            toff = aw.qmc.timeB[aw.qmc.timeindexB[0]]
                    else:
                        x_range = list(range(int(aw.qmc.startofx),int(aw.qmc.endofx)))
                    #create y range
                    y_range = []

                    if not commentoutplot[e]:
                        for i in range(len(x_range)):
                            y_range.append(aw.qmc.eval_math_expression(eqs,x_range[i],equeditnumber=e+1,t_offset=toff)) #pass e+1 = equeditnumber(1-9)
                        if not hideplot[e]:
                            aw.qmc.ax.plot(x_range, y_range, color=aw.qmc.plotcurvecolor[e], linestyle = '-', linewidth=1)
                    
            aw.qmc.fig.canvas.draw()
            self.updatePlotterleftlabels()
            self.equlabel.setText(aw.qmc.plottermessage)

        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " plotequ(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(int)
    def setappearance(self,_):
        try:
            app.setStyle(str(self.styleComboBox.currentText()))
            aw.appearance = str(self.styleComboBox.currentText()).lower()
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setappearance(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def showunivarinfo(self,_):
        if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6]:
            aw.qmc.univariateinfo()
        else:
            aw.sendmessage(QApplication.translate("Univariate: no profile data available", None))
    
    @pyqtSlot(int)
    def lnvar(self,_):
        if self.lnvarCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[0] > -1:
                try:
                    curvefit_starttime = int(self.exptimeoffset.text()) + aw.qmc.timex[aw.qmc.timeindex[0]]
                except:
                    curvefit_starttime = 0
                res = aw.qmc.lnRegression(curvefit_starttime=curvefit_starttime)
                self.lnresult.setText(res)
            else:
                aw.sendmessage(QApplication.translate("Error Message", "ln(): no profile data available", None))
                self.lnvarCheck.setChecked(False)
                self.lnresult.setText("")
        else:
            self.lnresult.setText("")
            aw.qmc.resetlines()
            self.redraw_enabled_math_curves()

    @pyqtSlot(int)
    def expvar(self,_):
        if self.expvarCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6]:
                try:
                    curvefit_starttime = int(self.exptimeoffset.text()) + aw.qmc.timex[aw.qmc.timeindex[0]]
                except:
                    curvefit_starttime = 0
                res = aw.qmc.lnRegression(power=self.exppower, curvefit_starttime=curvefit_starttime)
                self.expresult.setText(res)
                self.bkgndButton.setEnabled(True)                
            else:
                aw.sendmessage(QApplication.translate("Error Message", "expvar(): no profile data available", None))
                self.expvarCheck.setChecked(False)
                self.expresult.setText("")
                self.bkgndButton.setEnabled(False)
        else:
            self.expresult.setText("")
            aw.qmc.resetlines()
            self.redraw_enabled_math_curves()
            self.bkgndButton.setEnabled(False)
    
    @pyqtSlot(int)
    def univar(self,_):
        if self.univarCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6]:
                aw.qmc.univariate()
            else:
                aw.sendmessage(QApplication.translate("Error Message", "Univariate: no profile data available", None))
                self.univarCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            self.redraw_enabled_math_curves()

    def redraw_enabled_math_curves(self):
        if self.interpCheck.isChecked():
            aw.qmc.drawinterp(str(self.interpComboBox.currentText()))
        if self.univarCheck.isChecked():
            aw.qmc.univariate()
        if self.lnvarCheck.isChecked():
            self.lnvar(0)
        if self.expvarCheck.isChecked():
            self.expvar(0)
        if self.polyfitCheck.isChecked():
            self.doPolyfit()
        if not self.polyfitCheck.isChecked() and not self.expvarCheck.isChecked() and not self.lnvarCheck.isChecked() and not self.univarCheck.isChecked() and not self.interpCheck.isChecked():
            aw.qmc.resetlines()
            aw.qmc.redraw(recomputeAllDeltas=False)
            
    @pyqtSlot(int)
    def calcEventRC(self,_):
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        
        Aevent = int(self.eventAComboBox.currentIndex())
        if Aevent == 0:
            a = 0
        else:
            a = self.events[Aevent-1][1]
                        
        Bevent = int(self.eventBComboBox.currentIndex())
        if Bevent == len(self.events):
            b = len(aw.qmc.timex) - 1
        else:
            b = self.events[Bevent][1]
        self.startEdit.setDisabled(True)
        self.startEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[a] - start))
        self.startEdit.setDisabled(False)
        self.endEdit.setDisabled(True)
        self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[b] - start))
        self.endEdit.setDisabled(False)
        self.polyfitcurveschanged(0)

    def eventlist(self):
        events = []
        if aw.qmc.timeindex[0] > -1:
            events.append(("CHARGE",aw.qmc.timeindex[0]))
        names = [
            QApplication.translate("Table", "DRY END",None),
            QApplication.translate("Table", "FC START",None),
            QApplication.translate("Table", "FC END",None),
            QApplication.translate("Table", "SC START",None),
            QApplication.translate("Table", "SC END",None),
            QApplication.translate("Table", "DROP",None),
            QApplication.translate("Table", "COOL",None)]
        for e in range(len(names)):
            if aw.qmc.timeindex[e+1]:
                events.append((names[e],aw.qmc.timeindex[e+1]))
        for e in range(len(aw.qmc.specialevents)):
            events.append((str("Event " + str(e+1)),aw.qmc.specialevents[e]))
        return events

    def doPolyfit(self):
        l = min(len(aw.qmc.timex),len(self.curves[self.c1ComboBox.currentIndex()]),len(self.curves[self.c2ComboBox.currentIndex()]))
        starttime = aw.qmc.stringtoseconds(str(self.startEdit.text()))
        endtime = aw.qmc.stringtoseconds(str(self.endEdit.text()))
        if starttime == -1 or endtime == -1:
            self.result.setText("")
            self.result.repaint()
            return
        if  endtime > aw.qmc.timex[-1] or endtime < starttime:
            self.result.setText("")
            self.result.repaint()
            return
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        startindex = aw.qmc.time2index(starttime + start)
        endindex = min(l,aw.qmc.time2index(endtime + start))
        c1 = [numpy.nan if x == -1 else x for x in self.curves[self.c1ComboBox.currentIndex()] ]
        c1 = numpy.array(c1,dtype='float64')
        c2 = [numpy.nan if x == -1 else x for x in self.curves[self.c2ComboBox.currentIndex()] ]
        c2 = numpy.array(c2,dtype='float64')
        idx = numpy.isfinite(c1) & numpy.isfinite(c2)
        z = aw.qmc.polyfit(c1[idx], c2[idx], # c1,c2,
               self.polyfitdeg.value(),startindex,endindex,self.deltacurves[self.c2ComboBox.currentIndex()])
        res = True
        if z is not None:
            for e in z:
                if numpy.isnan(e):
                    res = False
                    return False
        if res and z is not None:
            s = aw.fit2str(z)
            self.result.setText(s)
            self.result.repaint()
            return True
        else:
            self.result.setText("")
            self.result.repaint()
            return False

    @pyqtSlot()
    @pyqtSlot(int)
    def polyfitcurveschanged(self,_):
        self.polyfitdeg.blockSignals(True)
        self.polyfitdeg.setDisabled(True)
        self.startEdit.blockSignals(True)
        self.startEdit.setDisabled(True)
        self.endEdit.blockSignals(True)
        self.endEdit.setDisabled(True)
        try:
            if self.polyfitCheck.isChecked() and len(aw.qmc.timex) > 2:
                QApplication.processEvents()
                res = self.doPolyfit()
                if not res:
                    self.polyfitCheck.setChecked(False)
                    self.result.setText("")
                    self.result.repaint()
                    aw.qmc.resetlines()
                QApplication.processEvents()
            else:
                self.polyfitCheck.setChecked(False)
                self.result.setText("")
                self.result.repaint()
                aw.qmc.resetlines()
        except Exception:
            pass
        self.startEdit.setDisabled(False)
        self.startEdit.blockSignals(False)
        self.endEdit.setDisabled(False)
        self.endEdit.blockSignals(False)
        self.polyfitdeg.setDisabled(False)
        self.polyfitdeg.blockSignals(False)
        self.polyfitdeg.setFocus()

    @pyqtSlot(int)
    def tabSwitched(self,i):
        self.closeHelp()
        if i != 4:
            if self.polyfitCheck.isChecked():
                self.polyfitCheck.setChecked(False)
            if self.expvarCheck.isChecked():
                self.expvarCheck.setChecked(False)
            if self.lnvarCheck.isChecked():
                self.lnvarCheck.setChecked(False)
            if self.interpCheck.isChecked():
                self.interpCheck.setChecked(False)
            if self.univarCheck.isChecked():
                self.univarCheck.setChecked(False)
        else:
            self.collectCurves()

    # TODO: add background curves temp1B, temp2B, timeB, delta1B, delta2B (could be of different size!)
    def collectCurves(self):
        idx = 0
        self.curves = []
        self.curvenames = []
        self.deltacurves = [] # list of flags. True if delta curve, False otherwise
        if aw.qmc.DeltaETflag:
            self.curvenames.append(deltaLabelUTF8 + QApplication.translate("Label","ET",None))
            self.curves.append(aw.qmc.delta1)
            self.deltacurves.append(True)
            idx = idx + 1
        if aw.qmc.DeltaBTflag:
            self.curvenames.append(deltaLabelUTF8 + QApplication.translate("Label","BT",None))
            self.curves.append(aw.qmc.delta2)
            self.deltacurves.append(True)
            idx = idx + 1
        self.curvenames.append(QApplication.translate("ComboBox","ET",None))
        self.curvenames.append(QApplication.translate("ComboBox","BT",None))
        self.curves.append(aw.qmc.temp1)
        self.curves.append(aw.qmc.temp2)
        self.deltacurves.append(False)
        self.deltacurves.append(False)
        for i in range(len(aw.qmc.extradevices)):
            self.curvenames.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            self.curvenames.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
            self.curves.append(aw.qmc.extratemp1[i])
            self.curves.append(aw.qmc.extratemp2[i])
            self.deltacurves.append(False)
            self.deltacurves.append(False)
        self.c1ComboBox.setDisabled(True) #blockSignals(True)
        self.c2ComboBox.setDisabled(True) #blockSignals(True)
        self.c1ComboBox.clear()
        self.c1ComboBox.addItems(self.curvenames)
        self.c2ComboBox.clear()
        self.c2ComboBox.addItems(self.curvenames)
        self.c1ComboBox.setDisabled(False) #blockSignals(False)
        self.c2ComboBox.setDisabled(False) #blockSignals(False)
        self.c1ComboBox.setCurrentIndex(idx)
        self.c2ComboBox.setCurrentIndex(idx+1)

    @pyqtSlot(bool)
    def polyfit(self,_):
        try:
            if self.polyfitCheck.isChecked():
                #check for finished roast
                if len(aw.qmc.timex) > 2:
                    res = self.doPolyfit()
                    if not res:
                        self.polyfitCheck.setChecked(False)
                        aw.qmc.resetlines()
                        self.redraw_enabled_math_curves()
                else:
                    aw.sendmessage(QApplication.translate("Error Message", "Polyfit: no profile data available", None))
                    self.polyfitCheck.setChecked(False)
            else:
                self.result.setText("")
                self.result.repaint()
                aw.qmc.resetlines()
                self.redraw_enabled_math_curves()
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass
    
    @pyqtSlot(int)
    def interpolation(self,_=0):
        mode = str(self.interpComboBox.currentText())
        if self.interpCheck.isChecked():
            #check for finished roast
            if aw.qmc.timeindex[6]:
                aw.qmc.drawinterp(mode)
            else:
                aw.sendmessage(QApplication.translate("Message","Interpolation failed: no profile available", None))
                self.interpCheck.setChecked(False)
        else:
            aw.qmc.resetlines()
            self.redraw_enabled_math_curves()

    @pyqtSlot(int)
    def soundset(self,_):
        if aw.soundflag == 0:
            aw.soundflag = 1
            aw.sendmessage(QApplication.translate("Message","Sound turned ON", None))
            aw.soundpop()
        else:
            aw.soundflag = 0
            aw.sendmessage(QApplication.translate("Message","Sound turned OFF", None))

    @pyqtSlot(int)
    def changeDeltaET(self,_=0):
        aw.qmc.DeltaETflag = not aw.qmc.DeltaETflag
        if aw.qmc.crossmarker:
            aw.qmc.togglecrosslines() # turn crossmarks off to adjust for new coordinate system
        aw.qmc.redraw(recomputeAllDeltas=True)
        
    @pyqtSlot(int)
    def changeDeltaBTspan(self,i):
        if aw.qmc.deltaBTspan != self.spanitems[i]:
            aw.qmc.deltaBTspan = self.spanitems[i]
            aw.qmc.updateDeltaSamples()
            aw.qmc.redraw(recomputeAllDeltas=True)
            
    @pyqtSlot(int)
    def changeDeltaETspan(self,i):
        if aw.qmc.deltaETspan != self.spanitems[i]:
            aw.qmc.deltaETspan = self.spanitems[i]
            aw.qmc.updateDeltaSamples()
            aw.qmc.redraw(recomputeAllDeltas=True)
        
    def changeDecimalPlaceslcd(self):
        if self.DecimalPlaceslcd.isChecked():
            aw.qmc.LCDdecimalplaces = 1
            aw.setLCDsDigitCount(5)
        else:
            aw.qmc.LCDdecimalplaces = 0
            aw.setLCDsDigitCount(3)

    @pyqtSlot(int)
    def changeDeltaBT(self,_=0):
        aw.qmc.DeltaBTflag = not aw.qmc.DeltaBTflag
        if aw.qmc.crossmarker:
            aw.qmc.togglecrosslines() # turn crossmarks off to adjust for new coordinate system
        aw.qmc.redraw(recomputeAllDeltas=True)

    @pyqtSlot(int)
    def changeDeltaETlcd(self,_=0):
        aw.qmc.DeltaETlcdflag = not aw.qmc.DeltaETlcdflag

    @pyqtSlot(int)
    def changeDeltaBTlcd(self,_=0):
        aw.qmc.DeltaBTlcdflag = not aw.qmc.DeltaBTlcdflag
    
    @pyqtSlot()
    def changePathEffects(self):
        try:
            v = self.PathEffects.value()
            if v != aw.qmc.patheffects:
                self.PathEffects.blockSignals(True)
                try:
                    aw.qmc.patheffects = v
                    aw.qmc.redraw(recomputeAllDeltas=False)
                except Exception:
                    pass
                self.PathEffects.blockSignals(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "changePathEffects(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(int)
    def changeGraphStyle(self,n):
        aw.qmc.graphstyle = n
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def changeGraphFont(self,n):
        aw.qmc.graphfont = n
        aw.setFonts()

    @pyqtSlot()
    def changeDeltaBTfilter(self):
        try:
            v = self.DeltaBTfilter.value()*2 + 1
            if v != aw.qmc.deltaBTfilter:
                self.DeltaBTfilter.setDisabled(True)
                self.DeltaBTfilter.blockSignals(True)
                try:
                    aw.qmc.deltaBTfilter = v
                    aw.qmc.redraw(recomputeAllDeltas=True)
                except Exception:
                    pass
                self.DeltaBTfilter.setDisabled(False)
                self.DeltaBTfilter.blockSignals(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "changeDeltaBTfilter(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    def changeDeltaETfilter(self):
        try:
            v = self.DeltaETfilter.value()*2 + 1
            if v != aw.qmc.deltaETfilter:
                self.DeltaETfilter.setDisabled(True)
                self.DeltaETfilter.blockSignals(True)
                try:
                    aw.qmc.deltaETfilter = v
                    aw.qmc.redraw(recomputeAllDeltas=True)
                except Exception:
                    pass
                self.DeltaETfilter.setDisabled(False)
                self.DeltaETfilter.blockSignals(False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "changeDeltaETfilter(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(int)
    def changeOptimalSmoothingFlag(self,_=0):
        aw.qmc.optimalSmoothing = not aw.qmc.optimalSmoothing
        aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
    
    @pyqtSlot(int) 
    def changeDropFilter(self,_=0):
        aw.qmc.filterDropOuts = not aw.qmc.filterDropOuts
        aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)

    @pyqtSlot(int) 
    def changeSpikeFilter(self,_=0):
        aw.qmc.dropSpikes = not aw.qmc.dropSpikes

    @pyqtSlot(int) 
    def changeMinMaxLimits(self,_=0):
        aw.qmc.minmaxLimits = not aw.qmc.minmaxLimits
        
    @pyqtSlot(int) 
    def changeSwapETBT(self,_=0):
        aw.qmc.swapETBT = not aw.qmc.swapETBT
    
    @pyqtSlot()
    def changeFilter(self):
        try:
            v = self.Filter.value()*2 + 1
            if v != aw.qmc.curvefilter:
                self.Filter.setDisabled(True)
                aw.qmc.curvefilter = v
                aw.qmc.redraw(recomputeAllDeltas=True,smooth=True)
                self.Filter.setDisabled(False)
                self.Filter.setFocus()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " changeFilter(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(int)
    def changeProjection(self,_=0):
        aw.qmc.projectFlag = not aw.qmc.projectFlag
        if not aw.qmc.projectFlag:
            #erase old projections
            aw.qmc.resetlines()

    @pyqtSlot(int)
    def changeProjectionMode(self,i):
        aw.qmc.projectionmode = i

    @pyqtSlot(int)
    def changeInterpolationMode(self,_=0):
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.interpolation()             
                        
    @pyqtSlot(bool)
    def showSymbolicHelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = symbolicformulasHelpDlg(self)
        except:
            self.helpdialog = symbolicformulasHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

    def closeEvent(self,_):
        self.close()
        
    #cancel button
    def close(self):
        self.closeHelp()
        settings = QSettings()
        #save window geometry
        settings.setValue("HUDDlgGeometry",self.saveGeometry())

        #restore settings
        aw.qmc.DeltaETflag = self.org_DeltaET
        aw.qmc.DeltaBTflag = self.org_DeltaBT
        aw.qmc.DeltaETlcdflag = self.org_DeltaETlcd
        aw.qmc.DeltaBTlcdflag = self.org_DeltaBTlcd
        aw.qmc.projectFlag = self.org_Projection
        aw.qmc.patheffects = self.org_patheffects
        aw.qmc.graphstyle = self.org_graphstyle
        aw.qmc.graphfont = self.org_graphfont
        aw.qmc.HUDbuttonflag = self.org_HUDbuttonflag
        aw.qmc.filterDropOuts = self.org_filterDropOuts
        aw.qmc.dropSpikes = self.org_dropSpikes
        aw.qmc.swapETBT = self.org_swapETBT
        aw.qmc.optimalSmoothing = self.org_optimalSmoothing
        aw.soundflag = self.org_soundflag
        aw.logoimgflag = self.org_logoimgflag
        aw.logoimgalpha = self.org_logoimgalpha
        aw.qmc.curvefilter = self.org_curvefilter
        aw.qmc.deltaETfilter = self.org_deltaETfilter
        aw.qmc.deltaBTfilter = self.org_deltaBTfilter
        aw.qmc.deltaBTspan = self.org_deltaBTspan
        aw.qmc.deltaETspan = self.org_deltaETspan
        aw.qmc.graphstyle = self.org_graphstyle
        aw.ETname = self.org_ETname
        aw.BTname = self.org_BTname
        
        aw.setFonts(False)
        aw.qmc.resetlinecountcaches()
        aw.qmc.resetdeltalines()
        aw.qmc.resetlines()        
        aw.qmc.redraw(recomputeAllDeltas=False)
        aw.clearMessageLine() #clears plotter possible exceptions if Cancel
        self.accept()

    #button OK
    @pyqtSlot()
    def updatetargets(self):
        self.closeHelp()
        settings = QSettings()
        #save window geometry
        settings.setValue("HUDDlgGeometry",self.saveGeometry())

        aw.qmc.DeltaETfunction = str(self.DeltaETfunctionedit.text())
        aw.qmc.DeltaBTfunction = str(self.DeltaBTfunctionedit.text())
        aw.LCD4frame.setVisible((aw.qmc.DeltaBTlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaETlcdflag))
        aw.LCD5frame.setVisible((aw.qmc.DeltaETlcdflag if aw.qmc.swapdeltalcds else aw.qmc.DeltaBTlcdflag))
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.updateVisiblitiesDeltaETBT()
        self.changeDecimalPlaceslcd()
        swap = self.swapdeltalcds.isChecked()
        # swap DeltaBT/ET lcds on leaving this dialog
        if aw.qmc.swapdeltalcds != swap:
            tmp = QWidget()
            tmp.setLayout(aw.LCD4frame.layout())
            aw.LCD4frame.setLayout(aw.LCD5frame.layout())
            aw.LCD5frame.setLayout(tmp.layout())
            aw.qmc.swapdeltalcds = swap
        # reflect swap or rename of ET/BT in large LCDs:
        if aw.largeLCDs_dialog is not None:
            aw.largeLCDs_dialog.reLayout()
        if aw.largeDeltaLCDs_dialog is not None:
            aw.largeDeltaLCDs_dialog.reLayout()
            
        aw.qmc.RoRlimitFlag = self.rorFilter.isChecked()
        aw.qmc.RoRlimitm = int(self.rorminLimit.value())
        aw.qmc.RoRlimit = int(self.rormaxLimit.value())
        aw.qmc.filterDropOuts = self.FilterSpikes.isChecked()
#        aw.qmc.altsmoothing = self.AltSmoothing.isChecked()
        aw.qmc.dropSpikes = self.DropSpikes.isChecked()
        aw.qmc.minmaxLimits = self.MinMaxLimits.isChecked()
        aw.qmc.filterDropOut_tmin = int(self.minLimit.value())
        aw.qmc.filterDropOut_tmax = int(self.maxLimit.value())
        mode = u(self.modeComboBox.currentText())
        if mode == QApplication.translate("ComboBox","metrics", None):
            aw.HUDfunction = 0
        elif mode == QApplication.translate("ComboBox","thermal", None):
            aw.HUDfunction = 1
        aw.qmc.ETtarget = int(str(self.ETlineEdit.text()))
        aw.qmc.BTtarget = int(str(self.BTlineEdit.text()))
        aw.qmc.ET2target = int(str(self.ET2lineEdit.text()))
        aw.qmc.BT2target = int(str(self.BT2lineEdit.text()))
        if aw.qmc.ETtarget > aw.qmc.ET2target: # swap such that ETtarget < ET2target
            aw.qmc.ETtarget = int(str(self.ET2lineEdit.text()))
            aw.qmc.ET2target = int(str(self.ETlineEdit.text()))
        if aw.qmc.BTtarget > aw.qmc.BT2target: # swap such that BTtarget < BT2target
            aw.qmc.BTtarget = int(str(self.BT2lineEdit.text()))
            aw.qmc.BT2target = int(str(self.BTlineEdit.text()))
        aw.qmc.hudETpid[0] = int(str(self.ETpidP.text()))
        aw.qmc.hudETpid[1] = int(str(self.ETpidI.text()))
        aw.qmc.hudETpid[2] = int(str(self.ETpidD.text()))
        aw.qmc.plotcurves[0] = str(self.equedit1.text())
        aw.qmc.plotcurves[1] = str(self.equedit2.text())
        aw.qmc.plotcurves[2] = str(self.equedit3.text())
        aw.qmc.plotcurves[3] = str(self.equedit4.text())
        aw.qmc.plotcurves[4] = str(self.equedit5.text())
        aw.qmc.plotcurves[5] = str(self.equedit6.text())
        aw.qmc.plotcurves[6] = str(self.equedit7.text())
        aw.qmc.plotcurves[7] = str(self.equedit8.text())
        aw.qmc.plotcurves[8] = str(self.equedit9.text())
        string = u(QApplication.translate("Message","[ET target 1 = {0}] [BT target 1 = {1}] [ET target 2 = {2}] [BT target 2 = {3}]", None).format(str(aw.qmc.ETtarget),str(aw.qmc.BTtarget),str(aw.qmc.ET2target),str(aw.qmc.BT2target)))
        aw.sendmessage(string)
        aw.qmc.resetlinecountcaches()
        aw.qmc.resetdeltalines()
        aw.qmc.resetlines()
        aw.qmc.redraw(recomputeAllDeltas=True)
        self.accept()

########################################################################################
#####################  Volume Calculator DLG  ##########################################
########################################################################################

class volumeCalculatorDlg(ArtisanDialog):
    def __init__(self, parent = None, weightIn=None, weightOut=None,
            weightunit=0,volumeunit=0,
            inlineedit=None,outlineedit=None,tare=0): # weight in and out expected in g (int)
        
        self.parent_dialog = parent
        # weightunit 0:g, 1:Kg  volumeunit 0:ml, 1:l
        super(volumeCalculatorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Volume Calculator",None))

        if aw.scale.device is not None and aw.scale.device != "" and aw.scale.device != "None":
            self.scale_connected = True
        else:
            self.scale_connected = False

        self.weightIn = weightIn
        self.weightOut = weightOut
        
        # the units
        self.weightunit = weightunit
        self.volumeunit = volumeunit
        
        # the results
        self.inVolume = None
        self.outVolume = None
        
        # the QLineedits of the RoastProperties dialog to be updated
        self.inlineedit = inlineedit
        self.outlineedit = outlineedit
        
        # the current active tare
        self.tare = tare
        
        # Scale Weight
        self.scale_weight = self.parent_dialog.scale_weight
        self.scaleWeight = QLabel() # displays the current reading - tare of the connected scale
        if self.parent_dialog.ble is not None:
            self.update_scale_weight()
            self.parent_dialog.ble.weightChanged.connect(self.ble_weight_changed)
            self.parent_dialog.ble.deviceDisconnected.connect(self.ble_scan_failed)
        
        # Unit Group
        unitvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit", None)) + "</b>")
        self.unitvolumeEdit = QLineEdit("%g" % aw.qmc.volumeCalcUnit)
#        self.unitvolumeEdit.setValidator(QIntValidator(0, 99999,self.unitvolumeEdit))
        self.unitvolumeEdit.setValidator(aw.createCLocaleDoubleValidator(0., 9999999., 4, self.unitvolumeEdit))
        self.unitvolumeEdit.setMinimumWidth(70)
        self.unitvolumeEdit.setMaximumWidth(70)
        self.unitvolumeEdit.setAlignment(Qt.AlignRight)
        unitvolumeUnit = QLabel(QApplication.translate("Label","ml", None))
        
        # unit button
        unitButton = QPushButton(QApplication.translate("Button", "unit",None))
        unitButton.clicked.connect(self.unitWeight)
        unitButton.setFocusPolicy(Qt.NoFocus)

        unitLayout = QHBoxLayout()
        if self.scale_connected:
            unitLayout.addStretch()
        unitLayout.addWidget(self.scaleWeight)
        unitLayout.addStretch()
        unitLayout.addWidget(unitvolumeLabel)
        unitLayout.addWidget(self.unitvolumeEdit)
        unitLayout.addWidget(unitvolumeUnit)
        unitLayout.addStretch()
        if self.scale_connected:
            unitLayout.addWidget(unitButton)
        
        # In Group
        coffeeinunitweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit Weight", None)) + "</b>")
        self.coffeeinweightEdit = QLineEdit(aw.qmc.volumeCalcWeightInStr)
        self.coffeeinweightEdit.setMinimumWidth(70)
        self.coffeeinweightEdit.setMaximumWidth(70)
        self.coffeeinweightEdit.setAlignment(Qt.AlignRight)
        coffeeinunitweightUnit = QLabel(QApplication.translate("Label","g", None))

        coffeeinweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Weight", None)) + "</b>")
        self.coffeeinweight = QLineEdit()
        if self.weightIn:
            self.coffeeinweight.setText("%g" % aw.float2floatWeightVolume(self.weightIn))
        self.coffeeinweight.setMinimumWidth(70)
        self.coffeeinweight.setMaximumWidth(70)
        self.coffeeinweight.setAlignment(Qt.AlignRight)
        self.coffeeinweight.setReadOnly(True)
        self.coffeeinweight.setFocusPolicy(Qt.NoFocus)
        if sys.platform.startswith("darwin"):
            self.coffeeinweight.setStyleSheet("border: 0.5px solid lightgrey; background-color:'lightgrey'")
        else:
            self.coffeeinweight.setStyleSheet("background-color:'lightgrey'")
        coffeeinweightUnit = QLabel(aw.qmc.weight_units[weightunit])
        
        coffeeinvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Volume", None)) + "</b>")
        self.coffeeinvolume = QLineEdit()
        self.coffeeinvolume.setMinimumWidth(70)
        self.coffeeinvolume.setMaximumWidth(70)
        
        palette = QPalette()
        palette.setColor(self.coffeeinvolume.foregroundRole(), QColor('red'))
        self.coffeeinvolume.setPalette(palette)
        
        self.coffeeinvolume.setAlignment(Qt.AlignRight)
        self.coffeeinvolume.setReadOnly(True)
        self.coffeeinvolume.setFocusPolicy(Qt.NoFocus)
        coffeeinvolumeUnit = QLabel(aw.qmc.volume_units[volumeunit])
            
        # in button
        inButton = QPushButton(QApplication.translate("Button", "in",None))
        inButton.clicked.connect(self.inWeight)
        inButton.setFocusPolicy(Qt.NoFocus)        
        
        inGrid = QGridLayout()
        inGrid.addWidget(coffeeinweightLabel,0,0)
        inGrid.addWidget(self.coffeeinweight,0,1)
        inGrid.addWidget(coffeeinweightUnit,0,2)
        inGrid.addWidget(coffeeinvolumeLabel,1,0)
        inGrid.addWidget(self.coffeeinvolume,1,1)
        inGrid.addWidget(coffeeinvolumeUnit,1,2)
        
        volumeInLayout = QHBoxLayout()
        volumeInLayout.addWidget(coffeeinunitweightLabel)
        volumeInLayout.addWidget(self.coffeeinweightEdit)
        volumeInLayout.addWidget(coffeeinunitweightUnit)
        volumeInLayout.addSpacing(15)
        volumeInLayout.addLayout(inGrid)
        
        inButtonLayout = QHBoxLayout()
        inButtonLayout.addWidget(inButton)
        inButtonLayout.addStretch()
        
        volumeInVLayout = QVBoxLayout()
        volumeInVLayout.addLayout(volumeInLayout)
        if self.scale_connected:
            volumeInVLayout.addLayout(inButtonLayout)
        
        volumeInGroupLayout = QGroupBox(QApplication.translate("Label","Green", None))
        volumeInGroupLayout.setLayout(volumeInVLayout)
        if weightIn is None:
            volumeInGroupLayout.setDisabled(True)

        self.resetInVolume()

        # Out Group
        coffeeoutunitweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Unit Weight", None)) + "</b>")
        self.coffeeoutweightEdit = QLineEdit(aw.qmc.volumeCalcWeightOutStr)
        self.coffeeoutweightEdit.setMinimumWidth(60)
        self.coffeeoutweightEdit.setMaximumWidth(60)
        self.coffeeoutweightEdit.setAlignment(Qt.AlignRight)
        coffeeoutunitweightUnit = QLabel(QApplication.translate("Label","g", None))

        coffeeoutweightLabel = QLabel("<b>" + u(QApplication.translate("Label","Weight", None)) + "</b>")
        self.coffeeoutweight = QLineEdit()
        if self.weightOut:
            self.coffeeoutweight.setText("%g" % aw.float2floatWeightVolume(self.weightOut))
        self.coffeeoutweight.setMinimumWidth(60)
        self.coffeeoutweight.setMaximumWidth(60)
        self.coffeeoutweight.setAlignment(Qt.AlignRight)
        self.coffeeoutweight.setReadOnly(True)
        if sys.platform.startswith("darwin"):
            self.coffeeoutweight.setStyleSheet("border: 0.5px solid lightgrey; background-color:'lightgrey'")
        else:
            self.coffeeoutweight.setStyleSheet("background-color:'lightgrey'")
        self.coffeeoutweight.setFocusPolicy(Qt.NoFocus)
        coffeeoutweightUnit = QLabel(aw.qmc.weight_units[weightunit])

        coffeeoutvolumeLabel = QLabel("<b>" + u(QApplication.translate("Label","Volume", None)) + "</b>")
        self.coffeeoutvolume = QLineEdit()
        self.coffeeoutvolume.setMinimumWidth(60)
        self.coffeeoutvolume.setMaximumWidth(60)
        
        palette = QPalette()
        palette.setColor(self.coffeeoutvolume.foregroundRole(), QColor('red'))
        self.coffeeoutvolume.setPalette(palette)

        self.coffeeoutvolume.setAlignment(Qt.AlignRight)
        self.coffeeoutvolume.setReadOnly(True)
        self.coffeeoutvolume.setFocusPolicy(Qt.NoFocus)
        coffeeoutvolumeUnit = QLabel(aw.qmc.volume_units[volumeunit])

        # out button
        outButton = QPushButton(QApplication.translate("Button", "out",None))
        outButton.clicked.connect(self.outWeight)
        outButton.setFocusPolicy(Qt.NoFocus)
                
        outGrid = QGridLayout()
        outGrid.addWidget(coffeeoutweightLabel,0,0)
        outGrid.addWidget(self.coffeeoutweight,0,1)
        outGrid.addWidget(coffeeoutweightUnit,0,2)
        outGrid.addWidget(coffeeoutvolumeLabel,1,0)
        outGrid.addWidget(self.coffeeoutvolume,1,1)
        outGrid.addWidget(coffeeoutvolumeUnit,1,2)
        
        volumeOutLayout = QHBoxLayout()
        volumeOutLayout.addWidget(coffeeoutunitweightLabel)
        volumeOutLayout.addWidget(self.coffeeoutweightEdit)
        volumeOutLayout.addWidget(coffeeoutunitweightUnit)
        volumeOutLayout.addSpacing(15)
        volumeOutLayout.addLayout(outGrid)
        
        outButtonLayout = QHBoxLayout()
        outButtonLayout.addWidget(outButton)
        outButtonLayout.addStretch()
        
        volumeOutVLayout = QVBoxLayout()
        volumeOutVLayout.addLayout(volumeOutLayout)
        if self.scale_connected:
            volumeOutVLayout.addLayout(outButtonLayout)
        
        volumeOutGroupLayout = QGroupBox(QApplication.translate("Label","Roasted", None))
        volumeOutGroupLayout.setLayout(volumeOutVLayout)
        if weightOut is None:
            volumeOutGroupLayout.setDisabled(True)

        self.resetOutVolume()
        
        self.coffeeinweightEdit.editingFinished.connect(self.resetInVolume)
        self.coffeeoutweightEdit.editingFinished.connect(self.resetOutVolume)
        self.unitvolumeEdit.editingFinished.connect(self.resetVolume)

        okButton = QPushButton(QApplication.translate("Button","OK",None))
        okButton.setAutoDefault(True)
        okButton.setFocusPolicy(Qt.StrongFocus)
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None))
        cancelButton.setFocusPolicy(Qt.StrongFocus)
        cancelButton.setAutoDefault(False)
        cancelButton.clicked.connect(self.close)
        okButton.clicked.connect(self.updateVolumes)
        # add standard Mac OS X shortcut CMD-. to close this dialog
        cancelButton.setShortcut(QKeySequence("Ctrl+."))
        # add additional CMD-W shortcut to close this dialog
        cancelAction = QAction(self, triggered=self.close)
        try:
            cancelAction.setShortcut(QKeySequence.Cancel)
        except:
            pass
        cancelButton.addActions([cancelAction])
        
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(okButton)
        buttonLayout.addWidget(cancelButton)

        mainlayout = QVBoxLayout()
        mainlayout.addLayout(unitLayout)
        mainlayout.addWidget(volumeInGroupLayout)
        mainlayout.addWidget(volumeOutGroupLayout)
        mainlayout.addLayout(buttonLayout)
        self.setLayout(mainlayout)
        self.coffeeinweightEdit.setFocus()
        
        self.parent_dialog.scaleWeightUpdated.connect(self.update_scale_weight)
        

    pyqtSlot()
    def ble_scan_failed(self):
        self.scale_weight = None
        self.scale_battery = None
        self.scaleWeight.setText("")

    pyqtSlot(float)
    def ble_weight_changed(self,w):
        if w is not None:
            self.scale_weight = w
            self.update_scale_weight()

    @pyqtSlot(float)
    def update_scale_weight(self,weight=None):
        try:
            if weight is not None:
                self.scale_weight = weight
            if self.scale_weight is not None and self.tare is not None:
                self.scaleWeight.setText("{0:.1f}g".format(self.scale_weight - self.tare))
            else:
                self.scaleWeight.setText("")
        except: # the dialog might have been closed already and thus the qlabel might not exist anymore
            pass
        
    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        if key == 16777220 and self.scale_connected: # ENTER key pressed
            v = self.retrieveWeight()
            if v and v != 0:
                if self.unitvolumeEdit.hasFocus():
                    self.unitvolumeEdit.setText("%g" % aw.float2float(v))
                elif self.coffeeinweightEdit.hasFocus():
                    self.coffeeinweightEdit.setText("%g" % aw.float2float(v))
                elif self.coffeeoutweightEdit.hasFocus():
                    self.coffeeoutweightEdit.setText("%g" % aw.float2float(v))
                    
    def widgetWeight(self,widget):
        w = self.retrieveWeight()
        if w is not None:
            v = aw.float2floatWeightVolume(w)
#            widget.setText("%g" % aw.float2float(v))
            # updating this widget in a separate thread seems to be important on OS X 10.14 to avoid delayed updates and widget redraw problesm
            QTimer.singleShot(2,lambda : widget.setText("%g" % aw.float2float(v)))
    
    pyqtSlot(bool)
    def unitWeight(self,_):
        self.widgetWeight(self.unitvolumeEdit)
        
    pyqtSlot(bool)
    def inWeight(self,_):
        QTimer.singleShot(1,lambda : self.widgetWeight(self.coffeeinweightEdit))
        QTimer.singleShot(10,lambda : self.resetInVolume())
        QApplication.processEvents()
        
    pyqtSlot(bool)
    def outWeight(self,_):
        QTimer.singleShot(1,lambda : self.widgetWeight(self.coffeeoutweightEdit))
        QTimer.singleShot(10,lambda : self.resetOutVolume())
        QApplication.processEvents()
        
    def retrieveWeight(self):
        v = self.scale_weight
        if v is not None: # value received
            # substruct tare
            return v - self.tare
        else:
            return None

    @pyqtSlot()
    def resetVolume(self):
        self.resetInVolume()
        self.resetOutVolume()

    @pyqtSlot()
    def resetInVolume(self):
        try:
            line = self.coffeeinweightEdit.text()
            if line is None or str(line).strip() == "":
                self.coffeeinvolume.setText("")
                self.inVolume = None
            else:
                self.inVolume = aw.convertVolume(aw.convertWeight(self.weightIn,self.weightunit,0) * float(aw.comma2dot(str(self.unitvolumeEdit.text()))) / float(aw.comma2dot(str(self.coffeeinweightEdit.text()))),5,self.volumeunit)
                self.coffeeinvolume.setText("%g" % aw.float2floatWeightVolume(self.inVolume))
        except Exception:
            self.inVolume = None
            self.coffeeinvolume.setText("")

    @pyqtSlot()
    def resetOutVolume(self):
        try:
            line = self.coffeeoutweightEdit.text()
            if line is None or str(line).strip() == "":
                self.coffeeoutvolume.setText("")
                self.outVolume = None
            else:
                self.outVolume = aw.convertVolume(aw.convertWeight(self.weightOut,self.weightunit,0) * float(aw.comma2dot(str(self.unitvolumeEdit.text()))) / float(aw.comma2dot(str(self.coffeeoutweightEdit.text()))),5,self.volumeunit)
                self.coffeeoutvolume.setText("%g" % aw.float2floatWeightVolume(self.outVolume))
        except Exception:
            self.outVolume = None
            self.coffeeoutvolume.setText("")

    @pyqtSlot(bool)
    def updateVolumes(self,_=False):
        if self.inVolume and self.inVolume != "":
            if self.volumeunit == 0:
                self.inlineedit.setText("%g" % aw.float2floatWeightVolume(self.inVolume))
            else:
                self.inlineedit.setText("%g" % aw.float2floatWeightVolume(self.inVolume))
        if self.outVolume and self.outVolume != "":
            if self.volumeunit == 0:
                self.outlineedit.setText("%g" % aw.float2floatWeightVolume(self.outVolume))
            else:
                self.outlineedit.setText("%g" % aw.float2floatWeightVolume(self.outVolume))
        self.parent_dialog.volume_percent()
        self.closeEvent(None)
        
    def closeEvent(self,_):
        try:
            self.parent_dialog.volumedialog = None
        except:
            pass
        if self.unitvolumeEdit.text() and self.unitvolumeEdit.text() != "":
            aw.qmc.volumeCalcUnit = float(self.unitvolumeEdit.text())
            aw.qmc.volumeCalcWeightInStr = aw.comma2dot(str(self.coffeeinweightEdit.text()))
            aw.qmc.volumeCalcWeightOutStr = aw.comma2dot(str(self.coffeeoutweightEdit.text()))
            self.parent_dialog.calculated_density()
        self.accept()

    @pyqtSlot(bool)
    def close(self,_):
        self.closeEvent(None)

########################################################################################
#####################  SYMBOLIC FORMULAS HELP DLG ######################################
########################################################################################
class symbolicformulasHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(symbolicformulasHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Symbolic Formulas Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("symbolicformulasHelpGeometry"):
            self.restoreGeometry(settings.value("symbolicformulasHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','SYMBOLIC VARIABLES',None)) + "</b>"
        tbl_SymbolicVariables = prettytable.PrettyTable()
        tbl_SymbolicVariables.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None)),u(QApplication.translate('HelpDlg','Can  shift?\n(see below)',None))]
        tbl_SymbolicVariables.add_row(['t',u(QApplication.translate('HelpDlg','Absolute time (seconds) from begin of recording (not only the time after CHARGE!)',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['b',u(QApplication.translate('HelpDlg','Absolute time (seconds) from begin of recording of the background profile',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['x',u(QApplication.translate('HelpDlg','Current channel reading (not available in the Plotter)',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['Y1',u(QApplication.translate('HelpDlg','ET value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['Y2',u(QApplication.translate('HelpDlg','BT value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['Y3',u(QApplication.translate('HelpDlg','Extra #1 T1 value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['Y4',u(QApplication.translate('HelpDlg','Extra #1 T2 value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['Y5',u(QApplication.translate('HelpDlg','Extra #2 T1 value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['Y6',u(QApplication.translate('HelpDlg','Extra #2 T2 value',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['...',u(QApplication.translate('HelpDlg','...and so forth',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['B1',u(QApplication.translate('HelpDlg','ET background',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['B2',u(QApplication.translate('HelpDlg','BT background',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['B3',u(QApplication.translate('HelpDlg','ExtraBackground #1-A',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['B4',u(QApplication.translate('HelpDlg','ExtraBackground #1-B',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['B5',u(QApplication.translate('HelpDlg','ExtraBackground #2-A',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['...',u(QApplication.translate('HelpDlg','...and so forth',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['T1',u(QApplication.translate('HelpDlg','ET tare value',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['T2',u(QApplication.translate('HelpDlg','BT tare value',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['T3',u(QApplication.translate('HelpDlg','Extra Device #1 channel 1 tare value',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['T4',u(QApplication.translate('HelpDlg','Extra Device #1 channel 2 tare value',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['T5',u(QApplication.translate('HelpDlg','Extra Device #2 channel 1 tare value',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['...',u(QApplication.translate('HelpDlg','...and so forth',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['E1',u(QApplication.translate('HelpDlg','Last event value of the first event type',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['E2',u(QApplication.translate('HelpDlg','Last event value of the second event type',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['E3',u(QApplication.translate('HelpDlg','Last event value of the third event type',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['E4',u(QApplication.translate('HelpDlg','Last event value of the fourth event type',None)),'&#160;'])
        tbl_SymbolicVariables.add_row(['&#160;','&#160;','&#160;'])
        tbl_SymbolicVariables.add_row(['R1',u(QApplication.translate('HelpDlg','ET rate of rise',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        tbl_SymbolicVariables.add_row(['R2',u(QApplication.translate('HelpDlg','BT rate of rise',None)),u(QApplication.translate('HelpDlg','Yes',None))])
        helpstr += tbl_SymbolicVariables.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','SHIFTED SYMBOLIC VARIABLES',None)) + "</b>"
        tbl_ShiftedSymbolicVariablestop = prettytable.PrettyTable()
        tbl_ShiftedSymbolicVariablestop.header = False
        tbl_ShiftedSymbolicVariablestop.add_row([u(QApplication.translate('HelpDlg','The symbolic variables t, b, Y<n>, B<n> and R<n> evaluate to the current value of a sequence of values that define a roast profile. To access earlier or later values one can apply a shift value.',None))+newline+u(QApplication.translate('HelpDlg','\nFor example, while "Y2" returns the current bean temperature (BT), "Y2[-1]" returns the previous BT temperature and "Y2[-2]" the one before that. Formulas used in the Plotter are applied in sequence to all values, thus there "Y2" points to the current BT temperature processed, "Y2[-1]" the previous BT temperature processed and "Y2[+1]" the next BT temperature to be processed. A positive shift is only available in the Plotter, obviously not during recording.',None))])
        helpstr += tbl_ShiftedSymbolicVariablestop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_ShiftedSymbolicVariables = prettytable.PrettyTable()
        tbl_ShiftedSymbolicVariables.field_names = [u(QApplication.translate('HelpDlg','Example',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_ShiftedSymbolicVariables.add_row(['t[+1]',u(QApplication.translate('HelpDlg','Time one index ahead (plotter only)',None))])
        tbl_ShiftedSymbolicVariables.add_row(['t[-3]',u(QApplication.translate('HelpDlg','Time three indexes delayed',None))])
        tbl_ShiftedSymbolicVariables.add_row(['Y1[-2]',u(QApplication.translate('HelpDlg','ET value delayed by 2 indexes',None))])
        tbl_ShiftedSymbolicVariables.add_row(['Y2[+1]',u(QApplication.translate('HelpDlg','BT value index advanced by one index (plotter only)',None))])
        tbl_ShiftedSymbolicVariables.add_row(['B4[-6]',u(QApplication.translate('HelpDlg','ExtraBackground #1-B delayed 6 indexes',None))])
        tbl_ShiftedSymbolicVariables.add_row(['B5[+2]',u(QApplication.translate('HelpDlg','ExtraBackground #2-A advanced 2 indexes (plotter only)',None))])
        tbl_ShiftedSymbolicVariables.add_row(['R1[-2]',u(QApplication.translate('HelpDlg','ET rate of rise delayed two indexes',None))])
        helpstr += tbl_ShiftedSymbolicVariables.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','INDEXED SYMBOLIC VARIABLES',None)) + "</b>"
        tbl_IndexedSymbolic = prettytable.PrettyTable()
        tbl_IndexedSymbolic.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_IndexedSymbolic.add_row([u(QApplication.translate('HelpDlg','t, b, Y<n>, B<n> and R<n>',None)),u(QApplication.translate('HelpDlg','Previously recorded data assigned to the symbolic variables t, b, Y<n>, B<n> and R<n> can also directly accessed by index. "Y2{0}" evaluates to the first recorded bean temperature (BT) and "Y2{CHARGE}" to the bean temperature at CHARGE. Additionally, the symbolic variable b can be used to access the recording time at a certain index of the background profile. Thus "b{CHARGE}" returns the recording time at CHARGE of the background profile.',None))])
        helpstr += tbl_IndexedSymbolic.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','AXIS MAPPING',None)) + "</b>"
        tbl_AxisMapping = prettytable.PrettyTable()
        tbl_AxisMapping.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_AxisMapping.add_row(['k',u(QApplication.translate('HelpDlg','Scaling factor from time to RoR axis. The range of the temperature scale divided by the range of the delta scale. ',None))])
        tbl_AxisMapping.add_row(['o',u(QApplication.translate('HelpDlg','Offset from time to RoR axis. ',None))])
        helpstr += tbl_AxisMapping.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_AxisMappingbottom = prettytable.PrettyTable()
        tbl_AxisMappingbottom.header = False
        tbl_AxisMappingbottom.add_row([u(QApplication.translate('HelpDlg','Note: RoR values r can be scaled to the temperature axis using a linear approximation of the form "r*k + o". As the variables k and o depend on the actual axis settings which can be changed by the user without triggering a recomputation, those variable are less useful for use in a recording, but useful in the Plotter to plot w.r.t. the RoR x-axis instead of the temperature x-axis.',None))])
        helpstr += tbl_AxisMappingbottom.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','EVENT INDEX and TIME DELTA',None)) + "</b>"
        tbl_EventIndex = prettytable.PrettyTable()
        tbl_EventIndex.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_EventIndex.add_row(['CHARGE, DRY, FCs, FCe, SCs, SCe, DROP',u(QApplication.translate('HelpDlg','Index of the corresponding event of the profile to retrieve time and values from the corresponding data structures. Evaluates to -1 if not set.',None))])
        tbl_EventIndex.add_row(['bCHARGE, bDRY, bFCs, bFCe, bSCs, bSCe, bDROP',u(QApplication.translate('HelpDlg','Index of the corresponding event of the background profile to retrieve time and values from the corresponding data structures. Evaluates to -1 if not set.',None))])
        tbl_EventIndex.add_row(['&#160;','&#160;'])
        tbl_EventIndex.add_row(['dCHARGE, dDRY, dFCs, dFCe, dSCs, dSCe, dDROP',u(QApplication.translate('HelpDlg','Time distance in seconds after the corresponding event. Thus dCHARGE is bound to the current roast time (after CHARGE) in seconds while t is bound to the time in seconds from the start of the recording.',None))])
        helpstr += tbl_EventIndex.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','AREA UNDER THE CURVE (AUC)',None)) + "</b>"
        tbl_AUC = prettytable.PrettyTable()
        tbl_AUC.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_AUC.add_row(['AUCbase',u(QApplication.translate('HelpDlg','AUC base temperature (could be from the selected event, if set)',None))])
        tbl_AUC.add_row(['AUCtarget',u(QApplication.translate('HelpDlg','AUC target value (could be from the background profile, if set)',None))])
        tbl_AUC.add_row(['AUCvalue',u(QApplication.translate('HelpDlg','the current AUC value. -1 if none available.',None))])
        helpstr += tbl_AUC.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','PREDICITONS',None)) + "</b>"
        tbl_Predictions = prettytable.PrettyTable()
        tbl_Predictions.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_Predictions.add_row(['pDRY',u(QApplication.translate('HelpDlg','Prediction of the time distance to the DRY event based on the current RoR. Evaluates to -1 on negative RoR and to 0 if the DRY event is already set.',None))])
        tbl_Predictions.add_row(['pFCS',u(QApplication.translate('HelpDlg','Same as pDRY, just for the FCs event.',None))])
        helpstr += tbl_Predictions.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Predictionsbottom = prettytable.PrettyTable()
        tbl_Predictionsbottom.header = False
        tbl_Predictionsbottom.add_row([u(QApplication.translate('HelpDlg','Note: The same rules as for the corresponding PhasesLCDs apply to pDRY and pFCs:',None))+newline+u(QApplication.translate('HelpDlg','\nIf there is no background profile the DRY or FCs bean temperature used for the prediction is taken from the Config>Phases setup.',None))+newline+u(QApplication.translate('HelpDlg','\nIf there is a background profile and there is DRY or FCs event in the background profile, the DRY or FCs bean temperature used for the prediction is taken from the background profile.',None))+newline+u(QApplication.translate('HelpDlg','\nException to the above for DRY only: if AutoDRY is checked the DRY temperature used for the prediction is taken from the Config>Phases setup.  This does not apply to FCs and AutoFCS.',None))+newline+u(QApplication.translate('HelpDlg','\nThe prediction value is the calculated time in seconds to reach the DRY or FCs temperature.',None))])
        helpstr += tbl_Predictionsbottom.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','EXPRESSIONS',None)) + "</b>"
        tbl_Expressions = prettytable.PrettyTable()
        tbl_Expressions.field_names = [u(QApplication.translate('HelpDlg','Expression',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_Expressions.add_row(['(<true-expr> if <cond> else <false-expr>)',u(QApplication.translate('HelpDlg','Conditional. Evaluates to the value of the expression <true-expr> if the condition <cond> holds, otherwise to the value of the expression <false-expr>. The rules of Python are applied to decide if a value holds or not. Thus the boolean values "True" and "False" have the obvious semantic. Any number unequal to 0 evaluates to True and 0 evaluates to False. The value "None" is also evaluated to False.',None))])
        helpstr += tbl_Expressions.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','MATHEMATICAL FORMULAS',None)) + "</b>"
        tbl_MathFormulas = prettytable.PrettyTable()
        tbl_MathFormulas.field_names = [u(QApplication.translate('HelpDlg','Formula',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_MathFormulas.add_row(['abs(x)',u(QApplication.translate('HelpDlg','Return the absolute value of x.',None))])
        tbl_MathFormulas.add_row(['acos(x)',u(QApplication.translate('HelpDlg','Return the arc cosine (measured in radians) of x.',None))])
        tbl_MathFormulas.add_row(['asin(x)',u(QApplication.translate('HelpDlg','Return the arc sine (measured in radians) of x.',None))])
        tbl_MathFormulas.add_row(['atan(x)',u(QApplication.translate('HelpDlg','Return the arc tangent (measured in radians) of x.',None))])
        tbl_MathFormulas.add_row(['cos(x)',u(QApplication.translate('HelpDlg','Return the cosine of x (measured in radians).',None))])
        tbl_MathFormulas.add_row(['degrees(x)',u(QApplication.translate('HelpDlg','Convert angle x from radians to degrees.',None))])
        tbl_MathFormulas.add_row(['exp(x)',u(QApplication.translate('HelpDlg','Return e raised to the power of x.',None))])
        tbl_MathFormulas.add_row(['log(x[, base])',u(QApplication.translate('HelpDlg','Return the logarithm of x to the given base.',None))])
        tbl_MathFormulas.add_row(['min(x1,...,xn)',u(QApplication.translate('HelpDlg','Return the minimum of the given values.',None))])
        tbl_MathFormulas.add_row(['max(x1,...,xn)',u(QApplication.translate('HelpDlg','Return the maximum of the given values.',None))])
        tbl_MathFormulas.add_row(['pow(x, y)',u(QApplication.translate('HelpDlg','Return x**y (x to the power of y).',None))])
        tbl_MathFormulas.add_row(['radians(x)',u(QApplication.translate('HelpDlg','Convert angle x from degrees to radians.',None))])
        tbl_MathFormulas.add_row(['sin(x)',u(QApplication.translate('HelpDlg','Return the sine of x (measured in radians).',None))])
        tbl_MathFormulas.add_row(['sqrt(x)',u(QApplication.translate('HelpDlg','Return the square root of x.',None))])
        tbl_MathFormulas.add_row(['tan(x)',u(QApplication.translate('HelpDlg','Return the tangent of x (measured in radians).',None))])
        helpstr += tbl_MathFormulas.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','MATHEMATICAL CONSTANTS',None)) + "</b>"
        tbl_Constants = prettytable.PrettyTable()
        tbl_Constants.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Value',None))]
        tbl_Constants.add_row(['e',2.71828182845904])
        tbl_Constants.add_row(['pi',3.14159265358979])
        helpstr += tbl_Constants.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','PLOTTER EXTENSIONS',None)) + "</b>"
        tbl_PlotterExtensionstop = prettytable.PrettyTable()
        tbl_PlotterExtensionstop.header = False
        tbl_PlotterExtensionstop.add_row([u(QApplication.translate('HelpDlg','Note:  This section applies only to the Plotter\nUsing math formulas in the plotter also allows to use the symbolic variables P and F (see Signals, Symbolic Assignments and the Plotter).',None))])
        helpstr += tbl_PlotterExtensionstop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_PlotterExtensions = prettytable.PrettyTable()
        tbl_PlotterExtensions.field_names = [u(QApplication.translate('HelpDlg','Symbol',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_PlotterExtensions.add_row(['P1...P9',u(QApplication.translate('HelpDlg','The variables P1,..,P9 represent the results from plot #1,..,#9. You can perform calculations in a later plot on variables of an earlier plot. That way, the plot variables P1,..,P9 allow the cascading or intermediate results. For example, plot #3 can refer to the results of plot 1 using the variable P1.',None))])
        tbl_PlotterExtensions.add_row(['F1...F9',u(QApplication.translate('HelpDlg','F1 refers to the previous result of the actual formula to realize a feedback loop. This is useful in filter designs. Similarly, F2 refers to the second previous result etc.',None))])
        helpstr += tbl_PlotterExtensions.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("symbolicformulasHelpGeometry",self.saveGeometry())


########################################################################################
#####################  PLOTTER DATA DLG  ###############################################
########################################################################################

        
class equDataDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(equDataDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Plotter Data",None))
        self.setModal(True)

        self.datalabel = QLabel("")
        self.dataprecisionlabel = QLabel(u(QApplication.translate("Label", "Data precision",None)))
        
        #DATA Table
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        header = self.datatable.horizontalHeader()
        header.setStretchLastSection(True)
        self.datatable.setMinimumSize(self.datatable.minimumSizeHint())

        self.copydataTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copydataTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copydataTableButton.setFocusPolicy(Qt.NoFocus)
        self.copydataTableButton.setMaximumSize(self.copydataTableButton.sizeHint())
        self.copydataTableButton.setMinimumSize(self.copydataTableButton.minimumSizeHint())
        self.copydataTableButton.clicked.connect(self.copyDataTabletoClipboard)

        self.dataprecision = ["%.1f","%.2f","%.3f","%.4f","%.5f","%.6f"]
        self.dataprecisionval = 1
        self.precisionSpinBox = QSpinBox()
        self.precisionSpinBox.setRange(1,6)
        self.precisionSpinBox.setSingleStep(1)
        self.precisionSpinBox.setValue(self.dataprecisionval)
        self.precisionSpinBox.setAlignment(Qt.AlignLeft)
        self.precisionSpinBox.setMaximumWidth(50)
        self.precisionSpinBox.valueChanged.connect(self.changeprecision)

        self.changeprecision()
        self.createDataTable()

        #layout
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(self.copydataTableButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dataprecisionlabel)
        buttonLayout.addWidget(self.precisionSpinBox)

        dataplotterLayout = QVBoxLayout()
        dataplotterLayout.addWidget(self.datalabel)
        dataplotterLayout.addWidget(self.datatable)
        dataplotterLayout.addLayout(buttonLayout)
            
        self.setLayout(dataplotterLayout)

    def changeprecision(self):
        self.dataprecisionval = int(self.precisionSpinBox.value())-1
        self.createDataTable()

    def createDataTable(self):
        try:
            self.datatable.clear()
            ndata = len(aw.qmc.timex)
            self.datatable.setRowCount(ndata)
            
            mm = "" 
            for i in range(len(aw.qmc.plotterequationresults)):
                if len(aw.qmc.plotterequationresults[i]):
                    mm += "P"+str(i+1)+" "
                    #ite = len(aw.qmc.plotterequationresults[i])
            if not mm:
                self.datalabel.setText(QApplication.translate("Label","No plotter data found.",None))
            else:
                self.datalabel.setText(mm)

            columns = [ QApplication.translate("Table", "t",None),
                        QApplication.translate("Table", "Time",None),
                        QApplication.translate("Table", "P1",None),
                        QApplication.translate("Table", "P2",None),
                        QApplication.translate("Table", "P3",None),
                        QApplication.translate("Table", "P4",None),
                        QApplication.translate("Table", "P5",None),
                        QApplication.translate("Table", "P6",None),
                        QApplication.translate("Table", "P7",None),
                        QApplication.translate("Table", "P8",None),
                        QApplication.translate("Table", "P9",None),
                        ""]
    
            self.datatable.setColumnCount(len(columns))
            self.datatable.setHorizontalHeaderLabels(columns)
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.SingleSelection)
            self.datatable.setShowGrid(True)
            self.datatable.verticalHeader().setSectionResizeMode(2)
            
            for i in range(ndata):
    
                t = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.timex[i])
                t.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                
                time = QTableWidgetItem(aw.qmc.stringfromseconds(aw.qmc.timex[i]-aw.qmc.timex[aw.qmc.timeindex[0]]))
                time.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
    
                if len(aw.qmc.plotterequationresults[0]) and len(aw.qmc.plotterequationresults[0]) > i:
                    P1 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[0][i])
                else:
                    P1 = QTableWidgetItem("NA")
                    P1.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[1]) and len(aw.qmc.plotterequationresults[1]) > i:
                    P2 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[1][i])
                else:
                    P2 = QTableWidgetItem("NA")
                    P2.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[2]) and len(aw.qmc.plotterequationresults[2]) > i:
                    P3 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[2][i])
                else:
                    P3 = QTableWidgetItem("NA")
                    P3.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[3]) and len(aw.qmc.plotterequationresults[3]) > i:
                    P4 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[3][i])
                else:
                    P4 = QTableWidgetItem("NA")
                    P4.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[4]) and len(aw.qmc.plotterequationresults[4]) > i:
                    P5 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[4][i])
                else:
                    P5 = QTableWidgetItem("NA")
                    P5.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[5]) and len(aw.qmc.plotterequationresults[5]) > i:
                    P6 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[5][i])
                else:
                    P6 = QTableWidgetItem("NA")
                    P6.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[6]) and len(aw.qmc.plotterequationresults[6]) > i:
                    P7 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[6][i])
                else:
                    P7 = QTableWidgetItem("NA")
                    P7.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[7]) and len(aw.qmc.plotterequationresults[7]) > i:
                    P8 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[7][i])
                else:
                    P8 = QTableWidgetItem("NA")
                    P8.setBackground(QColor('lightgrey'))
                if len(aw.qmc.plotterequationresults[8]) and len(aw.qmc.plotterequationresults[8]) > i:
                    P9 = QTableWidgetItem(self.dataprecision[self.dataprecisionval]%aw.qmc.plotterequationresults[8][i])
                else:
                    P9 = QTableWidgetItem("NA")
                    P9.setBackground(QColor('lightgrey'))
                                    
                P1.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P2.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P3.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P4.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P5.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P6.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P7.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P8.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                P9.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
    
                self.datatable.setItem(i,0,t)
                self.datatable.setItem(i,1,time)
                self.datatable.setItem(i,2,P1)
                self.datatable.setItem(i,3,P2)
                self.datatable.setItem(i,4,P3)
                self.datatable.setItem(i,5,P4)
                self.datatable.setItem(i,6,P5)
                self.datatable.setItem(i,7,P6)
                self.datatable.setItem(i,8,P7)
                self.datatable.setItem(i,9,P8)
                self.datatable.setItem(i,10,P9)
    
            header = self.datatable.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.Fixed)
            header.setSectionResizeMode(1, QHeaderView.Fixed)
            header.setSectionResizeMode(2, QHeaderView.Fixed)
            header.setSectionResizeMode(3, QHeaderView.Fixed)
            header.setSectionResizeMode(4, QHeaderView.Fixed)
            header.setSectionResizeMode(len(columns) - 1, QHeaderView.Stretch)
            self.datatable.resizeColumnsToContents()
        except:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass
            
    @pyqtSlot(bool)
    def copyDataTabletoClipboard(self,_=False):
        nrows = self.datatable.rowCount() 
        ncols = self.datatable.columnCount() - 1 #there is a dummy column at the end on the right
        clipboard = ""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            tbl = prettytable.PrettyTable()
            fields = []
            for c in range(ncols):
                fields.append(u(self.datatable.horizontalHeaderItem(c).text()))
            tbl.field_names = fields
            for r in range(nrows):
                rows = []
                for c in range(ncols):
                    rows.append(u(self.datatable.item(r,c).text()))
                tbl.add_row(rows)
            clipboard = tbl.get_string()
        else:
            for c in range(ncols):
                clipboard += u(self.datatable.horizontalHeaderItem(c).text())
                if c != (ncols-1):
                    clipboard += '\t'
            clipboard += '\n'
            for r in range(nrows):
                for c in range(ncols):
                    clipboard += u(self.datatable.item(r,c).text())
                    if c != (ncols-1):
                        clipboard += '\t'
                clipboard += '\n'
        # copy to the system clipboard
        sys_clip = QApplication.clipboard()
        sys_clip.setText(clipboard)
        aw.sendmessage(QApplication.translate("Message","Data table copied to clipboard",None))

########################################################################################
#####################  RECENT ROAST POPUP  #############################################


class RoastsComboBox(QComboBox):
    def __init__(self, parent = None, selection = None):
        super(RoastsComboBox, self).__init__(parent)
        self.installEventFilter(self)
        self.selection = u(selection) # just the roast title
        self.edited = selection
        self.updateMenu()
        self.editTextChanged.connect(self.textEdited)
        self.setEditable(True)

    @pyqtSlot("QString")
    def textEdited(self,txt):
        cleaned = ' '.join(txt.split())
        self.edited = cleaned

    def getSelection(self):
        return self.edited or self.selection

    def setSelection(self,i):
        if i >= 0:
            try:
                self.edited = None # reset the user text editing
            except Exception:
                pass

    def eventFilter(self, obj, event):
# the next prevents correct setSelection on Windows
#        if event.type() == QEvent.FocusIn:
#            self.setSelection(self.currentIndex())
        if event.type() == QEvent.MouseButtonPress:
            self.updateMenu()
            return True
        return super(RoastsComboBox, self).eventFilter(obj, event)

    # the first entry is always just the current text edit line
    def updateMenu(self):
        self.blockSignals(True)
        try:
            roasts = aw.recentRoastsMenuList()
            self.clear()
            self.addItems([u(self.edited)] + roasts)
        except:
            pass
        self.blockSignals(False)

            
########################################################################################
#####################  ROAST PROPERTIES EDIT GRAPH DLG  ################################
########################################################################################

class ClickableQLabel(QLabel):
    clicked = pyqtSignal()
    left_clicked = pyqtSignal()
    right_clicked = pyqtSignal()
    
    def __init__(self, *args, **kwargs):
        super(ClickableQLabel, self).__init__(*args, **kwargs)

    def mousePressEvent(self, event):
        self.clicked.emit()
        if event.button() == Qt.LeftButton:
            self.left_clicked.emit()
        elif event.button() == Qt.RightButton:
            self.right_clicked.emit()


# this one emits a clicked event on right-clicks and an editingFinished event when the text was changed and the focus got lost
class ClickableTextEdit(QTextEdit):
    clicked = pyqtSignal()
    editingFinished = pyqtSignal()
    receivedFocus = pyqtSignal()
    
    def __init__(self, *args, **kwargs):
        super(ClickableTextEdit, self).__init__(*args, **kwargs)
        self._changed = False
        self.setTabChangesFocus(True)
        self.textChanged.connect(self._handle_text_changed)
        
    def mousePressEvent(self, event):
        super(ClickableTextEdit, self).mousePressEvent(event)
        if event.modifiers() == Qt.ControlModifier:
            self.clicked.emit()

    def focusInEvent(self, event):
        super(ClickableTextEdit, self).focusInEvent(event)
        self.receivedFocus.emit()

    def focusOutEvent(self, event):
        if self._changed:
            self.editingFinished.emit()
        super(ClickableTextEdit, self).focusOutEvent(event)

    @pyqtSlot()
    def _handle_text_changed(self):
        self._changed = True

    def setTextChanged(self, state=True):
        self._changed = state

    def setNewPlainText(self, text):
        QTextEdit.setPlainText(self, text)
        self._changed = False
            

class editGraphDlg(ArtisanResizeablDialog):
    scaleWeightUpdated = pyqtSignal(float)
    connectScaleSignal = pyqtSignal()
    readScaleSignal = pyqtSignal()

    def __init__(self, parent = None):
        super(editGraphDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Properties",None))
        
        # we remember user modifications to revert to them on deselecting a plus element
        self.modified_beans = aw.qmc.beans
        self.modified_density_in_text = str(aw.float2float(aw.qmc.density[0]))
        self.modified_volume_in_text = str(aw.float2float(aw.qmc.volume[0]))
        self.modified_beansize_min_text = str(aw.qmc.beansize_min)
        self.modified_beansize_max_text = str(aw.qmc.beansize_max)
        self.modified_moisture_greens_text = str(aw.qmc.moisture_greens)
        
        # remember parameters set by plus_coffee/plus_blend on entering the dialog to enable a Cancel action
        self.org_beans = aw.qmc.beans
        self.org_density = aw.qmc.density
        self.org_density_roasted = aw.qmc.density_roasted
        self.org_beansize_min = aw.qmc.beansize_min
        self.org_beansize_max = aw.qmc.beansize_max
        self.org_moisture_greens = aw.qmc.moisture_greens
        
        self.org_title = aw.qmc.title
        self.org_title_show_always = aw.qmc.title_show_always
        
        self.org_weight = aw.qmc.weight[:]
        self.org_volume = aw.qmc.volume[:]
        
        self.batcheditmode = False # a click to the batch label enables the batcheditmode
        
        self.ble = None # the BLE interface
        self.scale_weight = None # weight received from a connected scale
        self.scale_battery = None # battery level of the connected scale in %
        self.scale_set = None # set weight for accumulation in g
        
        self.disconnecting = False # this is set to True to terminate the scale connection
        self.volumedialog = None # link forward to the the Volume Calculator
        
        # other parameters remembered for Cancel operation
        self.org_specialevents = aw.qmc.specialevents[:]
        self.org_specialeventstype = aw.qmc.specialeventstype[:]
        self.org_specialeventsStrings = aw.qmc.specialeventsStrings[:]
        self.org_specialeventsvalue = aw.qmc.specialeventsvalue[:]
        self.org_timeindex = aw.qmc.timeindex[:]
        
        self.org_ambientTemp = aw.qmc.ambientTemp
        self.org_ambient_humidity = aw.qmc.ambient_humidity
        self.org_ambient_pressure = aw.qmc.ambient_pressure
        
        # propulated by selecting a recent roast from the popup via recentRoastActivated()
        self.template_file = None
        self.template_name = None
        self.template_uuid = None
        self.template_batchnr = None
        self.template_batchprefix = None
        
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #MARKERS
        chargelabel = QLabel("<b>" + u(QApplication.translate("Label", "CHARGE",None)) + "</b>")
        chargelabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        chargelabel.setStyleSheet("background-color:'#f07800';")
        self.chargeedit = QLineEdit(aw.qmc.stringfromseconds(0))
#        self.chargeedit.setFocusPolicy(Qt.NoFocus)
        self.chargeedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.chargeeditcopy = aw.qmc.stringfromseconds(0)
        self.chargeedit.setValidator(QRegExpValidator(regextime,self))
        self.chargeedit.setMaximumWidth(50)
        self.chargeedit.setMinimumWidth(50)
        chargelabel.setBuddy(self.chargeedit)
        self.charge_idx = 0
        self.drop_idx = 0
        #charge_str = ""
        drop_str = ""
        if len(aw.qmc.timex):
            TP_index = aw.findTP()
            if aw.qmc.timeindex[1]:
                #manual dryend available
                dryEndIndex = aw.qmc.timeindex[1]
            else:
                #find when dry phase ends 
                dryEndIndex = aw.findDryEnd(TP_index)
            self.charge_idx = aw.findBTbreak(0,dryEndIndex,offset=0.5)
            self.drop_idx = aw.findBTbreak(dryEndIndex,offset=0.2)
            if self.drop_idx != 0 and self.drop_idx != aw.qmc.timeindex[6]:
                drop_str = aw.qmc.stringfromseconds(int(aw.qmc.timex[self.drop_idx]-aw.qmc.timex[aw.qmc.timeindex[0]]))
        drylabel = QLabel("<b>" + u(QApplication.translate("Label", "DRY END",None)) + "</b>")
        drylabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        drylabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[1] and aw.qmc.timeindex[1] < len(aw.qmc.timex):
            t2 = aw.qmc.timex[aw.qmc.timeindex[1]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t2 = 0
        self.dryedit = QLineEdit(aw.qmc.stringfromseconds(t2))
        self.dryedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dryeditcopy = aw.qmc.stringfromseconds(t2)
        self.dryedit.setValidator(QRegExpValidator(regextime,self))
        self.dryedit.setMaximumWidth(50)
        self.dryedit.setMinimumWidth(50)
        drylabel.setBuddy(self.dryedit)
        Cstartlabel = QLabel("<b>" + u(QApplication.translate("Label","FC START",None)) + "</b>")
        Cstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[2] and aw.qmc.timeindex[2] < len(aw.qmc.timex):
            t3 = aw.qmc.timex[aw.qmc.timeindex[2]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t3 = 0
        self.Cstartedit = QLineEdit(aw.qmc.stringfromseconds(t3))
#        self.Cstartedit.setFocusPolicy(Qt.NoFocus)
        self.Cstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cstarteditcopy = aw.qmc.stringfromseconds(t3)
        self.Cstartedit.setValidator(QRegExpValidator(regextime,self))
        self.Cstartedit.setMaximumWidth(50)
        self.Cstartedit.setMinimumWidth(50)
        Cstartlabel.setBuddy(self.Cstartedit)
        
        Cendlabel = QLabel("<b>" + u(QApplication.translate("Label","FC END",None)) + "</b>")
        Cendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        Cendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[3] and aw.qmc.timeindex[3] < len(aw.qmc.timex):
            t4 = aw.qmc.timex[aw.qmc.timeindex[3]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t4 = 0
        self.Cendedit = QLineEdit(aw.qmc.stringfromseconds(t4))
#        self.Cendedit.setFocusPolicy(Qt.NoFocus)
        self.Cendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.Cendeditcopy = aw.qmc.stringfromseconds(t4)
        self.Cendedit.setValidator(QRegExpValidator(regextime,self))
        self.Cendedit.setMaximumWidth(50)
        self.Cendedit.setMinimumWidth(50)
        Cendlabel.setBuddy(self.Cendedit)
        CCstartlabel = QLabel("<b>" + u(QApplication.translate("Label","SC START",None)) + "</b>")
        CCstartlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCstartlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[4] and aw.qmc.timeindex[4] < len(aw.qmc.timex):
            t5 = aw.qmc.timex[aw.qmc.timeindex[4]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t5 = 0
        self.CCstartedit = QLineEdit(aw.qmc.stringfromseconds(t5))
#        self.CCstartedit.setFocusPolicy(Qt.NoFocus)
        self.CCstartedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCstarteditcopy = aw.qmc.stringfromseconds(t5)
        self.CCstartedit.setValidator(QRegExpValidator(regextime,self))
        self.CCstartedit.setMaximumWidth(50)
        self.CCstartedit.setMinimumWidth(50)
        CCstartlabel.setBuddy(self.CCstartedit)
        CCendlabel = QLabel("<b>" + u(QApplication.translate("Label","SC END",None)) + "</b>")
        CCendlabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        CCendlabel.setStyleSheet("background-color:'orange';")
        if aw.qmc.timeindex[5] and aw.qmc.timeindex[5] < len(aw.qmc.timex):
            t6 = aw.qmc.timex[aw.qmc.timeindex[5]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t6 = 0
        self.CCendedit = QLineEdit(aw.qmc.stringfromseconds(t6))
#        self.CCendedit.setFocusPolicy(Qt.NoFocus)
        self.CCendedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.CCendeditcopy = aw.qmc.stringfromseconds(t6)
        self.CCendedit.setValidator(QRegExpValidator(regextime,self))
        self.CCendedit.setMaximumWidth(50)
        self.CCendedit.setMinimumWidth(50)
        CCendlabel.setBuddy(self.CCendedit)
        droplabel = QLabel("<b>" + u(QApplication.translate("Label", "DROP",None)) + "</b>")
        droplabel.setStyleSheet("background-color:'#f07800';")
        droplabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[6] and aw.qmc.timeindex[6] < len(aw.qmc.timex):
            t7 = aw.qmc.timex[aw.qmc.timeindex[6]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t7 = 0
        self.dropedit = QLineEdit(aw.qmc.stringfromseconds(t7))
#        self.dropedit.setFocusPolicy(Qt.NoFocus)
        self.dropedit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.dropeditcopy = aw.qmc.stringfromseconds(t7)
        self.dropedit.setValidator(QRegExpValidator(regextime,self))
        self.dropedit.setMaximumWidth(50)
        self.dropedit.setMinimumWidth(50)
        droplabel.setBuddy(self.dropedit)
        self.dropestimate = QLabel(drop_str)
        coollabel = QLabel("<b>" + u(QApplication.translate("Label", "COOL",None)) + "</b>")
        coollabel.setStyleSheet("background-color:'#6666ff';")
        coollabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        if aw.qmc.timeindex[7] and aw.qmc.timeindex[7] < len(aw.qmc.timex):
            t8 = aw.qmc.timex[aw.qmc.timeindex[7]]-aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            t8 = 0
        self.cooledit = QLineEdit(aw.qmc.stringfromseconds(t8))
#        self.cooledit.setFocusPolicy(Qt.NoFocus)
        self.cooledit.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.cooleditcopy = aw.qmc.stringfromseconds(t8)
        self.cooledit.setValidator(QRegExpValidator(regextime,self))
        self.cooledit.setMaximumWidth(50)
        self.cooledit.setMinimumWidth(50)
        coollabel.setBuddy(self.cooledit)
        self.roastproperties = QCheckBox(QApplication.translate("CheckBox","Delete roast properties on RESET", None))
        self.roastproperties.setChecked(bool(aw.qmc.roastpropertiesflag))
        self.roastproperties.stateChanged.connect(self.roastpropertiesChanged)
        self.roastpropertiesAutoOpen = QCheckBox(QApplication.translate("CheckBox","Open on CHARGE", None))
        self.roastpropertiesAutoOpen.setChecked(bool(aw.qmc.roastpropertiesAutoOpenFlag))
        self.roastpropertiesAutoOpen.stateChanged.connect(self.roastpropertiesAutoOpenChanged)
        # EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        self.clusterEventsButton = QPushButton(QApplication.translate("Button", "Cluster",None))
        self.clusterEventsButton.setFocusPolicy(Qt.NoFocus)
        self.clusterEventsButton.setMaximumSize(self.clusterEventsButton.sizeHint())
        self.clusterEventsButton.setMinimumSize(self.clusterEventsButton.minimumSizeHint())
        self.clusterEventsButton.clicked.connect(self.clusterEvents)
        self.clearEventsButton = QPushButton(QApplication.translate("Button", "Clear",None))
        self.clearEventsButton.setFocusPolicy(Qt.NoFocus)
        self.clearEventsButton.setMaximumSize(self.clearEventsButton.sizeHint())
        self.clearEventsButton.setMinimumSize(self.clearEventsButton.minimumSizeHint())
        self.clearEventsButton.clicked.connect(self.clearEvents) 
        self.createalarmTableButton = QPushButton(QApplication.translate("Button", "Create Alarms",None))
        self.createalarmTableButton.setFocusPolicy(Qt.NoFocus)
        self.createalarmTableButton.setMaximumSize(self.createalarmTableButton.sizeHint())
        self.createalarmTableButton.setMinimumSize(self.createalarmTableButton.minimumSizeHint())
        self.createalarmTableButton.clicked.connect(self.createAlarmEventTable)
        self.ordereventTableButton = QPushButton(QApplication.translate("Button", "Order",None))
        self.ordereventTableButton.setFocusPolicy(Qt.NoFocus)
        self.ordereventTableButton.setMaximumSize(self.ordereventTableButton.sizeHint())
        self.ordereventTableButton.setMinimumSize(self.ordereventTableButton.minimumSizeHint())
        self.ordereventTableButton.clicked.connect(self.orderEventTable)
        self.neweventTableButton = QPushButton(QApplication.translate("Button", "Add",None))
        self.neweventTableButton.setFocusPolicy(Qt.NoFocus)
        self.neweventTableButton.setMaximumSize(self.neweventTableButton.sizeHint())
        self.neweventTableButton.setMinimumSize(self.neweventTableButton.minimumSizeHint())
        self.neweventTableButton.clicked.connect(self.addEventTable)
        self.deleventTableButton = QPushButton(QApplication.translate("Button", "Delete",None))
        self.deleventTableButton.setFocusPolicy(Qt.NoFocus)
        self.deleventTableButton.setMaximumSize(self.deleventTableButton.sizeHint())
        self.deleventTableButton.setMinimumSize(self.deleventTableButton.minimumSizeHint())
        self.deleventTableButton.clicked.connect(self.deleteEventTable)
        self.copyeventTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copyeventTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copyeventTableButton.setFocusPolicy(Qt.NoFocus)
        self.copyeventTableButton.setMaximumSize(self.copyeventTableButton.sizeHint())
        self.copyeventTableButton.setMinimumSize(self.copyeventTableButton.minimumSizeHint())
        self.copyeventTableButton.clicked.connect(self.copyEventTabletoClipboard)
        
        #DATA Table
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        self.copydataTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copydataTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copydataTableButton.setFocusPolicy(Qt.NoFocus)
        self.copydataTableButton.setMaximumSize(self.copydataTableButton.sizeHint())
        self.copydataTableButton.setMinimumSize(self.copydataTableButton.minimumSizeHint())
        self.copydataTableButton.clicked.connect(self.copyDataTabletoClipboard)
        #TITLE
        titlelabel = QLabel("<b>" + u(QApplication.translate("Label", "Title",None)) + "</b>")
        self.titleedit = RoastsComboBox(selection = aw.qmc.title)
        self.titleedit.setMinimumWidth(100)
        self.titleedit.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Fixed)
        self.titleedit.activated.connect(self.recentRoastActivated)
        self.titleedit.editTextChanged.connect(self.recentRoastEnabled)
        if sys.platform.startswith("darwin") and darkdetect.isDark():
            if aw.qmc.palette["canvas"] == None or aw.qmc.palette["canvas"] == "None":
                canvas_color = "white"
            else:
                canvas_color = aw.qmc.palette["canvas"]
            brightness_title = aw.QColorBrightness(QColor(aw.qmc.palette["title"]))
            brightness_canvas = aw.QColorBrightness(QColor(canvas_color))
            # in dark mode we choose the darker color as background
            if brightness_title > brightness_canvas:
                backgroundcolor = QColor(canvas_color).name()
                color = QColor(aw.qmc.palette["title"]).name()
            else:
                backgroundcolor = QColor(aw.qmc.palette["title"]).name()
                color = QColor(canvas_color).name()
            self.titleedit.setStyleSheet(
                "QComboBox {font-weight: bold; background-color: " + backgroundcolor + "; color: " + color + ";} QComboBox QAbstractItemView {font-weight: normal;}")
        else:
            color = ""
            if aw.qmc.palette["title"] != None and aw.qmc.palette["title"] != "None":
                color = " color: " + QColor(aw.qmc.palette["title"]).name() + ";"
            backgroundcolor = ""
            if aw.qmc.palette["canvas"] != None and aw.qmc.palette["canvas"] != "None":
                backgroundcolor = " background-color: " + QColor(aw.qmc.palette["canvas"]).name() + ";"
            self.titleedit.setStyleSheet(
                "QComboBox {font-weight: bold;" + color + backgroundcolor + "} QComboBox QAbstractItemView {font-weight: normal;}")
        self.titleedit.setView(QListView())
        self.titleShowAlwaysFlag = QCheckBox(QApplication.translate("CheckBox","Show Always", None))
        self.titleShowAlwaysFlag.setChecked(aw.qmc.title_show_always)
        
        #Date
        datelabel1 = QLabel("<b>" + u(QApplication.translate("Label", "Date",None)) + "</b>")
        date = aw.qmc.roastdate.date().toString()
        date += ", " + u(aw.qmc.roastdate.time().toString()[:-3])
        dateedit = QLineEdit(date)
        dateedit.setFocusPolicy(Qt.NoFocus)
        dateedit.setReadOnly(True)
        if sys.platform.startswith("darwin") and darkdetect.isDark():
            dateedit.setStyleSheet("background-color: #757575; color : white;")
        else:
            dateedit.setStyleSheet("background-color: #eeeeee;")
        #Batch
        batchlabel = ClickableQLabel("<b>" + u(QApplication.translate("Label", "Batch",None)) + "</b>")
        batchlabel.right_clicked.connect(self.enableBatchEdit)
        self.batchLayout = QHBoxLayout()
        if aw.superusermode: # and aw.qmc.batchcounter > -1:
            self.defineBatchEditor()
        else:
            batch = ""
            if aw.qmc.roastbatchnr != 0:
                roastpos = " (" + u(aw.qmc.roastbatchpos) + ")"
            else:
                roastpos = ""
            if aw.qmc.roastbatchnr == 0:
                batch = ""
            else:
                batch = u(aw.qmc.roastbatchprefix) + u(aw.qmc.roastbatchnr) + roastpos + u(" ")
            self.batchedit = QLineEdit(batch)
            self.batchedit.setReadOnly(True)
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                self.batchedit.setStyleSheet("background-color: #757575; color : white;")
            else:
                self.batchedit.setStyleSheet("background-color: #eeeeee;")
            self.batchedit.setFocusPolicy(Qt.NoFocus)
            
        #Beans
        beanslabel = QLabel("<b>" + u(QApplication.translate("Label", "Beans",None)) + "</b>")
        self.beansedit = ClickableTextEdit()
        self.beansedit.editingFinished.connect(self.beansEdited)
        
        self.beansedit.setMaximumHeight(60)
        if aw.qmc.beans is not None:
            self.beansedit.setNewPlainText(u(aw.qmc.beans))
                    
        #roaster
        self.roaster = QLineEdit(aw.qmc.roastertype)
        #operator
        self.operator = QLineEdit(aw.qmc.operator)
        #drum speed
        self.drumspeed = QLineEdit(aw.qmc.drumspeed)
        self.drumspeed.setAlignment(Qt.AlignCenter)
        #weight
        weightlabel = QLabel("<b>" + u(QApplication.translate("Label", "Weight",None)) + "</b>")
        green_label = QLabel("<b>" + QApplication.translate("Label", "Green",None) + "</b>")
        roasted_label = QLabel("<b>" + QApplication.translate("Label", "Roasted",None) + "</b>")
        inw = "%g" % aw.float2floatWeightVolume(aw.qmc.weight[0])
        outw = "%g" % aw.float2floatWeightVolume(aw.qmc.weight[1])
        self.weightinedit = QLineEdit(inw)
        self.weightinedit.setValidator(aw.createCLocaleDoubleValidator(0., 9999999., 4, self.weightinedit))  # the max limit has to be high enough otherwise the connected signals are not send!
        self.weightinedit.setMinimumWidth(70)
        self.weightinedit.setMaximumWidth(70)
        self.weightinedit.setAlignment(Qt.AlignRight)
        self.weightoutedit = QLineEdit(outw)
        self.weightoutedit.setValidator(aw.createCLocaleDoubleValidator(0., 9999999., 4, self.weightoutedit))  # the max limit has to be high enough otherwise the connected signals are not send!
        self.weightoutedit.setMinimumWidth(70)
        self.weightoutedit.setMaximumWidth(70)
        self.weightoutedit.setAlignment(Qt.AlignRight)
        self.weightpercentlabel = QLabel(QApplication.translate("Label", "",None))
        self.weightpercentlabel.setMinimumWidth(55)
        self.weightpercentlabel.setMaximumWidth(55)
        self.weightpercentlabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.roastdegreelabel = QLabel("")
        self.roastdegreelabel.setMinimumWidth(80)
        self.roastdegreelabel.setMaximumWidth(80)
        self.percent()
        self.weightinedit.editingFinished.connect(self.weightineditChanged)
        self.weightoutedit.editingFinished.connect(self.weightouteditChanged)
        self.unitsComboBox = QComboBox()
        self.unitsComboBox.setMaximumWidth(60)
        self.unitsComboBox.setMinimumWidth(60)
        self.unitsComboBox.addItems(aw.qmc.weight_units)
        self.unitsComboBox.setCurrentIndex(aw.qmc.weight_units.index(aw.qmc.weight[2]))
        self.unitsComboBox.currentIndexChanged.connect(self.changeWeightUnit)
        #volume
        volumelabel = QLabel("<b>" + u(QApplication.translate("Label", "Volume",None)) + "</b>")
        inv = "%g" %  aw.float2floatWeightVolume(aw.qmc.volume[0])
        outv = "%g" % aw.float2floatWeightVolume(aw.qmc.volume[1])
        self.volumeinedit = QLineEdit(inv)
        self.volumeinedit.setValidator(aw.createCLocaleDoubleValidator(0., 999999., 4, self.volumeinedit)) # the max limit has to be high enough otherwise the connected signals are not send!
        self.volumeinedit.setMinimumWidth(70)
        self.volumeinedit.setMaximumWidth(70)
        self.volumeinedit.setAlignment(Qt.AlignRight)
        self.volumeoutedit = QLineEdit(outv)
        self.volumeoutedit.setValidator(aw.createCLocaleDoubleValidator(0., 999999., 4, self.volumeoutedit)) # the max limit has to be high enough otherwise the connected signals are not send!
        self.volumeoutedit.setMinimumWidth(70)
        self.volumeoutedit.setMaximumWidth(70)
        self.volumeoutedit.setAlignment(Qt.AlignRight)
        self.volumepercentlabel = QLabel(QApplication.translate("Label", " %",None))
        self.volumepercentlabel.setMinimumWidth(55)
        self.volumepercentlabel.setMaximumWidth(55)
        self.volumepercentlabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.volumeoutedit.editingFinished.connect(self.volume_percent)
        self.volumeinedit.editingFinished.connect(self.volume_percent)
        self.volumeUnitsComboBox = QComboBox()
        self.volumeUnitsComboBox.setMaximumWidth(60)
        self.volumeUnitsComboBox.setMinimumWidth(60)
        self.volumeUnitsComboBox.addItems(aw.qmc.volume_units)
        self.volumeUnitsComboBox.setCurrentIndex(aw.qmc.volume_units.index(aw.qmc.volume[2]))
        self.volumeUnitsComboBox.currentIndexChanged.connect(self.changeVolumeUnit)
        self.unitsComboBox.currentIndexChanged.connect(self.calculated_density)
        #density
        bean_density_label = QLabel("<b>" + u(QApplication.translate("Label", "Density",None)) + "</b>")
        density_unit_label = QLabel("g/l")
        self.bean_density_in_edit = QLineEdit("%g" % aw.float2float(aw.qmc.density[0]))
        self.bean_density_in_edit.setValidator(aw.createCLocaleDoubleValidator(0., 999999., 1,self.bean_density_in_edit))
        self.bean_density_in_edit.setMinimumWidth(70)
        self.bean_density_in_edit.setMaximumWidth(70)
        self.bean_density_in_edit.setAlignment(Qt.AlignRight)
        self.bean_density_out_edit = QLineEdit("%g" % aw.float2float(aw.qmc.density_roasted[0]))
        self.bean_density_out_edit.setValidator(aw.createCLocaleDoubleValidator(0., 999999., 1,self.bean_density_out_edit))
        self.bean_density_out_edit.setMinimumWidth(70)
        self.bean_density_out_edit.setMaximumWidth(70)
        self.bean_density_out_edit.setAlignment(Qt.AlignRight)
        self.bean_density_in_edit.editingFinished.connect(self.density_in_editing_finished)
        self.bean_density_out_edit.editingFinished.connect(self.density_out_editing_finished)
        self.densitypercentlabel = QLabel(QApplication.translate("Label", "",None))
        self.densitypercentlabel.setMinimumWidth(55)
        self.densitypercentlabel.setMaximumWidth(55)
        self.densitypercentlabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        
        self.organicpercentlabel = QLabel(QApplication.translate("Label", "",None))
        self.organicpercentlabel.setMinimumWidth(55)
        self.organicpercentlabel.setMaximumWidth(55)
        self.organicpercentlabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        
        # volume calc button
        volumeCalcButton = QPushButton(QApplication.translate("Button", "calc",None))
        volumeCalcButton.clicked.connect(self.volumeCalculatorTimer)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        volumeCalcButton.setFocusPolicy(Qt.NoFocus)
        
        # add to recent
        self.addRecentButton = QPushButton("+")
        self.addRecentButton.clicked.connect(self.addRecentRoast)
        self.addRecentButton.setFocusPolicy(Qt.NoFocus)
        
        # delete from recent
        self.delRecentButton = QPushButton("-")
        self.delRecentButton.clicked.connect(self.delRecentRoast)
        self.delRecentButton.setFocusPolicy(Qt.NoFocus)

        self.recentRoastEnabled()
        
        #bean size
        bean_size_label = QLabel("<b>" + u(QApplication.translate("Label", "Screen",None)) + "</b>")
        self.bean_size_min_edit = QLineEdit(str(int(round(aw.qmc.beansize_min))))
        self.bean_size_min_edit.editingFinished.connect(self.beanSizeMinEdited)
        self.bean_size_min_edit.setValidator(QIntValidator(0,50,self.bean_size_min_edit))
        self.bean_size_min_edit.setMinimumWidth(25)
        self.bean_size_min_edit.setMaximumWidth(25)
        self.bean_size_min_edit.setAlignment(Qt.AlignRight)
        bean_size_sep_label = QLabel("/")
        self.bean_size_max_edit = QLineEdit(str(int(round(aw.qmc.beansize_max))))
        self.bean_size_max_edit.editingFinished.connect(self.beanSizeMaxEdited)
        self.bean_size_max_edit.setValidator(QIntValidator(0,50,self.bean_size_max_edit))
        self.bean_size_max_edit.setMinimumWidth(25)
        self.bean_size_max_edit.setMaximumWidth(25)
        self.bean_size_max_edit.setAlignment(Qt.AlignRight)
        bean_size_unit_label = QLabel(QApplication.translate("Label", "18/64\u2033",None))
        #bean color
        color_label = QLabel("<b>" + u(QApplication.translate("Label", "Color",None)) + "</b>")
        whole_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Whole",None)) + "</b>")
        self.whole_color_edit = QLineEdit(str(aw.qmc.whole_color))
        self.whole_color_edit.setValidator(QIntValidator(0, 1000, self.whole_color_edit))
        self.whole_color_edit.setMinimumWidth(70)
        self.whole_color_edit.setMaximumWidth(70)
        self.whole_color_edit.setAlignment(Qt.AlignRight)
        ground_color_label = QLabel("<b>" + u(QApplication.translate("Label", "Ground",None)) + "</b>")
        self.ground_color_edit = QLineEdit(str(aw.qmc.ground_color))
        self.ground_color_edit.setValidator(QIntValidator(0, 1000, self.ground_color_edit))
        self.ground_color_edit.setMinimumWidth(70)
        self.ground_color_edit.setMaximumWidth(70)
        self.ground_color_edit.setAlignment(Qt.AlignRight)
        self.bean_size_min_edit.setAlignment(Qt.AlignRight)
        self.bean_size_max_edit.setAlignment(Qt.AlignRight)
        self.colorSystemComboBox = QComboBox()
        self.colorSystemComboBox.addItems(aw.qmc.color_systems)
        self.colorSystemComboBox.setCurrentIndex(aw.qmc.color_system_idx)
        #Greens Temp
        greens_temp_label = QLabel("<b>" + u(QApplication.translate("Label", "Beans",None)) + "</b>")
        greens_temp_unit_label = QLabel(aw.qmc.mode)
        self.greens_temp_edit = QLineEdit()
        self.greens_temp_edit.setText("%g" % aw.float2float(aw.qmc.greens_temp))
        self.greens_temp_edit.setMaximumWidth(60)
        self.greens_temp_edit.setValidator(aw.createCLocaleDoubleValidator(-9999., 999999., 1, self.greens_temp_edit)) # range to 1000 needed to trigger editing_finished on input "12,2"
        self.greens_temp_edit.setAlignment(Qt.AlignRight)
        self.greens_temp_edit.editingFinished.connect(self.greens_temp_editing_finished)
        greens_temp = QHBoxLayout()
        greens_temp.addStretch()
        #Moisture Greens
        moisture_label = QLabel("<b>" + u(QApplication.translate("Label", "Moisture",None)) + "</b>")
        moisture_greens_unit_label = QLabel(QApplication.translate("Label", "%",None))
        self.moisture_greens_edit = QLineEdit()
        self.moisture_greens_edit.setText("%g" % aw.float2float(aw.qmc.moisture_greens))
        self.moisture_greens_edit.setMaximumWidth(70)
        self.moisture_greens_edit.setValidator(aw.createCLocaleDoubleValidator(0., 100., 1, self.moisture_greens_edit))
        self.moisture_greens_edit.setAlignment(Qt.AlignRight)
        #Moisture Roasted
        #bag humidity
        moisture_roasted_label = QLabel("<b>" + u(QApplication.translate("Label", "Roasted",None)) + "</b>")
        moisture_roasted_unit_label = QLabel(QApplication.translate("Label", "%",None))
        self.moisture_roasted_edit = QLineEdit()
        self.moisture_roasted_edit.setText("%g" % aw.float2float(aw.qmc.moisture_roasted))
        self.moisture_roasted_edit.setMaximumWidth(70)
        self.moisture_roasted_edit.setValidator(aw.createCLocaleDoubleValidator(0., 100., 1, self.moisture_roasted_edit))
        self.moisture_roasted_edit.setAlignment(Qt.AlignRight)
        self.moisturepercentlabel = QLabel(QApplication.translate("Label", "",None))
        self.moisturepercentlabel.setMinimumWidth(55)
        self.moisturepercentlabel.setMaximumWidth(55)
        self.moisturepercentlabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.moisture_greens_edit.editingFinished.connect(self.moistureEdited)
        self.moisture_roasted_edit.editingFinished.connect(self.moistureEdited)

        moisture_roasted = QHBoxLayout()
        moisture_roasted.addWidget(moisture_roasted_label)
        moisture_roasted.addWidget(moisture_roasted_unit_label)
        moisture_roasted.addStretch()
        #Ambient temperature (uses display mode as unit (F or C)
        ambientlabel = QLabel("<b>" + u(QApplication.translate("Label", "Ambient Conditions",None)) + "</b>")
        ambientunitslabel = QLabel(aw.qmc.mode)
        ambient_humidity_unit_label = QLabel(QApplication.translate("Label", "%",None))
        self.ambient_humidity_edit = QLineEdit()
        self.ambient_humidity_edit.setText("%g" % aw.float2float(aw.qmc.ambient_humidity))
        self.ambient_humidity_edit.setMinimumWidth(50)
        self.ambient_humidity_edit.setMaximumWidth(50)
        self.ambient_humidity_edit.setValidator(aw.createCLocaleDoubleValidator(0., 9999999., 1, self.ambient_humidity_edit))
        self.ambient_humidity_edit.setAlignment(Qt.AlignRight)
        self.ambient_humidity_edit.editingFinished.connect(self.ambient_humidity_editing_finished)
        self.ambientedit = QLineEdit()
        self.ambientedit.setText("%g" % aw.float2float(aw.qmc.ambientTemp))
        self.ambientedit.setMinimumWidth(50)
        self.ambientedit.setMaximumWidth(50)
        self.ambientedit.setValidator(aw.createCLocaleDoubleValidator(-9999., 9999999., 1, self.ambientedit))  # larger range needed to triger editing_finished
        self.ambientedit.setAlignment(Qt.AlignRight)
        self.ambientedit.editingFinished.connect(self.ambientedit_editing_finished)
        pressureunitslabel = QLabel("hPa")
        self.pressureedit = QLineEdit()
        self.pressureedit.setText("%g" % aw.float2float(aw.qmc.ambient_pressure))
        self.pressureedit.setMinimumWidth(55)
        self.pressureedit.setMaximumWidth(55)
        self.pressureedit.setValidator(aw.createCLocaleDoubleValidator(0, 9999999., 1, self.pressureedit))
        self.pressureedit.setAlignment(Qt.AlignRight)
        self.pressureedit.editingFinished.connect(self.pressureedit_editing_finished)
        ambient = QHBoxLayout()
        ambient.addWidget(self.ambient_humidity_edit)
        ambient.addSpacing(1)
        ambient.addWidget(ambient_humidity_unit_label)
        ambient.addSpacing(7)
        ambient.addWidget(self.ambientedit)
        ambient.addSpacing(1)
        ambient.addWidget(ambientunitslabel)
        ambient.addSpacing(7)
        ambient.addWidget(self.pressureedit)
        ambient.addSpacing(1)
        ambient.addWidget(pressureunitslabel)
        ambient.addStretch()
        self.organiclosslabel = QLabel()
        self.scaleWeight = QLabel()
        self.scaleWeightAccumulated = ClickableQLabel("")
        self.scaleWeightAccumulated.clicked.connect(self.resetScaleSet)
        # NOTES
        roastertypelabel = QLabel()
        roastertypelabel.setText("<b>" + u(QApplication.translate("Label", "Machine",None)) + "</b>")
        operatorlabel = QLabel()
        operatorlabel.setText("<b> " + u(QApplication.translate("Label", "Operator",None)) + "</b>")
        drumspeedlabel = QLabel()
        drumspeedlabel.setText("<b> " + u(QApplication.translate("Label", "Drum Speed",None)) + "</b>")
        roastinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Roasting Notes",None)) + "</b>")
        self.roastingeditor = QTextEdit()
#        self.roastingeditor.setMaximumHeight(125)
        if aw.qmc.roastingnotes is not None:
            self.roastingeditor.setPlainText(u(aw.qmc.roastingnotes))
        cuppinglabel = QLabel("<b>" + u(QApplication.translate("Label", "Cupping Notes",None)) + "</b>")
        self.cuppingeditor =  QTextEdit()
#        self.cuppingeditor.setMaximumHeight(125)
        if aw.qmc.cuppingnotes is not None:
            self.cuppingeditor.setPlainText(u(aw.qmc.cuppingnotes))
        # Flags
        self.heavyFC = QCheckBox(QApplication.translate("CheckBox","Heavy FC", None))
        self.heavyFC.setChecked(aw.qmc.heavyFC_flag)
        self.heavyFC.stateChanged.connect(self.roastflagHeavyFCChanged)
        self.lowFC = QCheckBox(QApplication.translate("CheckBox","Low FC", None))
        self.lowFC.setChecked(aw.qmc.lowFC_flag)
        self.lowFC.stateChanged.connect(self.roastflagLowFCChanged)
        self.lightCut = QCheckBox(QApplication.translate("CheckBox","Light Cut", None))
        self.lightCut.setChecked(aw.qmc.lightCut_flag)
        self.lightCut.stateChanged.connect(self.roastflagLightCutChanged)
        self.darkCut = QCheckBox(QApplication.translate("CheckBox","Dark Cut", None))
        self.darkCut.setChecked(aw.qmc.darkCut_flag)
        self.darkCut.stateChanged.connect(self.roastflagDarkCutChanged)        
        self.drops = QCheckBox(QApplication.translate("CheckBox","Drops", None))
        self.drops.setChecked(aw.qmc.drops_flag)
        self.drops.stateChanged.connect(self.roastflagDropsChanged)
        self.oily = QCheckBox(QApplication.translate("CheckBox","Oily", None))
        self.oily.setChecked(aw.qmc.oily_flag)
        self.oily.stateChanged.connect(self.roastflagOilyChanged)
        self.uneven = QCheckBox(QApplication.translate("CheckBox","Uneven", None))
        self.uneven.setChecked(aw.qmc.uneven_flag)
        self.tipping = QCheckBox(QApplication.translate("CheckBox","Tipping", None))
        self.tipping.setChecked(aw.qmc.tipping_flag)
        self.scorching = QCheckBox(QApplication.translate("CheckBox","Scorching", None))
        self.scorching.setChecked(aw.qmc.scorching_flag)
        self.divots = QCheckBox(QApplication.translate("CheckBox","Divots", None))
        self.divots.setChecked(aw.qmc.divots_flag)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.rejected.connect(self.cancel_dialog)
        
        # container tare
        self.tareComboBox = QComboBox()
        self.tareComboBox.addItem("<edit> TARE")
        self.tareComboBox.addItem("")
        self.tareComboBox.insertSeparator(1)
        self.tareComboBox.addItems(aw.qmc.container_names)
        self.tareComboBox.setMaximumWidth(80)
        self.tareComboBox.setMinimumWidth(80)
        self.tareComboBox.setCurrentIndex(aw.qmc.container_idx + 3)
        self.tareComboBox.currentIndexChanged.connect(self.tareChanged)
        self.tarePopupEnabled = True # controls if the popup will process tareChange events
        
        # in button
        inButton = QPushButton(QApplication.translate("Button", "in",None))
        inButton.clicked.connect(self.inWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        inButton.setFocusPolicy(Qt.NoFocus)
        inButton.setMinimumWidth(70)
        inButtonLayout = QHBoxLayout()
        inButtonLayout.addStretch()
        inButtonLayout.addWidget(inButton)
        inButtonLayout.addStretch()
        # out button
        outButton = QPushButton(QApplication.translate("Button", "out",None))
        outButton.clicked.connect(self.outWeight)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        outButton.setFocusPolicy(Qt.NoFocus)
        outButton.setMinimumWidth(70)
        outButtonLayout = QHBoxLayout()
        outButtonLayout.addStretch()
        outButtonLayout.addWidget(outButton)
        outButtonLayout.addStretch()
        # scan whole button
        scanWholeButton = QPushButton(QApplication.translate("Button", "scan",None))
        scanWholeButton.clicked.connect(self.scanWholeColor)
        scanWholeButton.setMinimumWidth(80)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        scanWholeButton.setFocusPolicy(Qt.NoFocus)
        # scan ground button
        scanGroundButton = QPushButton(QApplication.translate("Button", "scan",None))
        scanGroundButton.setMinimumWidth(80)
        scanGroundButton.clicked.connect(self.scanGroundColor)
        #the size of Buttons on the Mac is too small with 70,30 and ok with sizeHint/minimumSizeHint
        scanGroundButton.setFocusPolicy(Qt.NoFocus)
        # Ambient Temperature Source Selector
        self.ambientComboBox = QComboBox()
        self.ambientComboBox.addItems(self.buildAmbientTemperatureSourceList())
        self.ambientComboBox.setCurrentIndex(aw.qmc.ambientTempSource)
        self.ambientComboBox.currentIndexChanged.connect(self.ambientComboBoxIndexChanged)
        ambientSourceLabel = QLabel(QApplication.translate("Label", "Ambient Source",None))
        updateAmbientTemp = QPushButton(QApplication.translate("Button", "update",None))
        updateAmbientTemp.setFocusPolicy(Qt.NoFocus)
        updateAmbientTemp.clicked.connect(self.updateAmbientTemp)
        ##### LAYOUTS
        timeLayout = QGridLayout()
        timeLayout.setVerticalSpacing(3)
        timeLayout.setHorizontalSpacing(3)
        timeLayout.addWidget(chargelabel,0,0)
        timeLayout.addWidget(drylabel,0,1)
        timeLayout.addWidget(Cstartlabel,0,2)
        timeLayout.addWidget(Cendlabel,0,3)
        timeLayout.addWidget(CCstartlabel,0,4)
        timeLayout.addWidget(CCendlabel,0,5)
        timeLayout.addWidget(droplabel,0,6)
        timeLayout.addWidget(coollabel,0,7)
        timeLayout.addWidget(self.chargeedit,1,0,Qt.AlignHCenter)
        timeLayout.addWidget(self.dryedit,1,1,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cstartedit,1,2,Qt.AlignHCenter)
        timeLayout.addWidget(self.Cendedit,1,3,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCstartedit,1,4,Qt.AlignHCenter)
        timeLayout.addWidget(self.CCendedit,1,5,Qt.AlignHCenter)
        timeLayout.addWidget(self.dropedit,1,6,Qt.AlignHCenter)
        timeLayout.addWidget(self.cooledit,1,7,Qt.AlignHCenter)
#        if charge_str != "":
#            calc_chargestr = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.timeindex[0]]))
#            aw.sendmessage(QApplication.translate("Message","The recorded CHARGE time ({0}) does not match the post roast calculated CHARGE time. ({1})", None).format(charge_str, calc_chargestr))
#        if drop_str != "":
#            calc_dropstr = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.timeindex[6]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
#            aw.sendmessage(QApplication.translate("Message","The recorded DROP time ({0}) does not match the post roast calculated DROP time ({1})", None).format(drop_str, calc_dropstr))
        textLayout = QGridLayout()
        textLayout.setHorizontalSpacing(3)
        textLayout.setVerticalSpacing(2)
        textLayout.setContentsMargins(0,0,0,0)
        textLayout.addWidget(datelabel1,0,0)
        datebatch = QHBoxLayout()
        datebatch.addWidget(dateedit)
        datebatch.addSpacing(15)
        datebatch.addWidget(batchlabel)
        datebatch.addSpacing(7)
        datebatch.addLayout(self.batchLayout)
        if not aw.superusermode: # and aw.qmc.batchcounter > -1:
            self.batchLayout.addWidget(self.batchedit)
        textLayout.addLayout(datebatch,0,1)
        
        titleLine = QHBoxLayout()
        titleLine.addWidget(self.titleedit)
        titleLine.addWidget(self.addRecentButton)
        titleLine.addWidget(self.delRecentButton)
        titleLine.addSpacing(2)
        titleLine.addWidget(self.titleShowAlwaysFlag) 
        
        self.template_line = QLabel("P249 Guatemala")
        template_font = self.template_line.font()
        template_font.setPointSize(template_font.pointSize() -1)
        self.template_line.setFont(template_font)
        
#PLUS
        self.plus_store_selected = None # holds the hr_id of the store of the selected coffee or blend
        self.plus_store_selected_label = None # the label of the selected store
        self.plus_coffee_selected = None # holds the hr_id of the selected coffee
        self.plus_coffee_selected_label = None # the label of the selected coffee
        self.plus_blend_selected_label = None # the name of the selected blend
        self.plus_blend_selected_spec = None # holds the blend dict specification of the selected blend
        self.plus_blend_selected_spec_labels = None # the list of coffee labels of the selected blend specification
        if aw.plus_account is not None:
            # variables populated by stock data as rendered in the corresponding popups
            self.plus_stores = None
            self.plus_coffees = None
            self.plus_blends = None
            self.plus_default_store = aw.qmc.plus_default_store
            # current selected stock/coffee/blend _id
            if aw.qmc.plus_store is not None:
                self.plus_store_selected = aw.qmc.plus_store # holds the store corresponding to the plus_coffee_selected/plus_blend_selected
                self.plus_store_selected_label = aw.qmc.plus_store_label
            if aw.qmc.plus_coffee is not None:
                self.plus_coffee_selected = aw.qmc.plus_coffee
                self.plus_coffee_selected_label = aw.qmc.plus_coffee_label
            else:
                if aw.qmc.plus_blend_spec is not None:
                    self.plus_blend_selected_label = aw.qmc.plus_blend_label
                    self.plus_blend_selected_spec = aw.qmc.plus_blend_spec
                    self.plus_blend_selected_spec_labels = aw.qmc.plus_blend_spec_labels
            self.plus_amount_selected = None # holds the amount of the selected coffee/blend if known
            plusCoffeeslabel = QLabel("<b>" + u(QApplication.translate("Label", "Stock",None)) + "</b>")
            self.plusStoreslabel = QLabel("<b>" + u(QApplication.translate("Label", "Store",None)) + "</b>")
            self.plusBlendslabel = QLabel("<b>" + u(QApplication.translate("Label", "Blend",None)) + "</b>")
            self.plus_stores_combo = QComboBox() 
            self.plus_coffees_combo = QComboBox()
            self.plus_blends_combo = QComboBox()
            self.plus_stores_combo.currentIndexChanged.connect(self.storeSelectionChanged)
            self.plus_coffees_combo.currentIndexChanged.connect(self.coffeeSelectionChanged)
            self.plus_blends_combo.currentIndexChanged.connect(self.blendSelectionChanged)
            self.plus_selected_line = QLabel()
            self.plus_selected_line.setOpenExternalLinks(True)
            label_font = self.plus_selected_line.font()
            label_font.setPointSize(label_font.pointSize() -2)
            self.plus_selected_line.setFont(label_font)
            self.populatePlusCoffeeBlendCombos()
            # layouting
            self.plus_coffees_combo.setMinimumContentsLength(15)
            self.plus_blends_combo.setMinimumContentsLength(10)
            self.plus_stores_combo.setMinimumContentsLength(10)
            self.plus_stores_combo.setMaximumWidth(120)            
            self.plus_coffees_combo.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Maximum)
            self.plus_coffees_combo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            self.plus_blends_combo.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Maximum)
            self.plus_blends_combo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            self.plus_stores_combo.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Maximum)
            self.plus_stores_combo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            # plus widget row
            plusLine = QHBoxLayout()
            plusLine.addWidget(self.plus_coffees_combo)
            plusLine.addSpacing(15)
            plusLine.addWidget(self.plusBlendslabel)
            plusLine.addSpacing(5)
            plusLine.addWidget(self.plus_blends_combo)
            plusLine.addSpacing(15)
            plusLine.addWidget(self.plusStoreslabel)
            plusLine.addSpacing(5)
            plusLine.addWidget(self.plus_stores_combo)
            textLayout.addWidget(self.plus_selected_line,4,1)
            textLayout.addWidget(plusCoffeeslabel,5,0)
            textLayout.addLayout(plusLine,5,1)
            textLayoutPlusOffset = 2 # to insert the plus widget row, we move the remaining ones one step lower
        else:
            textLayoutPlusOffset = 0
        textLayout.addWidget(self.template_line,2,1)
        textLayout.addWidget(titlelabel,3,0)
        textLayout.addLayout(titleLine,3,1)
        textLayout.addWidget(beanslabel,4+textLayoutPlusOffset,0)
        textLayout.addWidget(self.beansedit,4+textLayoutPlusOffset,1)
        textLayout.addWidget(operatorlabel,5+textLayoutPlusOffset,0)
            
        roasteroperator = QHBoxLayout()
        roasteroperator.addWidget(self.operator, stretch=3)
        roasteroperator.addSpacing(10)
        roasteroperator.addWidget(roastertypelabel)
        roasteroperator.addSpacing(5)
        roasteroperator.addWidget(self.roaster,stretch=3)
        roasteroperator.addSpacing(10)
        roasteroperator.addWidget(drumspeedlabel)
        roasteroperator.addSpacing(5)
        roasteroperator.addWidget(self.drumspeed,stretch=1)
        textLayout.addLayout(roasteroperator,5+textLayoutPlusOffset,1)
        
        beanSizeLayout = QHBoxLayout()
        beanSizeLayout.setSpacing(2)
        beanSizeLayout.addStretch()
        beanSizeLayout.addWidget(self.bean_size_min_edit)
        beanSizeLayout.addWidget(bean_size_sep_label)
        beanSizeLayout.addWidget(self.bean_size_max_edit)
        beanSizeLayout.addStretch()
        
        propGrid = QGridLayout()
        propGrid.setContentsMargins(0,0,0,0)
        propGrid.setHorizontalSpacing(3)
        propGrid.setVerticalSpacing(0)
        propGrid.addWidget(green_label,0,1,Qt.AlignCenter | Qt.AlignBottom)
        propGrid.addWidget(roasted_label,0,2,Qt.AlignCenter | Qt.AlignBottom)
        propGrid.addWidget(self.organicpercentlabel,0,4,Qt.AlignRight)
        propGrid.addWidget(self.organiclosslabel,0,5,1,3,Qt.AlignLeft)
        propGrid.addWidget(self.scaleWeight,0,8,1,2,Qt.AlignCenter)
        
        propGrid.addWidget(weightlabel,1,0)
        propGrid.addWidget(self.weightinedit,1,1,Qt.AlignRight)
        propGrid.addWidget(self.weightoutedit,1,2,Qt.AlignRight)
        propGrid.addWidget(self.unitsComboBox,1,3)
        propGrid.addWidget(self.weightpercentlabel,1,4,Qt.AlignRight)
        
        propGrid.setColumnStretch(5,10)
        
        if aw.scale.device is not None and aw.scale.device != "" and aw.scale.device != "None":
            propGrid.addWidget(self.tareComboBox,1,7)
            propGrid.addLayout(inButtonLayout,1,8)
            propGrid.addLayout(outButtonLayout,1,9)
            
            if aw.scale.device == "acaia":
                try:
                    with suppress_stdout_stderr():
                        # if selected scale is the Acaia, start the BLE interface
                        from artisanlib.ble import BleInterface
                        from artisanlib.acaia import AcaiaBLE
                        acaia = AcaiaBLE()
                        self.ble = BleInterface(
                            acaia.SERVICE_UUID,
                            acaia.CHAR_UUID,
                            acaia.processData,
                            acaia.sendHeartbeat,
                            acaia.sendStop,
                            acaia.reset)
                            
                    # start BLE loop
                    self.ble.deviceDisconnected.connect(self.ble_scan_failed)
                    self.ble.weightChanged.connect(self.ble_weight_changed)
                    self.ble.batteryChanged.connect(self.ble_battery_changed)
                    self.ble.scanDevices()
                except:
                    pass
            elif aw.scale.device in ["KERN NDE","Shore 930"]:
                self.connectScaleSignal.connect(self.connectScaleLoop)
                QTimer.singleShot(2,lambda : self.connectScaleSignal.emit())
        
        propGrid.addWidget(volumelabel,2,0)
        propGrid.addWidget(self.volumeinedit,2,1,Qt.AlignRight)
        propGrid.addWidget(self.volumeoutedit,2,2,Qt.AlignRight)
        propGrid.addWidget(self.volumeUnitsComboBox,2,3)
        propGrid.addWidget(self.volumepercentlabel,2,4,Qt.AlignRight)
        propGrid.addWidget(self.scaleWeightAccumulated,2,7,1,2,Qt.AlignCenter)
        propGrid.addWidget(volumeCalcButton,2,9)
        
        propGrid.setRowMinimumHeight(3,self.volumeUnitsComboBox.minimumSizeHint().height())
        propGrid.addWidget(bean_density_label,3,0)
        propGrid.addWidget(self.bean_density_in_edit,3,1,Qt.AlignRight)
        propGrid.addWidget(self.bean_density_out_edit,3,2,Qt.AlignRight)
        propGrid.addWidget(density_unit_label,3,3,Qt.AlignCenter)
        propGrid.addWidget(self.densitypercentlabel,3,4,Qt.AlignRight)
        
        propGrid.addWidget(bean_size_label,3,7)
        propGrid.addLayout(beanSizeLayout,3,8,Qt.AlignRight)
        propGrid.addWidget(bean_size_unit_label,3,9,Qt.AlignCenter)
        
        propGrid.addWidget(moisture_label,4,0)
        propGrid.addWidget(self.moisture_greens_edit,4,1,Qt.AlignRight)
        propGrid.addWidget(self.moisture_roasted_edit,4,2,Qt.AlignRight)
        propGrid.addWidget(moisture_greens_unit_label,4,3,Qt.AlignCenter)
        propGrid.addWidget(self.moisturepercentlabel,4,4,Qt.AlignRight)
        propGrid.addWidget(greens_temp_label,4,7)
        propGrid.addWidget(self.greens_temp_edit,4,8,Qt.AlignRight)
        propGrid.addWidget(greens_temp_unit_label,4,9,Qt.AlignCenter)
        
        propGrid.setRowMinimumHeight(7,30)
        propGrid.addWidget(whole_color_label,7,1,Qt.AlignCenter | Qt.AlignBottom)
        propGrid.addWidget(ground_color_label,7,2,Qt.AlignCenter | Qt.AlignBottom)
        
        propGrid.addWidget(color_label,8,0)
        propGrid.addWidget(self.whole_color_edit,8,1,Qt.AlignRight)
        propGrid.addWidget(self.ground_color_edit,8,2,Qt.AlignRight)
        propGrid.addWidget(self.colorSystemComboBox,8,3,1, 2)
                
        if aw.color.device is not None and aw.color.device != "" and aw.color.device not in ["None","Tiny Tonino", "Classic Tonino"]:
            propGrid.addWidget(scanWholeButton,8,6)
        if aw.color.device is not None and aw.color.device != "" and aw.color.device != "None":
            propGrid.addWidget(scanGroundButton,8,7)
            
        propGrid.addWidget(ambientSourceLabel,8,8,1,2,Qt.AlignRight | Qt.AlignBottom)
        
        ambientGrid = QGridLayout()
        ambientGrid.setContentsMargins(0,0,0,0)
        ambientGrid.setHorizontalSpacing(3)
        ambientGrid.setVerticalSpacing(0)
        ambientGrid.addWidget(ambientlabel,2,0)
        ambientGrid.addLayout(ambient,2,2,1,5)
        ambientGrid.addWidget(updateAmbientTemp,2,10)
        ambientGrid.addWidget(self.ambientComboBox,2,11,Qt.AlignRight)
        ambientGrid.setColumnMinimumWidth(3, 11)
        ambientGrid.setColumnMinimumWidth(5, 11)
        ambientGrid.setColumnMinimumWidth(8, 11)
        roastFlagsLayout = QHBoxLayout()
        roastFlagsGrid = QGridLayout()
        roastFlagsGrid.addWidget(self.lowFC,0,0)
        roastFlagsGrid.addWidget(self.heavyFC,1,0)
        roastFlagsGrid.addWidget(self.lightCut,0,1)
        roastFlagsGrid.addWidget(self.darkCut,1,1)
        roastFlagsGrid.addWidget(self.drops,0,2)
        roastFlagsGrid.addWidget(self.oily,1,2)
        roastFlagsGrid.addWidget(self.uneven,0,3)
        roastFlagsGrid.addWidget(self.tipping,1,3)
        roastFlagsGrid.addWidget(self.scorching,0,4)
        roastFlagsGrid.addWidget(self.divots,1,4)
        roastFlagsLayout.addLayout(roastFlagsGrid)
        roastFlagsLayout.addStretch()
        anotationLayout = QVBoxLayout()
        anotationLayout.addWidget(roastinglabel)
        anotationLayout.addWidget(self.roastingeditor)
        anotationLayout.addLayout(roastFlagsLayout)
        anotationLayout.addWidget(cuppinglabel)
        anotationLayout.addWidget(self.cuppingeditor)
        okLayout = QHBoxLayout()
        okLayout.addWidget(self.roastproperties)
        okLayout.addStretch()
        okLayout.addWidget(self.roastpropertiesAutoOpen)
        okLayout.addStretch()
        okLayout.addWidget(self.dialogbuttons)
        okLayout.setSpacing(10)
        okLayout.setContentsMargins(5, 15, 5, 15) # left, top, right, bottom
        timeLayoutBox = QHBoxLayout()
        timeLayoutBox.addStretch()
        timeLayoutBox.addLayout(timeLayout)
        timeLayoutBox.addStretch()
        mainLayout = QVBoxLayout()
        mainLayout.setContentsMargins(3, 3, 3, 3)
        eventbuttonLayout = QHBoxLayout()
        eventbuttonLayout.addWidget(self.copyeventTableButton)
        eventbuttonLayout.addWidget(self.createalarmTableButton)
        eventbuttonLayout.addStretch()
        eventbuttonLayout.addWidget(self.clusterEventsButton)
        eventbuttonLayout.addWidget(self.ordereventTableButton)
        eventbuttonLayout.addStretch()
        eventbuttonLayout.addWidget(self.clearEventsButton)
        eventbuttonLayout.addStretch()
        eventbuttonLayout.addWidget(self.deleventTableButton)
        eventbuttonLayout.addWidget(self.neweventTableButton)
        databuttonLayout = QHBoxLayout()
        databuttonLayout.addWidget(self.copydataTableButton)
        databuttonLayout.addStretch()
        #tab 1
        self.tab1aLayout = QVBoxLayout()
        self.tab1aLayout.setContentsMargins(0,0,0,0)
        self.tab1aLayout.setSpacing(0)
#        self.tab1aLayout.addLayout(mainLayout)
#        self.tab1aLayout.addStretch()
        self.tab1aLayout.addLayout(textLayout)
        self.tab1aLayout.addStretch()
        self.tab1aLayout.setSpacing(8)
        self.tab1aLayout.addLayout(propGrid)
        self.tab1aLayout.addLayout(ambientGrid)
        tab1Layout = QVBoxLayout()
#        tab1Layout.addStretch()
        tab1Layout.setContentsMargins(5, 5, 5, 5) # left, top, right, bottom
        tab1Layout.addLayout(self.tab1aLayout)
        tab1Layout.setSpacing(0)
        tab1Layout.addStretch()
        # set volume from density if given
        self.density_in_editing_finished()
        self.density_out_editing_finished()
        # set density from volume if given
        #tab 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addLayout(anotationLayout)
        tab2Layout.setContentsMargins(5, 5, 5, 5) # left, top, right, bottom
        #tab3 events
        tab3Layout = QVBoxLayout()
        tab3Layout.addLayout(timeLayoutBox)
        tab3Layout.addWidget(self.eventtable)
        tab3Layout.addLayout(eventbuttonLayout)
        tab3Layout.setContentsMargins(5, 5, 5, 5) # left, top, right, bottom
        #tab 4 data
        tab4Layout = QVBoxLayout()
        tab4Layout.addWidget(self.datatable) 
        tab4Layout.addLayout(databuttonLayout)
        tab4Layout.setContentsMargins(5, 5, 5, 5) # left, top, right, bottom 
        #tabwidget
        self.TabWidget = QTabWidget()
        self.TabWidget.setContentsMargins(0,0,0,0)
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab", "General",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab", "Notes",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab", "Events",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab", "Data",None)) 
        self.TabWidget.currentChanged.connect(self.tabSwitched)
        #incorporate layouts
        totallayout = QVBoxLayout()
        totallayout.addWidget(self.TabWidget)
        totallayout.addLayout(okLayout)
        totallayout.setContentsMargins(10,10,10,0)
        totallayout.setSpacing(0)
        self.volume_percent()
        self.setLayout(totallayout)

        self.titleedit.setFocus()

        self.updateTemplateLine()
        
        settings = QSettings()
        if settings.contains("RoastGeometry"):
            self.restoreGeometry(settings.value("RoastGeometry"))
        else:
            self.resize(self.minimumSizeHint())

#PLUS
        try:
            if aw.plus_account is not None:
                plus.stock.update()
                QTimer.singleShot(1500,lambda : self.populatePlusCoffeeBlendCombos())
        except:
            pass
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
    
    def enableBatchEdit(self):
        if not aw.superusermode and not self.batcheditmode:
            self.batcheditmode = True
            self.batchLayout.removeWidget(self.batchedit)
            self.defineBatchEditor()
    
    def defineBatchEditor(self):
        self.batchprefixedit = QLineEdit(u(aw.qmc.roastbatchprefix))
        self.batchcounterSpinBox = QSpinBox()
        self.batchcounterSpinBox.setRange(0,999999)
        self.batchcounterSpinBox.setSingleStep(1)
        self.batchcounterSpinBox.setValue(aw.qmc.roastbatchnr)
        self.batchcounterSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter) 
        self.batchposSpinBox = QSpinBox()
        self.batchposSpinBox.setRange(1,99)
        self.batchposSpinBox.setSingleStep(1)
        self.batchposSpinBox.setValue(aw.qmc.roastbatchpos)
        self.batchposSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.batchLayout.addWidget(self.batchprefixedit)
        self.batchLayout.addWidget(self.batchcounterSpinBox)
        self.batchLayout.addWidget(self.batchposSpinBox)
        
    def readScale(self):
        if self.disconnecting:
            aw.scale.closeport()
            self.scale_weight = None
            self.scale_battery = None
        else:
            if aw.scale.SP is None or not aw.scale.SP.isOpen():
                self.connectScaleSignal.emit()
            else:
                w,_,_ = aw.scale.readWeight()
                if w != -1:
                    self.scale_weight = w
                else:
                    self.scale_weight = None
                self.update_scale_weight()
                if self.volumedialog is not None:
                    self.scaleWeightUpdated.emit(w)
                self.readScaleSignal.emit()
    
    @pyqtSlot()
    def readScaleLoop(self):
        QTimer.singleShot(1000,lambda : self.readScale())
    
    @pyqtSlot()
    def connectScaleLoop(self):
        QTimer.singleShot(2000,lambda : self.connectScale())
        
    def connectScale(self):
        if self.disconnecting:
            aw.scale.closeport()
        else:
            res = aw.scale.connect(error=False)
            if res:
                self.readScaleSignal.connect(self.readScaleLoop)
                QTimer.singleShot(2,lambda : self.readScaleSignal.emit())
            else:
                self.connectScaleSignal.emit()

    @pyqtSlot()
    def resetScaleSet(self):
        self.scale_set = None
        self.updateScaleWeightAccumulated()
    
    def updateScaleWeightAccumulated(self,weight=None):
        if self.scale_set is None or weight is None:
            self.scaleWeightAccumulated.setText("")
        else:
            v = weight + self.scale_set
            if aw.qmc.weight_units.index(aw.qmc.weight[2]) in [0,1]:
                if v > 1000:
                    v_formatted = "{0:.2f}kg".format(v/1000)
                else:
                    v_formatted = "{0:.1f}g".format(v)
            # non-metric
            else:
                v = aw.convertWeight(v,0,aw.qmc.weight_units.index(aw.qmc.weight[2]))
                v_formatted = "{0:.2f}{1}".format(v,aw.qmc.weight[2])
            self.scaleWeightAccumulated.setText(v_formatted)

    def ble_scan_failed(self):
#        import datetime
#        ts = libtime.time()
#        st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
#        print(st,"ble_scan_failed")
        self.scale_weight = None
        self.scale_battery = None
        self.scaleWeight.setText("")
        if self.ble is not None:
            QTimer.singleShot(200,lambda : self.ble.scanDevices())

    def ble_weight_changed(self,w):
        if w is not None:
            self.scale_weight = w
            self.update_scale_weight()
    
    def ble_battery_changed(self,b):
        if b is not None:
            self.scale_battery = b
            self.update_scale_weight()
            
    def update_scale_weight(self):
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except Exception:
            pass
        if self.scale_weight is not None and tare is not None:
            v = self.scale_weight - tare # weight in g
            if aw.qmc.weight_units.index(aw.qmc.weight[2]) in [0,1]:
                # metric
                if v > 1000:
                    v_formatted = "{0:.2f}kg".format(v/1000)
                else:
                    v_formatted = "{0:.1f}g".format(v)
            # non-metric
            else:
                v = aw.convertWeight(v,0,aw.qmc.weight_units.index(aw.qmc.weight[2]))
                v_formatted = "{0:.2f}{1}".format(v,aw.qmc.weight[2])
            self.scaleWeight.setText(v_formatted)
            self.updateScaleWeightAccumulated(self.scale_weight - tare)
        else:
            self.scaleWeight.setText("")
            self.updateScaleWeightAccumulated()
            
    def updateTemplateLine(self):
        line = ""
        if self.template_file:
            if self.template_batchprefix:
                line = self.template_batchprefix
            if self.template_batchnr:
                line = line + str(self.template_batchnr)
            if self.template_name:
                if len(line) != 0:
                    line = line + " "
                line = line + self.template_name
        if len(line) > 0:
            line = u(QApplication.translate("Label", "Template",None)) + ": " + line
        self.template_line.setText(line)
            
    def updatePlusSelectedLine(self):
        try:
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                dark_mode_link_color = " style=\"color: #e5e9ec;\""
            else:
                dark_mode_link_color = ""
            line = ""
            if self.plus_coffee_selected is not None and self.plus_coffee_selected_label:
                line = '<a href="{0}"{2}>{1}</a>'.format(plus.util.coffeeLink(self.plus_coffee_selected),self.plus_coffee_selected_label,dark_mode_link_color)
            elif self.plus_blend_selected_spec and self.plus_blend_selected_spec_labels:
                for i,l in sorted(zip(self.plus_blend_selected_spec["ingredients"],self.plus_blend_selected_spec_labels), key=lambda tup:tup[0]["ratio"],reverse = True):
                    if line:
                        line = line + ", "
                    c = '<a href="{0}"{2}>{1}</a>'.format(plus.util.coffeeLink(i["coffee"]),l,dark_mode_link_color)
                    line = line + str(int(round(i["ratio"]*100))) + "% " + c
            if line and len(line)>0 and self.plus_store_selected is not None and self.plus_store_selected_label is not None:
                line = line + ', <a href="{0}"{2}>{1}</a>'.format(plus.util.storeLink(self.plus_store_selected),self.plus_store_selected_label,dark_mode_link_color)
            self.plus_selected_line.setText(line)
        except Exception:
            pass
    
    @pyqtSlot()
    def beansEdited(self):
        self.modified_beans = u(self.beansedit.toPlainText())
    
    @pyqtSlot()
    def beanSizeMinEdited(self):
        self.modified_beansize_min_text = self.bean_size_min_edit.text()
    
    @pyqtSlot()
    def beanSizeMaxEdited(self):
        self.modified_beansize_max_text = self.bean_size_max_edit.text()

    @pyqtSlot()
    def moistureEdited(self):
        self.moisture_greens_edit.setText(aw.comma2dot(str(self.moisture_greens_edit.text())))
        self.moisture_roasted_edit.setText(aw.comma2dot(str(self.moisture_roasted_edit.text())))
        self.modified_moisture_greens_text = self.moisture_greens_edit.text()
        self.calculated_organic_loss()
        
    def plus_popups_set_enabled(self,b):
        try:
            self.plus_stores_combo.setEnabled(b)
            self.plus_coffees_combo.setEnabled(b)
            self.plus_blends_combo.setEnabled(b)
        except:
            pass

    # storeIndex is the index of the selected entry in the popup
    def populatePlusCoffeeBlendCombos(self,storeIndex=None):
        try: # this can crash if dialog got closed while this is processed in a different thread!
            self.plus_popups_set_enabled(False)
            
            #---- Stores
            
            if storeIndex is None or storeIndex == -1:
                self.plus_stores = plus.stock.getStores()
                try:
                    if len(self.plus_stores) == 1:
                        self.plus_default_store = plus.stock.getStoreId(self.plus_stores[0])
                    if len(self.plus_stores) < 2:
                        self.plusStoreslabel.setVisible(False)
                        self.plus_stores_combo.setVisible(False)
                    else:
                        self.plusStoreslabel.setVisible(True)
                        self.plus_stores_combo.setVisible(True)
                except:
                    pass
                self.plus_stores_combo.blockSignals(True)       
                self.plus_stores_combo.clear()
                self.plus_stores_combo.addItems([""] + plus.stock.getStoreLabels(self.plus_stores))
                p = plus.stock.getStorePosition(self.plus_default_store,self.plus_stores)
                if p is None:
                    self.plus_stores_combo.setCurrentIndex(0)
                else:
                    # we set to the default_store if available
                    self.plus_stores_combo.setCurrentIndex(p+1)
                self.plus_stores_combo.blockSignals(False)
            
            storeIdx = self.plus_stores_combo.currentIndex()
            
            # we reset the store if a coffee or blend is selected and the selected store is not equal to the default store
            # we clean the coffee/blend selection as it does not fit
            if storeIdx > 0 and (self.plus_coffee_selected or self.plus_blend_selected_spec) and self.plus_store_selected != plus.stock.getStoreId(self.plus_stores[storeIdx-1]):
                self.defaultCoffeeData()
                self.plus_amount_selected = None
                self.plus_store_selected_label = None
                if self.plus_coffee_selected:
                    self.plus_coffee_selected = None
                    self.plus_coffee_selected_label = None
                if self.plus_blend_selected_spec:
                    self.plus_blend_selected_label = None
                    self.plus_blend_selected_spec = None
                    self.plus_blend_selected_spec_labels = None
            
            if storeIdx:
                self.plus_default_store = plus.stock.getStoreId(self.plus_stores[storeIdx-1])
            else:
                self.plus_default_store = None
            
            mark_coffee_fields = False
            
            #---- Coffees
            
            self.plus_coffees = plus.stock.getCoffees(self.unitsComboBox.currentIndex(),self.plus_default_store)
            self.plus_coffees_combo.blockSignals(True)  
            self.plus_coffees_combo.clear()
            self.plus_coffees_combo.addItems([""] + plus.stock.getCoffeesLabels(self.plus_coffees))
            
            p = None
            if self.plus_coffee_selected:
                p = plus.stock.getCoffeeStockPosition(self.plus_coffee_selected,self.plus_store_selected,self.plus_coffees)
            if p is None:
                # not in the current stock
                self.plus_coffees_combo.setCurrentIndex(0)
                #self.plus_coffee_selected = None # we don't "deselect" a coffee just because it is not in the popup!
                self.plus_coffees_combo.blockSignals(False)
            else:
                # if roast is complete (charge and drop are set) 
                if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6] > 0:
                    # we first change the index and then unblock signals to avoid properties being overwritten from the selected coffee
                    self.plus_coffees_combo.setCurrentIndex(p+1)
                    self.plus_coffees_combo.blockSignals(False)
                else:
                    # if roast is not yet complete we unblock the signals before changing the index to get the coffee data be filled in
                    self.plus_coffees_combo.blockSignals(False)
                    self.plus_coffees_combo.setCurrentIndex(p+1)
                mark_coffee_fields = True
            
            
            #---- Blends  
    
            self.plus_blends = plus.stock.getBlends(self.unitsComboBox.currentIndex(),self.plus_default_store)
            self.plus_blends_combo.blockSignals(True)  
            self.plus_blends_combo.clear()
            self.plus_blends_combo.addItems([""] + plus.stock.getBlendLabels(self.plus_blends)) 
            
            if len(self.plus_blends) == 0:
                self.plusBlendslabel.setVisible(False)
                self.plus_blends_combo.setVisible(False)
            else:
                self.plusBlendslabel.setVisible(True)
                self.plus_blends_combo.setVisible(True)
            
            p = None
            if self.plus_blend_selected_spec:
                p = plus.stock.getBlendSpecStockPosition(self.plus_blend_selected_spec,self.plus_store_selected,self.plus_blends)
            if p is None:
                self.plus_blends_combo.setCurrentIndex(0)
                #self.plus_blend_selected_spec = None # we don't deselect a blend just because it is not in the popup
                self.plus_blends_combo.blockSignals(False)
            else:
                # if roast is complete (charge and drop are set) 
                if aw.qmc.timeindex[0] > -1 and aw.qmc.timeindex[6] > 0:
                    # we first change the index and then unblock signals to avoid properties being overwritten from the selected blend
                    self.plus_blends_combo.setCurrentIndex(p+1)
                    self.plus_blends_combo.blockSignals(False)
                else:
                    # if roast is not yet complete we unblock the signals before changing the index to get the blend data be filled in
                    self.plus_blends_combo.blockSignals(False)
                    self.plus_blends_combo.setCurrentIndex(p+1)
                mark_coffee_fields = True

            self.markPlusCoffeeFields(mark_coffee_fields)
            self.updatePlusSelectedLine() 
        except:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            pass     
        finally:
            self.plus_popups_set_enabled(True)

    def markPlusCoffeeFields(self,b):
        # for QTextEdit
        if b:
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                self.beansedit.setStyleSheet("QTextEdit { background-color: #0D658F; selection-background-color: darkgray; }")
            else:
                self.beansedit.setStyleSheet("QTextEdit { background-color: #e4f3f8; selection-background-color: darkgray;  }")
        else:
            self.beansedit.setStyleSheet("")
        # for QLineEdit
        if b:
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                qlineedit_marked_style = "QLineEdit { background-color: #0D658F; selection-background-color: darkgray; }"
            else:
                qlineedit_marked_style = "QLineEdit { background-color: #e4f3f8; selection-background-color: #424242; }"
            self.bean_density_in_edit.setStyleSheet(qlineedit_marked_style)
            self.bean_size_min_edit.setStyleSheet(qlineedit_marked_style)
            self.bean_size_max_edit.setStyleSheet(qlineedit_marked_style)
            self.moisture_greens_edit.setStyleSheet(qlineedit_marked_style)
        else:
            background_white_style = "" 
            self.bean_density_in_edit.setStyleSheet(background_white_style)
            self.bean_size_min_edit.setStyleSheet(background_white_style)
            self.bean_size_max_edit.setStyleSheet(background_white_style)
            self.moisture_greens_edit.setStyleSheet(background_white_style)
        
    def updateTitle(self,prev_coffee_label,prev_blend_label):
        titles_to_be_overwritten = [ "", QApplication.translate("Scope Title", "Roaster Scope",None) ]
        if prev_coffee_label is not None:
            titles_to_be_overwritten.append(prev_coffee_label)
        if prev_blend_label is not None:
            titles_to_be_overwritten.append(prev_blend_label)
        if self.titleedit.currentText() in titles_to_be_overwritten:
            if self.plus_blend_selected_label is not None:
                self.titleedit.textEdited(self.plus_blend_selected_label)
                self.titleedit.setEditText(self.plus_blend_selected_label)
            elif self.plus_coffee_selected_label is not None:
                self.titleedit.textEdited(self.plus_coffee_selected_label)
                self.titleedit.setEditText(self.plus_coffee_selected_label)
            else:
                default_title = QApplication.translate("Scope Title", "Roaster Scope",None) 
                self.titleedit.textEdited(default_title)
                self.titleedit.setEditText(default_title)
                        
    def fillBlendData(self,blend,prev_coffee_label,prev_blend_label):
        try:
            if self.weightinedit.text() != "":
                weightIn = float(str(self.weightinedit.text()))
            else:
                weightIn = 0.0
            blend_lines = plus.stock.blend2beans(blend,self.unitsComboBox.currentIndex(),weightIn)
            self.beansedit.clear()
            for l in blend_lines:
                self.beansedit.append(l)
            keep_modified_moisture = self.modified_moisture_greens_text
            keep_modified_density = self.modified_density_in_text
            blend_dict = plus.stock.getBlendBlendDict(blend)
            if "moisture" in blend_dict:
                self.moisture_greens_edit.setText("%g" % blend_dict["moisture"])
            else:
                self.moisture_greens_edit.setText(str(0))
            if "density" in blend_dict:
                self.bean_density_in_edit.setText("%g" % aw.float2float(blend_dict["density"]))
            else:
                self.bean_density_in_edit.setText(str(0))
            if "screen_min" in blend_dict:
                self.bean_size_min_edit.setText(str(int(blend_dict["screen_min"])))
            else:
                self.bean_size_min_edit.setText("0")
            if "screen_max" in blend_dict:
                self.bean_size_max_edit.setText(str(int(blend_dict["screen_max"])))
            else:
                self.bean_size_max_edit.setText("0")
            # check if title should be changed (if still default, or equal to the previous selection:
            self.updateTitle(prev_coffee_label,prev_blend_label)
            self.markPlusCoffeeFields(True)
            self.density_in_editing_finished()
            self.moistureEdited()
            self.modified_density_in_text = keep_modified_density
            self.modified_moisture_greens_text = keep_modified_moisture
        except:
            pass
        
    # if current title is equal to default title or prev_coffee/blend_label, we set title from selected label
    def fillCoffeeData(self,coffee,prev_coffee_label,prev_blend_label):
        try:
            cd = plus.stock.getCoffeeCoffeeDict(coffee)
            self.beansedit.setPlainText(plus.stock.coffee2beans(coffee))
            keep_modified_moisture = self.modified_moisture_greens_text
            keep_modified_density = self.modified_density_in_text
            if "moisture" in cd:
                self.moisture_greens_edit.setText("%g" % cd["moisture"])
            else:
                self.moisture_greens_edit.setText(str(0))
            if "density" in cd:
                self.bean_density_in_edit.setText("%g" % aw.float2float(cd["density"]))
            else:
                self.bean_density_in_edit.setText(str(0)) 
            if "screen_size" in cd:
                screen = cd["screen_size"]
                if "min" in screen:
                    self.bean_size_min_edit.setText(str(int(screen["min"])))
                else:
                    self.bean_size_min_edit.setText("0")
                if "max" in screen:
                    self.bean_size_max_edit.setText(str(int(screen["max"])))
                else:
                    self.bean_size_max_edit.setText("0")
            else:
                self.bean_size_min_edit.setText("0")
                self.bean_size_max_edit.setText("0")
            self.updateTitle(prev_coffee_label,prev_blend_label)
            self.markPlusCoffeeFields(True)
            self.density_in_editing_finished()
            self.moistureEdited()
            self.modified_density_in_text = keep_modified_density
            self.modified_moisture_greens_text = keep_modified_moisture
        except:
            pass
        
    def defaultCoffeeData(self):
        if self.modified_beans is None:
            self.beansedit.clear()
        else:
            self.beansedit.setPlainText(u(self.modified_beans))
        self.bean_density_in_edit.setText(self.modified_density_in_text)
        self.volumeinedit.setText(self.modified_volume_in_text)
        self.bean_size_min_edit.setText(self.modified_beansize_min_text)
        self.bean_size_max_edit.setText(self.modified_beansize_max_text)
        self.moisture_greens_edit.setText(self.modified_moisture_greens_text)
        self.markPlusCoffeeFields(False)
        self.density_in_editing_finished()
        self.moistureEdited()
    
    @pyqtSlot(int)
    def storeSelectionChanged(self,n):
        if n != -1:
            prev_coffee_label = self.plus_coffee_selected_label
            prev_blend_label = self.plus_blend_selected_label
            self.populatePlusCoffeeBlendCombos(n)
            self.updateTitle(prev_coffee_label,prev_blend_label)
 
    @pyqtSlot(int)
    def coffeeSelectionChanged(self,n):
        # check for previously selected blend label
        prev_coffee_label = self.plus_coffee_selected_label
        prev_blend_label = self.plus_blend_selected_label
        if n < 1:
            self.defaultCoffeeData()
            self.plus_store_selected = None
            self.plus_store_selected_label = None
            self.plus_coffee_selected = None
            self.plus_coffee_selected_label = None
            self.plus_amount_selected = None
            self.updateTitle(prev_coffee_label,prev_blend_label)
        else:
            # reset blend and set new coffee            
            self.plus_blends_combo.setCurrentIndex(0)
            selected_coffee = self.plus_coffees[n-1]
            sd = plus.stock.getCoffeeStockDict(selected_coffee)
            self.plus_store_selected = sd["location_hr_id"]
            self.plus_store_selected_label = sd["location_label"]
            cd = plus.stock.getCoffeeCoffeeDict(selected_coffee)
            self.plus_coffee_selected = cd["hr_id"]
            origin = ""
            if "origin" in cd:
                origin = cd["origin"] + " "
            self.plus_coffee_selected_label = origin + cd["label"]
            self.plus_blend_selected_label = None
            self.plus_blend_selected_spec = None
            self.plus_blend_selected_spec_labels = None
            if "amount" in plus.stock.getCoffeeStockDict(selected_coffee):
                self.plus_amount_selected = plus.stock.getCoffeeStockDict(selected_coffee)["amount"]
            else:
                self.pus_amount_selected = None
            self.fillCoffeeData(selected_coffee,prev_coffee_label,prev_blend_label)
        self.checkWeightIn()
        self.updatePlusSelectedLine()
    
    @pyqtSlot(int)
    def blendSelectionChanged(self,n):
        # check for previously selected blend label
        prev_coffee_label = self.plus_coffee_selected_label
        prev_blend_label = self.plus_blend_selected_label
        if n < 1:
            self.defaultCoffeeData()
            self.plus_store_selected = None
            self.plus_store_selected_label = None
            self.plus_blend_selected_label = None
            self.plus_blend_selected_spec = None
            self.plus_blend_selected_spec_labels = None
            self.pus_amount_selected = None
            self.updateTitle(prev_coffee_label,prev_blend_label)
        else:
            # reset coffee and set new blend
            self.plus_coffees_combo.setCurrentIndex(0)
            selected_blend = self.plus_blends[n-1]
            bsd = plus.stock.getBlendStockDict(selected_blend)
            self.plus_store_selected = bsd["location_hr_id"]    
            self.plus_store_selected_label = bsd["location_label"]
            bd = plus.stock.getBlendBlendDict(selected_blend)
            self.plus_coffee_selected = None
            self.plus_blend_selected_label = bd["label"]
            self.plus_blend_selected_spec = dict(bd) # make a copy of the blend dict
            # we trim the blend_spec to the external from
            self.plus_blend_selected_spec.pop("hr_id", None) # remove the hr_id
            self.plus_blend_selected_spec_labels = [i["label"] for i in self.plus_blend_selected_spec["ingredients"]]
            self.plus_blend_selected_spec["ingredients"] = \
              [{"ratio": i["ratio"],"coffee": i["coffee"]} for i in 
                 self.plus_blend_selected_spec["ingredients"]]
            if "amount" in bsd:
                self.plus_amount_selected = plus.stock.getBlendMaxAmount(selected_blend)
            else:
                self.pus_amount_selected = None
            self.fillBlendData(selected_blend,prev_coffee_label,prev_blend_label)
        self.checkWeightIn()
        self.updatePlusSelectedLine()

    # recentRoast activated from within RoastProperties dialog
    def recentRoastActivated(self,n):
        # note, the first item is the edited text!
        if n > 0 and n <= len(aw.recentRoasts):
            rr = aw.recentRoasts[n-1]
            if "title" in rr and rr["title"] is not None:
                self.titleedit.textEdited(rr["title"])
                self.titleedit.setEditText(rr["title"])
            if "weightUnit" in rr and rr["weightUnit"] is not None:
                self.unitsComboBox.setCurrentIndex(aw.qmc.weight_units.index(rr["weightUnit"]))
            if "weightIn" in rr and rr["weightIn"] is not None:
                self.weightinedit.setText("%g" % rr["weightIn"])
            # all of the following items might not be in the dict
            if "beans" in rr and rr["beans"] is not None:
                self.beansedit.setPlainText(rr["beans"])
            if "weightOut" in rr and rr["weightOut"] is not None:
                self.weightoutedit.setText("%g" % rr["weightOut"])
            else:
                self.weightoutedit.setText("%g" % 0)
            if "volumeIn" in rr and rr["volumeIn"] is not None:
                self.volumeinedit.setText("%g" % rr["volumeIn"])
            if "volumeOut" in rr and rr["volumeOut"] is not None:
                self.volumeoutedit.setText("%g" % rr["volumeOut"])
            else:
                self.volumeoutedit.setText("%g" % 0)
            if "volumeUnit" in rr and rr["volumeUnit"] is not None:
                self.volumeUnitsComboBox.setCurrentIndex(aw.qmc.volume_units.index(rr["volumeUnit"]))
            if "densityWeight" in rr and rr["densityWeight"] is not None:
                self.bean_density_in_edit.setText("%g" % aw.float2float(rr["densityWeight"]))
            if "densityRoasted" in rr and rr["densityRoasted"] is not None:
                self.bean_density_out_edit.setText("%g" % aw.float2float(rr["densityRoasted"]))
            else:
                self.bean_density_out_edit.setText("%g" % 0)
            if "moistureGreen" in rr and rr["moistureGreen"] is not None:
                self.moisture_greens_edit.setText("%g" % aw.float2float(rr["moistureGreen"]))
            if "moistureRoasted" in rr and rr["moistureRoasted"] is not None:
                self.moisture_roasted_edit.setText("%g" % aw.float2float(rr["moistureRoasted"]))
            else:
                self.moisture_roasted_edit.setText("%g" % 0)
            if "wholeColor" in rr and rr["wholeColor"] is not None:
                self.whole_color_edit.setText(str(rr["wholeColor"]))
            else:
                self.whole_color_edit.setText(str(0))
            if "groundColor" in rr and rr["groundColor"] is not None:
                self.ground_color_edit.setText(str(rr["groundColor"]))
            else:
                self.ground_color_edit.setText(str(0))
            if "colorSystem" in rr and rr["colorSystem"] is not None:
                self.colorSystemComboBox.setCurrentIndex(rr["colorSystem"])
            # items added in v1.4 might not be in the data set of previous stored recent roasts
            if "beanSize_min" in rr and rr["beanSize_min"] is not None:
                self.bean_size_min_edit.setText(str(int(rr["beanSize_min"])))
            if "beanSize_max" in rr and rr["beanSize_max"] is not None:
                self.bean_size_max_edit.setText(str(int(rr["beanSize_max"])))
            # Note: the background profile will not be changed if recent roast is activated from Roast Properties
            if "background" in rr and rr["background"] is not None:
                self.template_file = rr["background"]
                if "title" in rr and rr["title"] is not None:
                    self.template_name = rr["title"]
                if "roastUUID" in rr and rr["roastUUID"] is not None:
                    self.template_uuid = rr["roastUUID"]
                if "batchnr" in rr and rr["batchnr"] is not None:
                    self.template_batchnr = rr["batchnr"]
                if "batchprefix" in rr and rr["batchprefix"] is not None:
                    self.template_batchprefix = rr["batchprefix"]
            else:
                self.template_file = None
                self.template_name = None
                self.template_uuid = None
                self.template_batchnr = None
                self.template_batchprefix = None
            self.updateTemplateLine()
            self.percent()

#PLUS
            if aw.plus_account is not None and "plus_account" in rr and aw.plus_account == rr["plus_account"]:
                if "plus_store" in rr:
                    self.plus_store_selected = rr["plus_store"]
                if "plus_store_label" in rr:
                    self.plus_store_selected_label = rr["plus_store_label"]
                if "plus_coffee" in rr:
                    self.plus_coffee_selected = rr["plus_coffee"]
                if "plus_coffee_label" in rr:
                    self.plus_coffee_selected_label = rr["plus_coffee_label"]
                if "plus_blend_spec" in rr:
                    self.plus_blend_selected_label = rr["plus_blend_label"]
                    self.plus_blend_selected_spec = rr["plus_blend_spec"]
                    if "plus_blend_spec_labels":
                        self.plus_blend_selected_spec_labels = rr["plus_blend_spec_labels"]
                if self.plus_store_selected is not None and self.plus_default_store is not None and self.plus_default_store != self.plus_store_selected:
                    self.plus_default_store = None # we reset the defaultstore
                # we now set the actual values from the stock
                self.populatePlusCoffeeBlendCombos()
            
            aw.sendmessage(QApplication.translate("Message","Recent roast properties '{0}' set".format(aw.recentRoastLabel(rr))))
        self.recentRoastEnabled()
    
    @pyqtSlot("QString")
    def recentRoastEnabled(self,_=""):
        try:
            title = u(self.titleedit.currentText())
            weightIn = float(str(self.weightinedit.text()))
            # add new recent roast entry only if title is not default, beans is not empty and weight-in is not 0
            if title != QApplication.translate("Scope Title", "Roaster Scope",None) and weightIn != 0:
                # enable "+" addRecentRoast button
                self.addRecentButton.setEnabled(True)
                self.delRecentButton.setEnabled(True)
            else:
                self.addRecentButton.setEnabled(False)
                self.delRecentButton.setEnabled(False)
        except:
            self.addRecentButton.setEnabled(False)
            self.delRecentButton.setEnabled(False)
        
    @pyqtSlot(bool)
    def delRecentRoast(self,_):
        try:
            title = ' '.join(u(self.titleedit.currentText()).split())
            weightIn = float(str(self.weightinedit.text()))
            weightUnit = u(self.unitsComboBox.currentText())
            aw.recentRoasts = aw.delRecentRoast(title,weightIn,weightUnit)
        except:
            pass
    
    @pyqtSlot(bool)
    def addRecentRoast(self,_):
        try:
            title = ' '.join(u(self.titleedit.currentText()).split())
            weightIn = float(aw.comma2dot(str(self.weightinedit.text())))
            # add new recent roast entry only if title is not default, beans is not empty and weight-in is not 0
            if title != QApplication.translate("Scope Title", "Roaster Scope",None) and weightIn != 0:
                beans = u(self.beansedit.toPlainText())
                weightUnit = u(self.unitsComboBox.currentText())
                if self.volumeinedit.text() != "":
                    volumeIn = float(aw.comma2dot(str(self.volumeinedit.text())))
                else:
                    volumeIn = 0
                volumeUnit = u(self.volumeUnitsComboBox.currentText())
                if self.bean_density_in_edit.text() != "":
                    densityWeight = float(aw.comma2dot(str(self.bean_density_in_edit.text())))
                else:
                    densityWeight = 0
                if self.bean_size_min_edit.text() != "":
                    beanSize_min = int(round(float(str(self.bean_size_min_edit.text()))))
                else:
                    beanSize_min = 0
                if self.bean_size_max_edit.text() != "":
                    beanSize_max = int(round(float(str(self.bean_size_max_edit.text()))))
                else:
                    beanSize_max = 0  
                if self.moisture_greens_edit.text() != "":
                    moistureGreen = float(aw.comma2dot(self.moisture_greens_edit.text()))
                else:
                    moistureGreen = 0.0
                colorSystem = self.colorSystemComboBox.currentIndex()
                
                modifiers = QApplication.keyboardModifiers()
                weightOut = volumeOut = densityRoasted = moistureRoasted = wholeColor = groundColor = None
                if modifiers == Qt.AltModifier:  #alt click
                    # we add weightOut, volumeOut, moistureRoasted, wholeColor, groundColor
                    weightOut = float(aw.comma2dot(str(self.weightoutedit.text())))
                    volumeOut = float(aw.comma2dot(str(self.volumeoutedit.text())))
                    densityRoasted = float(aw.comma2dot(str(self.bean_density_out_edit.text())))
                    moistureRoasted = float(aw.comma2dot(self.moisture_roasted_edit.text()))
                    wholeColor = int(self.whole_color_edit.text())
                    groundColor = int(self.ground_color_edit.text())
                                 
                rr = aw.createRecentRoast(
                    title,
                    beans,
                    weightIn,
                    weightUnit,
                    volumeIn,
                    volumeUnit,
                    densityWeight,
                    beanSize_min,
                    beanSize_max,
                    moistureGreen,
                    colorSystem,
                    aw.curFile, # could be empty
                    aw.qmc.roastUUID, # could be empty
                    aw.qmc.roastbatchnr, #self.batchcounterSpinBox # aw.superusermode and aw.qmc.batchcounter > -1
                    aw.qmc.roastbatchprefix,  #self.batchprefixedit
                    aw.plus_account,
                    self.plus_store_selected,
                    self.plus_store_selected_label,
                    self.plus_coffee_selected, 
                    self.plus_coffee_selected_label,
                    self.plus_blend_selected_label,
                    self.plus_blend_selected_spec,
                    self.plus_blend_selected_spec_labels,
                    weightOut,
                    volumeOut,
                    densityRoasted,
                    moistureRoasted, 
                    wholeColor, 
                    groundColor
                    )
                aw.addRecentRoast(rr)
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " addRecentRoast(): {0}").format(str(e)),exc_tb.tb_lineno)

    # triggered if dialog is closed via its windows close box
    # and called from accept if dialog is closed via OK
    def closeEvent(self, _):
        self.disconnecting = True
        if self.ble is not None:
            try:
                self.ble.batteryChanged.disconnect()
                self.ble.weightChanged.disconnect()
                self.ble.deviceDisconnected.disconnect()
            except:
                pass
            try:
                self.ble.disconnectDevice()
            except:
                pass
        settings = QSettings()
        #save window geometry
        settings.setValue("RoastGeometry",self.saveGeometry())

    # triggered via the cancel button
    @pyqtSlot()
    def cancel_dialog(self):
        self.disconnecting = True
        if self.ble is not None:
            try:
                self.ble.batteryChanged.disconnect()
                self.ble.weightChanged.disconnect()
                self.ble.deviceDisconnected.disconnect()
            except:
                pass
            try:
                self.ble.disconnectDevice()
            except:
                pass
        settings = QSettings()
        #save window geometry
        settings.setValue("RoastGeometry",self.saveGeometry())
        
        aw.qmc.beans = self.org_beans
        aw.qmc.density = self.org_density
        aw.qmc.density_roasted = self.org_density_roasted
        aw.qmc.beansize_min = self.org_beansize_min
        aw.qmc.beansize_max = self.org_beansize_max
        aw.qmc.moisture_greens = self.org_moisture_greens
        
        aw.qmc.weight = self.org_weight
        aw.qmc.volume = self.org_volume
        
        aw.qmc.specialevents = self.org_specialevents
        aw.qmc.specialeventstype = self.org_specialeventstype
        aw.qmc.specialeventsStrings = self.org_specialeventsStrings
        aw.qmc.specialeventsvalue = self.org_specialeventsvalue
        aw.qmc.timeindex = self.org_timeindex
        
        aw.qmc.ambientTemp = self.org_ambientTemp
        aw.qmc.ambient_humidity = self.org_ambient_humidity
        aw.qmc.ambient_pressure = self.org_ambient_pressure
        
        self.reject()

    # calcs volume (in ml) from density (in g/l) and weight (in g)
    def calc_volume(self,density,weight):
        return (1./density) * weight * 1000

    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        key = int(event.key())
        if event.matches(QKeySequence.Copy):
            if self.TabWidget.currentIndex() == 3: # datatable
                aw.copy_cells_to_clipboard(self.datatable,adjustment=1)
                aw.sendmessage(QApplication.translate("Message","Data table copied to clipboard",None))
        if key == 16777220 and aw.scale.device is not None and aw.scale.device != "" and aw.scale.device != "None": # ENTER key pressed and scale connected
            if self.weightinedit.hasFocus():
                self.inWeight(overwrite=True) # we don't add to current reading but overwrite
            elif self.weightoutedit.hasFocus():
                self.outWeight(overwrite=True) # we don't add to current reading but overwrite
    
    @pyqtSlot(int)       
    def tareChanged(self,i):
        if i == 0 and self.tarePopupEnabled:
            tareDLG = tareDlg(self,tarePopup=self)
            tareDLG.show()
            # reset index and popup
            self.tareComboBox.setCurrentIndex(aw.qmc.container_idx + 3)
        # update displayed scale weight
        self.update_scale_weight()
    
    @pyqtSlot(int)
    def changeWeightUnit(self,i):
        o = aw.qmc.weight_units.index(aw.qmc.weight[2]) # previous unit index
        aw.qmc.weight[2] = u(self.unitsComboBox.currentText())
        for le in [self.weightinedit,self.weightoutedit]:
            if le.text() and le.text() != "":
                wi = float(le.text())
                if wi != 0.0:
                    converted = aw.convertWeight(wi,o,i)
                    le.setText("%g" % aw.float2floatWeightVolume(converted))
        self.calculated_density()
#PLUS
        try:
            # weight unit changed, we update the coffee/blend lists in plus mode
            if aw.plus_account is not None:
                self.populatePlusCoffeeBlendCombos(self.plus_stores_combo.currentIndex())
        except:
            pass

    @pyqtSlot(int)
    def changeVolumeUnit(self,i):
        o = aw.qmc.volume_units.index(aw.qmc.volume[2]) # previous unit index
        aw.qmc.volume[2] = u(self.volumeUnitsComboBox.currentText())
        for le in [self.volumeinedit,self.volumeoutedit]:
            if le.text() and le.text() != "":
                wi = float(le.text())
                if wi != 0.0:
                    converted = aw.convertVolume(wi,o,i)
                    le.setText("%g" % aw.float2floatWeightVolume(converted))
#        self.calculated_density() # if just the unit changes, the density will not change as it is fixed now

    @pyqtSlot(int)
    def tabSwitched(self,i):
        if i == 0:
            self.saveEventTable()
        elif i == 1:
            self.saveEventTable()
        elif i == 2:
            self.createEventTable()
        elif i == 3:
            self.saveEventTable()
            self.createDataTable()

    @pyqtSlot(int)
    def roastflagHeavyFCChanged(self,i):
        if i:
            self.lowFC.setChecked(False)
    @pyqtSlot(int)
    def roastflagLowFCChanged(self,i):
        if i:
            self.heavyFC.setChecked(False)
    @pyqtSlot(int)
    def roastflagLightCutChanged(self,i):
        if i:
            self.darkCut.setChecked(False)
    @pyqtSlot(int)
    def roastflagDarkCutChanged(self,i):
        if i:
            self.lightCut.setChecked(False)
    @pyqtSlot(int)
    def roastflagDropsChanged(self,i):
        if i:
            self.oily.setChecked(False)
    @pyqtSlot(int)
    def roastflagOilyChanged(self,i):
        if i:
            self.drops.setChecked(False)

    @pyqtSlot(int)
    def ambientComboBoxIndexChanged(self,i):
        aw.qmc.ambientTempSource = i

    def buildAmbientTemperatureSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(u(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(u(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
                QApplication.translate("ComboBox","ET",None),
                QApplication.translate("ComboBox","BT",None)] + extra_names

    @pyqtSlot(bool)
    def updateAmbientTemp(self,_):
        aw.qmc.updateAmbientTemp()
        self.ambientedit.setText("%g" % aw.float2float(aw.qmc.ambientTemp))
        self.ambientedit.repaint() # seems to be necessary in some PyQt versions!?
        self.ambient_humidity_edit.setText("%g" % aw.float2float(aw.qmc.ambient_humidity))
        self.ambient_humidity_edit.repaint() # seems to be necessary in some PyQt versions!?
        self.pressureedit.setText("%g" % aw.float2float(aw.qmc.ambient_pressure))
        self.pressureedit.repaint() # seems to be necessary in some PyQt versions!?

    @pyqtSlot(bool)
    def scanWholeColor(self,_):
        v = aw.color.readColor()
        if v is not None and v > -1:
            if v >= 0 and v <= 250:
                aw.qmc.whole_color = v
                self.whole_color_edit.setText(str(v))

    @pyqtSlot(bool)
    def scanGroundColor(self,_):
        v = aw.color.readColor()
        if v is not None and v > -1:
            v = max(0,min(250,v))
            aw.qmc.ground_color = v
            self.ground_color_edit.setText(str(v))

    @pyqtSlot(bool)
    def volumeCalculatorTimer(self,_):
        QTimer.singleShot(1,lambda : self.volumeCalculator())

    def volumeCalculator(self):
        weightin = None
        weightout = None
        try:
            weightin = float(self.weightinedit.text())
        except Exception:
            pass
        try:
            weightout = float(self.weightoutedit.text())
        except Exception:
            pass
        k = 1.
        if weightin is not None:
            weightin = weightin * k
        else:
            weightin = None
        if weightout is not None:
            weightout = weightout * k
        else:
            weightout = None
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except Exception:
            pass
        self.volumedialog = volumeCalculatorDlg(self,
            weightIn=weightin,
            weightOut=weightout,
            weightunit=self.unitsComboBox.currentIndex(),
            volumeunit=self.volumeUnitsComboBox.currentIndex(),
            inlineedit=self.volumeinedit,
            outlineedit=self.volumeoutedit,
            tare=tare)
        self.volumedialog.show()
        self.volumedialog.setFixedSize(self.volumedialog.size())

    @pyqtSlot(bool)
    def inWeight(self,_,overwrite=False):
        QTimer.singleShot(1,lambda : self.setWeight(self.weightinedit,self.bean_density_in_edit,self.moisture_greens_edit,overwrite))
    
    @pyqtSlot(bool)
    def outWeight(self,_=False,overwrite=False):
        QTimer.singleShot(1,lambda : self.setWeight(self.weightoutedit,self.bean_density_out_edit,self.moisture_roasted_edit,overwrite))

    def setWeight(self,weight_edit,density_edit,moisture_edit,overwrite=False):
        tare = 0
        try:
            tare_idx = self.tareComboBox.currentIndex() - 3
            if tare_idx > -1:
                tare = aw.qmc.container_weights[tare_idx]
        except Exception:
            pass
        #w,d,m = aw.scale.readWeight(self.scale_weight) # read value from scale in 'g'
        w,d,m = self.scale_weight,-1,-1
        if w is not None and w > -1:
            w = w - tare
            w = aw.convertWeight(w,0,aw.qmc.weight_units.index(aw.qmc.weight[2])) # convert to weight units
            current_w = 0
            try:
                current_w = float(weight_edit.text())
            except:
                pass
            if overwrite:
                new_w = w
            else:
                new_w = current_w + w # we add the new weight to the already existing one!
                self.scale_set = aw.convertWeight(new_w,aw.qmc.weight_units.index(aw.qmc.weight[2]),0) # convert to weight units
#            weight_edit.setText("%g" % aw.float2float(new_w))
            # updating this widget in a separate thread seems to be important on OS X 10.14 to avoid delayed updates and widget redraw problems
            # a QApplication.processEvents() or an weight_edit.update() seems not to help
            # no issue on OS X 10.13
            QTimer.singleShot(2,lambda : self.updateWeightEdits(weight_edit,new_w))
        if d is not None and d > -1:
            density_edit.setText("%g" % aw.float2float(d))
        if m is not None and m > -1:
            moisture_edit.setText("%g" % aw.float2float(m))
    
    def updateWeightEdits(self,weight_edit,w):
        weight_edit.setText("%g" % aw.float2float(w))
        self.updateScaleWeightAccumulated(w)
        self.weightouteditChanged()
    
    @pyqtSlot(int)
    def roastpropertiesChanged(self,_=0):
        if self.roastproperties.isChecked():
            aw.qmc.roastpropertiesflag = 1
        else:
            aw.qmc.roastpropertiesflag = 0
            
    @pyqtSlot(int)
    def roastpropertiesAutoOpenChanged(self,_=0):
        if self.roastpropertiesAutoOpen.isChecked():
            aw.qmc.roastpropertiesAutoOpenFlag = 1
        else:
            aw.qmc.roastpropertiesAutoOpenFlag = 0

    def createDataTable(self):
        self.datatable.clear()
        ndata = len(aw.qmc.timex)
        self.datatable.setRowCount(ndata)
        columns = [QApplication.translate("Table", "Time",None),
                                                  QApplication.translate("Table", "ET",None),
                                                  QApplication.translate("Table", "BT",None),
                                                  deltaLabelUTF8 + QApplication.translate("Label", "ET",None),
                                                  deltaLabelUTF8 + QApplication.translate("Label", "BT",None)]
        for i in range(len(aw.qmc.extratimex)):
            en1 = aw.qmc.extraname1[i]
            en2 = aw.qmc.extraname2[i]
            try:
                en1 = en1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
                en2 = en2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
            except:
                pass
            columns.append(en1)
            columns.append(en2)
        columns.append("") # add a last dummy table that extends
        self.datatable.setColumnCount(len(columns))
        self.datatable.setHorizontalHeaderLabels(columns)
        self.datatable.setAlternatingRowColors(True)
        self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
        self.datatable.setSelectionMode(QTableWidget.ExtendedSelection) # QTableWidget.SingleSelection, ContiguousSelection, MultiSelection
        self.datatable.setShowGrid(True)
        self.datatable.verticalHeader().setSectionResizeMode(2)
        offset = 0
        if aw.qmc.timeindex[0] > -1:
            offset = aw.qmc.timex[aw.qmc.timeindex[0]]
        
        for i in range(ndata):
            Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(aw.qmc.timex[i]-offset))
            Rtime.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if aw.qmc.LCDdecimalplaces:
                fmtstr = "%.1f"
            else:
                fmtstr = "%.0f"
            ET = QTableWidgetItem(fmtstr%aw.qmc.temp1[i])
            BT = QTableWidgetItem(fmtstr%aw.qmc.temp2[i])
            ET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            BT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if i > 0 and (aw.qmc.timex[i]-aw.qmc.timex[i-1]) and aw.qmc.temp1[i] != -1 and aw.qmc.temp1[i-1] != -1:
                deltaET = QTableWidgetItem("%.1f"%(60*(aw.qmc.temp1[i]-aw.qmc.temp1[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
            else:
                deltaET = QTableWidgetItem("--")
            if i > 0 and (aw.qmc.timex[i]-aw.qmc.timex[i-1]) and aw.qmc.temp2[i] != -1 and aw.qmc.temp2[i-1] != -1:
                deltaBT = QTableWidgetItem("%.1f"%(60*(aw.qmc.temp2[i]-aw.qmc.temp2[i-1])/(aw.qmc.timex[i]-aw.qmc.timex[i-1])))
            else:
                deltaBT = QTableWidgetItem("--")
            deltaET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            deltaBT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
            if i in aw.qmc.specialevents:
                index = aw.qmc.specialevents.index(i)
                text = QApplication.translate("Table", "#{0} {1}{2}",None).format(str(index+1),aw.qmc.etypesf(aw.qmc.specialeventstype[index])[0],aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[index]))
                Rtime.setText(text + u(" " + Rtime.text()))
            self.datatable.setItem(i,0,Rtime)
            if i in aw.qmc.specialevents:
                self.datatable.item(i,0).setBackground(QColor('yellow'))
            
            if i:
                    #identify by color and add notation
                if i == aw.qmc.timeindex[0]:
                    self.datatable.item(i,0).setBackground(QColor('#f07800'))
                    text = QApplication.translate("Table", "CHARGE",None)
                elif i == aw.qmc.timeindex[1]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "DRY END",None)
                elif i == aw.qmc.timeindex[2]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "FC START",None)
                elif i == aw.qmc.timeindex[3]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "FC END",None)
                elif i == aw.qmc.timeindex[4]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "SC START",None)
                elif i == aw.qmc.timeindex[5]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "SC END",None)
                elif i == aw.qmc.timeindex[6]:
                    self.datatable.item(i,0).setBackground(QColor('#f07800'))
                    text = QApplication.translate("Table", "DROP",None)
                elif i == aw.qmc.timeindex[7]:
                    self.datatable.item(i,0).setBackground(QColor('orange'))
                    text = QApplication.translate("Table", "COOL",None)
                else:
                    text = ""
                Rtime.setText(text + u(" " + Rtime.text()))
            else:
                Rtime.setText(u(" " + Rtime.text()))
                            
            self.datatable.setItem(i,1,ET)
            self.datatable.setItem(i,2,BT)
            self.datatable.setItem(i,3,deltaET)
            self.datatable.setItem(i,4,deltaBT)
            j = 5
            for k in range(len(aw.qmc.extratimex)):
                if len(aw.qmc.extratemp1) > k and len(aw.qmc.extratemp1[k]) > i:
                    extra_qtw1 = QTableWidgetItem(fmtstr%aw.qmc.extratemp1[k][i])
                    extra_qtw1.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                    self.datatable.setItem(i,j,extra_qtw1)
                    j = j + 1
                if len(aw.qmc.extratemp2) > k and len(aw.qmc.extratemp2[k]) > i:
                    extra_qtw2 = QTableWidgetItem(fmtstr%aw.qmc.extratemp2[k][i])
                    extra_qtw2.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                    self.datatable.setItem(i,j,extra_qtw2)
                    j = j + 1

    def createEventTable(self):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            
            nevents = len(aw.qmc.specialevents)
            
            #self.eventtable.clear() # this crashes Ubuntu 16.04
    #        if nevents != 0:
    #            self.eventtable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
            self.eventtable.clearSelection() # this seems to work also for Ubuntu 16.04
            
            self.eventtable.setRowCount(nevents)
            self.eventtable.setColumnCount(6)
            self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table", "Time", None),
                                                       QApplication.translate("Table", "ET", None),
                                                       QApplication.translate("Table", "BT", None),
                                                       QApplication.translate("Table", "Description", None),
                                                       QApplication.translate("Table", "Type", None),
                                                       QApplication.translate("Table", "Value", None)])
            self.eventtable.setAlternatingRowColors(True)
            self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
            self.eventtable.setSelectionMode(QTableWidget.ExtendedSelection)

            self.eventtable.setShowGrid(True)
            
            self.eventtable.verticalHeader().setSectionResizeMode(2)
            regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
            etypes = aw.qmc.getetypes()
            #populate table
            for i in range(nevents):
                #create widgets
                typeComboBox = MyQComboBox()
                typeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToContents)
                typeComboBox.addItems(etypes)
                typeComboBox.setCurrentIndex(aw.qmc.specialeventstype[i])
    
                if aw.qmc.LCDdecimalplaces:
                    fmtstr = "%.1f"
                else:
                    fmtstr = "%.0f"
    
                etline = QLineEdit()
                etline.setReadOnly(True)
                etline.setAlignment(Qt.AlignRight)
                ettemp = fmtstr%(aw.qmc.temp1[aw.qmc.specialevents[i]]) + aw.qmc.mode
                etline.setText(ettemp)
                    
                btline = QLineEdit()
                btline.setReadOnly(True)
                btline.setAlignment(Qt.AlignRight)
                bttemp = fmtstr%(aw.qmc.temp2[aw.qmc.specialevents[i]]) + aw.qmc.mode
                btline.setText(bttemp)
                
                valueEdit = QLineEdit()
                valueEdit.setAlignment(Qt.AlignRight)
                valueEdit.setText(aw.qmc.eventsvalues(aw.qmc.specialeventsvalue[i]))
                
                timeline = QLineEdit()
                timeline.setAlignment(Qt.AlignRight)
                if aw.qmc.timeindex[0] > -1 and len(aw.qmc.timex) > aw.qmc.timeindex[0]:
                    timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]-aw.qmc.timex[aw.qmc.timeindex[0]]))
                else:
                    timez = aw.qmc.stringfromseconds(int(aw.qmc.timex[aw.qmc.specialevents[i]]))
                timeline.setText(timez)
                timeline.setValidator(QRegExpValidator(regextime,self))
                
                stringline = QLineEdit(aw.qmc.specialeventsStrings[i])
                #add widgets to the table
                self.eventtable.setCellWidget(i,0,timeline)
                self.eventtable.setCellWidget(i,1,etline)
                self.eventtable.setCellWidget(i,2,btline)
                self.eventtable.setCellWidget(i,3,stringline)
                self.eventtable.setCellWidget(i,4,typeComboBox)
                self.eventtable.setCellWidget(i,5,valueEdit)
                valueEdit.setValidator(QIntValidator(0,aw.eventsMaxValue,self.eventtable.cellWidget(i,5)))
            header = self.eventtable.horizontalHeader()
            #header.setStretchLastSection(True)
            header.setSectionResizeMode(0, QHeaderView.Fixed)
            header.setSectionResizeMode(1, QHeaderView.Fixed)
            header.setSectionResizeMode(2, QHeaderView.Fixed)
            header.setSectionResizeMode(3, QHeaderView.Stretch)
            header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(5, QHeaderView.Fixed)
            # improve width of Time column
            self.eventtable.setColumnWidth(0,60)
            self.eventtable.setColumnWidth(1,65)
            self.eventtable.setColumnWidth(2,65)
            self.eventtable.setColumnWidth(5,55)
            # header.setSectionResizeMode(QHeaderView.Stretch)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)


    def saveEventTable(self):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            nevents = self.eventtable.rowCount()
            for i in range(nevents):
                timez = self.eventtable.cellWidget(i,0)
                if aw.qmc.timeindex[0] > -1:
                    aw.qmc.specialevents[i] = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]]+ aw.qmc.stringtoseconds(str(timez.text())))
                else:
                    aw.qmc.specialevents[i] = aw.qmc.time2index(aw.qmc.stringtoseconds(str(timez.text())))
                description = self.eventtable.cellWidget(i,3)
                aw.qmc.specialeventsStrings[i] = u(description.text())
                etype = self.eventtable.cellWidget(i,4)
                aw.qmc.specialeventstype[i] = etype.currentIndex()
                evalue = self.eventtable.cellWidget(i,5).text()
                aw.qmc.specialeventsvalue[i] = aw.qmc.str2eventsvalue(str(evalue))
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    @pyqtSlot(bool)
    def copyDataTabletoClipboard(self,_=False):
        aw.copy_cells_to_clipboard(self.datatable,adjustment=5)
        aw.sendmessage(QApplication.translate("Message","Data table copied to clipboard",None))

    @pyqtSlot(bool)
    def copyEventTabletoClipboard(self,_=False):
        nrows = self.eventtable.rowCount() 
        ncols = self.eventtable.columnCount()
        clipboard = ""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            tbl = prettytable.PrettyTable()
            fields = []
            for c in range(ncols):
                fields.append(u(self.eventtable.horizontalHeaderItem(c).text()))
            tbl.field_names = fields
            for i in range(nrows):
                rows = []
                rows.append(u(self.eventtable.cellWidget(i,0).text()))
                rows.append(u(self.eventtable.cellWidget(i,1).text()))
                rows.append(u(self.eventtable.cellWidget(i,2).text()))
                rows.append(u(self.eventtable.cellWidget(i,3).text()))
                rows.append(u(self.eventtable.cellWidget(i,4).currentText()))
                rows.append(u(self.eventtable.cellWidget(i,5).text()))
                tbl.add_row(rows)
            clipboard = tbl.get_string()
        else:
            for c in range(ncols):
                clipboard += u(self.eventtable.horizontalHeaderItem(c).text())
                if c != (ncols-1):
                    clipboard += '\t'
            clipboard += '\n'
            for r in range(nrows):
                clipboard += u(self.eventtable.cellWidget(r,0).text()) + "\t"
                clipboard += u(self.eventtable.cellWidget(r,1).text()) + "\t"
                clipboard += u(self.eventtable.cellWidget(r,2).text()) + "\t"
                clipboard += u(self.eventtable.cellWidget(r,3).text()) + "\t"
                clipboard += u(self.eventtable.cellWidget(r,4).currentText()) + "\t"
                clipboard += u(self.eventtable.cellWidget(r,5).text()) + "\n"
        # copy to the system clipboard
        sys_clip = QApplication.clipboard()
        sys_clip.setText(clipboard)
        aw.sendmessage(QApplication.translate("Message","Event table copied to clipboard",None))

    def createAlarmEventRows(self,rows):
        for r in rows:
            TP = aw.findTP()
            if TP:
                aw.qmc.alarmflag.append(1)
                aw.qmc.alarmguard.append(-1)
                aw.qmc.alarmnegguard.append(-1)
                tx = aw.qmc.timex[aw.qmc.specialevents[r]] - aw.qmc.timex[TP]
                ev = 8 # TP
                if tx < 0: # events before TP are moved to CHARGE
                    tx = 1 # set to one second after
                    ev = 0 # CHARGE
                aw.qmc.alarmoffset.append(tx) # seconds after TP
                aw.qmc.alarmtime.append(ev)
                aw.qmc.alarmcond.append(1) # rises above (we assume that BT always rises after TP)
                aw.qmc.alarmstate.append(-1) # not yet triggered
                aw.qmc.alarmsource.append(1) # 1=BT
                aw.qmc.alarmtemperature.append(float(round(aw.qmc.temp2[aw.qmc.specialevents[r]]))) # the BT trigger temperature
                aw.qmc.alarmaction.append(aw.qmc.specialeventstype[r] + 3) # 3,4,5,6 for slider 0-3
                aw.qmc.alarmbeep.append(0)
                aw.qmc.alarmstrings.append(str(int(aw.qmc.specialeventsvalue[r]*10 - 10)))
        
    @pyqtSlot(bool)
    def clusterEvents(self,_=False):
        nevents = len(aw.qmc.specialevents)
        if nevents:
            aw.clusterEvents()
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.qmc.fileDirty()
            
    @pyqtSlot(bool)
    def clearEvents(self,_=False):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            nevents = len(aw.qmc.specialevents)
            if nevents:
                aw.qmc.specialevents = []
                aw.qmc.specialeventstype = []
                aw.qmc.specialeventsStrings = []
                aw.qmc.specialeventsvalue = []
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)
        self.createEventTable()
        aw.qmc.redraw(recomputeAllDeltas=False)
        aw.qmc.fileDirty()
    
    @pyqtSlot(bool)
    def createAlarmEventTable(self,_=False):
        if len(aw.qmc.specialevents):
            # check for selection
            selected = self.eventtable.selectedRanges()
            if selected and len(selected) > 0:
                rows = []
                for s in selected:
                    top = s.topRow()
                    for x in range(s.rowCount()):
                        rows.append(top + x)
                #rows = [s.topRow() for s in selected]
                self.createAlarmEventRows(rows)
                message = QApplication.translate("Message","Alarms from events #{0} created", None).format(str([r+1 for r in rows]))
            else:
                rows = range(self.eventtable.rowCount())
                self.createAlarmEventRows(rows)
                message = QApplication.translate("Message","Alarms from events #{0} created", None).format(str([r+1 for r in rows]))
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No events found", None)
            aw.sendmessage(message)
    
    @pyqtSlot(bool)
    def orderEventTable(self,_=False):
        self.saveEventTable()
        self.orderEventTableLoop()
        aw.qmc.fileDirty()
        
    def orderEventTableLoop(self):
        nevents = len(aw.qmc.specialevents)
        if nevents:
            aw.orderEvents()
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(bool)
    def addEventTable(self,_=False):
        if len(aw.qmc.timex):
            self.saveEventTable()
            aw.qmc.specialevents.append(len(aw.qmc.timex)-1)   #qmc.specialevents holds indexes in qmx.timex. Initialize event index
            aw.qmc.specialeventstype.append(0)
            aw.qmc.specialeventsStrings.append(str(len(aw.qmc.specialevents)))
            aw.qmc.specialeventsvalue.append(0)
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            message = QApplication.translate("Message","Event #{0} added", None).format(str(len(aw.qmc.specialevents))) 
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No profile found", None)
            aw.sendmessage(message)
            
    def deleteEventRows(self,rows):
        specialevents = []
        specialeventstype = []
        specialeventsStrings = []
        specialeventsvalue = []
        for r in range(len(aw.qmc.specialevents)):
            if not (r in rows):
                specialevents.append(aw.qmc.specialevents[r])
                specialeventstype.append(aw.qmc.specialeventstype[r])
                specialeventsStrings.append(aw.qmc.specialeventsStrings[r])
                specialeventsvalue.append(aw.qmc.specialeventsvalue[r])
        aw.qmc.specialevents = specialevents
        aw.qmc.specialeventstype = specialeventstype
        aw.qmc.specialeventsStrings = specialeventsStrings
        aw.qmc.specialeventsvalue = specialeventsvalue
    
    @pyqtSlot(bool)
    def deleteEventTable(self,_=False):
        if len(aw.qmc.specialevents):
            self.saveEventTable()
            # check for selection
            selected = self.eventtable.selectedRanges()
            if selected and len(selected) > 0:
                rows = []
                for s in selected:
                    top = s.topRow()
                    for x in range(s.rowCount()):
                        rows.append(top + x)
                self.deleteEventRows(rows)
                message = QApplication.translate("Message"," Events #{0} deleted", None).format(str([r+1 for r in rows]))
            else:
                aw.qmc.specialevents.pop()
                aw.qmc.specialeventstype.pop()
                aw.qmc.specialeventsStrings.pop()
                aw.qmc.specialeventsvalue.pop()
                message = QApplication.translate("Message"," Event #{0} deleted", None).format(str(len(aw.qmc.specialevents)+1))
            aw.qmc.fileDirty()
            self.createEventTable()
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
        else:
            message = QApplication.translate("Message","No events found", None)
            aw.sendmessage(message)
    
    @pyqtSlot()
    def weightouteditChanged(self):
        self.weightoutedit.setText(aw.comma2dot(str(self.weightoutedit.text())))
        self.percent()
        self.calculated_density()
        self.density_out_editing_finished() # recalc volume_out

    def checkWeightIn(self):
        enough = True
        if self.plus_amount_selected is not None:
            weightIn = 0.0
            try:
                weightIn = float(str(self.weightinedit.text()))
                # convert weight to kg
                wc = aw.convertWeight(weightIn,aw.qmc.weight_units.index(self.unitsComboBox.currentText()),aw.qmc.weight_units.index("Kg"))
                if wc > self.plus_amount_selected:
                    enough = False 
            except:
                pass
        if enough:
            self.weightinedit.setStyleSheet("")
        else:
            if sys.platform.startswith("darwin") and darkdetect.isDark():
                self.weightinedit.setStyleSheet("""QLineEdit { background-color: #ad0427;  }""")
            else:
                self.weightinedit.setStyleSheet("""QLineEdit { color: red; }""")
    
    @pyqtSlot()
    def weightineditChanged(self):
        self.weightinedit.setText(aw.comma2dot(str(self.weightinedit.text())))
        self.percent()
        self.calculated_density()
        keep_modified_density = self.modified_density_in_text
        self.density_in_editing_finished() # recalc volume_in
        self.modified_density_in_text = keep_modified_density
        self.recentRoastEnabled()
        if aw.plus_account is not None:
            self.checkWeightIn()
        
    def density_percent(self):
        percent = 0.
        try:
            if self.bean_density_out_edit.text() != "" and float(str(self.bean_density_out_edit.text())) != 0.0:
                percent = aw.weight_loss(float(aw.comma2dot(str(self.bean_density_in_edit.text()))),float(aw.comma2dot(str(self.bean_density_out_edit.text()))))
        except Exception:
            pass
        if percent <= 0:
            self.densitypercentlabel.setText("")
        else:
            percentstring =  "-%.1f" %(percent) + "%"
            self.densitypercentlabel.setText(u(percentstring))    #density percent loss
        
    def moisture_percent(self):
        percent = 0.
        try:
            m_roasted = float(aw.comma2dot(str(self.moisture_roasted_edit.text())))
            if m_roasted != 0.0:
                percent = float(aw.comma2dot(str(self.moisture_greens_edit.text()))) - m_roasted
        except Exception:
            pass
        if percent <= 0:
            self.moisturepercentlabel.setText("")
        else:
            percentstring =  "-%.1f" %(percent) + "%"
            self.moisturepercentlabel.setText(u(percentstring))    #density percent loss
                
    def percent(self):
        percent = 0.
        try:
            if self.weightoutedit.text() != "" and float(str(self.weightoutedit.text())) != 0.0:
                percent = aw.weight_loss(float(str(self.weightinedit.text())),float(str(self.weightoutedit.text())))
        except Exception:
            pass
        if percent > 0:
            percentstring =  "-%.1f" %(percent) + "%"
            self.weightpercentlabel.setText(u(percentstring))    #weight percent loss
        else:
            self.weightpercentlabel.setText("")

    @pyqtSlot()
    def volume_percent(self):
        self.volumeinedit.setText(aw.comma2dot(str(self.volumeinedit.text())))
        self.volumeoutedit.setText(aw.comma2dot(str(self.volumeoutedit.text())))
        self.modified_volume_in_text = str(self.volumeinedit.text())
        percent = 0.
        try:
            if self.volumeoutedit.text() != "" and float(str(self.volumeoutedit.text())) != 0.0:
                percent = aw.volume_increase(float(str(self.volumeinedit.text()).replace(",",".")),float(str(self.volumeoutedit.text().replace(",","."))))
        except Exception:
            pass
        if percent == 0:
            self.volumepercentlabel.setText("")
        else:
            percentstring =  "%.1f" %(percent) + "%"
            self.volumepercentlabel.setText(u(percentstring))    #volume percent gain
        self.calculated_density()
        
    # calculates density in g/l from weightin/weightout and volumein/volumeout
    def calc_density(self):
        din = dout = 0.0
        try:
            if self.volumeinedit.text() != "" and self.weightinedit.text() != "":
                volumein = float(str(self.volumeinedit.text()))
                weightin = float(str(self.weightinedit.text()))
                if volumein != 0.0 and weightin != 0.0:
                    vol_idx = aw.qmc.volume_units.index(self.volumeUnitsComboBox.currentText())
                    volumein = aw.convertVolume(volumein,vol_idx,0)
                    weight_idx = aw.qmc.weight_units.index(self.unitsComboBox.currentText())
                    weightin = aw.convertWeight(weightin,weight_idx,0)
                    din = (weightin / volumein) 
            if self.volumeoutedit.text() != ""  and self.weightoutedit.text() != "":
                volumeout = float(str(self.volumeoutedit.text()))
                weightout = float(str(self.weightoutedit.text()))
                if volumeout != 0.0 and weightout != 0.0:
                    vol_idx = aw.qmc.volume_units.index(self.volumeUnitsComboBox.currentText())
                    volumeout = aw.convertVolume(volumeout,vol_idx,0)
                    weight_idx = aw.qmc.weight_units.index(self.unitsComboBox.currentText())
                    weightout = aw.convertWeight(weightout,weight_idx,0)
                    dout = (weightout / volumeout)
        except:
            pass
        return din,dout

    @pyqtSlot(int)
    def calculated_density(self,_=0):
        din, dout = self.calc_density()
        if din > 0.:
            # set also the green density if not yet set
            self.bean_density_in_edit.setText("%g" % aw.float2float(din))
        if  dout > 0.:
            # set also the roasted density if not yet set
            self.bean_density_out_edit.setText("%g" % aw.float2float(dout))
        self.density_percent()
        self.calculated_organic_loss()
            
    def calc_organic_loss(self):
        wloss = 0. # weight (moisture + organic)
        mloss = 0. # moisture
        try:
            if self.weightpercentlabel.text() and self.weightpercentlabel.text() != "":
                wloss = abs(float(self.weightpercentlabel.text().split("%")[0]))
        except Exception:
            pass
        try:
            if self.moisturepercentlabel.text() and self.moisturepercentlabel.text() != "":
                mloss = abs(float(self.moisturepercentlabel.text().split("%")[0]))
        except Exception:
            pass
        if mloss != 0. and wloss != 0.:
            return mloss, aw.float2float(max(min(wloss - mloss,100),0))
        else:
            return 0., 0.

    def calculated_organic_loss(self):
        self.moisture_percent()
        mloss, oloss = self.calc_organic_loss()
        if oloss > 0. and mloss > 0.:
            self.organiclosslabel.setText(QApplication.translate("Label", "organic material",None))
            self.organicpercentlabel.setText("-{}%".format(oloss))
        else:
            self.organiclosslabel.setText("")
            self.organicpercentlabel.setText("")

    @pyqtSlot()
    def greens_temp_editing_finished(self):
        self.greens_temp_edit.setText(aw.comma2dot(str(self.greens_temp_edit.text())))
        
    @pyqtSlot()
    def ambientedit_editing_finished(self):
        self.ambientedit.setText(aw.comma2dot(str(self.ambientedit.text())))
    
    @pyqtSlot()
    def ambient_humidity_editing_finished(self):
        self.ambient_humidity_edit.setText(aw.comma2dot(str(self.ambient_humidity_edit.text())))
        
    @pyqtSlot()
    def pressureedit_editing_finished(self):
        self.pressureedit.setText(aw.comma2dot(str(self.pressureedit.text())))
    
    @pyqtSlot()
    def density_in_editing_finished(self):
        self.bean_density_in_edit.setText(aw.comma2dot(str(self.bean_density_in_edit.text())))
        self.modified_density_in_text = str(self.bean_density_in_edit.text())
        # if density-in and weight-in is given, we re-calc volume-in:
        if self.bean_density_in_edit.text() != "" and self.weightinedit.text() != "":
            density_in = float(str(self.bean_density_in_edit.text()))
            weight_in = float(str(self.weightinedit.text()))
            if density_in != 0 and weight_in != 0:
                weight_in = aw.convertWeight(weight_in,self.unitsComboBox.currentIndex(),aw.qmc.weight_units.index("g"))
                volume_in = weight_in / density_in # in g/l
                # convert to selected volume unit
                volume_in = aw.convertVolume(volume_in,aw.qmc.volume_units.index("l"),self.volumeUnitsComboBox.currentIndex())
            else:
                volume_in = 0
            self.volumeinedit.setText("%g" % aw.float2floatWeightVolume(volume_in))
            self.volume_percent()
    
    @pyqtSlot()
    def density_out_editing_finished(self):
        self.bean_density_out_edit.setText(aw.comma2dot(str(self.bean_density_out_edit.text())))
        # if density-out and weight-out is given, we re-calc volume-out:
        if self.bean_density_out_edit.text() != "" and self.weightoutedit.text() != "":
            density_out = float(str(self.bean_density_out_edit.text()))
            weight_out = float(str(self.weightoutedit.text()))
            if density_out != 0 and weight_out != 0:
                weight_out = aw.convertWeight(weight_out,self.unitsComboBox.currentIndex(),aw.qmc.weight_units.index("g"))
                volume_out = weight_out / density_out # in g/l
                # convert to selected volume unit
                volume_out = aw.convertVolume(volume_out,aw.qmc.volume_units.index("l"),self.volumeUnitsComboBox.currentIndex())
            else:
                volume_out = 0
            self.volumeoutedit.setText("%g" % aw.float2floatWeightVolume(volume_out))
            self.volume_percent()
    
    @pyqtSlot()
    def accept(self):
        #check for graph
        if len(aw.qmc.timex):
            #prevents accidentally deleting a modified profile.
            aw.qmc.fileDirty()
            if self.chargeedit.text() == "":
                aw.qmc.timeindex[0] = -1
                aw.qmc.xaxistosm(redraw=False)
            elif self.chargeeditcopy != str(self.chargeedit.text()):
                #if there is a CHARGE recorded and the time entered is positive. Use relative time
                if aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] != -1:
                    startindex = aw.qmc.time2index(aw.qmc.timex[aw.qmc.timeindex[0]] + aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm(redraw=False)
                #if there is a CHARGE recorded and the time entered is negative. Use relative time
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] != -1:
                    relativetime = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    startindex = aw.qmc.time2index(relativetime)
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm(redraw=False)
                #if there is _no_ CHARGE recorded and the time entered is positive. Use absolute time 
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) > 0 and aw.qmc.timeindex[0] == -1:
                    startindex = aw.qmc.time2index(aw.qmc.stringtoseconds(str(self.chargeedit.text())))
                    aw.qmc.timeindex[0] = startindex
                    aw.qmc.xaxistosm(redraw=False)
                #if there is _no_ CHARGE recorded and the time entered is negative. ERROR
                elif aw.qmc.stringtoseconds(str(self.chargeedit.text())) < 0 and aw.qmc.timeindex[0] == -1:
                    aw.qmc.adderror(QApplication.translate("Error Message", "Unable to move CHARGE to a value that does not exist",None))
                    return
            # check CHARGE (with index aw.qmc.timeindex[0])
            if aw.qmc.timeindex[0] == -1:
                start = 0                   #relative start time
            else:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            if self.dryeditcopy != str(self.dryedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dryedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[1] = 0
                else:
                    dryindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[1] = dryindex
            if self.Cstarteditcopy != str(self.Cstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[2] = 0
                else:
                    fcsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[2] = fcsindex
            if self.Cendeditcopy != str(self.Cendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.Cendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[3] = 0
                else:
                    fceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[3] = fceindex
            if self.CCstarteditcopy != str(self.CCstartedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCstartedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[4] = 0
                else:
                    scsindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[4] = scsindex
            if self.CCendeditcopy != str(self.CCendedit.text()):
                s = aw.qmc.stringtoseconds(str(self.CCendedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[5] = 0
                elif aw.qmc.stringtoseconds(str(self.CCendedit.text())) > 0:
                    sceindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[5] = sceindex
            if self.dropeditcopy != str(self.dropedit.text()):
                s = aw.qmc.stringtoseconds(str(self.dropedit.text()))
                if s <= 0:
                    aw.qmc.timeindex[6] = 0
                else:
                    dropindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[6] = dropindex
            if self.cooleditcopy != str(self.cooledit.text()):
                s = aw.qmc.stringtoseconds(str(self.cooledit.text()))
                if s <= 0:
                    aw.qmc.timeindex[7] = 0
                else:
                    coolindex = aw.qmc.time2index(start + s)
                    aw.qmc.timeindex[7] = coolindex
            if aw.qmc.phasesbuttonflag:   
                # adjust phases by DryEnd and FCs events
                if aw.qmc.timeindex[1]:
                    aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
                if aw.qmc.timeindex[2]:
                    aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            
            self.saveEventTable()
        # Update Title
        aw.qmc.title = ' '.join(u(self.titleedit.currentText()).split())
        aw.qmc.title_show_always = self.titleShowAlwaysFlag.isChecked()
        aw.qmc.container_idx = self.tareComboBox.currentIndex() - 3

#PLUS        
        # Update Plus
        if aw.plus_account is not None:
            aw.qmc.plus_default_store = self.plus_default_store
            aw.qmc.plus_store = self.plus_store_selected
            aw.qmc.plus_store_label = self.plus_store_selected_label
            aw.qmc.plus_coffee = self.plus_coffee_selected
            aw.qmc.plus_coffee_label = self.plus_coffee_selected_label
            aw.qmc.plus_blend_label = self.plus_blend_selected_label
            aw.qmc.plus_blend_spec = self.plus_blend_selected_spec
            aw.qmc.plus_blend_spec_labels = self.plus_blend_selected_spec_labels
        
        # Update beans
        aw.qmc.beans = u(self.beansedit.toPlainText())
        #update ambient temperature source
        aw.qmc.ambientTempSource = self.ambientComboBox.currentIndex()
        #update weight
        try:
            aw.qmc.weight[0] = float(aw.comma2dot(str(self.weightinedit.text())))
        except Exception:
            aw.qmc.weight[0] = 0
        try:
            aw.qmc.weight[1] = float(aw.comma2dot(str(self.weightoutedit.text())))
        except Exception:
            aw.qmc.weight[1] = 0
        aw.qmc.weight[2] =u(self.unitsComboBox.currentText())
        #update volume
        try:
            aw.qmc.volume[0] = float(aw.comma2dot(str(self.volumeinedit.text())))
        except Exception:
            aw.qmc.volume[0] = 0
        try:
            aw.qmc.volume[1] = float(aw.comma2dot(str(self.volumeoutedit.text())))
        except Exception:
            aw.qmc.volume[1] = 0
        aw.qmc.volume[2] = u(self.volumeUnitsComboBox.currentText())
        #update density
        try:
            aw.qmc.density[0] = float(aw.comma2dot(str(self.bean_density_in_edit.text())))
        except Exception:
            aw.qmc.density[0] = 0
        aw.qmc.density[1] = "g"
        aw.qmc.density[2] = 1
        aw.qmc.density[3] = "l"
        try:
            aw.qmc.density_roasted[0] = float(aw.comma2dot(str(self.bean_density_out_edit.text())))
        except Exception:
            aw.qmc.density_roasted[0] = 0
        aw.qmc.density_roasted[1] = "g"
        aw.qmc.density_roasted[2] = 1
        aw.qmc.density_roasted[3] = "l"
        #update bean size
        try:
            aw.qmc.beansize_min = int(str(self.bean_size_min_edit.text()))
        except Exception:
            aw.qmc.beansize_min = 0
        try:
            aw.qmc.beansize_max = int(str(self.bean_size_max_edit.text()))
        except Exception:
            aw.qmc.beansize_max = 0
        #update roastflags
        aw.qmc.heavyFC_flag = self.heavyFC.isChecked()
        aw.qmc.lowFC_flag = self.lowFC.isChecked()
        aw.qmc.lightCut_flag = self.lightCut.isChecked()
        aw.qmc.darkCut_flag = self.darkCut.isChecked()
        aw.qmc.drops_flag = self.drops.isChecked()
        aw.qmc.oily_flag = self.oily.isChecked()
        aw.qmc.uneven_flag = self.uneven.isChecked()
        aw.qmc.tipping_flag = self.tipping.isChecked()
        aw.qmc.scorching_flag = self.scorching.isChecked()
        aw.qmc.divots_flag = self.divots.isChecked()
        #update color
        try:
            aw.qmc.whole_color = int(str(self.whole_color_edit.text()))
        except:
            aw.qmc.whole_color = 0
        try:
            aw.qmc.ground_color = int(str(self.ground_color_edit.text()))
        except:
            aw.qmc.ground_color = 0
        aw.qmc.color_system_idx = self.colorSystemComboBox.currentIndex()
        #update beans temperature
        try:
            aw.qmc.greens_temp = float(aw.comma2dot(str(self.greens_temp_edit.text())))
        except:
            aw.qmc.greens_temp = 0.
        #update greens moisture
        try:
            aw.qmc.moisture_greens = float(aw.comma2dot(str(self.moisture_greens_edit.text())))
        except Exception:
            aw.qmc.moisture_greens = 0.
        #update roasted moisture
        try:
            aw.qmc.moisture_roasted = float(aw.comma2dot(str(self.moisture_roasted_edit.text())))
        except Exception:
            aw.qmc.moisture_roasted = 0.
        #update ambient temperature
        try:
            aw.qmc.ambientTemp = float(str(self.ambientedit.text()))
            if math.isnan(aw.qmc.ambientTemp):
                aw.qmc.ambientTemp = 0.0
        except Exception:
            aw.qmc.ambientTemp = 0.0
        #update ambient humidity
        try:
            aw.qmc.ambient_humidity = float(aw.comma2dot(str(self.ambient_humidity_edit.text())))
        except Exception:
            aw.qmc.ambient_humidity = 0
        #update ambient pressure
        try:
            aw.qmc.ambient_pressure = float(aw.comma2dot(str(self.pressureedit.text())))
        except Exception:
            aw.qmc.ambient_pressure = 0
        #update notes
        aw.qmc.roastertype = u(self.roaster.text())
        aw.qmc.operator = u(self.operator.text())
        aw.qmc.drumspeed = u(self.drumspeed.text())
        aw.qmc.roastingnotes = u(self.roastingeditor.toPlainText())
        aw.qmc.cuppingnotes = u(self.cuppingeditor.toPlainText())
        if aw.superusermode or self.batcheditmode:
            aw.qmc.roastbatchprefix = u(self.batchprefixedit.text())
            aw.qmc.roastbatchnr = self.batchcounterSpinBox.value()
            aw.qmc.roastbatchpos = self.batchposSpinBox.value()
            
        # if custom events were changed we clear the event flag position cache 
        if aw.qmc.specialevents != self.org_specialevents:
            aw.qmc.l_event_flags_dict = {}
        # if events were changed we clear the event flag position cache 
        if aw.qmc.timeindex != self.org_timeindex:
            aw.qmc.l_annotations_dict = {}
        
        # load selected recent roast template in the background
        if self.template_file:
            try:
                aw.qmc.resetlinecountcaches()
                aw.loadbackground(self.template_file)
                aw.qmc.background = True
                aw.qmc.timealign(redraw=False)
                aw.qmc.redraw()
            except:
                pass
        elif ((not aw.qmc.flagon) or
            (aw.qmc.specialevents != self.org_specialevents) or
            (aw.qmc.specialeventstype != self.org_specialeventstype) or
            (aw.qmc.specialeventsStrings != self.org_specialeventsStrings) or
            (aw.qmc.specialeventsvalue != self.org_specialeventsvalue) or
            (aw.qmc.timeindex != self.org_timeindex)):
            # we do a general redraw only if not sampling
            aw.qmc.redraw(recomputeAllDeltas=False)
        elif (self.org_title != aw.qmc.title) or self.org_title_show_always != aw.qmc.title_show_always:
            # if title changed we at least update that one
            if aw.qmc.flagstart and not aw.qmc.title_show_always:
                aw.qmc.setProfileTitle("")
                st_artist = aw.qmc.fig.suptitle("")
                try:
                    st_artist.set_in_layout(False) # remove suptitle from tight_layout calculation
                except: # set_in_layout not available in mpl<3.x
                    pass
                aw.qmc.fig.canvas.draw()
            else:                        
                aw.qmc.setProfileTitle(aw.qmc.title)
#                aw.qmc.updateBackground()
                aw.qmc.fig.canvas.draw()
        
        if not aw.qmc.flagon:
            aw.sendmessage(QApplication.translate("Message","Roast properties updated but profile not saved to disk", None))
        self.close()


##########################################################################
#####################  VIEW Tare  ########################################
##########################################################################


class tareDlg(ArtisanDialog):
    def __init__(self, parent = None, tarePopup = None):
        super(tareDlg,self).__init__(parent)
        self.parent = parent
        self.tarePopup = tarePopup
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Tare Setup", None))

        self.taretable = QTableWidget()
        self.taretable.setTabKeyNavigation(True)
        self.createTareTable()
        
        self.taretable.itemSelectionChanged.connect(self.selectionChanged)
        
        addButton = QPushButton(QApplication.translate("Button","Add", None))
        addButton.setFocusPolicy(Qt.NoFocus)
        self.delButton = QPushButton(QApplication.translate("Button","Delete", None))
        self.delButton.setDisabled(True)
        self.delButton.setFocusPolicy(Qt.NoFocus)
        
        addButton.clicked.connect(self.addTare)
        self.delButton.clicked.connect(self.delTare)
        
        okButton = QPushButton(QApplication.translate("Button","OK", None))
        cancelButton = QPushButton(QApplication.translate("Button","Cancel",None))
        cancelButton.setFocusPolicy(Qt.NoFocus)
        okButton.clicked.connect(self.close)
        cancelButton.clicked.connect(self.reject)
        contentbuttonLayout = QHBoxLayout()
        contentbuttonLayout.addStretch()
        contentbuttonLayout.addWidget(addButton)
        contentbuttonLayout.addWidget(self.delButton)
        contentbuttonLayout.addStretch()

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(okButton)
        layout = QVBoxLayout()
        layout.addWidget(self.taretable)
        layout.addLayout(contentbuttonLayout)
        layout.addLayout(buttonLayout)
        self.setLayout(layout)
    
    @pyqtSlot()
    def selectionChanged(self):
        if len(self.taretable.selectedRanges()) > 0:
            self.delButton.setDisabled(False)
        else:
            self.delButton.setDisabled(False)
        
    def closeEvent(self,_):
        self.saveTareTable()
        # update popup
        self.tarePopup.tarePopupEnabled = False
        self.tarePopup.tareComboBox.clear()
        self.tarePopup.tareComboBox.addItem("<edit> TARE")
        self.tarePopup.tareComboBox.insertSeparator(2)
        self.tarePopup.tareComboBox.addItem("")
        self.tarePopup.tareComboBox.addItems(aw.qmc.container_names)
        self.tarePopup.tareComboBox.setCurrentIndex(2) # reset to the empty entry
        aw.qmc.container_idx = -1
        self.tarePopup.tarePopupEnabled = True
        self.accept()

    @pyqtSlot(bool)
    def addTare(self,_):
        rows = self.taretable.rowCount()
        self.taretable.setRowCount(rows + 1)
        #add widgets to the table
        name = QLineEdit()
        name.setAlignment(Qt.AlignRight)
        name.setText("name")
        w,_,_ = aw.scale.readWeight(self.parent.scale_weight) # read value from scale in 'g'
        weight = QLineEdit()
        weight.setAlignment(Qt.AlignRight)
        if w > -1:
            weight.setText(str(w))
        else:
            weight.setText(str(0))
        weight.setValidator(QIntValidator(0,999,weight))
        self.taretable.setCellWidget(rows,0,name)
        self.taretable.setCellWidget(rows,1,weight)
        
    @pyqtSlot(bool)
    def delTare(self,_):
        selected = self.taretable.selectedRanges()
        if len(selected) > 0:
            bindex = selected[0].topRow()
            if bindex >= 0:
                self.taretable.removeRow(bindex)

    def saveTareTable(self):
        tars = self.taretable.rowCount() 
        names = []
        weights = []
        for i in range(tars):
            name = u(self.taretable.cellWidget(i,0).text())
            weight = int(round(float(self.taretable.cellWidget(i,1).text())))
            names.append(name)
            weights.append(weight)
        aw.qmc.container_names = names
        aw.qmc.container_weights = weights
        
    def createTareTable(self):
        self.taretable.clear()        
        self.taretable.setRowCount(len(aw.qmc.container_names))
        self.taretable.setColumnCount(2)
        self.taretable.setHorizontalHeaderLabels([QApplication.translate("Table","Name",None),
                                                         QApplication.translate("Table","Weight",None)])
        self.taretable.setAlternatingRowColors(True)
        self.taretable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.taretable.setSelectionBehavior(QTableWidget.SelectRows)
        self.taretable.setSelectionMode(QTableWidget.SingleSelection)
        self.taretable.setShowGrid(True)
        self.taretable.verticalHeader().setSectionResizeMode(2)
        for i in range(len(aw.qmc.container_names)):
            #add widgets to the table
            name = QLineEdit()
            name.setAlignment(Qt.AlignRight)
            name.setText(aw.qmc.container_names[i])
            weight = QLineEdit()
            weight.setAlignment(Qt.AlignRight)
            weight.setText(str(aw.qmc.container_weights[i]))
            weight.setValidator(QIntValidator(0,999,weight))
            
            self.taretable.setCellWidget(i,0,name)
            self.taretable.setCellWidget(i,1,weight)
        header = self.taretable.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.Fixed)
        self.taretable.setColumnWidth(1,65)


##########################################################################
#####################  VIEW PLATFORM      ################################
##########################################################################

class platformDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(platformDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Artisan Platform", None))
        platformdic = {}
        platformdic["Architecture"] = str(platform.architecture())
        platformdic["Machine"] = str(platform.machine())
        platformdic["Platform name"] =  str(platform.platform())
        platformdic["Processor"] = str(platform.processor())
        platformdic["Python Build"] = str(platform.python_build())
        platformdic["Python Compiler"] = str(platform.python_compiler())
        platformdic["Python Branch"] = str(platform.python_branch())
        platformdic["Python Implementation"] = str(platform.python_implementation())
        platformdic["Python Revision"] = str(platform.python_revision())
        platformdic["Release"] = str(platform.release())
        platformdic["System"] = str(platform.system())
        platformdic["Version"] = str(platform.version())
        platformdic["Python version"] = str(platform.python_version())
        system = str(platform.system())
        if system == "Windows":
            platformdic["Win32"] = str(platform.win32_ver())
        elif system == "Darwin":
            platformdic["Mac"] = str(platform.mac_ver())
        elif system == "Linux":
            platformdic["Linux"] = str(platform.linux_distribution())
            platformdic["Libc"] = str(platform.libc_ver())
        htmlplatform = "<b>version =</b> " + __version__ + " (" + __revision__ + ")<br>"
        for key in sorted(platformdic):
            htmlplatform += "<b>" + key + " = </b> <i>" + platformdic[key] + "</i><br>"
        platformEdit = QTextEdit()
        platformEdit.setHtml(htmlplatform)
        platformEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(platformEdit)
        self.setLayout(layout)

##########################################################################
#####################  VIEW ATISAN SETTINGS ##############################
##########################################################################

#class artisansettingsDlg(ArtisanDialog):
#    def __init__(self, parent = None):
#        super(artisansettingsDlg,self).__init__(parent)
#        self.setWindowTitle(QApplication.translate("Form Caption","Preferences", None))
#        # Layout
#        layout = QVBoxLayout()
#        self.setLayout(layout)

##########################################################################
#####################  VIEW SERIAL LOG DLG  ##############################
##########################################################################

class serialLogDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(serialLogDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Serial Log", None))
        self.serialcheckbox = QCheckBox(QApplication.translate("CheckBox","Serial Log ON/OFF", None))
        self.serialcheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF logs serial communication",None))
        self.serialcheckbox.setChecked(aw.seriallogflag)
        self.serialcheckbox.stateChanged.connect(self.serialcheckboxChanged)
        self.serialEdit = QTextEdit()
        self.serialEdit.setReadOnly(True)
        self.serialEdit.setHtml(self.getstring())
        layout = QVBoxLayout()
        layout.addWidget(self.serialcheckbox,0)
        layout.addWidget(self.serialEdit,1)
        self.setLayout(layout)

    def getstring(self):
        #convert list of serial comm an html string
        htmlserial = "version = " +__version__ +"<br><br>"
        lenl = len(aw.seriallog)
        for i in range(len(aw.seriallog)):
            htmlserial += "<b>" + str(lenl-i) + "</b> " + aw.seriallog[-i-1] + "<br><br>"
        return htmlserial
            
    def update(self):
        if aw.seriallogflag:
            self.serialEdit.setText(self.getstring())

    @pyqtSlot(int)
    def serialcheckboxChanged(self,_):
        if self.serialcheckbox.isChecked():
            aw.seriallogflag = True
        else:
            aw.seriallogflag = False
            
    def closeEvent(self,_):
        self.close()
        aw.serial_dlg = None

##########################################################################
#####################  VIEW ERROR LOG DLG  ###############################
##########################################################################

class errorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(errorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Error Log", None))
        self.elabel = QLabel()
        self. errorEdit = QTextEdit()
        self.errorEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(self.elabel,0)
        layout.addWidget(self.errorEdit,1)
        self.setLayout(layout)
        self.update()
        
    def update(self):
        #convert list of errors to an html string
        htmlerr = "version = " +__version__ +"<br><br>"
        lenl = len(aw.qmc.errorlog)
        for i in range(len(aw.qmc.errorlog)):
            htmlerr += "<b>" + str(lenl-i) + "</b> <i>" + aw.qmc.errorlog[-i-1] + "</i><br><br>"
        enumber = len(aw.qmc.errorlog)
        labelstr =  "<b>"+ QApplication.translate("Label","Number of errors found {0}", None).format(str(enumber)) + "</b>"
        self.elabel.setText(labelstr)
        self.errorEdit.setHtml(htmlerr)
        
    def closeEvent(self,_):
        self.close()
        aw.error_dlg = None


##########################################################################
#####################  MESSAGE HISTORY DLG  ##############################
##########################################################################

class messageDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(messageDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Message History", None))
        self.messageEdit = QTextEdit()
        self.messageEdit.setReadOnly(True)
        layout = QVBoxLayout()
        layout.addWidget(self.messageEdit,0)
        self.setLayout(layout)
        self.update()
        
    def update(self):
        #convert list of messages to an html string
        htmlmessage = ""
        for i in range(len(aw.messagehist)):
            htmlmessage += "<b>" + str(len(aw.messagehist)-i) + "</b> <i>" + aw.messagehist[-i-1] + "</i><br><br>"
        self.messageEdit.setHtml(htmlmessage)
    
    def closeEvent(self,_):
        self.close()
        aw.message_dlg = None

##########################################################################
#####################  AUTOSAVE DLG  #####################################
##########################################################################

class autosaveDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(autosaveDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Autosave", None))

        settings = QSettings()
        if settings.contains("autosaveGeometry"):
            self.restoreGeometry(settings.value("autosaveGeometry"))
        
        self.helpdialog = None

        self.prefixEdit = QLineEdit(aw.qmc.autosaveprefix)
        self.prefixEdit.setToolTip(QApplication.translate("Tooltip", "Automatic generated name",None))
        self.prefixEdit.textChanged.connect(self.prefixChanged)
        prefixpreviewLabel = QLabel()
        prefixpreviewLabel.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        prefixpreviewLabel.setText(u(QApplication.translate("Label", "Preview:",None)))
        self.prefixPreview = QLabel()
        self.prefixpreviewrecordingLabel = QLabel()
        self.prefixpreviewrecordingLabel.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        self.prefixPreviewrecording = QLabel()
        self.prefixChanged()
 
        autochecklabel = QLabel(QApplication.translate("CheckBox","Autosave [a]", None))
        self.autocheckbox = QCheckBox()
        self.autocheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF of automatic saving when pressing keyboard letter [a]",None))
        self.autocheckbox.setChecked(aw.qmc.autosaveflag)        
        autopdflabel = QLabel(QApplication.translate("CheckBox","Save also", None))
        self.autopdfcheckbox = QCheckBox()
        self.autopdfcheckbox.setToolTip(QApplication.translate("Tooltip", "Save image alongside .alog profiles",None))
        self.autopdfcheckbox.setChecked(aw.qmc.autosaveimage)
        imageTypes = ["PDF", "SVG", "PNG", "JPEG", "BMP", "CSV", "JSON"]
        self.imageTypesComboBox = QComboBox()
        self.imageTypesComboBox.addItems(imageTypes)
        self.imageTypesComboBox.setCurrentIndex(imageTypes.index(aw.qmc.autosaveimageformat))
        prefixlabel = QLabel()
        prefixlabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        prefixlabel.setText(u(QApplication.translate("Label", "File Name Prefix",None)))

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.autoChanged)
        self.dialogbuttons.rejected.connect(self.close)
        
        pathButton = QPushButton(QApplication.translate("Button","Path", None))
        pathButton.setFocusPolicy(Qt.NoFocus)
        self.pathEdit = QLineEdit(u(aw.qmc.autosavepath))
        self.pathEdit.setToolTip(QApplication.translate("Tooltip", "Sets the directory to store batch profiles when using the letter [a]",None))
        pathButton.clicked.connect(self.getpath)
        
        pathAlsoButton = QPushButton(QApplication.translate("Button","Path", None))
        pathAlsoButton.setFocusPolicy(Qt.NoFocus)
        self.pathAlsoEdit = QLineEdit(u(aw.qmc.autosavealsopath))
        self.pathAlsoEdit.setToolTip(QApplication.translate("Tooltip", "Sets the directory to store the save also files",None))
        pathAlsoButton.clicked.connect(self.getalsopath)

        helpButton = QPushButton(QApplication.translate("Button","Help", None))
        helpButton.clicked.connect(self.showautosavehelp)

        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(helpButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        autolayout = QGridLayout()
        autolayout.addWidget(self.autocheckbox,0,0,Qt.AlignRight)
        autolayout.addWidget(autochecklabel,0,1)
        autolayout.addWidget(prefixlabel,1,0)
        autolayout.addWidget(self.prefixEdit,1,1,1,2)
        autolayout.addWidget(prefixpreviewLabel,2,0)
        autolayout.addWidget(self.prefixPreview,2,1)
        autolayout.addWidget(self.prefixpreviewrecordingLabel,3,0)
        autolayout.addWidget(self.prefixPreviewrecording,3,1)
        autolayout.addWidget(pathButton,4,0)
        autolayout.addWidget(self.pathEdit,4,1,1,2)
        autolayout.addWidget(self.autopdfcheckbox,5,0,Qt.AlignRight)
        autolayout.addWidget(autopdflabel,5,1)
        autolayout.addWidget(self.imageTypesComboBox,5,2)
        autolayout.addWidget(pathAlsoButton,6,0)
        autolayout.addWidget(self.pathAlsoEdit,6,1,1,2)
        autolayout.setColumnStretch(0,0)
        autolayout.setColumnStretch(1,10)
        autolayout.setColumnStretch(2,0)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(autolayout)
        mainLayout.addStretch()
        mainLayout.addSpacing(10)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    @pyqtSlot()
    def showautosavehelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = autosavefieldsHelpDlg(self)
        except:
            self.helpdialog = autosavefieldsHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

    @pyqtSlot()
    def prefixChanged(self):
        preview = aw.generateFilename(self.prefixEdit.text(),previewmode=2)
        self.prefixPreview.setText(preview)
        previewrecording = aw.generateFilename(self.prefixEdit.text(),previewmode=1)
        if previewrecording == preview:
            self.prefixpreviewrecordingLabel.setText("")
            self.prefixPreviewrecording.setText("")
        else:
            self.prefixpreviewrecordingLabel.setText(u(QApplication.translate("Label", "While recording:",None)))
            self.prefixPreviewrecording.setText(previewrecording)

    @pyqtSlot(bool)
    def getpath(self,_):
        filename = aw.ArtisanExistingDirectoryDialog(msg=QApplication.translate("Form Caption","AutoSave Path", None))
        self.pathEdit.setText(filename)

    @pyqtSlot(bool)
    def getalsopath(self,_):
        filename = aw.ArtisanExistingDirectoryDialog(msg=QApplication.translate("Form Caption","AutoSave Save Also Path", None))
        self.pathAlsoEdit.setText(filename)

    @pyqtSlot()
    def autoChanged(self):
        aw.qmc.autosavepath = u(self.pathEdit.text())
        aw.qmc.autosavealsopath = u(self.pathAlsoEdit.text())
        if self.autocheckbox.isChecked():
            aw.qmc.autosaveflag = 1
            aw.qmc.autosaveprefix = u(self.prefixEdit.text())
            message = QApplication.translate("Message","Autosave ON. Prefix: {0}").format(self.prefixEdit.text())
            aw.sendmessage(message)
        else:
            aw.qmc.autosaveflag = 0
            aw.qmc.autosaveprefix = u(self.prefixEdit.text())
            message = QApplication.translate("Message","Autosave OFF. Prefix: {0}").format(self.prefixEdit.text())
            aw.sendmessage(message)
        aw.qmc.autosaveimage = self.autopdfcheckbox.isChecked()
        aw.qmc.autosaveimageformat = self.imageTypesComboBox.currentText()
        self.close()

    @pyqtSlot()
    def closeEvent(self, _):
        self.closeHelp()
        settings = QSettings()
        #save window geometry
        settings.setValue("autosaveGeometry",self.saveGeometry())              

########################################################################################
#####################  AUTOSAVE FIELDS HELP DLG ########################################
########################################################################################
class autosavefieldsHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(autosavefieldsHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Autosave Filename Fields Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("autosavefieldsHelpGeometry"):
            self.restoreGeometry(settings.value("autosavefieldsHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','AUTOSAVE FIELDS',None)) + "</b>"
        tbl_Autosave = prettytable.PrettyTable()
        tbl_Autosave.field_names = [u(QApplication.translate('HelpDlg','Prefix Field',None)),u(QApplication.translate('HelpDlg','Source',None)),u(QApplication.translate('HelpDlg','Example',None))]
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~batchprefix',None)),u(QApplication.translate('HelpDlg','The batch prefix set in Config>Batch>Prefix',None)),u(QApplication.translate('HelpDlg','Prod-',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~batchcounter',None)),u(QApplication.translate('HelpDlg','The current batch number',None)),653])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~batch',None)),u(QApplication.translate('HelpDlg','Same as "~batchprefix~batchnum"',None)),u(QApplication.translate('HelpDlg','Prod-653',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~batchposition',None)),u(QApplication.translate('HelpDlg','The current batch position, or "Roast of the Day"',None)),9])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~batch_long',None)),u(QApplication.translate('HelpDlg','Same as Batch field in Roast Properties\n "~batchprefix~batchnum (~batchposition)"',None)),u(QApplication.translate('HelpDlg','Prod-653 (9)',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~title',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Title',None)),u(QApplication.translate('HelpDlg','Ethiopia Guji',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~beans',None)),u(QApplication.translate('HelpDlg','The first 30 characters of the first line \nFrom Roast>Properties>Beans',None)),u(QApplication.translate('HelpDlg','Ethiopia Guji purchased from R',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~beans_line',None)),u(QApplication.translate('HelpDlg','The entire first line From Roast>Properties>Beans',None)),u(QApplication.translate('HelpDlg','Ethiopia Guji purchased from Royal',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~date',None)),u(QApplication.translate('HelpDlg','Roast date in format yy-MM-dd',None)),u(QApplication.translate('HelpDlg','20-02-05',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~date_long',None)),u(QApplication.translate('HelpDlg','Roast date in format yyyy-MM-dd',None)),u(QApplication.translate('HelpDlg','2020-02-05',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~time',None)),u(QApplication.translate('HelpDlg','Roast time in format hhmm',None)),1742])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~datetime',None)),u(QApplication.translate('HelpDlg','Roast date and time in format yy-MM-dd_hhmm',None)),u(QApplication.translate('HelpDlg','20-02-05_1742',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~datetime_long',None)),u(QApplication.translate('HelpDlg','Roast date and time in format yyyy-MM-dd_hhmm',None)),u(QApplication.translate('HelpDlg','2020-02-05_1742',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~operator',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Operator',None)),u(QApplication.translate('HelpDlg','Dave',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~weight',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Weight Green',None)),3])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~weightunits',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Weight',None)),u(QApplication.translate('HelpDlg','Kg',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~volume',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Volume Green',None)),4.1])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~volumeunits',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Volume',None)),u(QApplication.translate('HelpDlg','l',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~density',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Density Green',None)),756.4])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~densityunits',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Density',None)),u(QApplication.translate('HelpDlg','g_l',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~moisture',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Moisture Green',None)),11.7])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~moisturetunits',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Moisture',None)),u(QApplication.translate('HelpDlg','pct',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~machine',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Machine',None)),u(QApplication.translate('HelpDlg','SF-6',None))])
        tbl_Autosave.add_row([u(QApplication.translate('HelpDlg','~drumspeed',None)),u(QApplication.translate('HelpDlg','From Roast>Properties>Drum Speed',None)),64])
        helpstr += tbl_Autosave.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        helpstr += "<UL>"
        helpstr += QApplication.translate("AutosaveField","NOTES:",None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField","Anything between single quotes ' will show in the file name <b>only</b> when ON. \
Example: 'REC ~batch'",None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField",'Anything between double quotes " will show in the file name <b>only</b> when OFF. \
Example: "~operator"',None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField","Hover the mouse over the Preview field to see a preview of the prefix while the roaster scope is ON.",None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField","For backward compatibility, when the Prefix field is text only \
the date and time is appended to the file name.\
<BR/>Example: 'Autosave' will result in file name 'Autosave_20-01-13_1705'. \
<BR/>To prevent this place a single '!' at the start of the Prefix field.\
<BR/> Example: '!Autosave' will result in file name 'Autosave'.",None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField","To maintain cross platform compatibility, file names may contain only letters, numbers, spaces, \
and the following special characters:<br/>_-.( )<br/>All other characters will be filtered out.",None)
        helpstr += "<LI>" + QApplication.translate("AutosaveField","The 'While recording' preview shows only when the file name will be different when saved during a recording. \
Pressing the 'a' key will save during a recording when 'Autosave [a]' is checked.",None)
        helpstr += "</UL>"
        helpstr += "<br/>"
        helpstr += "</body>"

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("autosavefieldsHelpGeometry",self.saveGeometry())


##########################################################################
#####################  BATCH DLG  ########################################
##########################################################################

class batchDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(batchDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Batch", None))
        self.prefixEdit = QLineEdit(aw.qmc.batchprefix)
        self.prefixEdit.setToolTip(QApplication.translate("Tooltip", "Batch prefix",None))
        self.counterSpinBox = QSpinBox()
        self.counterSpinBox.setRange(0,999999)
        self.counterSpinBox.setSingleStep(1)
        self.counterSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        batchchecklabel = QLabel(QApplication.translate("CheckBox","Batch Counter", None))
        self.batchcheckbox = QCheckBox()
        self.batchcheckbox.setToolTip(QApplication.translate("Tooltip", "ON/OFF batch counter",None))
        if aw.qmc.batchcounter > -1:
            self.batchcheckbox.setChecked(True)
        else:
            self.batchcheckbox.setChecked(False)
        prefixlabel = QLabel()
        prefixlabel.setAlignment(Qt.Alignment(Qt.AlignVCenter | Qt.AlignRight))
        prefixlabel.setText(u(QApplication.translate("Label", "Prefix",None)))
        counterlabel = QLabel()
        counterlabel.setAlignment(Qt.Alignment(Qt.AlignVCenter | Qt.AlignRight))
        counterlabel.setText(u(QApplication.translate("Label", "Counter",None)))
        descrLabel = QLabel("<i>" + QApplication.translate("Message", "Next batch: counter+1",None) + "</i>")
        
        neverOverwriteCounterlabel = QLabel(QApplication.translate("CheckBox","Never overwrite counter", None))
        self.neverOverwriteCheckbox = QCheckBox()
        self.neverOverwriteCheckbox.setToolTip(QApplication.translate("Tooltip", "If ticked, the batch counter is never modified by loading a settings file",None))
        if aw.qmc.neverUpdateBatchCounter:
            self.neverOverwriteCheckbox.setChecked(True)
        else:
            self.neverOverwriteCheckbox.setChecked(False)
        
        if aw.qmc.batchcounter > -1:
            self.counterSpinBox.setValue(aw.qmc.batchcounter)
            self.counterSpinBox.setEnabled(True)
            self.prefixEdit.setEnabled(True)
            self.neverOverwriteCheckbox.setEnabled(True)
        else:
            self.counterSpinBox.setValue(0)
            self.counterSpinBox.setEnabled(False)
            self.prefixEdit.setEnabled(False)
            self.neverOverwriteCheckbox.setEnabled(False)
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.batchChanged)
        self.dialogbuttons.rejected.connect(self.close)
        
        self.batchcheckbox.stateChanged.connect(self.toggleCounterFlag)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        batchlayout = QGridLayout()
        batchlayout.addWidget(self.batchcheckbox,0,0,Qt.AlignRight)
        batchlayout.addWidget(batchchecklabel,0,1)
        batchlayout.addWidget(prefixlabel,1,0)
        batchlayout.addWidget(self.prefixEdit,1,1)
        batchlayout.addWidget(counterlabel,2,0)
        batchlayout.addWidget(self.counterSpinBox,2,1)
        batchlayout.addWidget(descrLabel,3,0,1,3)
        batchlayout.addWidget(self.neverOverwriteCheckbox,4,0,Qt.AlignRight)
        batchlayout.addWidget(neverOverwriteCounterlabel,4,1)
        
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(batchlayout)
        mainLayout.addStretch()
        mainLayout.addSpacing(10)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    @pyqtSlot(int)
    def toggleCounterFlag(self,_):
        if self.batchcheckbox.isChecked():
            self.prefixEdit.setEnabled(True)
            self.counterSpinBox.setEnabled(True)
            self.neverOverwriteCheckbox.setEnabled(True)
        else:
            self.prefixEdit.setEnabled(False)
            self.counterSpinBox.setEnabled(False)
            self.neverOverwriteCheckbox.setEnabled(False)

    @pyqtSlot()
    def batchChanged(self):
        aw.qmc.batchprefix = self.prefixEdit.text()
        if self.batchcheckbox.isChecked():
            aw.qmc.batchcounter = self.counterSpinBox.value()
        else:
            aw.qmc.batchcounter = -1
            aw.qmc.batchsequence = 1
        aw.qmc.neverUpdateBatchCounter = self.neverOverwriteCheckbox.isChecked()
        self.close()
        
##########################################################################
#####################  WINDOW PROPERTIES DLG  ############################
##########################################################################

class WindowsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WindowsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Axes",None))
        self.setModal(True)
        xlimitLabel = QLabel(QApplication.translate("Label", "Max",None))
        xlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None))
        ylimitLabel = QLabel(QApplication.translate("Label", "Max",None))
        ylimitLabel_min = QLabel(QApplication.translate("Label", "Min",None))
        zlimitLabel = QLabel(QApplication.translate("Label", "Max",None))
        zlimitLabel_min = QLabel(QApplication.translate("Label", "Min",None))
        self.xlimitEdit = QLineEdit()
        self.xlimitEdit.setMaximumWidth(50)
        self.xlimitEdit.setMinimumWidth(50)
        self.xlimitEdit.setAlignment(Qt.AlignRight)
        self.xlimitEdit_min = QLineEdit()
        self.xlimitEdit_min.setMaximumWidth(55)
        self.xlimitEdit_min.setMinimumWidth(55)
        self.xlimitEdit_min.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.xlimitEdit.setValidator(QRegExpValidator(regextime,self))
        self.xlimitEdit_min.setValidator(QRegExpValidator(regextime,self))
        self.ylimitEdit = QLineEdit()
        self.ylimitEdit.setMaximumWidth(60)
        self.ylimitEdit_min = QLineEdit()
        self.ylimitEdit_min.setMaximumWidth(60)
        self.ylimitEdit.setValidator(QIntValidator(aw.qmc.ylimit_min_max, aw.qmc.ylimit_max, self.ylimitEdit))
        self.ylimitEdit_min.setValidator(QIntValidator(aw.qmc.ylimit_min_max, aw.qmc.ylimit_max, self.ylimitEdit_min))
        self.ylimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.ylimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit = QLineEdit()
        self.zlimitEdit.setMaximumWidth(60)
        self.zlimitEdit_min = QLineEdit()
        self.zlimitEdit_min.setMaximumWidth(60)
        self.zlimitEdit.setValidator(QIntValidator(aw.qmc.zlimit_min_max, aw.qmc.zlimit_max, self.zlimitEdit))
        self.zlimitEdit_min.setValidator(QIntValidator(aw.qmc.zlimit_min_max, aw.qmc.zlimit_max, self.zlimitEdit_min))
        self.zlimitEdit.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zlimitEdit_min.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.xlimitEdit.setText(aw.qmc.stringfromseconds(aw.qmc.endofx))
        if aw.qmc.timeindex[0] != -1:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx - aw.qmc.timex[aw.qmc.timeindex[0]]))
        else:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx))
        self.ylimitEdit.setText(str(aw.qmc.ylimit))
        self.ylimitEdit_min.setText(str(aw.qmc.ylimit_min))
        self.zlimitEdit.setText(str(aw.qmc.zlimit))
        self.zlimitEdit_min.setText(str(aw.qmc.zlimit_min))
        self.legendComboBox = QComboBox()
        self.legendComboBox.setMaximumWidth(160)
        legendlocs = ["",#QApplication.translate("ComboBox", "none",None),
                      QApplication.translate("ComboBox", "upper right",None),
                      QApplication.translate("ComboBox", "upper left",None),
                      QApplication.translate("ComboBox", "lower left",None),
                      QApplication.translate("ComboBox", "lower right",None),
                      QApplication.translate("ComboBox", "right",None),
                      QApplication.translate("ComboBox", "center left",None),
                      QApplication.translate("ComboBox", "center right",None),
                      QApplication.translate("ComboBox", "lower center",None),
                      QApplication.translate("ComboBox", "upper center",None),
                      QApplication.translate("ComboBox", "center",None)]
        self.legendComboBox.addItems(legendlocs)
        self.legendComboBox.setCurrentIndex(aw.qmc.legendloc)
        self.legendComboBox.currentIndexChanged.connect(self.changelegendloc)
        resettimelabel = QLabel(QApplication.translate("Label", "Max",None))
        self.resetEdit = QLineEdit()
        self.resetEdit.setMaximumWidth(50)
        self.resetEdit.setMinimumWidth(50)
        self.resetEdit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.resetEdit.setValidator(QRegExpValidator(regextime,self))
        self.resetEdit.setText(aw.qmc.stringfromseconds(aw.qmc.resetmaxtime))
        self.resetEdit.setToolTip(QApplication.translate("Tooltip", "Time axis max on RESET", None))
        # CHARGE min
        chargeminlabel = QLabel(QApplication.translate("Label", "RESET",None) + " " + QApplication.translate("Label", "Min",None))
        self.chargeminEdit = QLineEdit()
        self.chargeminEdit.setMaximumWidth(50)
        self.chargeminEdit.setMinimumWidth(50)
        self.chargeminEdit.setAlignment(Qt.AlignRight)
        self.chargeminEdit.setValidator(QRegExpValidator(regextime,self))
        self.chargeminEdit.setText(aw.qmc.stringfromseconds(aw.qmc.chargemintime))
        self.chargeminEdit.setToolTip(QApplication.translate("Tooltip", "Time axis min on RESET", None))
        
        # fixmaxtime flag
        self.fixmaxtimeFlag = QCheckBox(QApplication.translate("CheckBox", "Expand",None))
        self.fixmaxtimeFlag.setChecked(not aw.qmc.fixmaxtime)
        self.fixmaxtimeFlag.setToolTip(QApplication.translate("Tooltip", "Automatically extend the time axis by 3min on need", None))
        # locktimex flag
        self.locktimexFlag = QCheckBox(QApplication.translate("CheckBox", "Lock",None))
        self.locktimexFlag.setChecked(aw.qmc.locktimex)
        self.locktimexFlag.setToolTip(QApplication.translate("Tooltip", "Do not set time axis min and max from profile on load", None))
        # locktimex flag
        self.autotimexFlag = QCheckBox(QApplication.translate("CheckBox", "Auto",None))
        self.autotimexFlag.setChecked(aw.qmc.autotimex)
        self.autotimexFlag.stateChanged.connect(self.autoTimexFlagChanged)
        self.locktimexFlag.stateChanged.connect(self.lockTimexFlagChanged)
        self.autotimexFlag.setToolTip(QApplication.translate("Tooltip", "Automatically set time axis min and max from profile CHARGE/DROP events", None))
        autoButton = QPushButton(QApplication.translate("Button","Calc",None))
        autoButton.setFocusPolicy(Qt.NoFocus)
        autoButton.clicked.connect(self.autoAxis)
        # time axis steps
        timegridlabel = QLabel(QApplication.translate("Label", "Step",None))
        self.xaxislencombobox = QComboBox()
        timelocs =   [
                    #QApplication.translate("ComboBox", "30 seconds",None),
                      QApplication.translate("ComboBox", "1 minute",None),
                      QApplication.translate("ComboBox", "2 minutes",None),
                      QApplication.translate("ComboBox", "3 minutes",None),
                      QApplication.translate("ComboBox", "4 minutes",None),
                      QApplication.translate("ComboBox", "5 minutes",None),
                      QApplication.translate("ComboBox", "10 minutes",None),
                      QApplication.translate("ComboBox", "30 minutes",None),
                      QApplication.translate("ComboBox", "1 hour",None)]
        self.xaxislencombobox.addItems(timelocs)
        
        self.xaxislencombobox.setMinimumContentsLength(6)
        width = self.xaxislencombobox.minimumSizeHint().width()
        self.xaxislencombobox.setMinimumWidth(width)
        if platf == 'Darwin':
            self.xaxislencombobox.setMaximumWidth(width)
#        self.xaxislencombobox.setMaximumWidth(120)
        
        self.timeconversion = [60,120,180,240,300,600,1800,3600]
        try:
            self.xaxislencombobox.setCurrentIndex(self.timeconversion.index(aw.qmc.xgrid))
        except Exception:
            self.xaxislencombobox.setCurrentIndex(0)
        self.xaxislencombobox.currentIndexChanged.connect(self.xaxislenloc)
        self.timeGridCheckBox = QCheckBox(QApplication.translate("CheckBox","Time",None))
        self.timeGridCheckBox.setChecked(aw.qmc.time_grid)
        self.timeGridCheckBox.setToolTip(QApplication.translate("Tooltip", "Show time grid", None))
        self.timeGridCheckBox.setFocusPolicy(Qt.NoFocus)
        self.tempGridCheckBox = QCheckBox(QApplication.translate("CheckBox","Temp",None))
        self.tempGridCheckBox.setToolTip(QApplication.translate("Tooltip", "Show temperature grid", None))
        self.tempGridCheckBox.setChecked(aw.qmc.temp_grid)
        self.tempGridCheckBox.setFocusPolicy(Qt.NoFocus)
        ygridlabel = QLabel(QApplication.translate("Label", "Step",None))
        self.ygridSpinBox = QSpinBox()
        self.ygridSpinBox.setRange(10,500)
        self.ygridSpinBox.setSingleStep(5)
        self.ygridSpinBox.setValue(aw.qmc.ygrid)
        self.ygridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.ygridSpinBox.valueChanged.connect(self.changeygrid)
        self.ygridSpinBox.setMaximumWidth(60)
        zgridlabel = QLabel(QApplication.translate("Label", "Step",None))
        self.zgridSpinBox = QSpinBox()
        self.zgridSpinBox.setRange(1,100)
        self.zgridSpinBox.setSingleStep(5)
        self.zgridSpinBox.setValue(aw.qmc.zgrid)
        self.zgridSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.zgridSpinBox.valueChanged.connect(self.changezgrid)
        self.zgridSpinBox.setMaximumWidth(60)
        linestylegridlabel = QLabel(QApplication.translate("Label", "Style",None))
        self.gridstylecombobox = QComboBox()
        gridstyles = [QApplication.translate("ComboBox", "solid",None),
                      QApplication.translate("ComboBox", "dashed",None),
                      QApplication.translate("ComboBox", "dashed-dot",None),
                      QApplication.translate("ComboBox", "dotted",None),
                      QApplication.translate("ComboBox", "None",None)]
        self.gridstylecombobox.addItems(gridstyles) 
        self.gridstylecombobox.setCurrentIndex(aw.qmc.gridlinestyle)
        self.gridstylecombobox.currentIndexChanged.connect(self.changegridstyle)
        gridthicknesslabel = QLabel(QApplication.translate("Label", "Width",None))
        self.gridwidthSpinBox = QSpinBox()
        self.gridwidthSpinBox.setRange(1,5)
        self.gridwidthSpinBox.setValue(aw.qmc.gridthickness)
        self.gridwidthSpinBox.valueChanged.connect(self.changegridwidth)
        self.gridwidthSpinBox.setMaximumWidth(40)
        self.gridwidthSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        gridalphalabel = QLabel(QApplication.translate("Label", "Opaqueness",None))
        self.gridalphaSpinBox = QSpinBox()
        self.gridalphaSpinBox.setRange(1,5)
        self.gridalphaSpinBox.setValue(int(aw.qmc.gridalpha*10))
        self.gridalphaSpinBox.valueChanged.connect(self.changegridalpha)
        self.gridalphaSpinBox.setMaximumWidth(40)
        self.gridalphaSpinBox.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.updatewindow)
        self.dialogbuttons.rejected.connect(self.close)
        
        resetButton = self.dialogbuttons.addButton(QDialogButtonBox.RestoreDefaults)
        resetButton.clicked.connect(self.reset)
        if aw.locale not in aw.qtbase_locales:
            resetButton.setText(QApplication.translate("Button","Defaults", None))
            
        self.loadAxisFromProfile = QCheckBox(QApplication.translate("CheckBox", "Load from profile",None))
        self.loadAxisFromProfile.setChecked(aw.qmc.loadaxisfromprofile)
        
        hline = QFrame()
        hline.setFrameShape(QFrame.HLine)
        hline.setFrameShadow(QFrame.Sunken)
        
        
        xlayout1 = QHBoxLayout()
        xlayout1.addWidget(self.autotimexFlag)
        xlayout1.addWidget(autoButton)
        xlayout1.addStretch()
        xlayout1.addWidget(self.locktimexFlag)
        xlayout2 = QHBoxLayout()
        xlayout2.addWidget(xlimitLabel_min)
        xlayout2.addWidget(self.xlimitEdit_min)
        xlayout2.addSpacing(10)
        xlayout2.addWidget(xlimitLabel)
        xlayout2.addWidget(self.xlimitEdit)
        xlayout2.addStretch()
        xlayout2.addWidget(timegridlabel)
        xlayout2.addWidget(self.xaxislencombobox)
        xlayout3 = QHBoxLayout()
        xlayout3.addWidget(chargeminlabel)
        xlayout3.addWidget(self.chargeminEdit)
        xlayout3.addSpacing(7)
        xlayout3.addWidget(resettimelabel)
        xlayout3.addWidget(self.resetEdit)
        xlayout3.addSpacing(7)
        xlayout3.addStretch()
        xlayout3.addWidget(self.fixmaxtimeFlag)
        xlayout = QVBoxLayout()
        xlayout.addLayout(xlayout1)
        xlayout.addLayout(xlayout2) 
        xlayout.addWidget(hline)
        xlayout.addLayout(xlayout3)
        ylayout = QGridLayout()
        ylayout.addWidget(ylimitLabel_min,0,0,Qt.AlignRight)
        ylayout.addWidget(self.ylimitEdit_min,0,1)
        ylayout.addWidget(ylimitLabel,0,3,Qt.AlignRight)
        ylayout.addWidget(self.ylimitEdit,0,4)
        ylayout.addWidget(ygridlabel,0,6,Qt.AlignRight)
        ylayout.addWidget(self.ygridSpinBox,0,7)
        ylayout.setColumnMinimumWidth(2,10)
        ylayout.setColumnMinimumWidth(5,10)
        ylayoutHbox = QHBoxLayout()
        ylayoutHbox.addStretch()
        ylayoutHbox.addLayout(ylayout)
        ylayoutHbox.addStretch()
        zlayout = QGridLayout()
        zlayout.addWidget(zlimitLabel_min,0,0,Qt.AlignRight)
        zlayout.addWidget(self.zlimitEdit_min,0,1)
        zlayout.addWidget(zlimitLabel,0,3,Qt.AlignRight)
        zlayout.addWidget(self.zlimitEdit,0,4)
        zlayout.addWidget(zgridlabel,0,6,Qt.AlignRight)
        zlayout.addWidget(self.zgridSpinBox,0,7)
        zlayout.setColumnMinimumWidth(2,10)
        zlayout.setColumnMinimumWidth(5,10)
        zlayoutHbox = QHBoxLayout()
        zlayoutHbox.addStretch()
        zlayoutHbox.addLayout(zlayout)
        zlayoutHbox.addStretch()
        legentlayout = QHBoxLayout()
        legentlayout.addStretch()
        legentlayout.addWidget(self.legendComboBox,0,Qt.AlignLeft)
        legentlayout.addStretch()
        graphgridlayout = QGridLayout()
        graphgridlayout.addWidget(linestylegridlabel,1,0,Qt.AlignRight)
        graphgridlayout.addWidget(self.gridstylecombobox,1,1,Qt.AlignLeft)
        graphgridlayout.addWidget(gridthicknesslabel,1,2,Qt.AlignRight)
        graphgridlayout.addWidget(self.gridwidthSpinBox,1,3,Qt.AlignLeft)
        graphgridlayout.addWidget(self.timeGridCheckBox,2,0,Qt.AlignLeft)
        graphgridlayout.addWidget(self.tempGridCheckBox,2,1,Qt.AlignLeft)
        graphgridlayout.addWidget(gridalphalabel,2,2,Qt.AlignRight)
        graphgridlayout.addWidget(self.gridalphaSpinBox,2,3,Qt.AlignLeft)
        xGroupLayout = QGroupBox(QApplication.translate("GroupBox","Time Axis",None))
        xGroupLayout.setLayout(xlayout)
        yGroupLayout = QGroupBox(QApplication.translate("GroupBox","Temperature Axis",None))
        yGroupLayout.setLayout(ylayoutHbox)
        zGroupLayout = QGroupBox(deltaLabelUTF8 + " " + QApplication.translate("GroupBox","Axis",None))
        zGroupLayout.setLayout(zlayoutHbox)
        legendLayout = QGroupBox(QApplication.translate("GroupBox","Legend Location",None))
        legendLayout.setLayout(legentlayout)
        GridGroupLayout = QGroupBox(QApplication.translate("GroupBox","Grid",None))
        GridGroupLayout.setLayout(graphgridlayout)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(self.loadAxisFromProfile)
        buttonLayout.addSpacing(10)
        buttonLayout.addWidget(self.dialogbuttons)
        mainLayout1 = QVBoxLayout()
        mainLayout1.addWidget(xGroupLayout)
        mainLayout1.addWidget(yGroupLayout)
        mainLayout1.addStretch()
        mainLayout2 = QVBoxLayout()
        mainLayout2.addWidget(legendLayout)
        mainLayout2.addWidget(GridGroupLayout)
        mainLayout2.addWidget(zGroupLayout)
        mainLayout2.addStretch()
        mainHLayout = QHBoxLayout()
        mainHLayout.addLayout(mainLayout1)
        mainHLayout.addLayout(mainLayout2)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(mainHLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
        
        if aw.qmc.locktimex:
            self.disableXAxisControls()
        else:
            self.enableXAxisControls()
            
            
    def enableXAxisControls(self):
        self.xlimitEdit.setEnabled(True)
        self.xlimitEdit_min.setEnabled(True)
        self.chargeminEdit.setEnabled(True)
        self.resetEdit.setEnabled(True)
        self.fixmaxtimeFlag.setEnabled(True)
    
    def disableXAxisControls(self):
        self.xlimitEdit.setEnabled(False)
        self.xlimitEdit_min.setEnabled(False)
        self.chargeminEdit.setEnabled(False)
        self.resetEdit.setEnabled(False)
        self.fixmaxtimeFlag.setEnabled(False)
        
    @pyqtSlot(int)
    def lockTimexFlagChanged(self,n):
        if n:
            self.autotimexFlag.setChecked(False)
            self.disableXAxisControls()
        else:
            self.enableXAxisControls()
    
    @pyqtSlot(int)
    def autoTimexFlagChanged(self,n):
        if n:
            self.locktimexFlag.setChecked(False) 
            self.enableXAxisControls()
            self.autoAxis()

    @pyqtSlot(bool)
    def autoAxis(self,_=False):
        if aw.qmc.backgroundpath and not aw.curFile:
            t_min,t_max = aw.calcAutoAxisBackground()
        else:
            t_min,t_max = aw.calcAutoAxis()
            if aw.qmc.backgroundpath:
                _,t_max_b = aw.calcAutoAxisBackground()
                t_max = max(t_max,t_max_b - aw.qmc.timeB[aw.qmc.timeindexB[0]])
        if aw.qmc.timeindex[0] != -1:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(t_min - aw.qmc.timex[aw.qmc.timeindex[0]]))
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(t_max - aw.qmc.timex[aw.qmc.timeindex[0]]))
        else:
            self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(t_min))
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(t_max))
        self.xlimitEdit_min.repaint()
        self.xlimitEdit.repaint()
        
    def changexrotation(self):
        aw.qmc.xrotation = self.xrotationSpinBox.value()
        self.xrotationSpinBox.setDisabled(True)
        aw.qmc.xaxistosm(redraw=False)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.xrotationSpinBox.setDisabled(False)
        self.xrotationSpinBox.setFocus()

    @pyqtSlot(int)
    def changegridalpha(self,_):
        aw.qmc.gridalpha = self.gridalphaSpinBox.value()/10.
        self.gridalphaSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.gridalphaSpinBox.setDisabled(False)
        self.gridalphaSpinBox.setFocus()

    @pyqtSlot(int)
    def changegridwidth(self,_):
        aw.qmc.gridthickness = self.gridwidthSpinBox.value()
        self.gridwidthSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.gridwidthSpinBox.setDisabled(False)
        self.gridwidthSpinBox.setFocus()

    @pyqtSlot(int)
    def changegridstyle(self,_):
        aw.qmc.gridlinestyle = self.gridstylecombobox.currentIndex()
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def changelegendloc(self,_):
        aw.qmc.legendloc = self.legendComboBox.currentIndex()
        aw.qmc.legend = None
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def xaxislenloc(self,_):
        aw.qmc.xgrid = self.timeconversion[self.xaxislencombobox.currentIndex()]
        aw.qmc.xaxistosm(redraw=False)
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def changeygrid(self,_):
        aw.qmc.ygrid = self.ygridSpinBox.value()
        self.ygridSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.ygridSpinBox.setDisabled(False)
        self.ygridSpinBox.setFocus()

    @pyqtSlot(int)
    def changezgrid(self,_):
        aw.qmc.zgrid = self.zgridSpinBox.value()
        self.zgridSpinBox.setDisabled(True)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.zgridSpinBox.setDisabled(False)
        self.zgridSpinBox.setFocus()

    # exit dialog with OK
    @pyqtSlot()
    def updatewindow(self):
        limits_changed = False
        aw.qmc.time_grid = self.timeGridCheckBox.isChecked()
        aw.qmc.temp_grid = self.tempGridCheckBox.isChecked()
        aw.qmc.loadaxisfromprofile = self.loadAxisFromProfile.isChecked()
        try:
            yl = int(str(self.ylimitEdit.text()))
            yl_min = int(str(self.ylimitEdit_min.text()))
            if yl > yl_min:
                if (aw.qmc.ylimit != yl) or (aw.qmc.ylimit_min != yl_min):
                    limits_changed = True
                aw.qmc.ylimit = yl
                aw.qmc.ylimit_min = yl_min
        except:
            pass
        try:
            zl = int(str(self.zlimitEdit.text()))
            zl_min = int(str(self.zlimitEdit_min.text()))
            if (aw.qmc.zlimit != zl) or (aw.qmc.zlimit_min != zl_min):
                limits_changed = True
            if zl > zl_min:
                aw.qmc.zlimit = zl
                aw.qmc.zlimit_min = zl_min
        except:
            pass
            
        if limits_changed and aw.qmc.crossmarker == True:
            # switch crosslines off and on again to adjust for changed axis limits
            aw.qmc.togglecrosslines()
            aw.qmc.togglecrosslines()
            
        
        endedittime_str = str(self.xlimitEdit.text())
        if endedittime_str is not None and endedittime_str != "":
            endeditime = aw.qmc.stringtoseconds(endedittime_str)
            aw.qmc.endofx = endeditime
            aw.qmc.locktimex_end = endeditime
        else:
            aw.qmc.endofx = aw.qmc.endofx_default
            aw.qmc.locktimex_end = aw.qmc.endofx_default
        
        startedittime_str = str(self.xlimitEdit_min.text())        
        if startedittime_str is not None and startedittime_str != "":
            starteditime = aw.qmc.stringtoseconds(startedittime_str)
            if starteditime >= 0 and aw.qmc.timeindex[0] != -1:
                aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]] + starteditime
            elif starteditime >= 0 and aw.qmc.timeindex[0] == -1:
                aw.qmc.startofx = starteditime
            elif starteditime < 0 and aw.qmc.timeindex[0] != -1:
                aw.qmc.startofx = aw.qmc.timex[aw.qmc.timeindex[0]]-abs(starteditime)
            else:
                aw.qmc.startofx = starteditime
            aw.qmc.locktimex_start = starteditime
        else:
            aw.qmc.startofx = aw.qmc.startofx_default
            aw.qmc.locktimex_start = aw.qmc.startofx_default
            
        resettime = aw.qmc.stringtoseconds(str(self.resetEdit.text()))
        if resettime > 0:
            aw.qmc.resetmaxtime = resettime
            
        chargetime = aw.qmc.stringtoseconds(str(self.chargeminEdit.text()))
        if chargetime <= 0:
            aw.qmc.chargemintime = chargetime
            
        aw.qmc.fixmaxtime = not self.fixmaxtimeFlag.isChecked()
        aw.qmc.locktimex = self.locktimexFlag.isChecked()
        aw.qmc.autotimex = self.autotimexFlag.isChecked()
        aw.qmc.redraw(recomputeAllDeltas=False)
        string = QApplication.translate("Message","xlimit = ({2},{3}) ylimit = ({0},{1}) zlimit = ({4},{5})",None).format(str(self.ylimitEdit_min.text()),str(self.ylimitEdit.text()),str(self.xlimitEdit_min.text()),str(self.xlimitEdit.text()),str(self.zlimitEdit_min.text()),str(self.zlimitEdit.text()))                                   
        aw.sendmessage(string)
        self.close()

    @pyqtSlot(bool)
    def reset(self,_):
        if len(aw.qmc.timex) > 1:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(int(aw.qmc.timex[-1])))
        else:
            self.xlimitEdit.setText(aw.qmc.stringfromseconds(aw.qmc.endofx_default))
        self.xlimitEdit_min.setText(aw.qmc.stringfromseconds(aw.qmc.startofx_default))
        if aw.qmc.mode == "F":
            self.ylimitEdit.setText(str(aw.qmc.ylimit_F_default))
            self.ylimitEdit_min.setText(str(aw.qmc.ylimit_min_F_default))
            self.zlimitEdit.setText(str(aw.qmc.zlimit_F_default))
            self.zlimitEdit_min.setText(str(aw.qmc.zlimit_min_F_default))
        else:
            self.ylimitEdit.setText(str(aw.qmc.ylimit_C_default))
            self.ylimitEdit_min.setText(str(aw.qmc.ylimit_min_C_default))
            self.zlimitEdit.setText(str(aw.qmc.zlimit_C_default))
            self.zlimitEdit_min.setText(str(aw.qmc.zlimit_min_C_default))

##########################################################################
#####################  ROAST CALCULATOR DLG   ############################
##########################################################################

class calculatorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(calculatorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Calculator",None))
        
        settings = QSettings()
        if settings.contains("CalculatorGeometry"):
            self.restoreGeometry(settings.value("CalculatorGeometry"))
            
        #RATE OF CHANGE
        self.result1 = QLabel(QApplication.translate("Label", "Enter two times along profile",None))
        self.result2 = QLabel()
        self.result2.setStyleSheet("background-color:'lightgrey';")
        startlabel = QLabel(QApplication.translate("Label", "Start (00:00)",None))
        endlabel = QLabel(QApplication.translate("Label", "End (00:00)",None))
        self.startEdit = QLineEdit()
        self.endEdit = QLineEdit()
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        self.startEdit.setValidator(QRegExpValidator(regextime,self))
        self.endEdit.setValidator(QRegExpValidator(regextime,self))
        self.startEdit.editingFinished.connect(self.calculateRC)
        self.endEdit.editingFinished.connect(self.calculateRC)
        nevents = len(aw.qmc.specialevents)
        events_found = [QApplication.translate("ComboBox","Event #0",None)]
        for i in range(nevents):
            events_found.append(QApplication.translate("ComboBox","Event #{0}",None).format(str(i+1)))
        self.eventAComboBox = QComboBox()
        self.eventAComboBox.addItems(events_found)
        self.eventAComboBox.currentIndexChanged.connect(self.calcEventRC)
        self.eventBComboBox = QComboBox()
        self.eventBComboBox.addItems(events_found)
        self.eventBComboBox.currentIndexChanged.connect(self.calcEventRC)
        #TEMPERATURE CONVERSION
        flabel = QLabel(QApplication.translate("Label", "Fahrenheit",None))
        clabel = QLabel(QApplication.translate("Label", "Celsius",None))
        self.faEdit = QLineEdit()
        self.ceEdit = QLineEdit()
        self.faEdit.setValidator(aw.createCLocaleDoubleValidator(-999999., 9999999., 2, self.faEdit))
        self.ceEdit.setValidator(aw.createCLocaleDoubleValidator(-999999., 9999999., 2, self.ceEdit))
        self.faEdit.editingFinished.connect(self.convertTempFtoC)
        self.ceEdit.editingFinished.connect(self.convertTempCtoF)
        #WEIGHT CONVERSION
        self.WinComboBox = QComboBox()
        self.WinComboBox.addItems(aw.qmc.weight_units)
        self.WinComboBox.setMaximumWidth(80)
        self.WinComboBox.setMinimumWidth(80)
        self.WoutComboBox = QComboBox()
        self.WoutComboBox.setMaximumWidth(80)
        self.WoutComboBox.setMinimumWidth(80)
        self.WoutComboBox.addItems(aw.qmc.weight_units)
        self.WoutComboBox.setCurrentIndex(2)
        self.WinEdit = QLineEdit()
        self.WoutEdit = QLineEdit()
        self.WinEdit.setMaximumWidth(70)
        self.WoutEdit.setMaximumWidth(70)
        #self.WinEdit.setMinimumWidth(60)
        #self.WoutEdit.setMinimumWidth(60)
        self.WinEdit.setValidator(aw.createCLocaleDoubleValidator(0., 99999., 4, self.WinEdit))
        self.WoutEdit.setValidator(aw.createCLocaleDoubleValidator(0., 99999., 4, self.WoutEdit))
        self.WinEdit.editingFinished.connect(self.convertWeightItoO)
        self.WoutEdit.editingFinished.connect(self.convertWeightOtoI)
        #VOLUME CONVERSION
        self.VinComboBox = QComboBox()
        volumeunits = [QApplication.translate("ComboBox","liter",None),
                       QApplication.translate("ComboBox","gallon",None),
                       QApplication.translate("ComboBox","quart",None),
                       QApplication.translate("ComboBox","pint",None),
                       QApplication.translate("ComboBox","cup",None),
                       QApplication.translate("ComboBox","cm^3",None)]
        self.VinComboBox.addItems(volumeunits)
        self.VinComboBox.setMaximumWidth(80)
        self.VinComboBox.setMinimumWidth(80)
        self.VoutComboBox = QComboBox()
        self.VoutComboBox.setMaximumWidth(80)
        self.VoutComboBox.setMinimumWidth(80)
        self.VoutComboBox.addItems(volumeunits)
        self.VoutComboBox.setCurrentIndex(4)
        self.VinEdit = QLineEdit()
        self.VoutEdit = QLineEdit()
        self.VinEdit.setMaximumWidth(70)
        self.VoutEdit.setMaximumWidth(70)
        #self.VinEdit.setMinimumWidth(60)
        #self.VoutEdit.setMinimumWidth(60)
        self.VinEdit.setValidator(aw.createCLocaleDoubleValidator(0., 99999., 4, self.VinEdit))
        self.VoutEdit.setValidator(aw.createCLocaleDoubleValidator(0., 99999., 4, self.VoutEdit))
        self.VinEdit.editingFinished.connect(self.convertVolumeItoO)
        self.VoutEdit.editingFinished.connect(self.convertVolumeOtoI)
        #EXTRACTION YIELD
        yieldlabel = QLabel(QApplication.translate("Label", "Yield (%)",None))
        groundslabel = QLabel(QApplication.translate("Label", "Grounds (g)",None))
        tdslabel = QLabel(QApplication.translate("Label", "TDS (%)",None))
        coffeelabel = QLabel(QApplication.translate("Label", "Coffee (g)",None))
        self.groundsEdit = QLineEdit()
        self.coffeeEdit = QLineEdit()
        self.tdsEdit = QLineEdit()
        self.yieldEdit = QLineEdit()
        self.yieldEdit.setReadOnly(True)
        self.groundsEdit.setValidator(aw.createCLocaleDoubleValidator(1., 999999., 2, self.groundsEdit))
        self.coffeeEdit.setValidator(aw.createCLocaleDoubleValidator(1., 999999., 2, self.coffeeEdit))
        self.tdsEdit.setValidator(aw.createCLocaleDoubleValidator(0., 100., 2, self.tdsEdit))
        for e in [self.groundsEdit, self.coffeeEdit, self.tdsEdit]:
            e.editingFinished.connect(self.calculateYield)
        #LAYOUTS
        #Rate of chage
        calrcLayout = QGridLayout()
        calrcLayout.addWidget(startlabel,0,0)
        calrcLayout.addWidget(endlabel,0,1)
        calrcLayout.addWidget(self.startEdit,1,0)
        calrcLayout.addWidget(self.endEdit,1,1)
        calrcLayout.addWidget(self.eventAComboBox ,2,0)
        calrcLayout.addWidget(self.eventBComboBox ,2,1)
        rclayout = QVBoxLayout()
        rclayout.addWidget(self.result1,0)
        rclayout.addWidget(self.result2,1)
        rclayout.addLayout(calrcLayout,2)
        #temperature conversion
        tempLayout = QGridLayout()
        tempLayout.addWidget(flabel,0,0)
        tempLayout.addWidget(clabel,0,1)
        tempLayout.addWidget(self.faEdit,1,0)
        tempLayout.addWidget(self.ceEdit,1,1)
        #weight conversions
        weightLayout = QHBoxLayout()
        weightLayout.addWidget(self.WinComboBox)
        weightLayout.addWidget(self.WinEdit)
        weightLayout.addWidget(self.WoutEdit)
        weightLayout.addWidget(self.WoutComboBox)
        #volume conversions
        volumeLayout = QHBoxLayout()
        volumeLayout.addWidget(self.VinComboBox)
        volumeLayout.addWidget(self.VinEdit)
        volumeLayout.addWidget(self.VoutEdit)
        volumeLayout.addWidget(self.VoutComboBox)
        #extraction yield
        extractionLayout = QGridLayout()
        extractionLayout.addWidget(groundslabel,0,0)
        extractionLayout.addWidget(self.groundsEdit,1,0)
        extractionLayout.addWidget(coffeelabel,0,1)
        extractionLayout.addWidget(self.coffeeEdit,1,1)
        extractionLayout.addWidget(tdslabel,0,2)
        extractionLayout.addWidget(self.tdsEdit,1,2)
        extractionLayout.addWidget(yieldlabel,0,3)
        extractionLayout.addWidget(self.yieldEdit,1,3)
        
        RoCGroup = QGroupBox(QApplication.translate("GroupBox","Rate of Change",None))
        RoCGroup.setLayout(rclayout)
        tempConvGroup = QGroupBox(QApplication.translate("GroupBox","Temperature Conversion",None))
        tempConvGroup.setLayout(tempLayout)
        weightConvGroup = QGroupBox(QApplication.translate("GroupBox","Weight Conversion",None))
        weightConvGroup.setLayout(weightLayout)
        volumeConvGroup = QGroupBox(QApplication.translate("GroupBox","Volume Conversion",None))
        volumeConvGroup.setLayout(volumeLayout)
        extractionYieldGroup = QGroupBox(QApplication.translate("GroupBox","Extraction Yield",None))
        extractionYieldGroup.setLayout(extractionLayout)
        #left side
        leftSide = QVBoxLayout()
        leftSide.addWidget(RoCGroup)
        #right side
        rightSide = QVBoxLayout()
        rightSide.addWidget(tempConvGroup)
        rightSide.addWidget(extractionYieldGroup)
        #rightSide.addStretch()
        topLayout = QHBoxLayout()
        topLayout.addLayout(leftSide)
        topLayout.addLayout(rightSide)
        botLayout = QHBoxLayout()
        botLayout.addWidget(weightConvGroup)
        botLayout.addWidget(volumeConvGroup)
        #main
        mainlayout = QVBoxLayout()
        mainlayout.addLayout(topLayout)
        mainlayout.addLayout(botLayout)
        self.setLayout(mainlayout)

    @pyqtSlot(int)
    def calcEventRC(self,_):
        nevents = len(aw.qmc.specialevents)
        Aevent = int(self.eventAComboBox.currentIndex())
        Bevent = int(self.eventBComboBox.currentIndex())
        if Aevent <= nevents and Bevent <= nevents and Aevent and Bevent:
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            self.startEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Aevent-1]] - start))
            self.endEdit.setText(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.specialevents[Bevent-1]] - start))
            self.calculateRC()

    #calculate rate of change
    @pyqtSlot()
    def calculateRC(self):
        if len(aw.qmc.timex)>2:
            if not len(self.startEdit.text()) or not len(self.endEdit.text()):
                #empty field
                return
            starttime = aw.qmc.stringtoseconds(str(self.startEdit.text()))
            endtime = aw.qmc.stringtoseconds(str(self.endEdit.text()))
            if starttime == -1 or endtime == -1:
                self.result1.setText(QApplication.translate("Label", "Time syntax error. Time not valid",None))
                self.result2.setText("")
                return
            if  endtime > aw.qmc.timex[-1] or endtime < starttime:
                self.result1.setText(QApplication.translate("Label", "Error: End time smaller than Start time",None))
                self.result2.setText("")
                return
            if aw.qmc.timeindex[0] != -1:
                start = aw.qmc.timex[aw.qmc.timeindex[0]]
            else:
                start = 0
            startindex = aw.qmc.time2index(starttime + start)
            endindex = aw.qmc.time2index(endtime + start)
            #delta
            deltatime = aw.qmc.timex[endindex] -  aw.qmc.timex[startindex]
            deltatemperature = aw.qmc.temp2[endindex] - aw.qmc.temp2[startindex]
            if deltatime == 0:
                deltaseconds = 0
            else:
                deltaseconds = deltatemperature/deltatime
            deltaminutes = deltaseconds*60.
            string1 = QApplication.translate("Label", "Best approximation was made from {0} to {1}",None).format(aw.qmc.stringfromseconds(aw.qmc.timex[startindex]- start),aw.qmc.stringfromseconds(aw.qmc.timex[endindex]- start))
            string2 = QApplication.translate("Label", "<b>{0}</b> {1}/sec, <b>{2}</b> {3}/min",None).format("%.2f"%(deltaseconds),aw.qmc.mode,"%.2f"%(deltaminutes),aw.qmc.mode)
            self.result1.setText(string1)
            self.result2.setText(string2)
        else:
            self.result1.setText(QApplication.translate("Label", "No profile found",None))
            self.result2.setText("")

    @pyqtSlot()
    def convertTempFtoC(self):
        self.convertTemp("FtoC")
    
    @pyqtSlot()
    def convertTempCtoF(self):
        self.convertTemp("CtoF")
    
    def convertTemp(self,x):
        self.faEdit.setText(aw.comma2dot(str(self.faEdit.text())))
        self.ceEdit.setText(aw.comma2dot(str(self.ceEdit.text())))
        if x == "FtoC":
            newC = aw.qmc.fromFtoC(float(str(self.faEdit.text())))
            result = "%.2f"%newC
            self.ceEdit.setText(result)
        elif x == "CtoF":
            newF = aw.qmc.fromCtoF(float(str(self.ceEdit.text())))
            result = "%.2f"%newF
            self.faEdit.setText(result)

    @pyqtSlot()
    def convertWeightItoO(self):
        self.WinEdit.setText(aw.comma2dot(str(self.WinEdit.text())))
        inx = float(str(self.WinEdit.text()))
        outx = aw.convertWeight(inx,self.WinComboBox.currentIndex(),self.WoutComboBox.currentIndex())
        self.WoutEdit.setText("%.2f"%outx)

    @pyqtSlot()
    def convertWeightOtoI(self):
        self.WoutEdit.setText(aw.comma2dot(str(self.WoutEdit.text())))
        outx = float(str(self.WoutEdit.text()))
        inx = aw.convertWeight(outx,self.WoutComboBox.currentIndex(),self.WinComboBox.currentIndex())
        self.WinEdit.setText("%.2f"%inx)
        
    @pyqtSlot()
    def convertVolumeItoO(self):
        self.VinEdit.setText(aw.comma2dot(str(self.VinEdit.text())))
        inx = float(str(self.VinEdit.text()))
        outx = aw.convertVolume(inx,self.VinComboBox.currentIndex(),self.VoutComboBox.currentIndex())
        self.VoutEdit.setText("%.3f"%outx)
    
    @pyqtSlot()
    def convertVolumeOtoI(self):
        self.VoutEdit.setText(aw.comma2dot(str(self.VoutEdit.text())))
        outx = float(str(self.VoutEdit.text()))
        inx = aw.convertVolume(outx,self.VoutComboBox.currentIndex(),self.VinComboBox.currentIndex())
        self.VinEdit.setText("%.3f"%inx)

    @pyqtSlot()
    def calculateYield(self):
        self.groundsEdit.setText(aw.comma2dot(str(self.groundsEdit.text())))
        self.tdsEdit.setText(aw.comma2dot(str(self.tdsEdit.text())))
        self.coffeeEdit.setText(aw.comma2dot(str(self.coffeeEdit.text())))
        # Extraction yield % = Brewed Coffee[g] x TDS[%] / Coffee Grounds[g]
        if self.groundsEdit.text() == "" or self.tdsEdit.text() == "" or self.coffeeEdit.text == "":
            return
        grounds = float(str(self.groundsEdit.text()))
        tds = float(str(self.tdsEdit.text()))
        coffee = float(str(self.coffeeEdit.text()))
        if grounds == 0:
            return
        cyield = coffee * tds / grounds
        self.yieldEdit.setText("%.1f" % cyield)

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("CalculatorGeometry",self.saveGeometry())

########################################################################################
######################## Profile Transformator  #######################################
########################################################################################

class profileTransformatorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(profileTransformatorDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Profile Transformator",None))
        
        self.regexpercent = QRegExp(r"^$|^?[0-9]?[0-9]?(\.[0-9])?$")
        self.regextime = QRegExp(r"^$|^?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.regextemp = QRegExp(r"^$|^?[0-9]?[0-9]?[0-9]?(\.[0-9])?$")
        
        # original data
        self.org_transMappingMode = aw.qmc.transMappingMode
        self.org_timex = aw.qmc.timex[:]
        self.org_temp2 = aw.qmc.temp2[:]
        self.org_extratimex = copy.deepcopy(aw.qmc.extratimex)
        self.org_curFile = aw.curFile
        self.org_UUID = aw.qmc.roastUUID
        self.org_roastdate = aw.qmc.roastdate
        self.org_roastepoch = aw.qmc.roastepoch
        self.org_roasttzoffset = aw.qmc.roasttzoffset
        self.org_roastbatchnr = aw.qmc.roastbatchnr
        self.org_safesaveflag = aw.qmc.safesaveflag
        self.org_l_event_flags_dict = aw.qmc.l_event_flags_dict
        self.org_l_annotations_dict = aw.qmc.l_annotations_dict
        
        self.phasestable = QTableWidget()
        self.timetable = QTableWidget()
        self.temptable = QTableWidget()
        
        # time table widgets initialized by createTimeTable() to a list (target/result) with 4 widgets each
        #   DRY, FCs, SCs, DROP
        # if an event is not set in the profile, None is set instead of a widget
        #
        self.phases_target_widgets_time = None
        self.phases_target_widgets_percent = None
        self.phases_result_widgets = None
        #
        self.time_target_widgets = None
        self.time_result_widgets = None
        
        # profileTimes: list of DRY, FCs, SCs and DROP times in seconds if event is set, otherwise None
        self.profileTimes = self.getProfileTimes()
        # list of DRY, FCs, SCs, and DROP target times in seconds as specified by the user, or None if not set
        self.targetTimes = self.getTargetTimes()
        
        # temp table widgets initialized by createTempTable() to a list (target/result) with 5 widgets each
        #   CHARGE, DRY, FCs, SCs, DROP
        # if an event is not set in the profile, None is set instead of a widget
        self.temp_target_widgets = None
        self.temp_result_widgets = None
        
        # list of CHARGE, DRY, FCs, SCs and DROP BT temperatures
        self.profileTemps = self.getProfileTemps()
        # list of DRY, FCs, SCs, and DROP target temperatures as specified by the user, or None if not set
        self.targetTemps = self.getTargetTemps()
        
        self.createPhasesTable()
        self.createTimeTable()
        self.createTempTable()
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.applyTransformations)
        self.dialogbuttons.rejected.connect(self.restoreState)
        self.applyButton = self.dialogbuttons.addButton(QDialogButtonBox.Apply)
        self.resetButton = self.dialogbuttons.addButton(QDialogButtonBox.Reset)
        self.helpButton = self.dialogbuttons.addButton(QDialogButtonBox.Help)
        self.dialogbuttons.button(QDialogButtonBox.Apply).clicked.connect(self.apply)
        self.dialogbuttons.button(QDialogButtonBox.Reset).clicked.connect(self.restore)
        self.dialogbuttons.button(QDialogButtonBox.Help).clicked.connect(self.help)
        
        #buttons
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(self.dialogbuttons)
        
        mappingLabel = QLabel(QApplication.translate("Label","Mapping",None))
        self.mappingModeComboBox = QComboBox()
        self.mappingModeComboBox.addItems([QApplication.translate("ComboBox","discrete",None),
                                              QApplication.translate("ComboBox","linear",None),
                                              QApplication.translate("ComboBox","quadratic",None)])
        self.mappingModeComboBox.setCurrentIndex(aw.qmc.transMappingMode)
        self.mappingModeComboBox.currentIndexChanged.connect(self.changeMappingMode)
        
        self.temp_formula = QLabel()
        
        settingsHLayout = QHBoxLayout()
        settingsHLayout.addStretch()
        settingsHLayout.addWidget(mappingLabel)
        settingsHLayout.addWidget(self.mappingModeComboBox)
        settingsHLayout.addStretch()
        
        phasesHLayout = QHBoxLayout()
        phasesHLayout.addStretch()
        phasesHLayout.addWidget(self.phasestable)
        phasesHLayout.addStretch()
        phasesLayout = QVBoxLayout()
        phasesLayout.addLayout(phasesHLayout)
        
        timeHLayout = QHBoxLayout()
        timeHLayout.addStretch()
        timeHLayout.addWidget(self.timetable)
        timeHLayout.addStretch()
        timeLayout = QVBoxLayout()
        timeLayout.addLayout(timeHLayout)
        timeLayout.addStretch()

        tempHLayout = QHBoxLayout()
        tempHLayout.addWidget(self.temptable)
        tempHLayout.addStretch()
        formulaHLayout = QHBoxLayout()
        formulaHLayout.addStretch()
        formulaHLayout.addWidget(self.temp_formula)
        formulaHLayout.addStretch()
        tempLayout = QVBoxLayout()
        tempLayout.addLayout(tempHLayout)
        tempLayout.addLayout(formulaHLayout)
        tempLayout.addStretch()
        
        phasesGroupLayout = QGroupBox(QApplication.translate("Table","Phases",None))
        phasesGroupLayout.setLayout(phasesLayout)
        timeGroupLayout = QGroupBox(QApplication.translate("Table","Time",None))
        timeGroupLayout.setLayout(timeLayout)
        tempGroupLayout = QGroupBox(QApplication.translate("Table","BT",None))
        tempGroupLayout.setLayout(tempLayout)
        
        #main
        mainlayout = QVBoxLayout()
        mainlayout.addLayout(settingsHLayout)
        mainlayout.addWidget(phasesGroupLayout)
        mainlayout.addWidget(timeGroupLayout)
        mainlayout.addWidget(tempGroupLayout)
        mainlayout.addStretch()
        mainlayout.addLayout(buttonsLayout)
        
        self.setLayout(mainlayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

        settings = QSettings()
        if settings.contains("TransformatorPosition"):
            self.move(settings.value("TransformatorPosition"))
        
        mainlayout.setSizeConstraint(QLayout.SetFixedSize)


    # utility functions
    
    def forgroundOffset(self):
        if aw.qmc.timeindex[0] == -1:
            return 0
        else:
            return self.org_timex[aw.qmc.timeindex[0]]
    
    def backgroundOffset(self):
        if aw.qmc.timeindexB[0] != -1 and len(aw.qmc.timeB) > aw.qmc.timeindexB[0]:
            return aw.qmc.timeB[aw.qmc.timeindexB[0]]
        else:
            return 0
    
    def clearPhasesTargetTimes(self):
        for i in range(3):
            if self.phases_target_widgets_time[i] is not None:
                self.phases_target_widgets_time[i].setText("")
    
    def clearPhasesTargetPercent(self):
        for i in range(3):
            if self.phases_target_widgets_percent[i] is not None:
                self.phases_target_widgets_percent[i].setText("")
    
    def clearPhasesResults(self):
        for i in range(3):
            if self.phases_result_widgets[i] is not None:
                self.phases_result_widgets[i].setText("")
    
    def clearTimeTargets(self):
        for i in range(4):
            if self.time_target_widgets[i] is not None:
                self.time_target_widgets[i].setText("")
    
    def clearTimeResults(self):
        for i in range(4):
            if self.time_result_widgets[i] is not None:
                self.time_result_widgets[i].setText("")
    
    def clearTempTargets(self):
        for i in range(5):
            if self.temp_target_widgets[i] is not None:
                self.temp_target_widgets[i].setText("")
    
    def clearTempResults(self):
        for i in range(5):
            if self.temp_result_widgets[i] is not None:
                self.temp_result_widgets[i].setText("")

    # returns list of DRY, FCs, SCs and DROP profile times in seconds if event is set, otherwise None
    def getProfileTimes(self):
        offset = self.forgroundOffset()
        res = []
        for i in [1,2,4,6]:
            idx = aw.qmc.timeindex[i]
            if idx == 0 or len(aw.qmc.timex) < idx:
                res.append(None)
            else:
                res.append(aw.qmc.timex[idx] - offset)
        return res
        
    # returns list of CHARGE, DRY, FCs, SCs and DROP BT temperatures if event is set, otherwise None
    def getProfileTemps(self):
        res = []
        for i in [0,1,2,4,6]:
            idx = aw.qmc.timeindex[i]
            if idx in [-1,0] or len(aw.qmc.timex) < idx:
                res.append(None)
            elif len(aw.qmc.temp2) > idx:
                res.append(aw.qmc.temp2[idx])
            else:
                res.append(None)
        return res
    
    # returns list of DRYING, MAILARD, FINISHING target phases times in seconds as first result and phases percentages (float) as second result
    # if a phase is set not set None is returned instead of a value
    def getTargetPhases(self):
        res_times = []
        res_phases = []
        if self.phases_target_widgets_time is not None:
            for w in self.phases_target_widgets_time:
                r = None
                if w is not None:
                    txt = w.text()
                    if txt is not None and txt != "":
                        r = aw.qmc.stringtoseconds(txt)
                res_times.append(r)
        if self.phases_target_widgets_percent is not None:
            for w in self.phases_target_widgets_percent:
                r = None
                if w is not None:
                    txt = w.text()
                    if txt is not None and txt != "":
                        r = float(txt)
                res_phases.append(r)
        return res_times, res_phases

    # returns list of DRY, FCs, SCs and DROP target times in seconds if event is set, otherwise None
    def getTargetTimes(self):
        res = []
        if self.time_target_widgets is not None:
            for w in self.time_target_widgets:
                r = None
                if w is not None:
                    txt = w.text()
                    if txt is not None and txt != "":
                        r = aw.qmc.stringtoseconds(txt)
                res.append(r)
        return res

    # returns list of CHARGE, DRY, FCs, SCs and DROP BT temperatures if event is set, otherwise None
    def getTargetTemps(self):
        res = []
        if self.temp_target_widgets is not None:
            for w in self.temp_target_widgets:
                r = None
                if w is not None:
                    txt = w.text()
                    if txt is not None and txt != "":
                        r = float(txt)
                res.append(r)
        return res


    # message slots
    
    @pyqtSlot(int)
    def changeMappingMode(self,i):
        aw.qmc.transMappingMode = i
        self.updateTimeResults()
        self.updateTempResults()

    @pyqtSlot(int)
    def phasesTableColumnHeaderClicked(self,i):
        if self.phases_target_widgets_time[i] is not None and self.phases_target_widgets_percent[i] is not None:
            # clear target value i
            if self.phases_target_widgets_time[i].text() != "" or self.phases_target_widgets_percent[i].text() != "":
                self.phases_target_widgets_time[i].setText("")
                self.phases_target_widgets_percent[i].setText("")
            elif aw.qmc.background and aw.qmc.timeindexB[1]>0 and aw.qmc.timeindexB[2]>0 and aw.qmc.timeindexB[6]>0 and \
                    aw.qmc.timeindex[1]>0 and aw.qmc.timeindex[2]>0 and aw.qmc.timeindex[6]>0:
                back_offset = self.backgroundOffset()
                back_dry = aw.qmc.timeB[aw.qmc.timeindexB[1]]
                back_fcs = aw.qmc.timeB[aw.qmc.timeindexB[2]]
                back_drop = aw.qmc.timeB[aw.qmc.timeindexB[6]]
                s = 0
                if i == 0:
                    # DRYING
                    s = aw.qmc.stringfromseconds(back_dry - back_offset)
                elif i == 1:
                    # MAILARD
                    s = aw.qmc.stringfromseconds(back_fcs - back_dry)
                elif i == 2:
                    s = aw.qmc.stringfromseconds(back_drop - back_fcs)
                self.phases_target_widgets_time[i].setText(s)
            self.updateTimeResults()
    
    @pyqtSlot(int)
    def phasesTableRowHeaderClicked(self,i):
        if i == 1: # row targets
            # clear all targets and results
            # clear all targets
            self.clearPhasesTargetTimes()
            self.clearPhasesTargetPercent()
            self.clearPhasesResults()

    @pyqtSlot(int)
    def timeTableColumnHeaderClicked(self,i):
        if self.time_target_widgets[i] is not None:
            # clear target value i
            if self.time_target_widgets[i].text() != "":
                self.time_target_widgets[i].setText("")
                self.updateTimeResults()
            elif aw.qmc.background:
                timeidx = [1,2,4,6][i]
                if aw.qmc.timeindex[timeidx] and aw.qmc.timeindexB[timeidx]:
                    s = aw.qmc.stringfromseconds(aw.qmc.timeB[aw.qmc.timeindexB[timeidx]]-self.backgroundOffset(),False)
                    self.time_target_widgets[i].setText(s)
                    self.updateTimeResults()

    @pyqtSlot(int)
    def timeTableRowHeaderClicked(self,i):
        if i == 1: # row targets
            self.clearTimeTargets()
            self.clearTimeResults()

    @pyqtSlot(int)
    def tempTableColumnHeaderClicked(self,i):
        if self.temp_target_widgets[i] is not None:
            # clear target value i
            if self.temp_target_widgets[i].text() != "":
                self.temp_target_widgets[i].setText("")
                self.updateTempResults()
            elif aw.qmc.background:
                timeidx = [0,1,2,4,6][i]
                if aw.qmc.timeindexB[timeidx] > 0:
                    self.temp_target_widgets[i].setText(str(aw.float2float(aw.qmc.temp2B[aw.qmc.timeindexB[timeidx]])))
                    self.updateTempResults()
    
    @pyqtSlot(int)
    def tempTableRowHeaderClicked(self,i):
        if i == 1: # row targets
            self.clearTempTargets()
            self.clearTempResults()
    
    @pyqtSlot()
    def updatePhasesWidget(self):
        self.clearTimeTargets()
        sender = self.sender()
        # clear corresponding time target if percentage target is set, or the otherway around
        if sender.text() != "":
            try:
                time_idx = self.phases_target_widgets_time.index(sender)
                self.phases_target_widgets_percent[time_idx].setText("")
            except:
                pass
            try:
                percent_idx = self.phases_target_widgets_percent.index(sender)
                self.phases_target_widgets_time[percent_idx].setText("")
            except:
                pass
        self.updateTimeResults()
    
    @pyqtSlot()
    def updateTimesWidget(self):
        self.clearPhasesTargetTimes()
        self.clearPhasesTargetPercent()
        self.updateTimeResults()

    # updates time and phases result widgets
    def updateTimeResults(self):
        self.targetTimes = self.getTargetTimes()
        time_targets_clear = all(v is None for v in self.targetTimes)
        target_times, target_phases = self.getTargetPhases()
        phases_targets_clear = all(v is None for v in target_times + target_phases)
        self.clearPhasesResults()
        self.clearTimeResults()
        if not (phases_targets_clear and time_targets_clear):
            self.clearTimeResults()
            # phases targets are set, first clear the time targets
            if not phases_targets_clear:
                self.targetTimes = self.getTargetPhasesTimes()
            else:
                self.targetTimes = self.getTargetTimes()
            # set new time results
            result_times = self.calcTimeResults()
            for i in range(4):
                if self.time_result_widgets[i] is not None:
                    if result_times[i] is None:
                        s = ""
                    else:
                        s = aw.qmc.stringfromseconds(result_times[i],leadingzero=False)
                    self.time_result_widgets[i].setText(s)
            # set new phases results
            result_times = self.calcTimeResults()
            if all(result_times[r] is not None for r in [0,1,3]):
                # DRYING
                drying_period = result_times[0]
                drying_percentage = 100 * drying_period / result_times[3]
                drying_str = \
                        "{}    {}%".format(aw.qmc.stringfromseconds(drying_period,leadingzero=False),aw.float2float(drying_percentage))
                self.phases_result_widgets[0].setText(drying_str)
                # MAILARD
                mailard_period = result_times[1] - result_times[0]
                mailard_percentage = 100 * mailard_period / result_times[3]
                mailard_str = \
                        "{}    {}%".format(aw.qmc.stringfromseconds(mailard_period,leadingzero=False),aw.float2float(mailard_percentage))
                self.phases_result_widgets[1].setText(mailard_str)
                # FINISHING
                finishing_period = result_times[3] - result_times[1]
                finishing_percentage = 100 * finishing_period / result_times[3]
                finishing_str = \
                        "{}    {}%".format(aw.qmc.stringfromseconds(finishing_period,leadingzero=False),aw.float2float(finishing_percentage))
                self.phases_result_widgets[2].setText(finishing_str)
            else:
                for w in self.phases_result_widgets:
                    if w is not None:
                        w.setText("")

    @pyqtSlot()
    def updateTempResults(self):
        self.targetTemps = self.getTargetTemps()
        if all(v is None for v in self.targetTemps):
            # clear all results if no targets are set
            self.clearTempResults()
        else:
            # set new results
            result_temps,fit = self.calcTempResults()
            for i in range(5):
                if self.temp_result_widgets[i] is not None and result_temps[i] is not None:
                    self.temp_result_widgets[i].setText(str(aw.float2float(result_temps[i])) + aw.qmc.mode)
            if fit is None:
                s = ""
            else:
                s = aw.fit2str(fit)
            self.temp_formula.setText(s)
            self.temp_formula.repaint()

    #called from Apply button
    @pyqtSlot()
    def apply(self):
        applied_time = self.applyTimeTransformation()
        applied_temp = self.applyTempTransformation()
        if applied_time or applied_temp:
            aw.qmc.roastUUID = None
            aw.qmc.roastdate = QDateTime.currentDateTime()
            aw.qmc.roastepoch = aw.qmc.roastdate.toTime_t()
            aw.qmc.roasttzoffset = libtime.timezone
            aw.qmc.roastbatchnr = 0
            aw.setCurrentFile(None,addToRecent=False)
            aw.qmc.l_event_flags_dict = {}
            aw.qmc.l_annotations_dict = {}
            aw.qmc.fileDirty()
            aw.qmc.timealign()
            aw.autoAdjustAxis()
            aw.qmc.redraw()
        else:
            self.restore()
    
    #called from Restore button
    @pyqtSlot()
    def restore(self):
        aw.setCurrentFile(self.org_curFile,addToRecent=False)
        aw.qmc.roastUUID = self.org_UUID
        aw.qmc.roastdate = self.org_roastdate
        aw.qmc.roastepoch = self.org_roastepoch
        aw.qmc.roasttzoffset = self.org_roasttzoffset
        aw.qmc.roastbatchnr = self.org_roastbatchnr
        if self.org_safesaveflag:
            aw.qmc.fileDirty()
        else:
            aw.qmc.fileClean()
        aw.qmc.l_event_flags_dict = self.org_l_event_flags_dict
        aw.qmc.l_annotations_dict = self.org_l_annotations_dict
        aw.qmc.timex = self.org_timex[:]
        aw.qmc.extratimex = copy.deepcopy(self.org_extratimex)
        aw.qmc.temp2 = self.org_temp2[:]
        aw.autoAdjustAxis()
        aw.qmc.redraw()

    #called from Help button
    @pyqtSlot()
    def help(self):
        pass
    
    #called from OK button
    @pyqtSlot()
    def applyTransformations(self):
        self.apply()
        #save window position (only; not size!)
        settings = QSettings()
        settings.setValue("TransformatorPosition",self.geometry().topLeft())
        self.accept()

    #called from Cancel button
    @pyqtSlot()
    def restoreState(self):
        self.restore()
        aw.qmc.transMappingMode = self.org_transMappingMode
        #save window position (only; not size!)
        settings = QSettings()
        settings.setValue("TransformatorPosition",self.geometry().topLeft())
        self.reject()

    def closeEvent(self, _):
        self.restoreState()


    # Calculations

    # returns the list of results times in seconds
    def calcTimeResults(self):
        res = []
        if aw.qmc.transMappingMode == 0:
            # discrete mapping
            # adding CHARGE
            fits = self.calcDiscretefits([0] + self.profileTimes,[0] + self.targetTimes)
            for i in range(4):
                if self.profileTimes[i] is not None and fits[i+1] is not None:
                    res.append(fits[i+1](self.profileTimes[i]))
                else:
                    res.append(None)
        else:
            with warnings.catch_warnings():
                warnings.filterwarnings('error')
                try:
                    fit = self.calcTimePolyfit()
                    for i in range(4):
                        if fit is not None and self.profileTimes[i] is not None:
                            res.append(fit(self.profileTimes[i]))
                        else:
                            res.append(None)
                except numpy.RankWarning:
                    pass
                except:
                    pass
        return res

    # returns the list of results temperatures and the polyfit or None as second result
    def calcTempResults(self):
        res = []
        fit = None
        if aw.qmc.transMappingMode == 0:
            # discrete mapping
            fits = self.calcDiscretefits(self.profileTemps,self.targetTemps)
            for i in range(5):
                if self.profileTemps[i] is not None and fits[i] is not None:
                    res.append(fits[i](self.profileTemps[i]))
                else:
                    res.append(None)
        else:
            with warnings.catch_warnings():
                warnings.filterwarnings('error')
                try:
                    fit = self.calcTempPolyfit()
                    p = numpy.poly1d(fit)
                    for i in range(5):
                        if fit is not None and self.profileTemps[i] is not None:
                            res.append(p(self.profileTemps[i]))
                        else:
                            res.append(None)
                except numpy.RankWarning:
                    pass
                except:
                    pass
        return res,fit
    
    # returns target times based on the phases target
    def getTargetPhasesTimes(self):
        # get the offset
        offset = self.forgroundOffset()
        # get profile phases events time
        dry = aw.qmc.timex[aw.qmc.timeindex[1]] - offset
        fcs = aw.qmc.timex[aw.qmc.timeindex[2]] - offset
        drop = aw.qmc.timex[aw.qmc.timeindex[6]] - offset
        # flags for targets set
        dry_set = False
        drop_set = False
        fcs_set = False
        
        # first determine the target DROP time (relative to the profile drop) if any
        if self.phases_target_widgets_time[2] is not None and self.phases_target_widgets_time[2].text() != "":
            drop = fcs + aw.qmc.stringtoseconds(self.phases_target_widgets_time[2].text())
            drop_set = True
        elif self.phases_target_widgets_percent[2] is not None and self.phases_target_widgets_percent[2].text() != "":
            drop = fcs + (float(self.phases_target_widgets_percent[2].text()) * drop / 100)
            drop_set = True
        
        # determine the target DRY time (relative to the target drop of above) if any
        if self.phases_target_widgets_time[0] is not None and self.phases_target_widgets_time[0].text() != "":
            dry = aw.qmc.stringtoseconds(self.phases_target_widgets_time[0].text())
            dry_set = True
        elif self.phases_target_widgets_percent[0] is not None and self.phases_target_widgets_percent[0].text() != "":
            dry = float(self.phases_target_widgets_percent[0].text()) * drop / 100
            dry_set = True
        
        # determine the target FCs time (relative to the target drop of above) if any
        if self.phases_target_widgets_time[1] is not None and self.phases_target_widgets_time[1].text() != "":
            fcs = dry + aw.qmc.stringtoseconds(self.phases_target_widgets_time[1].text())
            fcs_set = True
        elif self.phases_target_widgets_percent[1] is not None and self.phases_target_widgets_percent[1].text() != "":
            fcs = dry + (float(self.phases_target_widgets_percent[1].text()) * drop / 100)
            fcs_set = True
            
#        return [(dry if dry_set else None),(fcs if fcs_set else None), None, (drop if drop_set else None)]
        # set all unset target times to the profile times
        return [
            (dry if dry_set else (aw.qmc.timex[aw.qmc.timeindex[1]] - offset)),
            (fcs if fcs_set else (aw.qmc.timex[aw.qmc.timeindex[2]] - offset)),
            None,
            (drop if drop_set else (aw.qmc.timex[aw.qmc.timeindex[6]] - offset))]

    # calculates the linear (aw.qmc.transMappingMode = 1) or quadratic (aw.qmc.transMappingMode = 2) mapping
    # between the profileTimes and the targetTimes
    def calcTimePolyfit(self):
        # initialized by CHARGE time 00:00
        xa = [0]
        ya = [0]
        for i in range(4):
            if self.targetTimes[i] is not None:
                xa.append(self.profileTimes[i])
                ya.append(self.targetTimes[i])
        deg = aw.qmc.transMappingMode
        if len(xa) > 1:
            try:
                deg = min(len(xa) - 1,deg)
                z = numpy.polyfit(xa, ya, deg)
                return numpy.poly1d(z)
            except:
                return None
        else:
            return None

    # calculates the linear (aw.qmc.transMappingMode = 1) or quadratic (aw.qmc.transMappingMode = 2) mapping
    # between the profileTemps and the targetTemps
    def calcTempPolyfit(self):
        xa = []
        ya = []
        for i in range(5):
            if self.targetTemps[i] is not None:
                xa.append(self.profileTemps[i])
                ya.append(self.targetTemps[i])
        deg = aw.qmc.transMappingMode
        if len(xa) > 0:
            try:
                deg = min(len(xa) - 1,deg)
                if deg == 0:
                    z = numpy.array([1, ya[0] - xa[0]])
                else:
                    z = numpy.polyfit(xa, ya, deg)
                return z
            except:
                return None
        else:
            return None
    
    # returns a list of segment-wise fits between sources and targets
    # each fit is a numpy.array as returned by numpy.polyfit
    # a source element of None generates None as fit
    # a target element of None is skipped and pervious and next segements are joined
    # the lists of sources and targets are expected to be of the same length
    # the length of the result list is the same as that of the sources and targets
    def calcDiscretefits(self,sources,targets):
        if len(sources) != len(targets):
            return [None]*len(sources)
        fits = [None]*len(sources)
        last_fit = None
        for i in range(len(sources)):
            if sources[i] is not None:
                if targets[i] is None:
                    # we take the last fit
                    fits[i] = last_fit
                else:
                    next_idx = None # the index of the next non-empty source/target pair
                    for j in range(i+1,len(sources)):
                        if sources[j] is not None and targets[j] is not None:
                            next_idx = j
                            break
                    if next_idx is None:
                        if last_fit is not None:
                            fits[i] = last_fit # copy previous fit
                        else:
                            # set a simple offset only as there is no previous nor next fit
                            fits[i] = numpy.poly1d(numpy.array([1,targets[i]-sources[i]]))
                    else:
                        fits[i] = numpy.poly1d(numpy.polyfit([sources[i],sources[j]],[targets[i],targets[j]],1))
                    # if this is the first fit, we copy it to all previous positions
                    if last_fit is None:
                        for k in range(0,i):
                            if sources[k] is not None:
                                fits[k] = fits[i]
                    # register this fit
                    last_fit = fits[i]
        return fits

    # fits of length 5
    def applyDiscreteTimeMapping(self,timex,fits):
        offset = self.forgroundOffset()
        res_timex = []
        if offset == 0:
            new_offset = 0
        else:
            new_offset = fits[0](offset)
        for i in range(len(timex)):
            # first fit is to be applied for all readings before DRY
            j = 0
            if aw.qmc.timeindex[6] > 0 and i >= aw.qmc.timeindex[6]:
                # last fit counts after DROP
                j = 4
            elif aw.qmc.timeindex[4] > 0 and i >= aw.qmc.timeindex[4]:
                j = 3 # after SCs
            elif aw.qmc.timeindex[2] > 0 and i >= aw.qmc.timeindex[2]:
                j = 2 # after FCs
            elif aw.qmc.timeindex[1] > 0 and i >= aw.qmc.timeindex[1]:
                j = 1 # after DRY
            fit = fits[j] # fit to be applied
            res_timex.append(fit(timex[i] - offset)+new_offset)
        return res_timex
    
    # returns False if no transformation was applied
    def applyTimeTransformation(self):
        # first update the targets
        self.targetTimes = self.getTargetTimes()
        if all(v is None for v in self.targetTimes):
            target_times, target_phases = self.getTargetPhases()
            if all(v is None for v in target_times + target_phases):
                aw.qmc.timex = self.org_timex[:]
                aw.qmc.extratimex = copy.deepcopy(self.org_extratimex)
                return False
            else:
                self.targetTimes = self.getTargetPhasesTimes()
        # calculate the offset of 00:00
        offset = self.forgroundOffset()
        # apply either the discrete or the polyfit mappings
        if aw.qmc.transMappingMode == 0:
            # discrete mapping
            fits = self.calcDiscretefits([0] + self.profileTimes,[0] + self.targetTimes)
            aw.qmc.timex = self.applyDiscreteTimeMapping(self.org_timex,fits)
            # apply to the extra timex
            aw.qmc.extratimex = []
            for timex in self.org_extratimex:
                try:
                    timex_trans = self.applyDiscreteTimeMapping(timex,fits)
                except:
                    timex_trans = timex
                aw.qmc.extratimex.append(timex_trans)
        else:
            # polyfit mappings
            with warnings.catch_warnings():
                warnings.filterwarnings('error')
                try:
                    fit = self.calcTimePolyfit()
                    if fit is not None:
                        aw.qmc.timex = [fit(tx-offset) for tx in self.org_timex]
                        if len(aw.qmc.timex) > 0 and aw.qmc.timeindex[0] != -1:
                            foffset = aw.qmc.timex[0]
                            aw.qmc.timex = [tx+foffset for tx in aw.qmc.timex]
                        extratimex = []
                        for timex in self.org_extratimex:
                            offset = 0
                            if aw.qmc.timeindex[0] != -1:
                                offset = timex[aw.qmc.timeindex[0]]
                            new_timex = [fit(tx-offset) for tx in timex]
                            if len(new_timex) > 0 and aw.qmc.timeindex[0] != -1:
                                foffset = new_timex[0]
                                new_timex = [tx+foffset for tx in new_timex]
                            extratimex.append(new_timex)
                        aw.qmc.extratimex = extratimex
                except numpy.RankWarning:
                    pass
        return True
    
    # returns False if no transformation was applied
    def applyTempTransformation(self):
        # first update the targets
        self.targetTemps = self.getTargetTemps()
        if all(v is None for v in self.targetTemps):
            aw.qmc.temp2 = self.org_temp2[:]
            return False
        # apply either the discrete or the polyfit mappings
        if aw.qmc.transMappingMode == 0:
            # discrete mappings, length 5
            fits = self.calcDiscretefits(self.profileTemps,self.targetTemps)
            aw.qmc.temp2 = []
            for i in range(len(self.org_temp2)):
                # first fit is to be applied for all readings before DRY
                j = 0
                if aw.qmc.timeindex[6] > 0 and i >= aw.qmc.timeindex[6]:
                    # last fit counts after DROP
                    j = 4
                elif aw.qmc.timeindex[4] > 0 and i >= aw.qmc.timeindex[4]:
                    j = 3 # after SCs
                elif aw.qmc.timeindex[2] > 0 and i >= aw.qmc.timeindex[2]:
                    j = 2 # after FCs
                elif aw.qmc.timeindex[1] > 0 and i >= aw.qmc.timeindex[1]:
                    j = 1 # after DRY
                fit = fits[j] # fit to be applied
                aw.qmc.temp2.append(fit(self.org_temp2[i]))
            return True
        else:
            # polyfit mappings
            with warnings.catch_warnings():
                warnings.filterwarnings('error')
                try:
                    fit = numpy.poly1d(self.calcTempPolyfit())
                    if fit is not None:
                        aw.qmc.temp2 = [fit(temp) for temp in self.org_temp2]
                except numpy.RankWarning:
                    pass
        return True
    
    # tables
    
    def createPhasesTable(self):
        self.phasestable.setRowCount(3)
        self.phasestable.setColumnCount(3)
        self.phasestable.horizontalHeader().setStretchLastSection(False)
        self.timetable.horizontalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.timetable.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.timetable.horizontalHeader().setHighlightSections(False)
        self.phasestable.setHorizontalHeaderLabels([QApplication.translate("Label","Drying",None),
                                                         QApplication.translate("Label","Mailard",None),
                                                         QApplication.translate("Label","Finishing",None)])
        self.phasestable.setVerticalHeaderLabels([QApplication.translate("Table","Profile",None),
                                                         QApplication.translate("Table","Target",None),
                                                         QApplication.translate("Table","Result",None)])
        self.phasestable.setShowGrid(True)
        self.phasestable.setAlternatingRowColors(True)
        self.phasestable.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.phasestable.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
#        self.phasestable.setFrameStyle(QTableWidget.NoFrame)
        self.phasestable.setFixedSize(
            self.phasestable.horizontalHeader().length() + 
#                self.phasestable.verticalHeader().width(), # only the width of the default labels (numbers)
                self.phasestable.verticalHeader().sizeHint().width(),
            self.phasestable.verticalHeader().length() + 
                self.phasestable.horizontalHeader().height())
        self.phasestable.setEditTriggers(QAbstractItemView.NoEditTriggers);
        self.phasestable.setFocusPolicy(Qt.NoFocus);
        self.phasestable.setSelectionMode(QAbstractItemView.NoSelection)
        self.phasestable.setAutoScroll(False)
        self.phasestable.setStyleSheet("QTableWidget { background-color: #fafafa; }")
        self.phasestable.verticalHeader().sectionClicked.connect(self.phasesTableRowHeaderClicked)
        self.phasestable.horizontalHeader().sectionClicked.connect(self.phasesTableColumnHeaderClicked)

        self.phases_target_widgets_time = []
        self.phases_target_widgets_percent = []
        self.phases_result_widgets = []
        
        profilePhasesTimes = [None]*3 # DRYING, MAILARD, FINISHING
        profilePhasesPercentages = [None] * 3
        #
        # the phases transformation are only enabled if at least DRY, FCs and DROP events are set
        phases_enabled = aw.qmc.timeindex[1] and aw.qmc.timeindex[2] and aw.qmc.timeindex[6]
        #
        if phases_enabled:
            profilePhasesTimes[0] = self.profileTimes[0] # DRYING == DRY
            if self.profileTimes[0] is not None and self.profileTimes[1] is not None:
                profilePhasesTimes[1] = self.profileTimes[1] - self.profileTimes[0]
            if self.profileTimes[1] is not None and self.profileTimes[3] is not None:
                profilePhasesTimes[2] = self.profileTimes[3] - self.profileTimes[1]
            if self.profileTimes[3] is not None:
                profilePhasesPercentages = [(ppt/self.profileTimes[3])*100 for ppt in profilePhasesTimes if ppt is not None]

        for i in range(3):
            if len(profilePhasesTimes) > i and profilePhasesTimes[i] is not None:
                profile_phases_time_str = \
                    "{}    {}%".format(aw.qmc.stringfromseconds(profilePhasesTimes[i],leadingzero=False),aw.float2float(profilePhasesPercentages[i]))
                profile_phases_widget = QTableWidgetItem(profile_phases_time_str)
                profile_phases_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.phasestable.setItem(0,i,profile_phases_widget)
                #
                target_widget_time = QLineEdit("")
                target_widget_time.setValidator(QRegExpValidator(self.regextime))
                target_widget_time.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                if phases_enabled:
                    target_widget_time.editingFinished.connect(self.updatePhasesWidget)
                else:
                    target_widget_time.setEnabled(False)
                target_widget_percent = QLineEdit("")
                target_widget_percent.setValidator(QRegExpValidator(self.regexpercent))
                target_widget_percent.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                if phases_enabled:
                    target_widget_percent.editingFinished.connect(self.updatePhasesWidget)
                else:
                    target_widget_percent.setEnabled(False)
                target_cell_widget = QWidget()
                target_cell_layout = QHBoxLayout(target_cell_widget)
                target_cell_layout.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                target_cell_layout.setContentsMargins(4,4,4,4)
                target_cell_layout.addWidget(target_widget_time)
                target_cell_layout.addWidget(target_widget_percent)
                target_cell_widget.setLayout(target_cell_layout)
                self.phasestable.setCellWidget(1,i,target_cell_widget)
                #
                result_widget = QTableWidgetItem("")
                result_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.phasestable.setItem(2,i,result_widget)
            else:
                target_widget_time = None
                target_widget_percent = None
                result_widget = None
            self.phases_target_widgets_time.append(target_widget_time)
            self.phases_target_widgets_percent.append(target_widget_percent)
            self.phases_result_widgets.append(result_widget)

    def createTimeTable(self):
        self.timetable.clear()
        self.timetable.setRowCount(3)
        self.timetable.setColumnCount(4)
        self.timetable.horizontalHeader().setStretchLastSection(False)
        self.timetable.horizontalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.timetable.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.timetable.horizontalHeader().setHighlightSections(False)
        self.timetable.setHorizontalHeaderLabels([QApplication.translate("Label","DRY END",None),
                                                         QApplication.translate("Label","FC START",None),
                                                         QApplication.translate("Label","SC START",None),
                                                         QApplication.translate("Label","DROP",None)])
        self.timetable.setVerticalHeaderLabels([QApplication.translate("Table","Profile",None),
                                                         QApplication.translate("Table","Target",None),
                                                         QApplication.translate("Table","Result",None)])
        self.timetable.setShowGrid(True)
        self.timetable.setAlternatingRowColors(False)
        self.timetable.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.timetable.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
#        self.timetable.setFrameStyle(QTableWidget.NoFrame)
        self.timetable.setFixedSize(
            self.timetable.horizontalHeader().length() + 
#                self.timetable.verticalHeader().width(), # only the width of the default labels (numbers)
                self.timetable.verticalHeader().sizeHint().width(),
            self.timetable.verticalHeader().length() + 
                self.timetable.horizontalHeader().height())
        self.timetable.setEditTriggers(QAbstractItemView.NoEditTriggers);
        self.timetable.setFocusPolicy(Qt.NoFocus);
        self.timetable.setSelectionMode(QAbstractItemView.NoSelection)
        self.timetable.setAutoScroll(False)
        self.timetable.setStyleSheet("QTableWidget { background-color: #fafafa; }")
        self.timetable.verticalHeader().sectionClicked.connect(self.timeTableRowHeaderClicked)
        self.timetable.horizontalHeader().sectionClicked.connect(self.timeTableColumnHeaderClicked)
        
        self.time_target_widgets = []
        self.time_result_widgets = []
        
        for i in range(4):
            if len(self.profileTimes) > i and self.profileTimes[i] is not None:
                profile_time_str = aw.qmc.stringfromseconds(self.profileTimes[i],leadingzero=False)
                profile_widget = QTableWidgetItem(profile_time_str)
                profile_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.timetable.setItem(0,i,profile_widget)
                #
                target_widget = QLineEdit("")
                target_widget.setValidator(QRegExpValidator(self.regextime))
                target_widget.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                target_widget.editingFinished.connect(self.updateTimesWidget)
                target_cell_widget = QWidget()
                target_cell_layout = QHBoxLayout(target_cell_widget)
                target_cell_layout.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                target_cell_layout.setContentsMargins(4,4,4,4)
                target_cell_layout.addWidget(target_widget)
                target_cell_widget.setLayout(target_cell_layout)
                self.timetable.setCellWidget(1,i,target_cell_widget)
                #
                result_widget = QTableWidgetItem("") #profile_time_str)
                result_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.timetable.setItem(2,i,result_widget)
            else:
                target_widget = None
                result_widget = None
            self.time_target_widgets.append(target_widget)
            self.time_result_widgets.append(result_widget)

    def createTempTable(self):
        self.temptable.clear()
        self.temptable.setRowCount(3)
        self.temptable.setColumnCount(5)
        self.temptable.horizontalHeader().setStretchLastSection(False)
        self.temptable.horizontalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.temptable.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.temptable.setHorizontalHeaderLabels([QApplication.translate("Label","CHARGE",None),
                                                         QApplication.translate("Label","DRY END",None),
                                                         QApplication.translate("Label","FC START",None),
                                                         QApplication.translate("Label","SC START",None),
                                                         QApplication.translate("Label","DROP",None)])
        self.temptable.setVerticalHeaderLabels([QApplication.translate("Table","Profile",None),
                                                         QApplication.translate("Table","Target",None),
                                                         QApplication.translate("Table","Result",None)])
        self.temptable.setShowGrid(True)
        self.temptable.setAlternatingRowColors(False)
        self.temptable.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.temptable.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
#        self.temptable.setFrameStyle(QTableWidget.NoFrame)
        self.temptable.setFixedSize(
            self.temptable.horizontalHeader().length() + 
#                self.temptable.verticalHeader().width(), # only the width of the default labels (numbers)
                self.temptable.verticalHeader().sizeHint().width(),
            self.temptable.verticalHeader().length() + 
                self.temptable.horizontalHeader().height())
        self.temptable.setEditTriggers(QAbstractItemView.NoEditTriggers);
        self.temptable.setFocusPolicy(Qt.NoFocus);
        self.temptable.setSelectionMode(QAbstractItemView.NoSelection)
        self.temptable.setAutoScroll(False)
        self.temptable.setStyleSheet("QTableWidget { background-color: #fafafa; }")
        self.temptable.verticalHeader().sectionClicked.connect(self.tempTableRowHeaderClicked)
        self.temptable.horizontalHeader().sectionClicked.connect(self.tempTableColumnHeaderClicked)
        
        self.temp_target_widgets = []
        self.temp_result_widgets = []
        
        for i in range(5):
            if len(self.profileTemps) > i and self.profileTemps[i] is not None:
                profile_temp_str = str(aw.float2float(self.profileTemps[i])) + aw.qmc.mode
                profile_widget = QTableWidgetItem(profile_temp_str)
                profile_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.temptable.setItem(0,i,profile_widget)
                #
                target_widget = QLineEdit("")
                target_widget.setValidator(QRegExpValidator(self.regextemp))
                target_widget.editingFinished.connect(self.updateTempResults)
                target_widget.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                
                target_cell_widget = QWidget()
                target_cell_layout = QHBoxLayout(target_cell_widget)
                target_cell_layout.setAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                target_cell_layout.setContentsMargins(4,4,4,4)
                target_cell_layout.addWidget(target_widget)
#                target_cell_layout.addWidget(QLabel(aw.qmc.mode))
                target_cell_widget.setLayout(target_cell_layout)
                self.temptable.setCellWidget(1,i,target_cell_widget)
                #
                result_widget = QTableWidgetItem("")
                result_widget.setTextAlignment(Qt.AlignCenter|Qt.AlignVCenter)
                self.temptable.setItem(2,i,result_widget)
            else:
                target_widget = None
                result_widget = None
            self.temp_target_widgets.append(target_widget)
            self.temp_result_widgets.append(result_widget)


##########################################################################
#####################  EVENTS CONFIGURATION DLG     ######################
##########################################################################
#accessed through menu conf

class EventsDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(EventsDlg,self).__init__(parent)
        titlefont = QFont()
        titlefont.setBold(True)
        titlefont.setWeight(75)
        self.setWindowTitle(QApplication.translate("Form Caption","Events",None))
        self.setModal(True)
        self.helpdialog = None
        settings = QSettings()
        if settings.contains("EventsGeometry"):
            self.restoreGeometry(settings.value("EventsGeometry"))
        self.storeState()

        ## TAB 7
        showAnnoLabel = QLabel()
        showAnnoLabel.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        showAnnoLabel.setText(u(QApplication.translate("Label", "Show",None)))
        showAnnoLabel.setFont(titlefont)
        AnnoLabel = QLabel()
        AnnoLabel.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        AnnoLabel.setText(u(QApplication.translate("Label", "Annotation",None)))
        AnnoLabel.setFont(titlefont)

        Epreview1Label = QLabel()
        Epreview1Label.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        Epreview1Label.setText(u(QApplication.translate("Label", "Preview before FCs",None)))
        Epreview1Label.setFont(titlefont)
        Epreview2Label = QLabel()
        Epreview2Label.setAlignment(Qt.Alignment(Qt.AlignCenter | Qt.AlignRight))
        Epreview2Label.setText(u(QApplication.translate("Label", "Preview after FCs",None)))
        Epreview2Label.setFont(titlefont)

        self.E1AnnoVisibility = QCheckBox(aw.qmc.etypesf(0))
        self.E1AnnoVisibility.setFocusPolicy(Qt.NoFocus)
        self.E1AnnoVisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[0]))
        self.E2Annovisibility = QCheckBox(aw.qmc.etypesf(1))
        self.E2Annovisibility.setFocusPolicy(Qt.NoFocus)
        self.E2Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[1]))
        self.E3Annovisibility = QCheckBox(aw.qmc.etypesf(2))
        self.E3Annovisibility.setFocusPolicy(Qt.NoFocus)
        self.E3Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[2]))
        self.E4Annovisibility = QCheckBox(aw.qmc.etypesf(3))
        self.E4Annovisibility.setFocusPolicy(Qt.NoFocus)
        self.E4Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[3]))

        E1EditLabel = QLabel()
        E1EditLabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        E1EditLabel.setText(u(QApplication.translate("Label", "Event 1",None)))
        self.E1Edit = QLineEdit(aw.qmc.specialeventannotations[0])
        self.E1Edit.setMinimumSize(self.E1Edit.sizeHint())
        self.E1Edit.textChanged.connect(self.changeSpecialeventEdit1)
        self.E1Edit.setToolTip(QApplication.translate("Tooltip", "Definition string for special event annotation",None))
        self.E1Preview1 = QLabel(aw.qmc.parseSpecialeventannotation(self.E1Edit.text(),eventnum=0,applyto="preview",postFCs=False))
        self.E1Preview2 = QLabel(aw.qmc.parseSpecialeventannotation(self.E1Edit.text(),eventnum=0,applyto="preview",postFCs=True))

        E2EditLabel = QLabel()
        E2EditLabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        E2EditLabel.setText(u(QApplication.translate("Label", "Event 2",None)))
        self.E2Edit = QLineEdit(aw.qmc.specialeventannotations[1])
        self.E2Edit.setMinimumSize(self.E2Edit.sizeHint())
        self.E2Edit.textChanged.connect(self.changeSpecialeventEdit2)
        self.E2Edit.setToolTip(QApplication.translate("Tooltip", "Definition string for special event annotation",None))
        self.E2Preview1 = QLabel(aw.qmc.parseSpecialeventannotation(self.E2Edit.text(),eventnum=0,applyto="preview",postFCs=False))
        self.E2Preview2 = QLabel(aw.qmc.parseSpecialeventannotation(self.E2Edit.text(),eventnum=0,applyto="preview",postFCs=True))

        E3EditLabel = QLabel()
        E3EditLabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        E3EditLabel.setText(u(QApplication.translate("Label", "Event 3",None)))
        self.E3Edit = QLineEdit(aw.qmc.specialeventannotations[2])
        self.E3Edit.setMinimumSize(self.E3Edit.sizeHint())
        self.E3Edit.textChanged.connect(self.changeSpecialeventEdit3)
        self.E3Edit.setToolTip(QApplication.translate("Tooltip", "Definition string for special event annotation",None))
        self.E3Preview1 = QLabel(aw.qmc.parseSpecialeventannotation(self.E3Edit.text(),eventnum=0,applyto="preview",postFCs=False))
        self.E3Preview2 = QLabel(aw.qmc.parseSpecialeventannotation(self.E3Edit.text(),eventnum=0,applyto="preview",postFCs=True))

        E4EditLabel = QLabel()
        E4EditLabel.setAlignment(Qt.Alignment(Qt.AlignBottom | Qt.AlignRight))
        E4EditLabel.setText(u(QApplication.translate("Label", "Event 4",None)))
        self.E4Edit = QLineEdit(aw.qmc.specialeventannotations[3])
        self.E4Edit.setMinimumSize(self.E4Edit.sizeHint())
        self.E4Edit.textChanged.connect(self.changeSpecialeventEdit4)
        self.E4Edit.setToolTip(QApplication.translate("Tooltip", "Definition string for special event annotation",None))
        self.E4Preview1 = QLabel(aw.qmc.parseSpecialeventannotation(self.E4Edit.text(),eventnum=0,applyto="preview",postFCs=False))
        self.E4Preview2 = QLabel(aw.qmc.parseSpecialeventannotation(self.E4Edit.text(),eventnum=0,applyto="preview",postFCs=True))

        eventannoLayout = QGridLayout()

        eventannoLayout.addWidget(showAnnoLabel, 0,0,Qt.AlignLeft)
        eventannoLayout.addWidget(AnnoLabel,     0,1,Qt.AlignLeft)
        eventannoLayout.addWidget(Epreview1Label,0,2,Qt.AlignLeft)
        eventannoLayout.addWidget(Epreview2Label,0,3,Qt.AlignLeft)

        eventannoLayout.addWidget(self.E1AnnoVisibility,1,0)
        eventannoLayout.addWidget(self.E2Annovisibility,2,0)
        eventannoLayout.addWidget(self.E3Annovisibility,3,0)
        eventannoLayout.addWidget(self.E4Annovisibility,4,0)

        eventannoLayout.addWidget(self.E1Edit,1,1)
        eventannoLayout.addWidget(self.E2Edit,2,1)
        eventannoLayout.addWidget(self.E3Edit,3,1)
        eventannoLayout.addWidget(self.E4Edit,4,1)
        eventannoLayout.addWidget(self.E1Preview1,1,2,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E2Preview1,2,2,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E3Preview1,3,2,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E4Preview1,4,2,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E1Preview2,1,3,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E2Preview2,2,3,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E3Preview2,3,3,Qt.AlignLeft)
        eventannoLayout.addWidget(self.E4Preview2,4,3,Qt.AlignLeft)

        eventannoLayout.setColumnStretch(0,0)
        eventannoLayout.setColumnStretch(1,10)
        eventannoLayout.setColumnStretch(2,8)
        eventannoLayout.setColumnStretch(3,8)

        helpButton = QPushButton(QApplication.translate("Button","Help", None))
        helpButton.clicked.connect(self.showEventannotationhelp)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(helpButton)
        entryLayout = QHBoxLayout()
        entryLayout.addLayout(eventannoLayout)
        entryLayout.addStretch()
        tab7Layout = QVBoxLayout()
        tab7Layout.addLayout(entryLayout)
        tab7Layout.addStretch()
        tab7Layout.addSpacing(10)
        tab7Layout.addLayout(buttonLayout)
        
        C7Widget = QWidget()
        C7Widget.setLayout(tab7Layout)

        ## TAB 1
        self.eventsbuttonflag = QCheckBox(QApplication.translate("CheckBox","Button",None))
        self.eventsbuttonflag.setChecked(bool(aw.eventsbuttonflag))
        self.eventsbuttonflag.stateChanged.connect(self.eventsbuttonflagChanged)
        self.annotationsflagbox = QCheckBox(QApplication.translate("CheckBox","Annotations",None))
        self.annotationsflagbox.setChecked(bool(aw.qmc.annotationsflag))
        self.annotationsflagbox.stateChanged.connect(self.annotationsflagChanged)
        self.showeventsonbtbox = QCheckBox(QApplication.translate("CheckBox","Show on BT",None))
        self.showeventsonbtbox.setChecked(bool(aw.qmc.showeventsonbt))
        self.showeventsonbtbox.stateChanged.connect(self.showeventsonbtChanged)
        
        self.eventsclampflag = QCheckBox(QApplication.translate("CheckBox","Snap",None))
        self.eventsclampflag.setChecked(bool(aw.qmc.clampEvents))
        self.eventsclampflag.stateChanged.connect(self.eventsclampflagChanged)
        self.eventslabelsflag = QCheckBox(QApplication.translate("CheckBox","Descr.",None))
        self.eventslabelsflag.setChecked(bool(aw.qmc.renderEventsDescr))
        self.eventslabelsflag.stateChanged.connect(self.eventslabelsflagChanged)
        self.eventslabelscharsSpinner = QSpinBox()
        self.eventslabelscharsSpinner.setAlignment(Qt.AlignRight)
        self.eventslabelscharsSpinner.setSingleStep(1)
        self.eventslabelscharsSpinner.setFocusPolicy(Qt.NoFocus)
        self.eventslabelscharsSpinner.setRange(1,20)
        self.eventslabelscharsSpinner.setValue(aw.qmc.eventslabelschars)
        
        if aw.qmc.eventsGraphflag not in [2,3,4]:
            self.eventsclampflag.setEnabled(False)
        self.minieventsflag = QCheckBox(QApplication.translate("CheckBox","Mini Editor",None))
        self.minieventsflag.setToolTip(QApplication.translate("Tooltip","Allows to enter a description of the last event",None))
        self.minieventsflag.setChecked(bool(aw.minieventsflag))
        self.minieventsflag.stateChanged.connect(self.minieventsflagChanged)
        barstylelabel = QLabel(QApplication.translate("Label","Markers",None))
        barstyles = ["",
                    QApplication.translate("ComboBox","Flag",None),
                    QApplication.translate("ComboBox","Bar",None),
                    QApplication.translate("ComboBox","Step",None),
                    QApplication.translate("ComboBox","Step+",None),
                    QApplication.translate("ComboBox","Combo",None)]
                    
        self.bartypeComboBox =  QComboBox()
        self.bartypeComboBox.setFocusPolicy(Qt.NoFocus)
#        self.bartypeComboBox.setMaximumWidth(80)
        self.bartypeComboBox.addItems(barstyles)
        if not aw.qmc.eventsshowflag:
            self.bartypeComboBox.setCurrentIndex(0)
        else:
            self.bartypeComboBox.setCurrentIndex(aw.qmc.eventsGraphflag+1)
        self.bartypeComboBox.currentIndexChanged.connect(self.eventsGraphTypeflagChanged)
        typelabel1 = QLabel("1")
        typelabel2 = QLabel("2")
        typelabel3 = QLabel("3")
        typelabel4 = QLabel("4")
        self.showEtype1 = QCheckBox(QApplication.translate("CheckBox","",None))
        self.showEtype2 = QCheckBox(QApplication.translate("CheckBox","",None))
        self.showEtype3 = QCheckBox(QApplication.translate("CheckBox","",None))
        self.showEtype4 = QCheckBox(QApplication.translate("CheckBox","",None))
        self.showEtype1.setChecked(aw.qmc.showEtypes[0])
        self.showEtype2.setChecked(aw.qmc.showEtypes[1])
        self.showEtype3.setChecked(aw.qmc.showEtypes[2])
        self.showEtype4.setChecked(aw.qmc.showEtypes[3])
        self.showEtype1.stateChanged.connect(self.changeShowEtypes0)         #toggle
        self.showEtype2.stateChanged.connect(self.changeShowEtypes1)         #toggle
        self.showEtype3.stateChanged.connect(self.changeShowEtypes2)         #toggle
        self.showEtype4.stateChanged.connect(self.changeShowEtypes3)         #toggle
        self.etype0 = QLineEdit(aw.qmc.etypesf(0))
        self.etype0.setCursorPosition(0)
        self.etype1 = QLineEdit(aw.qmc.etypesf(1))
        self.etype1.setCursorPosition(0)
        self.etype2 = QLineEdit(aw.qmc.etypesf(2))
        self.etype2.setCursorPosition(0)
        self.etype3 = QLineEdit(aw.qmc.etypesf(3))
        self.etype3.setCursorPosition(0)
        self.etype0.setMaximumWidth(60)
        self.etype1.setMaximumWidth(60)
        self.etype2.setMaximumWidth(60)
        self.etype3.setMaximumWidth(60)
        self.E1colorButton = QPushButton(aw.qmc.etypesf(0))
        self.E1colorButton.setFocusPolicy(Qt.NoFocus)
        self.E2colorButton = QPushButton(aw.qmc.etypesf(1))
        self.E2colorButton.setFocusPolicy(Qt.NoFocus)
        self.E3colorButton = QPushButton(aw.qmc.etypesf(2))
        self.E3colorButton.setFocusPolicy(Qt.NoFocus)
        self.E4colorButton = QPushButton(aw.qmc.etypesf(3))
        self.E4colorButton.setFocusPolicy(Qt.NoFocus)
        self.E1colorButton.clicked.connect(self.setcoloreventline0)
        self.E2colorButton.clicked.connect(self.setcoloreventline1)
        self.E3colorButton.clicked.connect(self.setcoloreventline2)
        self.E4colorButton.clicked.connect(self.setcoloreventline3)
        self.E1textcolorButton = QPushButton(aw.qmc.etypesf(0))
        self.E1textcolorButton.setFocusPolicy(Qt.NoFocus)
        self.E2textcolorButton = QPushButton(aw.qmc.etypesf(1))
        self.E2textcolorButton.setFocusPolicy(Qt.NoFocus)
        self.E3textcolorButton = QPushButton(aw.qmc.etypesf(2))
        self.E3textcolorButton.setFocusPolicy(Qt.NoFocus)
        self.E4textcolorButton = QPushButton(aw.qmc.etypesf(3))
        self.E4textcolorButton.setFocusPolicy(Qt.NoFocus)
        self.E1textcolorButton.clicked.connect(self.setcoloreventtext0)
        self.E2textcolorButton.clicked.connect(self.setcoloreventtext1)
        self.E3textcolorButton.clicked.connect(self.setcoloreventtext2)
        self.E4textcolorButton.clicked.connect(self.setcoloreventtext3)
        #marker selection for comboboxes
        self.markers = ["",
                        QApplication.translate("Marker","Circle",None),
                        QApplication.translate("Marker","Square",None),
                        QApplication.translate("Marker","Pentagon",None),
                        QApplication.translate("Marker","Diamond",None),
                        QApplication.translate("Marker","Star",None),
                        QApplication.translate("Marker","Hexagon 1",None),
                        QApplication.translate("Marker","Hexagon 2",None),
                        QApplication.translate("Marker","+",None),
                        QApplication.translate("Marker","x",None),
                        QApplication.translate("Marker","None",None)]
        #keys interpreted by matplotlib. Must match order of self.markers 
        self.markervals = [None,"o","s","p","D","*","h","H","+","x","None"]
        #Marker type
        self.marker1typeComboBox =  QComboBox()
        self.marker1typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker1typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[0] in self.markervals:
            self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        else:
            self.marker1typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.marker1typeComboBox.currentIndexChanged.connect(self.seteventmarker0)
        self.marker2typeComboBox =  QComboBox()
        self.marker2typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker2typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[1] in self.markervals:
            self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        else:
            self.marker2typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.marker2typeComboBox.currentIndexChanged.connect(self.seteventmarker1)
        self.marker3typeComboBox =  QComboBox()
        self.marker3typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker3typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[2] in self.markervals:
            self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        else:
            self.marker3typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.marker3typeComboBox.currentIndexChanged.connect(self.seteventmarker2)
        self.marker4typeComboBox =  QComboBox()
        self.marker4typeComboBox.setFocusPolicy(Qt.NoFocus)
        self.marker4typeComboBox.addItems(self.markers)
        if aw.qmc.EvalueMarker[3] in self.markervals:
            self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        else:
            self.marker4typeComboBox.setCurrentIndex(0) # set to first empty entry
        self.marker4typeComboBox.currentIndexChanged.connect(self.seteventmarker3)
        valuecolorlabel = QLabel(QApplication.translate("Label","Color",None))
        valuecolorlabel.setFont(titlefont)
        valuetextcolorlabel = QLabel(QApplication.translate("Label","Text Color",None))
        valuetextcolorlabel.setFont(titlefont)
        valuesymbollabel = QLabel(QApplication.translate("Label","Marker",None))
        valuesymbollabel.setFont(titlefont)
        valuethicknesslabel = QLabel(QApplication.translate("Label","Thickness",None))
        valuethicknesslabel.setFont(titlefont)
        valuealphalabel = QLabel(QApplication.translate("Label","Opacity",None))
        valuealphalabel.setFont(titlefont)
        valuesizelabel = QLabel(QApplication.translate("Label","Size",None))
        valuesizelabel.setFont(titlefont)
        valuecolorlabel.setMaximumSize(80,20)
        valuetextcolorlabel.setMaximumSize(80,20)
        valuesymbollabel.setMaximumSize(70,20)
        valuethicknesslabel.setMaximumSize(80,20)
        valuealphalabel.setMaximumSize(80,20)
        valuesizelabel.setMaximumSize(80,20)
        self.E1thicknessSpinBox = QSpinBox()
        self.E1thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E1thicknessSpinBox.setSingleStep(1)
        self.E1thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1thicknessSpinBox.setRange(1,10)
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.E1thicknessSpinBox.valueChanged.connect(self.setElinethickness0)
        self.E2thicknessSpinBox = QSpinBox()
        self.E2thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E2thicknessSpinBox.setSingleStep(1)
        self.E2thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2thicknessSpinBox.setRange(1,10)
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.E2thicknessSpinBox.valueChanged.connect(self.setElinethickness1)
        self.E3thicknessSpinBox = QSpinBox()
        self.E3thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E3thicknessSpinBox.setSingleStep(1)
        self.E3thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3thicknessSpinBox.setRange(1,10)
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.E3thicknessSpinBox.valueChanged.connect(self.setElinethickness2)
        self.E4thicknessSpinBox = QSpinBox()
        self.E4thicknessSpinBox.setAlignment(Qt.AlignRight)
        self.E4thicknessSpinBox.setSingleStep(1)
        self.E4thicknessSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4thicknessSpinBox.setRange(1,10)
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        self.E4thicknessSpinBox.valueChanged.connect(self.setElinethickness3)
        self.E1alphaSpinBox = QDoubleSpinBox()
        self.E1alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E1alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1alphaSpinBox.setRange(.1,1.)
        self.E1alphaSpinBox.setSingleStep(.1)
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.E1alphaSpinBox.valueChanged.connect(self.setElinealpha0)
        self.E2alphaSpinBox = QDoubleSpinBox()
        self.E2alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E2alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2alphaSpinBox.setRange(.1,1.)
        self.E2alphaSpinBox.setSingleStep(.1)
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.E1alphaSpinBox.valueChanged.connect(self.setElinealpha1)
        self.E3alphaSpinBox = QDoubleSpinBox()
        self.E3alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E3alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3alphaSpinBox.setRange(.1,1.)
        self.E3alphaSpinBox.setSingleStep(.1)
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.E3alphaSpinBox.valueChanged.connect(self.setElinealpha2)
        self.E4alphaSpinBox = QDoubleSpinBox()
        self.E4alphaSpinBox.setAlignment(Qt.AlignRight)
        self.E4alphaSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4alphaSpinBox.setRange(.1,1.)
        self.E4alphaSpinBox.setSingleStep(.1)
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        self.E4alphaSpinBox.valueChanged.connect(self.setElinealpha3)
        #Marker size
        self.E1sizeSpinBox = QSpinBox()
        self.E1sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E1sizeSpinBox.setSingleStep(1)
        self.E1sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E1sizeSpinBox.setRange(1,14)
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.E1sizeSpinBox.valueChanged.connect(self.setEmarkersize0)
        self.E2sizeSpinBox = QSpinBox()
        self.E2sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E2sizeSpinBox.setSingleStep(1)
        self.E2sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E2sizeSpinBox.setRange(1,14)
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.E2sizeSpinBox.valueChanged.connect(self.setEmarkersize1)
        self.E3sizeSpinBox = QSpinBox()
        self.E3sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E3sizeSpinBox.setSingleStep(1)
        self.E3sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E3sizeSpinBox.setRange(1,14)
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.E3sizeSpinBox.valueChanged.connect(self.setEmarkersize2)
        self.E4sizeSpinBox = QSpinBox()
        self.E4sizeSpinBox.setAlignment(Qt.AlignRight)
        self.E4sizeSpinBox.setSingleStep(1)
        self.E4sizeSpinBox.setFocusPolicy(Qt.NoFocus)
        self.E4sizeSpinBox.setRange(1,14)
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])
        self.E4sizeSpinBox.valueChanged.connect(self.setEmarkersize3)
        self.autoCharge = QCheckBox(QApplication.translate("CheckBox","Auto CHARGE",None))
        self.autoCharge.setChecked(aw.qmc.autoChargeFlag)
        self.autoCharge.setFocusPolicy(Qt.NoFocus)
        if app.artisanviewerMode:
            self.autoCharge.setEnabled(False)
        self.autoDrop = QCheckBox(QApplication.translate("CheckBox","Auto DROP",None))
        self.autoDrop.setChecked(aw.qmc.autoDropFlag)
        self.autoDrop.setFocusPolicy(Qt.NoFocus)
        if app.artisanviewerMode:
            self.autoDrop.setEnabled(False)
        self.markTP = QCheckBox(QApplication.translate("CheckBox","Mark TP",None))
        self.markTP.setChecked(aw.qmc.markTPflag)
        self.markTP.setFocusPolicy(Qt.NoFocus)
        #show met 
        self.ShowMet = QCheckBox(QApplication.translate("CheckBox", "Mark MET",None))
        self.ShowMet.setChecked(aw.qmc.showmet)
        self.ShowMet.setFocusPolicy(Qt.NoFocus)
        self.ShowMet.stateChanged.connect(self.changeShowMet)         #toggle          
        self.ShowTimeguide = QCheckBox(QApplication.translate("CheckBox", "Show Time Guide",None))
        self.ShowTimeguide.setChecked(aw.qmc.showtimeguide)
        self.ShowTimeguide.setFocusPolicy(Qt.NoFocus)
        self.ShowTimeguide.stateChanged.connect(self.changeShowTimeguide)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.updatetypes)
        self.dialogbuttons.rejected.connect(self.restoreState)
        
        defaultButtonDialog = QDialogButtonBox()
        defaultButton = defaultButtonDialog.addButton(QDialogButtonBox.RestoreDefaults)
        defaultButton.clicked.connect(self.settypedefault)
        if aw.locale not in aw.qtbase_locales:
            defaultButton.setText(QApplication.translate("Button","Defaults", None))
        
        ###  TAB 2
        #number of buttons per row
        self.nbuttonslabel = QLabel(QApplication.translate("Label","Max buttons per row", None))
        self.nbuttonsSpinBox = QSpinBox()
        self.nbuttonsSpinBox.setMaximumWidth(100)
        self.nbuttonsSpinBox.setAlignment(Qt.AlignCenter)
        self.nbuttonsSpinBox.setRange(2,30)
        self.nbuttonsSpinBox.setValue(aw.buttonlistmaxlen)
        self.nbuttonsSpinBox.valueChanged.connect(self.setbuttonlistmaxlen)
        nbuttonsSizeLabel = QLabel(QApplication.translate("Label","Button size", None))
        self.nbuttonsSizeBox = MyQComboBox()
        size_items = [
                    QApplication.translate("ComboBox", "tiny",None),
                    QApplication.translate("ComboBox", "small",None),
                    QApplication.translate("ComboBox", "large",None)
                ]
        self.nbuttonsSizeBox.addItems(size_items)
        self.nbuttonsSizeBox.setCurrentIndex(aw.buttonsize)
        #table for showing events
        self.eventbuttontable = QTableWidget()
        self.eventbuttontable.setTabKeyNavigation(True)
        self.eventbuttontable.itemSelectionChanged.connect(self.selectionChanged)
        self.createEventbuttonTable()
        self.copyeventbuttonTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copyeventbuttonTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copyeventbuttonTableButton.setFocusPolicy(Qt.NoFocus)
        self.copyeventbuttonTableButton.clicked.connect(self.copyEventButtonTabletoClipboard)
        addButton = QPushButton(QApplication.translate("Button","Add",None))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new extra Event button",None))
        #addButton.setMaximumWidth(100)
        addButton.setFocusPolicy(Qt.NoFocus)
        addButton.clicked.connect(self.addextraeventbuttonSlot)
        delButton = QPushButton(QApplication.translate("Button","Delete",None))
        delButton.setToolTip(QApplication.translate("Tooltip","Delete the last extra Event button",None))
        #delButton.setMaximumWidth(100)
        delButton.setFocusPolicy(Qt.NoFocus)
        delButton.clicked.connect(self.delextraeventbutton)
        self.insertButton = QPushButton(QApplication.translate("Button","Insert",None))
        self.insertButton.clicked.connect(self.insertextraeventbuttonSlot)
        self.insertButton.setMinimumWidth(80)
        self.insertButton.setFocusPolicy(Qt.NoFocus)
        self.insertButton.setEnabled(False)
        helpDialogButton = QDialogButtonBox()
        helpButton = helpDialogButton.addButton(QDialogButtonBox.Help)
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None))
        if aw.locale not in aw.qtbase_locales:
            helpButton.setText(QApplication.translate("Button","Help", None))
        helpButton.clicked.connect(self.showEventbuttonhelp)
        #color patterns
        #flag that prevents changing colors too fast
        self.changingcolorflag = False
        colorpatternlabel = QLabel(QApplication.translate("Label","Color Pattern", None))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setWrapping(True)
        self.colorSpinBox.setMaximumWidth(100)
        self.colorSpinBox.setAlignment(Qt.AlignCenter)
        self.colorSpinBox.setRange(0,359)
        self.colorSpinBox.valueChanged.connect(self.colorizebuttons)
        ## tab4
        transferpalettebutton = QPushButton(QApplication.translate("Button","<< Store Palette", None))
        transferpalettebutton.setFocusPolicy(Qt.NoFocus)
        setpalettebutton = QPushButton(QApplication.translate("Button","Apply Palette >>", None))
        setpalettebutton.setFocusPolicy(Qt.NoFocus)
        palette = QApplication.translate("Label","palette #", None)
        palettelist = []
        for i in range(10):
            palettelist.append(palette + str(i))
        transferpalettecurrentLabel = QLabel((QApplication.translate("Label","current palette", None)))
        self.transferpalettecombobox = QComboBox()
        self.transferpalettecombobox.setFocusPolicy(Qt.NoFocus)
        # next line needed to avoid truncation of entries on Mac OS X under Qt 5.12.1-5.12.3
        # https://bugreports.qt.io/browse/QTBUG-73653
        self.transferpalettecombobox.setMinimumWidth(120)
        self.transferpalettecombobox.addItems(palettelist)
        
        transferpalettebutton.clicked.connect(self.transferbuttonstoSlot)
        self.switchPaletteByNumberKey = QCheckBox(QApplication.translate("CheckBox","Switch Using Number Keys + Cmd",None))
        self.switchPaletteByNumberKey.setChecked(aw.buttonpalette_shortcuts)
        self.switchPaletteByNumberKey.setFocusPolicy(Qt.NoFocus)
        
        setpalettebutton.clicked.connect(self.setbuttonsfrom)
        backupbutton = QPushButton(QApplication.translate("Button","Save", None))
        backupbutton.setFocusPolicy(Qt.NoFocus)
        restorebutton = QPushButton(QApplication.translate("Button","Load", None))
        restorebutton.setFocusPolicy(Qt.NoFocus)
        backupbutton.setToolTip(QApplication.translate("Tooltip","Backup all palettes to a text file",None))
        restorebutton.setToolTip(QApplication.translate("Tooltip","Restore all palettes from a text file",None))
        backupbutton.setMaximumWidth(140)
        restorebutton.setMaximumWidth(140)
        backupbutton.clicked.connect(self.backuppaletteeventbuttonsSlot)
        restorebutton.clicked.connect(self.restorepaletteeventbuttons)
        ## tab5
        eventtitlelabel = QLabel(QApplication.translate("Label","Event", None))
        eventtitlelabel.setFont(titlefont)
        actiontitlelabel = QLabel(QApplication.translate("Label","Action", None))
        actiontitlelabel.setFont(titlefont)
        commandtitlelabel = QLabel(QApplication.translate("Label","Command", None))
        commandtitlelabel.setFont(titlefont)
        offsettitlelabel = QLabel(QApplication.translate("Label","Offset", None))
        offsettitlelabel.setFont(titlefont)
        factortitlelabel = QLabel(QApplication.translate("Label","Factor", None))
        factortitlelabel.setFont(titlefont)
        min_titlelabel = QLabel(QApplication.translate("Label","Min", None))
        min_titlelabel.setFont(titlefont)
        max_titlelabel = QLabel(QApplication.translate("Label","Max", None))
        max_titlelabel.setFont(titlefont)
        slidercoarsetitlelabel = QLabel(QApplication.translate("Label","Coarse", None))
        slidercoarsetitlelabel.setFont(titlefont)
        slidertemptitlelabel = QLabel(QApplication.translate("Label","Temp", None))
        slidertemptitlelabel.setFont(titlefont)
        sliderunittitlelabel = QLabel(QApplication.translate("Label","Unit", None))
        sliderunittitlelabel.setFont(titlefont)
        self.E1visibility = QCheckBox(aw.qmc.etypesf(0))
        self.E1visibility.setFocusPolicy(Qt.NoFocus)
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility = QCheckBox(aw.qmc.etypesf(1))
        self.E2visibility.setFocusPolicy(Qt.NoFocus)
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility = QCheckBox(aw.qmc.etypesf(2))
        self.E3visibility.setFocusPolicy(Qt.NoFocus)
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility = QCheckBox(aw.qmc.etypesf(3))
        self.E4visibility.setFocusPolicy(Qt.NoFocus)
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        self.sliderActionTypes = ["",#QApplication.translate("ComboBox", "None",None),
                       QApplication.translate("ComboBox", "Serial Command",None),
                       QApplication.translate("ComboBox", "Modbus Command",None),
                       QApplication.translate("ComboBox", "DTA Command",None),
                       QApplication.translate("ComboBox", "Call Program",None),
                       QApplication.translate("ComboBox", "Hottop Heater",None),
                       QApplication.translate("ComboBox", "Hottop Fan",None),
                       QApplication.translate("ComboBox", "Hottop Command",None),
                       QApplication.translate("ComboBox", "Fuji Command",None),
                       QApplication.translate("ComboBox", "PWM Command",None),
                       QApplication.translate("ComboBox", "VOUT Command",None),
                       QApplication.translate("ComboBox", "IO Command",None),
                       QApplication.translate("ComboBox", "S7 Command",None),
                       QApplication.translate("ComboBox", "Aillio R1 Heater",None),
                       QApplication.translate("ComboBox", "Aillio R1 Fan",None),
                       QApplication.translate("ComboBox", "Aillio R1 Drum",None),
                       QApplication.translate("ComboBox", "Artisan Command",None),
                       QApplication.translate("ComboBox", "RC Command",None)]
        self.E1action = QComboBox()
        self.E1action.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.E1action.setFocusPolicy(Qt.NoFocus)
        self.E1action.addItems(self.sliderActionTypes)
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action = QComboBox()
        self.E2action.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.E2action.setFocusPolicy(Qt.NoFocus)
        self.E2action.addItems(self.sliderActionTypes)
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action = QComboBox()
        self.E3action.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.E3action.setFocusPolicy(Qt.NoFocus)
        self.E3action.addItems(self.sliderActionTypes)
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action = QComboBox()
        self.E4action.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.E4action.setFocusPolicy(Qt.NoFocus)
        self.E4action.addItems(self.sliderActionTypes)
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        self.E1command = QLineEdit(aw.eventslidercommands[0])
        self.E2command = QLineEdit(aw.eventslidercommands[1])
        self.E3command = QLineEdit(aw.eventslidercommands[2])
        self.E4command = QLineEdit(aw.eventslidercommands[3])
        self.E1offset = QDoubleSpinBox()
        self.E1offset.setAlignment(Qt.AlignRight)
        self.E1offset.setRange(-9999,9999)
        self.E1offset.setDecimals(1)
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset = QDoubleSpinBox()
        self.E2offset.setAlignment(Qt.AlignRight)
        self.E2offset.setRange(-9999,9999)
        self.E2offset.setDecimals(1)
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset = QDoubleSpinBox()
        self.E3offset.setAlignment(Qt.AlignRight)
        self.E3offset.setRange(-9999,9999)
        self.E3offset.setDecimals(1)
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset = QDoubleSpinBox()
        self.E4offset.setAlignment(Qt.AlignRight)
        self.E4offset.setRange(-9999,9999)
        self.E4offset.setDecimals(1)
        self.E4offset.setValue(aw.eventslideroffsets[3])
        self.E1factor = QDoubleSpinBox()
        self.E1factor.setAlignment(Qt.AlignRight)
        self.E1factor.setRange(-999,999)
        self.E1factor.setDecimals(3)
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E1factor.setMaximumWidth(70)
        self.E2factor = QDoubleSpinBox()
        self.E2factor.setAlignment(Qt.AlignRight)
        self.E2factor.setRange(-999,999)
        self.E2factor.setDecimals(3)
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E2factor.setMaximumWidth(70)
        self.E3factor = QDoubleSpinBox()
        self.E3factor.setAlignment(Qt.AlignRight)
        self.E3factor.setRange(-999,999)
        self.E3factor.setDecimals(3)
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E3factor.setMaximumWidth(70)
        self.E4factor = QDoubleSpinBox()
        self.E4factor.setAlignment(Qt.AlignRight)
        self.E4factor.setRange(-999,999)
        self.E4factor.setDecimals(3)
        self.E4factor.setValue(aw.eventsliderfactors[3])
        self.E4factor.setMaximumWidth(70)
        self.E1_min = QSpinBox()
        self.E1_min.setAlignment(Qt.AlignRight)
        self.E1_min.setRange(0,aw.eventsMaxValue)
        self.E1_min.setValue(aw.eventslidermin[0])
        self.E2_min = QSpinBox()
        self.E2_min.setAlignment(Qt.AlignRight)
        self.E2_min.setRange(0,aw.eventsMaxValue)
        self.E2_min.setValue(aw.eventslidermin[1])
        self.E3_min = QSpinBox()
        self.E3_min.setAlignment(Qt.AlignRight)
        self.E3_min.setRange(0,aw.eventsMaxValue)
        self.E3_min.setValue(aw.eventslidermin[2])
        self.E4_min = QSpinBox()
        self.E4_min.setAlignment(Qt.AlignRight)
        self.E4_min.setRange(0,aw.eventsMaxValue)
        self.E4_min.setValue(aw.eventslidermin[3])
        self.E1_max = QSpinBox()
        self.E1_max.setAlignment(Qt.AlignRight)
        self.E1_max.setRange(0,aw.eventsMaxValue)
        self.E1_max.setValue(aw.eventslidermax[0])
        self.E2_max = QSpinBox()
        self.E2_max.setAlignment(Qt.AlignRight)
        self.E2_max.setRange(0,aw.eventsMaxValue)
        self.E2_max.setValue(aw.eventslidermax[1])
        self.E3_max = QSpinBox()
        self.E3_max.setAlignment(Qt.AlignRight)
        self.E3_max.setRange(0,aw.eventsMaxValue)
        self.E3_max.setValue(aw.eventslidermax[2])
        self.E4_max = QSpinBox()
        self.E4_max.setAlignment(Qt.AlignRight)
        self.E4_max.setRange(0,aw.eventsMaxValue)
        self.E4_max.setValue(aw.eventslidermax[3])
        self.E1slider_coarse = QCheckBox()
        self.E1slider_coarse.setFocusPolicy(Qt.NoFocus)
        self.E1slider_coarse.setChecked(bool(aw.eventslidercoarse[0]))
        self.E1slider_coarse.setToolTip(QApplication.translate("Tooltip", "Slider steps in multiple of 10 otherwise 1", None))
        self.E2slider_coarse = QCheckBox()
        self.E2slider_coarse.setFocusPolicy(Qt.NoFocus)
        self.E2slider_coarse.setChecked(bool(aw.eventslidercoarse[1]))
        self.E2slider_coarse.setToolTip(QApplication.translate("Tooltip", "Slider steps in multiple of 10 otherwise 1", None))
        self.E3slider_coarse = QCheckBox()
        self.E3slider_coarse.setFocusPolicy(Qt.NoFocus)
        self.E3slider_coarse.setChecked(bool(aw.eventslidercoarse[2]))
        self.E3slider_coarse.setToolTip(QApplication.translate("Tooltip", "Slider steps in multiple of 10 otherwise 1", None))
        self.E4slider_coarse = QCheckBox()
        self.E4slider_coarse.setFocusPolicy(Qt.NoFocus)
        self.E4slider_coarse.setChecked(bool(aw.eventslidercoarse[3]))
        self.E4slider_coarse.setToolTip(QApplication.translate("Tooltip", "Slider steps in multiple of 10 otherwise 1", None))
        self.E1slider_temp = QCheckBox()
        self.E1slider_temp.setFocusPolicy(Qt.NoFocus)
        self.E1slider_temp.setChecked(bool(aw.eventslidertemp[0]))
        self.E1slider_temp.setToolTip(QApplication.translate("Tooltip", "Slider values interpreted as temperatures", None))
        self.E2slider_temp = QCheckBox()
        self.E2slider_temp.setFocusPolicy(Qt.NoFocus)
        self.E2slider_temp.setChecked(bool(aw.eventslidertemp[1]))
        self.E2slider_temp.setToolTip(QApplication.translate("Tooltip", "Slider values interpreted as temperatures", None))
        self.E3slider_temp = QCheckBox()
        self.E3slider_temp.setFocusPolicy(Qt.NoFocus)
        self.E3slider_temp.setChecked(bool(aw.eventslidertemp[2]))
        self.E3slider_temp.setToolTip(QApplication.translate("Tooltip", "Slider values interpreted as temperatures", None))
        self.E4slider_temp = QCheckBox()
        self.E4slider_temp.setFocusPolicy(Qt.NoFocus)
        self.E4slider_temp.setChecked(bool(aw.eventslidertemp[3]))
        self.E4slider_temp.setToolTip(QApplication.translate("Tooltip", "Slider values interpreted as temperatures", None))
        maxwidth = 40
        self.E1unit = QLineEdit(aw.eventsliderunits[0])
        self.E1unit.setMaximumWidth(maxwidth)
        self.E1unit.setToolTip(QApplication.translate("Tooltip", "Unit to be added to generated event descriptions", None))
        self.E2unit = QLineEdit(aw.eventsliderunits[1])
        self.E2unit.setMaximumWidth(maxwidth)
        self.E2unit.setToolTip(QApplication.translate("Tooltip", "Unit to be added to generated event descriptions", None))
        self.E3unit = QLineEdit(aw.eventsliderunits[2])
        self.E3unit.setMaximumWidth(maxwidth)
        self.E3unit.setToolTip(QApplication.translate("Tooltip", "Unit to be added to generated event descriptions", None))
        self.E4unit = QLineEdit(aw.eventsliderunits[3])
        self.E4unit.setMaximumWidth(maxwidth)
        self.E4unit.setToolTip(QApplication.translate("Tooltip", "Unit to be added to generated event descriptions", None))
        helpsliderDialogButton = QDialogButtonBox()
        helpsliderbutton = helpsliderDialogButton.addButton(QDialogButtonBox.Help)
        if aw.locale not in aw.qtbase_locales:
            helpsliderbutton.setText(QApplication.translate("Button","Help", None))
        helpsliderbutton.clicked.connect(self.showSliderHelp)
        ## tab4
        qeventtitlelabel = QLabel(QApplication.translate("Label","Event", None))
        qeventtitlelabel.setFont(titlefont)
        sourcetitlelabel = QLabel(QApplication.translate("Label","Source", None))
        sourcetitlelabel.setFont(titlefont)
        mintitlelabel = QLabel(QApplication.translate("Label","Min", None))
        mintitlelabel.setFont(titlefont)
        maxtitlelabel = QLabel(QApplication.translate("Label","Max", None))
        maxtitlelabel.setFont(titlefont)
        coarsetitlelabel = QLabel(QApplication.translate("Label","Coarse", None))
        coarsetitlelabel.setFont(titlefont)
        self.E1active = QCheckBox(aw.qmc.etypesf(0))
        self.E1active.setFocusPolicy(Qt.NoFocus)
        self.E1active.setChecked(bool(aw.eventquantifieractive[0]))
        self.E2active = QCheckBox(aw.qmc.etypesf(1))
        self.E2active.setFocusPolicy(Qt.NoFocus)
        self.E2active.setChecked(bool(aw.eventquantifieractive[1]))
        self.E3active = QCheckBox(aw.qmc.etypesf(2))
        self.E3active.setFocusPolicy(Qt.NoFocus)
        self.E3active.setChecked(bool(aw.eventquantifieractive[2]))
        self.E4active = QCheckBox(aw.qmc.etypesf(3))
        self.E4active.setFocusPolicy(Qt.NoFocus)
        self.E4active.setChecked(bool(aw.eventquantifieractive[3]))
        self.E1coarse = QCheckBox()
        self.E1coarse.setFocusPolicy(Qt.NoFocus)
        self.E1coarse.setChecked(bool(aw.eventquantifiercoarse[0]))
        self.E2coarse = QCheckBox()
        self.E2coarse.setFocusPolicy(Qt.NoFocus)
        self.E2coarse.setChecked(bool(aw.eventquantifiercoarse[1]))
        self.E3coarse = QCheckBox()
        self.E3coarse.setFocusPolicy(Qt.NoFocus)
        self.E3coarse.setChecked(bool(aw.eventquantifiercoarse[2]))
        self.E4coarse = QCheckBox()
        self.E4coarse.setFocusPolicy(Qt.NoFocus)
        self.E4coarse.setChecked(bool(aw.eventquantifiercoarse[3]))
        self.curvenames = []
        self.curvenames.append(QApplication.translate("ComboBox","ET",None))
        self.curvenames.append(QApplication.translate("ComboBox","BT",None))
        for i in range(len(aw.qmc.extradevices)):
            self.curvenames.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            self.curvenames.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
        self.E1SourceComboBox = QComboBox()
        self.E1SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[0] < len(self.curvenames):
            self.E1SourceComboBox.setCurrentIndex(aw.eventquantifiersource[0])
        self.E2SourceComboBox = QComboBox()
        self.E2SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[1] < len(self.curvenames):
            self.E2SourceComboBox.setCurrentIndex(aw.eventquantifiersource[1])
        self.E3SourceComboBox = QComboBox()
        self.E3SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[2] < len(self.curvenames):
            self.E3SourceComboBox.setCurrentIndex(aw.eventquantifiersource[2])
        self.E4SourceComboBox = QComboBox()
        self.E4SourceComboBox.addItems(self.curvenames)
        if aw.eventquantifiersource[3] < len(self.curvenames):
            self.E4SourceComboBox.setCurrentIndex(aw.eventquantifiersource[3])
        self.E1min = QSpinBox()
        self.E1min.setAlignment(Qt.AlignRight)
        self.E1min.setRange(-99999,99999)
        self.E1min.setValue(aw.eventquantifiermin[0])
        self.E2min = QSpinBox()
        self.E2min.setAlignment(Qt.AlignRight)
        self.E2min.setRange(-99999,99999)
        self.E2min.setValue(aw.eventquantifiermin[1])
        self.E3min = QSpinBox()
        self.E3min.setAlignment(Qt.AlignRight)
        self.E3min.setRange(-99999,99999)
        self.E3min.setValue(aw.eventquantifiermin[2])
        self.E4min = QSpinBox()
        self.E4min.setAlignment(Qt.AlignRight)
        self.E4min.setRange(-99999,99999)
        self.E4min.setValue(aw.eventquantifiermin[3])
        self.E1max = QSpinBox()
        self.E1max.setAlignment(Qt.AlignRight)
        self.E1max.setRange(-99999,99999)
        self.E1max.setValue(aw.eventquantifiermax[0])
        self.E2max = QSpinBox()
        self.E2max.setAlignment(Qt.AlignRight)
        self.E2max.setRange(-99999,99999)
        self.E2max.setValue(aw.eventquantifiermax[1])
        self.E3max = QSpinBox()
        self.E3max.setAlignment(Qt.AlignRight)
        self.E3max.setRange(-99999,99999)
        self.E3max.setValue(aw.eventquantifiermax[2])
        self.E4max = QSpinBox()
        self.E4max.setAlignment(Qt.AlignRight)
        self.E4max.setRange(-99999,99999)
        self.E4max.setValue(aw.eventquantifiermax[3])
        applyquantifierbutton =  QPushButton(QApplication.translate("Button","Apply",None))
        applyquantifierbutton.setFocusPolicy(Qt.NoFocus)
        applyquantifierbutton.clicked.connect(self.applyQuantifiers)
        self.clusterEventsFlag = QCheckBox(QApplication.translate("Label","Cluster", None))
        self.clusterEventsFlag.setFocusPolicy(Qt.NoFocus)
        self.clusterEventsFlag.setChecked(bool(aw.clusterEventsFlag))
        ### LAYOUTS
        #### tab1 layout
        bartypeLayout = QHBoxLayout()
        bartypeLayout.addWidget(barstylelabel)
        bartypeLayout.addWidget(self.bartypeComboBox,Qt.AlignLeft)
        FlagsLayout = QHBoxLayout()
        FlagsLayout.addStretch()
        FlagsLayout.addWidget(self.eventsbuttonflag)
        FlagsLayout.addSpacing(5)
        FlagsLayout.addWidget(self.minieventsflag)
        FlagsLayout.addSpacing(5)
        FlagsLayout.addWidget(self.showeventsonbtbox)
        FlagsLayout.addSpacing(5)
        FlagsLayout.addWidget(self.annotationsflagbox)
        FlagsLayout.addStretch()
#        FlagsLayout.addWidget(self.eventsshowflagbox)
#        FlagsLayout.addSpacing(10)
        FlagsLayout.addLayout(bartypeLayout)
        FlagsLayout.addSpacing(10)
        FlagsLayout.addWidget(self.eventsclampflag)
        FlagsLayout.addSpacing(5)
        FlagsLayout.addWidget(self.eventslabelsflag)
        FlagsLayout.addSpacing(5)
        FlagsLayout.addWidget(self.eventslabelscharsSpinner)
        FlagsLayout.addStretch()
        
        FlagsLayout2 = QHBoxLayout()
        FlagsLayout2.addWidget(self.autoCharge)
        FlagsLayout2.addSpacing(15)
        FlagsLayout2.addWidget(self.autoDrop)
        FlagsLayout2.addSpacing(15)
        FlagsLayout2.addWidget(self.markTP)
        FlagsLayout2.addSpacing(15)
        FlagsLayout2.addWidget(self.ShowMet)
        FlagsLayout2.addSpacing(15)
        FlagsLayout2.addWidget(self.ShowTimeguide)

        typeLayout = QGridLayout()
        typeLayout.addWidget(typelabel1,0,0)
        typeLayout.addWidget(self.showEtype1,0,1)
        typeLayout.addWidget(self.etype0,0,2)
        typeLayout.addWidget(typelabel2,0,3)
        typeLayout.addWidget(self.showEtype2,0,4)
        typeLayout.addWidget(self.etype1,0,5)
        typeLayout.addWidget(typelabel3,0,6)
        typeLayout.addWidget(self.showEtype3,0,7)
        typeLayout.addWidget(self.etype2,0,8)
        typeLayout.addWidget(typelabel4,0,9)
        typeLayout.addWidget(self.showEtype4,0,10)
        typeLayout.addWidget(self.etype3,0,11)
        buttonLayout = QHBoxLayout()
        buttonLayout.addLayout(FlagsLayout2)
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        typeHBox = QHBoxLayout()
        typeHBox.addLayout(typeLayout)
        typeHBox.addStretch()
        typeHBox.addWidget(defaultButtonDialog)
        TypeGroupLayout = QGroupBox(QApplication.translate("GroupBox","Event Types",None))
        TypeGroupLayout.setLayout(typeHBox)
        self.buttonActionTypes = ["",#QApplication.translate("ComboBox", "None",None),
                       QApplication.translate("ComboBox", "Serial Command",None),
                       QApplication.translate("ComboBox", "Call Program",None),
                       QApplication.translate("ComboBox", "Modbus Command",None),
                       QApplication.translate("ComboBox", "DTA Command",None),
                       QApplication.translate("ComboBox", "IO Command",None),
                       QApplication.translate("ComboBox", "Hottop Heater",None),
                       QApplication.translate("ComboBox", "Hottop Fan",None),
                       QApplication.translate("ComboBox", "Hottop Command",None),
                       QApplication.translate("ComboBox", "p-i-d",None),
                       QApplication.translate("ComboBox", "Fuji Command",None),
                       QApplication.translate("ComboBox", "PWM Command",None),
                       QApplication.translate("ComboBox", "VOUT Command",None),
                       QApplication.translate("ComboBox", "S7 Command",None),
                       QApplication.translate("ComboBox", "Aillio R1 Heater",None),
                       QApplication.translate("ComboBox", "Aillio R1 Fan",None),
                       QApplication.translate("ComboBox", "Aillio R1 Drum",None),
                       QApplication.translate("ComboBox", "Aillio R1 Command",None),
                       QApplication.translate("ComboBox", "Artisan Command",None),
                       QApplication.translate("ComboBox", "RC Command",None),
                       QApplication.translate("ComboBox", "Multiple Event",None)]
        self.CHARGEbutton = QCheckBox(QApplication.translate("CheckBox", "CHARGE",None))
        self.CHARGEbutton.setChecked(bool(aw.qmc.buttonvisibility[0]))
        self.CHARGEbuttonActionType = QComboBox()
        self.CHARGEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.CHARGEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.CHARGEbuttonActionType.addItems(self.buttonActionTypes)
        self.CHARGEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[0])
        self.CHARGEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[0])
        self.CHARGEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.DRYbutton = QCheckBox(QApplication.translate("CheckBox", "DRY END",None))
        self.DRYbutton.setChecked(bool(aw.qmc.buttonvisibility[1]))
        self.DRYbuttonActionType = QComboBox()
        self.DRYbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.DRYbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DRYbuttonActionType.addItems(self.buttonActionTypes)
        self.DRYbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[1])
        self.DRYbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[1])
        self.DRYbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.FCSbutton = QCheckBox(QApplication.translate("CheckBox", "FC START",None))
        self.FCSbutton.setChecked(bool(aw.qmc.buttonvisibility[2]))
        self.FCSbuttonActionType = QComboBox()
        self.FCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.FCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCSbuttonActionType.addItems(self.buttonActionTypes)
        self.FCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[2])
        self.FCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[2])
        self.FCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.FCEbutton = QCheckBox(QApplication.translate("CheckBox", "FC END",None))
        self.FCEbutton.setChecked(bool(aw.qmc.buttonvisibility[3]))
        self.FCEbuttonActionType = QComboBox()
        self.FCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.FCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.FCEbuttonActionType.addItems(self.buttonActionTypes)
        self.FCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[3])
        self.FCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[3])
        self.FCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.SCSbutton = QCheckBox(QApplication.translate("CheckBox", "SC START",None))
        self.SCSbutton.setChecked(bool(aw.qmc.buttonvisibility[4]))
        self.SCSbuttonActionType = QComboBox()
        self.SCSbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.SCSbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCSbuttonActionType.addItems(self.buttonActionTypes)
        self.SCSbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[4])
        self.SCSbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[4])
        self.SCSbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.SCEbutton = QCheckBox(QApplication.translate("CheckBox", "SC END",None))
        self.SCEbutton.setChecked(bool(aw.qmc.buttonvisibility[5]))
        self.SCEbuttonActionType = QComboBox()
        self.SCEbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.SCEbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SCEbuttonActionType.addItems(self.buttonActionTypes)
        self.SCEbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[5])
        self.SCEbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[5])
        self.SCEbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.DROPbutton = QCheckBox(QApplication.translate("CheckBox", "DROP",None))
        self.DROPbutton.setChecked(bool(aw.qmc.buttonvisibility[6]))
        self.DROPbuttonActionType = QComboBox()
        self.DROPbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.DROPbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.DROPbuttonActionType.addItems(self.buttonActionTypes)
        self.DROPbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[6])
        self.DROPbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[6])
        self.DROPbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.COOLbutton = QCheckBox(QApplication.translate("CheckBox", "COOL END",None))
        self.COOLbutton.setChecked(bool(aw.qmc.buttonvisibility[7]))
        self.COOLbuttonActionType = QComboBox()
        self.COOLbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.COOLbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.COOLbuttonActionType.addItems(self.buttonActionTypes)
        self.COOLbuttonActionType.setCurrentIndex(aw.qmc.buttonactions[7])
        self.COOLbuttonActionString = QLineEdit(aw.qmc.buttonactionstrings[7])
        self.COOLbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.ONbuttonLabel = QLabel(QApplication.translate("Label", "ON", None))
        self.ONbuttonActionType = QComboBox()
        self.ONbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.ONbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.ONbuttonActionType.addItems(self.buttonActionTypes)
        self.ONbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[0])
        self.ONbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[0])
        self.ONbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.OFFbuttonActionType = QComboBox()
        self.OFFbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.OFFbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.OFFbuttonActionType.addItems(self.buttonActionTypes)
        self.OFFbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[1])
        self.OFFbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[1])
        self.OFFbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.OFFbuttonLabel = QLabel(QApplication.translate("Label", "OFF", None))
        self.SAMPLINGbuttonActionType = QComboBox()
        self.SAMPLINGbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.SAMPLINGbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.SAMPLINGbuttonActionType.addItems(self.buttonActionTypes)
        self.SAMPLINGbuttonActionType.setCurrentIndex(aw.qmc.extrabuttonactions[2])
        self.SAMPLINGbuttonActionType.setMinimumContentsLength(3)
        self.SAMPLINGbuttonActionType.setMinimumWidth(self.SAMPLINGbuttonActionType.minimumSizeHint().width())
        self.SAMPLINGbuttonActionString = QLineEdit(aw.qmc.extrabuttonactionstrings[2])
        self.SAMPLINGbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.SAMPLINGbuttonActionInterval = QComboBox()
        self.SAMPLINGbuttonActionInterval.setToolTip(QApplication.translate("Tooltip", "Interval", None))
        self.SAMPLINGbuttonActionInterval.setFocusPolicy(Qt.NoFocus)
        buttonActionIntervals = ["sync", "1.0s", "1.5s", "2.0s", "2.5s", "3.0s", "3.5s", "4.0s", "4.5s", "5.0s"]
        self.sampling_delays = [0,1000,1500,2000,2500,3000,3500,4000,4500,5000]
        self.SAMPLINGbuttonActionInterval.addItems(buttonActionIntervals)
        self.SAMPLINGbuttonActionInterval.setMaximumWidth(70)
        try:
            self.SAMPLINGbuttonActionInterval.setCurrentIndex(self.sampling_delays.index(aw.qmc.extra_event_sampling_delay))
        except Exception:
            pass
        self.RESETbuttonLabel = QLabel(QApplication.translate("Label", "RESET", None))
        self.RESETbuttonActionType = QComboBox()
        self.RESETbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.RESETbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.RESETbuttonActionType.addItems(self.buttonActionTypes)
        self.RESETbuttonActionType.setCurrentIndex(aw.qmc.xextrabuttonactions[0])
        self.RESETbuttonActionString = QLineEdit(aw.qmc.xextrabuttonactionstrings[0])
        self.RESETbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        self.STARTbuttonLabel = QLabel(QApplication.translate("Label", "START", None))
        self.STARTbuttonActionType = QComboBox()
        self.STARTbuttonActionType.setToolTip(QApplication.translate("Tooltip", "Action Type", None))
        self.STARTbuttonActionType.setFocusPolicy(Qt.NoFocus)
        self.STARTbuttonActionType.addItems(self.buttonActionTypes)
        self.STARTbuttonActionType.setCurrentIndex(aw.qmc.xextrabuttonactions[1])
        self.STARTbuttonActionString = QLineEdit(aw.qmc.xextrabuttonactionstrings[1])
        self.STARTbuttonActionString.setToolTip(QApplication.translate("Tooltip", "Action String", None))
        defaultButtonsLayout = QGridLayout()
        defaultButtonsLayout.addWidget(self.RESETbuttonLabel,0,0,Qt.AlignRight)
        defaultButtonsLayout.addWidget(self.RESETbuttonActionType,0,1)
        defaultButtonsLayout.addWidget(self.RESETbuttonActionString,0,2)        
        defaultButtonsLayout.addWidget(self.ONbuttonLabel,1,0,Qt.AlignRight)
        defaultButtonsLayout.addWidget(self.ONbuttonActionType,1,1)
        defaultButtonsLayout.addWidget(self.ONbuttonActionString,1,2)
        defaultButtonsLayout.addWidget(self.OFFbuttonLabel,2,0,Qt.AlignRight)
        defaultButtonsLayout.addWidget(self.OFFbuttonActionType,2,1)
        defaultButtonsLayout.addWidget(self.OFFbuttonActionString,2,2)
        defaultButtonsLayout.addWidget(self.STARTbuttonLabel,3,0,Qt.AlignRight)
        defaultButtonsLayout.addWidget(self.STARTbuttonActionType,3,1)
        defaultButtonsLayout.addWidget(self.STARTbuttonActionString,3,2)        
        defaultButtonsLayout.addWidget(self.CHARGEbutton,4,0)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionType,4,1)
        defaultButtonsLayout.addWidget(self.CHARGEbuttonActionString,4,2)
        defaultButtonsLayout.addWidget(self.DRYbutton,5,0)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionType,5,1)
        defaultButtonsLayout.addWidget(self.DRYbuttonActionString,5,2)
        defaultButtonsLayout.addWidget(self.FCSbutton,0,4)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionType,0,5)
        defaultButtonsLayout.addWidget(self.FCSbuttonActionString,0,6)
        defaultButtonsLayout.addWidget(self.FCEbutton,1,4)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionType,1,5)
        defaultButtonsLayout.addWidget(self.FCEbuttonActionString,1,6)
        defaultButtonsLayout.addWidget(self.SCSbutton,2,4)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionType,2,5)
        defaultButtonsLayout.addWidget(self.SCSbuttonActionString,2,6)
        defaultButtonsLayout.addWidget(self.SCEbutton,3,4)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionType,3,5)
        defaultButtonsLayout.addWidget(self.SCEbuttonActionString,3,6)
        defaultButtonsLayout.addWidget(self.DROPbutton,4,4)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionType,4,5)
        defaultButtonsLayout.addWidget(self.DROPbuttonActionString,4,6)
        defaultButtonsLayout.addWidget(self.COOLbutton,5,4)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionType,5,5)
        defaultButtonsLayout.addWidget(self.COOLbuttonActionString,5,6)
        defaultButtonsLayout.setContentsMargins(5,5,5,5)
        defaultButtonsLayout.setHorizontalSpacing(10)
        defaultButtonsLayout.setVerticalSpacing(5)
        defaultButtonsLayout.setColumnMinimumWidth(3,20)
        ButtonGroupLayout = QGroupBox(QApplication.translate("GroupBox","Default Buttons",None))
        ButtonGroupLayout.setLayout(defaultButtonsLayout)
        if app.artisanviewerMode:
            ButtonGroupLayout.setEnabled(False)
        
        samplingLayout = QHBoxLayout()
        samplingLayout.addStretch()
        samplingLayout.addWidget(self.SAMPLINGbuttonActionType)
        samplingLayout.addWidget(self.SAMPLINGbuttonActionString)
        samplingLayout.addWidget(self.SAMPLINGbuttonActionInterval)
        samplingLayout.addStretch()
        SamplingGroupLayout = QGroupBox(QApplication.translate("GroupBox","Sampling",None))
        SamplingGroupLayout.setLayout(samplingLayout)
        if app.artisanviewerMode:
            SamplingGroupLayout.setEnabled(False)
        topLineLayout = QHBoxLayout()
        topLineLayout.addWidget(TypeGroupLayout)
        topLineLayout.addWidget(SamplingGroupLayout)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(FlagsLayout)
        tab1layout.addLayout(topLineLayout)
        tab1layout.addWidget(ButtonGroupLayout)
        tab1layout.addStretch()
        FlagsLayout.setContentsMargins(0,10,0,0)
        FlagsLayout.setSpacing(10)
        topLineLayout.setContentsMargins(0,0,0,0)
        tab1layout.setSpacing(2)
        tab1layout.setContentsMargins(0,0,0,0)
        nbuttonslayout = QHBoxLayout()
        nbuttonslayout.addWidget(self.nbuttonslabel)
        nbuttonslayout.addWidget(self.nbuttonsSpinBox)
        nbuttonslayout.addSpacing(10)
        nbuttonslayout.addWidget(nbuttonsSizeLabel)
        nbuttonslayout.addWidget(self.nbuttonsSizeBox)
        nbuttonslayout.addSpacing(10)
        nbuttonslayout.addWidget(colorpatternlabel)
        nbuttonslayout.addWidget(self.colorSpinBox)
        nbuttonslayout.addStretch()
        tab2buttonlayout = QHBoxLayout()
        tab2buttonlayout.addWidget(addButton)
        tab2buttonlayout.addWidget(self.insertButton)
        tab2buttonlayout.addWidget(delButton)
        tab2buttonlayout.addWidget(self.copyeventbuttonTableButton)
        tab2buttonlayout.addStretch()
        tab2buttonlayout.addWidget(helpDialogButton)
        ### tab2 layout
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventbuttontable)
        tab2layout.addLayout(nbuttonslayout)
        tab2layout.addLayout(tab2buttonlayout)
        tab2layout.setSpacing(5)
        tab2layout.setContentsMargins(0,10,0,5)
        ### tab4 layout
        paletteGrid = QGridLayout()
        paletteGrid.addWidget(transferpalettebutton,0,1)
        paletteGrid.addWidget(self.transferpalettecombobox,1,0)
        paletteGrid.addWidget(transferpalettecurrentLabel,1,2)
        paletteGrid.addWidget(setpalettebutton,2,1)
        paletteBox = QHBoxLayout()
        paletteBox.addStretch()
        paletteBox.addLayout(paletteGrid)
        paletteBox.addStretch()
        paletteFlags = QHBoxLayout()
        paletteFlags.addStretch()
        paletteFlags.addWidget(self.switchPaletteByNumberKey)
        paletteFlags.addStretch()
        paletteManagementBox = QVBoxLayout()
        paletteManagementBox.addLayout(paletteBox)
        paletteManagementBox.addLayout(paletteFlags)
        paletteGroupLayout = QGroupBox(QApplication.translate("GroupBox","Management",None))
        paletteGroupLayout.setLayout(paletteManagementBox)
        paletteButtons = QHBoxLayout()
        paletteButtons.addStretch()
        paletteButtons.addWidget(restorebutton)
        paletteButtons.addWidget(backupbutton)
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(paletteGroupLayout)
        tab3layout.addLayout(paletteButtons)
        tab3layout.addStretch()
        ### tab5 layout
        valueLayout = QGridLayout()
        valueLayout.addWidget(valuecolorlabel,0,0)
        valueLayout.addWidget(valuetextcolorlabel,0,1)
        valueLayout.addWidget(valuesymbollabel,0,2)
        valueLayout.addWidget(valuethicknesslabel,0,3)
        valueLayout.addWidget(valuealphalabel,0,4)
        valueLayout.addWidget(valuesizelabel,0,5)
        valueLayout.addWidget(self.E1colorButton,1,0)
        valueLayout.addWidget(self.E1textcolorButton,1,1)
        valueLayout.addWidget(self.marker1typeComboBox,1,2)
        valueLayout.addWidget(self.E1thicknessSpinBox,1,3)
        valueLayout.addWidget(self.E1alphaSpinBox,1,4)
        valueLayout.addWidget(self.E1sizeSpinBox,1,5)
        valueLayout.addWidget(self.E2colorButton,2,0)
        valueLayout.addWidget(self.E2textcolorButton,2,1)
        valueLayout.addWidget(self.marker2typeComboBox,2,2)
        valueLayout.addWidget(self.E2thicknessSpinBox,2,3)
        valueLayout.addWidget(self.E2alphaSpinBox,2,4)
        valueLayout.addWidget(self.E2sizeSpinBox,2,5)
        valueLayout.addWidget(self.E3colorButton,3,0)
        valueLayout.addWidget(self.E3textcolorButton,3,1)
        valueLayout.addWidget(self.marker3typeComboBox,3,2)
        valueLayout.addWidget(self.E3thicknessSpinBox,3,3)
        valueLayout.addWidget(self.E3alphaSpinBox,3,4)
        valueLayout.addWidget(self.E3sizeSpinBox,3,5)
        valueLayout.addWidget(self.E4colorButton,4,0)
        valueLayout.addWidget(self.E4textcolorButton,4,1)
        valueLayout.addWidget(self.marker4typeComboBox,4,2)
        valueLayout.addWidget(self.E4thicknessSpinBox,4,3)
        valueLayout.addWidget(self.E4alphaSpinBox,4,4)
        valueLayout.addWidget(self.E4sizeSpinBox,4,5)
        valueHLayout = QHBoxLayout()
        valueHLayout.addStretch()
        valueHLayout.addLayout(valueLayout)
        valueHLayout.addStretch()
        ### tab5 layout
        tab5Layout = QGridLayout()
        tab5Layout.addWidget(eventtitlelabel,0,0)
        tab5Layout.addWidget(actiontitlelabel,0,1)
        tab5Layout.addWidget(commandtitlelabel,0,2)
        tab5Layout.addWidget(offsettitlelabel,0,3)
        tab5Layout.addWidget(factortitlelabel,0,4)
        tab5Layout.addWidget(min_titlelabel,0,5)
        tab5Layout.addWidget(max_titlelabel,0,6)
        tab5Layout.addWidget(slidercoarsetitlelabel,0,7)
        tab5Layout.addWidget(slidertemptitlelabel,0,8)
        tab5Layout.addWidget(sliderunittitlelabel,0,9)
        tab5Layout.addWidget(self.E1visibility,1,0)
        tab5Layout.addWidget(self.E2visibility,2,0)
        tab5Layout.addWidget(self.E3visibility,3,0)
        tab5Layout.addWidget(self.E4visibility,4,0)
        tab5Layout.addWidget(self.E1action,1,1)
        tab5Layout.addWidget(self.E2action,2,1)
        tab5Layout.addWidget(self.E3action,3,1)
        tab5Layout.addWidget(self.E4action,4,1)
        tab5Layout.addWidget(self.E1command,1,2)
        tab5Layout.addWidget(self.E2command,2,2)
        tab5Layout.addWidget(self.E3command,3,2)
        tab5Layout.addWidget(self.E4command,4,2)
        tab5Layout.addWidget(self.E1offset,1,3)
        tab5Layout.addWidget(self.E2offset,2,3)
        tab5Layout.addWidget(self.E3offset,3,3)
        tab5Layout.addWidget(self.E4offset,4,3)
        tab5Layout.addWidget(self.E1factor,1,4)
        tab5Layout.addWidget(self.E2factor,2,4)
        tab5Layout.addWidget(self.E3factor,3,4)
        tab5Layout.addWidget(self.E4factor,4,4)
        tab5Layout.addWidget(self.E1_min,1,5)
        tab5Layout.addWidget(self.E2_min,2,5)
        tab5Layout.addWidget(self.E3_min,3,5)
        tab5Layout.addWidget(self.E4_min,4,5)
        tab5Layout.addWidget(self.E1_max,1,6)
        tab5Layout.addWidget(self.E2_max,2,6)
        tab5Layout.addWidget(self.E3_max,3,6)
        tab5Layout.addWidget(self.E4_max,4,6)
        tab5Layout.addWidget(self.E1slider_coarse,1,7,Qt.AlignCenter)
        tab5Layout.addWidget(self.E2slider_coarse,2,7,Qt.AlignCenter)
        tab5Layout.addWidget(self.E3slider_coarse,3,7,Qt.AlignCenter)
        tab5Layout.addWidget(self.E4slider_coarse,4,7,Qt.AlignCenter)
        tab5Layout.addWidget(self.E1slider_temp,1,8,Qt.AlignCenter)
        tab5Layout.addWidget(self.E2slider_temp,2,8,Qt.AlignCenter)
        tab5Layout.addWidget(self.E3slider_temp,3,8,Qt.AlignCenter)
        tab5Layout.addWidget(self.E4slider_temp,4,8,Qt.AlignCenter)
        tab5Layout.addWidget(self.E1unit,1,9)
        tab5Layout.addWidget(self.E2unit,2,9)
        tab5Layout.addWidget(self.E3unit,3,9)
        tab5Layout.addWidget(self.E4unit,4,9)
        SliderHelpHBox = QHBoxLayout()
        SliderHelpHBox.addStretch()
        SliderHelpHBox.addWidget(helpsliderDialogButton)
        C5VBox = QVBoxLayout()
        C5VBox.addLayout(tab5Layout)
        C5VBox.addStretch()
        C5VBox.addLayout(SliderHelpHBox)
        ### tab6 layout
        tab6Layout = QGridLayout()
        tab6Layout.addWidget(qeventtitlelabel,0,0)
        tab6Layout.addWidget(sourcetitlelabel,0,1)
        tab6Layout.addWidget(mintitlelabel,0,2)
        tab6Layout.addWidget(maxtitlelabel,0,3)
        tab6Layout.addWidget(coarsetitlelabel,0,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E1active,1,0)
        tab6Layout.addWidget(self.E2active,2,0)
        tab6Layout.addWidget(self.E3active,3,0)
        tab6Layout.addWidget(self.E4active,4,0)
        tab6Layout.addWidget(self.E1SourceComboBox,1,1)
        tab6Layout.addWidget(self.E2SourceComboBox,2,1)
        tab6Layout.addWidget(self.E3SourceComboBox,3,1)
        tab6Layout.addWidget(self.E4SourceComboBox,4,1)
        tab6Layout.addWidget(self.E1min,1,2)
        tab6Layout.addWidget(self.E2min,2,2)
        tab6Layout.addWidget(self.E3min,3,2)
        tab6Layout.addWidget(self.E4min,4,2)
        tab6Layout.addWidget(self.E1max,1,3)
        tab6Layout.addWidget(self.E2max,2,3)
        tab6Layout.addWidget(self.E3max,3,3)
        tab6Layout.addWidget(self.E4max,4,3)
        tab6Layout.addWidget(self.E1coarse,1,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E2coarse,2,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E3coarse,3,4,Qt.AlignCenter)
        tab6Layout.addWidget(self.E4coarse,4,4,Qt.AlignCenter)
        QuantifierApplyHBox = QHBoxLayout()
        QuantifierApplyHBox.addStretch()
        QuantifierApplyHBox.addWidget(self.clusterEventsFlag)
        QuantifierApplyHBox.addStretch()
        QuantifierApplyHBox.addWidget(applyquantifierbutton)
        C6HBox = QHBoxLayout()
        C6HBox.addStretch()
        C6HBox.addLayout(tab6Layout)
        C6HBox.addStretch()
        C6VBox = QVBoxLayout()
        C6VBox.addLayout(C6HBox)
        C6VBox.addStretch()
        C6VBox.addLayout(QuantifierApplyHBox)
###########################################
        #tab layout
        self.TabWidget = QTabWidget()
        self.TabWidget.currentChanged.connect(self.tabSwitched)
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None))
        C1Widget.setContentsMargins(5, 0, 5, 0)
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        if app.artisanviewerMode:
            C2Widget.setEnabled(False)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab","Buttons",None))
        C5Widget = QWidget()
        C5Widget.setLayout(C5VBox)
        if app.artisanviewerMode:
            C5Widget.setEnabled(False)
        self.TabWidget.addTab(C5Widget,QApplication.translate("Tab","Sliders",None))
        C6Widget = QWidget()
        C6Widget.setLayout(C6VBox)
        self.TabWidget.addTab(C6Widget,QApplication.translate("Tab","Quantifiers",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab","Palettes",None))
        valueVLayout = QVBoxLayout()
        valueVLayout.addLayout(valueHLayout)
        valueVLayout.addStretch()
        C4Widget = QWidget()
        C4Widget.setLayout(valueVLayout)
        self.TabWidget.addTab(C4Widget,QApplication.translate("Tab","Style",None))

        self.TabWidget.addTab(C7Widget,QApplication.translate("Tab","Annotations",None))

        mainLayout = QVBoxLayout()
        mainLayout.addWidget(self.TabWidget)
        mainLayout.setSpacing(5)
        mainLayout.setContentsMargins(5, 15, 5, 5)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    @pyqtSlot(str)
    def changeSpecialeventEdit1(self):
        self.specialeventEditchanged(1)
    @pyqtSlot(str)
    def changeSpecialeventEdit2(self):
        self.specialeventEditchanged(2)
    @pyqtSlot(str)
    def changeSpecialeventEdit3(self):
        self.specialeventEditchanged(3)
    @pyqtSlot(str)
    def changeSpecialeventEdit4(self):
        self.specialeventEditchanged(4)
    
    def specialeventEditchanged(self,n):
        if n == 1:
            self.E1Preview1.setText(aw.qmc.parseSpecialeventannotation(self.E1Edit.text(),eventnum=0,applyto="preview",postFCs=False))
            self.E1Preview2.setText(aw.qmc.parseSpecialeventannotation(self.E1Edit.text(),eventnum=0,applyto="preview",postFCs=True))
            aw.qmc.specialeventannotations[0] = self.E1Edit.text()
        if n == 2:
            self.E2Preview1.setText(aw.qmc.parseSpecialeventannotation(self.E2Edit.text(),eventnum=0,applyto="preview",postFCs=False))
            self.E2Preview2.setText(aw.qmc.parseSpecialeventannotation(self.E2Edit.text(),eventnum=0,applyto="preview",postFCs=True))
            aw.qmc.specialeventannotations[1] = self.E2Edit.text()
        if n == 3:
            self.E3Preview1.setText(aw.qmc.parseSpecialeventannotation(self.E3Edit.text(),eventnum=0,applyto="preview",postFCs=False))
            self.E3Preview2.setText(aw.qmc.parseSpecialeventannotation(self.E3Edit.text(),eventnum=0,applyto="preview",postFCs=True))
            aw.qmc.specialeventannotations[2] = self.E3Edit.text()
        if n == 4:
            self.E4Preview1.setText(aw.qmc.parseSpecialeventannotation(self.E4Edit.text(),eventnum=0,applyto="preview",postFCs=False))
            self.E4Preview2.setText(aw.qmc.parseSpecialeventannotation(self.E4Edit.text(),eventnum=0,applyto="preview",postFCs=True))
            aw.qmc.specialeventannotations[3] = self.E4Edit.text()

    @pyqtSlot(bool)
    def backuppaletteeventbuttonsSlot(self,_):
        aw.backuppaletteeventbuttons(self.buttonpalette,self.buttonpalettemaxlen)

    @pyqtSlot(bool)
    def restorepaletteeventbuttons(self,_):
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Palettes",None),path=aw.profilepath)
        if filename:
            maxlen = aw.loadPalettes(filename,self.buttonpalette)
            if maxlen is not None:
                self.buttonpalettemaxlen = maxlen

    def selectionChanged(self):
        selected = self.eventbuttontable.selectedRanges()
        if selected and len(selected) > 0:
            self.insertButton.setEnabled(True)
        else:
            self.insertButton.setEnabled(False)

    @pyqtSlot(int)
    def changeShowMet(self,_):
        aw.qmc.showmet = not aw.qmc.showmet
        aw.qmc.redraw(recomputeAllDeltas=False)
        
    @pyqtSlot(int)
    def changeShowTimeguide(self,_):
        aw.qmc.showtimeguide = not aw.qmc.showtimeguide

    @pyqtSlot(bool)
    def settypedefault(self,_):
        aw.qmc.etypes = aw.qmc.etypesdefault
        self.showEtypes = [True]*5
        self.showEtype1.setChecked(self.showEtypes[0])
        self.showEtype2.setChecked(self.showEtypes[1])
        self.showEtype3.setChecked(self.showEtypes[2])
        self.showEtype4.setChecked(self.showEtypes[3])
        self.etype0.setText(aw.qmc.etypesdefault[0])
        self.etype0.setCursorPosition(0)
        self.etype0.repaint()
        self.etype1.setText(aw.qmc.etypesdefault[1])
        self.etype1.setCursorPosition(0)
        self.etype1.repaint()
        self.etype2.setText(aw.qmc.etypesdefault[2])
        self.etype2.setCursorPosition(0)
        self.etype2.repaint()
        self.etype3.setText(aw.qmc.etypesdefault[3])
        self.etype3.setCursorPosition(0)
        self.etype3.repaint()
        # update extra LCD label substitutions
        for i in range(len(aw.qmc.extradevices)):
            if i < len(aw.qmc.extraname1):
                l1 = "<b>" + aw.qmc.extraname1[i] + "</b>"
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel1[i].setText(l1)
            if i < len(aw.qmc.extraname2):
                l2 = "<b>" + aw.qmc.extraname2[i] + "</b>"
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel2[i].setText(l2)
        aw.settooltip()

    @pyqtSlot(bool)
    def applyQuantifiers(self,_):
        self.saveQuantifierSettings()
        # recompute the 4 event quantifier linspaces
        aw.computeLinespaces()
        # remove previous quantifier events
        # recompute quantifier events
        redraw = False
        for i in range(4):
            if aw.eventquantifieractive[i]:
                temp,timex = aw.quantifier2tempandtime(i)
                if temp:
                    # a temp curve exists
                    linespace = aw.eventquantifierlinspaces[i]
                    if aw.eventquantifiercoarse[i]:
                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdcoarse
                    else:
                        linespacethreshold = abs(linespace[1] - linespace[0]) * aw.eventquantifierthresholdfine
                    # loop over that data and classify each value
                    ld = None # last digitized value
                    lt = None # last digitized temp value
                    for ii in range(len(temp)):
                        t = temp[ii]
                        if t != -1: # -1 is an error value
                            d = aw.digitize(t,linespace,aw.eventquantifiercoarse[i],aw.eventslidermin[i])
                            if d is not None and (ld is None or ld != d):
                                # take only changes
                                # and only if significantly different than previous to avoid fluktuation
                                if ld is None or lt is None or linespacethreshold < abs(t - lt):
                                    # establish this one
                                    ld = d
                                    lt = t
                                    # add to event table
                                    aw.qmc.specialevents.append(aw.qmc.time2index(timex[ii]))
                                    aw.qmc.specialeventstype.append(i)
                                    aw.qmc.specialeventsStrings.append("Q"+ aw.qmc.eventsvalues(float(d+1)))
                                    aw.qmc.specialeventsvalue.append(float(d+1))
                                    aw.qmc.fileDirty()
                    redraw = True
        if aw.clusterEventsFlag:
            aw.clusterEvents(True)
        if redraw:
            aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def tabSwitched(self,i):
        self.closeHelp()
        if i == 0:
            self.saveSliderSettings()
            self.saveQuantifierSettings()
        elif i == 1: # switched to Button tab
            # save column widths
            aw.eventbuttontablecolumnwidths = [self.eventbuttontable.columnWidth(c) for c in range(self.eventbuttontable.columnCount())] 
            self.createEventbuttonTable()
            self.saveSliderSettings()
            self.saveQuantifierSettings()
            self.saveAnnotationsSettings()
        elif i == 2: # switched to Slider tab
            self.updateSliderTab()
            self.saveQuantifierSettings()
            self.saveAnnotationsSettings()
        elif i == 3: # switched to Quantifier tab
            self.saveSliderSettings()
            self.updateQuantifierTab()
            self.saveAnnotationsSettings()
        elif i == 4: # switched to Palette tab
            # store slider settings from Slider tab to global variables
            # store sliders
            self.saveSliderSettings()
            self.saveQuantifierSettings()
#            # store buttons (not done here anymore: buttons are saved on leaving the dialog with OK)
#            self.savetableextraeventbutton()
            self.saveAnnotationsSettings()
        elif i == 5: # switched to Style tab
            self.updateStyleTab()
            self.saveSliderSettings()
            self.saveQuantifierSettings()
            self.saveAnnotationsSettings()
        elif i == 6: # switched to Annotations tab
            self.updateAnnotationsTab()
            self.saveQuantifierSettings()

    def updateQuantifierTab(self):
        self.E1active.setText(self.etype0.text())
        self.E2active.setText(self.etype1.text())
        self.E3active.setText(self.etype2.text())
        self.E4active.setText(self.etype3.text())

    def updateStyleTab(self):
        # update color button texts
        self.E1colorButton.setText(self.etype0.text())
        self.E2colorButton.setText(self.etype1.text())
        self.E3colorButton.setText(self.etype2.text())
        self.E4colorButton.setText(self.etype3.text())
        self.E1textcolorButton.setText(self.etype0.text())
        self.E2textcolorButton.setText(self.etype1.text())
        self.E3textcolorButton.setText(self.etype2.text())
        self.E4textcolorButton.setText(self.etype3.text())
        self.E1colorButton.setMinimumWidth(max(self.dialogbuttons.button(QDialogButtonBox.Ok).width(),self.E1textcolorButton.minimumSizeHint().width()))
        self.E1textcolorButton.setMinimumWidth(max(self.dialogbuttons.button(QDialogButtonBox.Ok).width(),self.E1textcolorButton.minimumSizeHint().width()))
        self.E1colorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[0] + "; color: " + aw.qmc.EvalueTextColor[0] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E2colorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[1] + "; color: " + aw.qmc.EvalueTextColor[1] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E3colorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[2] + "; color: " + aw.qmc.EvalueTextColor[2] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E4colorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[3] + "; color: " + aw.qmc.EvalueTextColor[3] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E1textcolorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[0] + "; color: " + aw.qmc.EvalueTextColor[0] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E2textcolorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[1] + "; color: " + aw.qmc.EvalueTextColor[1] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E3textcolorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[2] + "; color: " + aw.qmc.EvalueTextColor[2] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        self.E4textcolorButton.setStyleSheet("background-color: " + aw.qmc.EvalueColor[3] + "; color: " + aw.qmc.EvalueTextColor[3] + "; border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;")
        
        # update markers
        if aw.qmc.EvalueMarker[0] in self.markervals:
            self.marker1typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[0]))
        else:
            self.marker1typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[1] in self.markervals:
            self.marker2typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[1]))
        else:
            self.marker2typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[2] in self.markervals:
            self.marker3typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[2]))
        else:
            self.marker3typeComboBox.setCurrentIndex(0)
        if aw.qmc.EvalueMarker[3] in self.markervals:
            self.marker4typeComboBox.setCurrentIndex(self.markervals.index(aw.qmc.EvalueMarker[3]))
        else:
            self.marker4typeComboBox.setCurrentIndex(0)
        # line thickness
        self.E1thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[0])
        self.E2thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[1])
        self.E3thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[2])
        self.E4thicknessSpinBox.setValue(aw.qmc.Evaluelinethickness[3])
        # opacity
        self.E1alphaSpinBox.setValue(aw.qmc.Evaluealpha[0])
        self.E2alphaSpinBox.setValue(aw.qmc.Evaluealpha[1])
        self.E3alphaSpinBox.setValue(aw.qmc.Evaluealpha[2])
        self.E4alphaSpinBox.setValue(aw.qmc.Evaluealpha[3])
        # marker sizes
        self.E1sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[0])
        self.E2sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[1])
        self.E3sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[2])
        self.E4sizeSpinBox.setValue(aw.qmc.EvalueMarkerSize[3])

    def updateSliderTab(self):
        # set event names
        self.E1visibility.setText(self.etype0.text())
        self.E2visibility.setText(self.etype1.text())
        self.E3visibility.setText(self.etype2.text())
        self.E4visibility.setText(self.etype3.text())
        # set slider visibility
        self.E1visibility.setChecked(bool(aw.eventslidervisibilities[0]))
        self.E2visibility.setChecked(bool(aw.eventslidervisibilities[1]))
        self.E3visibility.setChecked(bool(aw.eventslidervisibilities[2]))
        self.E4visibility.setChecked(bool(aw.eventslidervisibilities[3]))
        # set slider action
        self.E1action.setCurrentIndex(aw.eventslideractions[0])
        self.E2action.setCurrentIndex(aw.eventslideractions[1])
        self.E3action.setCurrentIndex(aw.eventslideractions[2])
        self.E4action.setCurrentIndex(aw.eventslideractions[3])
        # set slider command
        self.E1command.setText(aw.eventslidercommands[0])
        self.E2command.setText(aw.eventslidercommands[1])
        self.E3command.setText(aw.eventslidercommands[2])
        self.E4command.setText(aw.eventslidercommands[3])
        # set slider offset
        self.E1offset.setValue(aw.eventslideroffsets[0])
        self.E2offset.setValue(aw.eventslideroffsets[1])
        self.E3offset.setValue(aw.eventslideroffsets[2])
        self.E4offset.setValue(aw.eventslideroffsets[3])
        # set slider factors
        self.E1factor.setValue(aw.eventsliderfactors[0])
        self.E2factor.setValue(aw.eventsliderfactors[1])
        self.E3factor.setValue(aw.eventsliderfactors[2])
        self.E4factor.setValue(aw.eventsliderfactors[3])
        # set slider min
        self.E1_min.setValue(aw.eventslidermin[0])
        self.E2_min.setValue(aw.eventslidermin[1])
        self.E3_min.setValue(aw.eventslidermin[2])
        self.E4_min.setValue(aw.eventslidermin[3])
        # set slider max
        self.E1_max.setValue(aw.eventslidermax[0])
        self.E2_max.setValue(aw.eventslidermax[1])
        self.E3_max.setValue(aw.eventslidermax[2])
        self.E4_max.setValue(aw.eventslidermax[3])
        # set slider coarse
        self.E1slider_coarse.setChecked(bool(aw.eventslidercoarse[0]))
        self.E2slider_coarse.setChecked(bool(aw.eventslidercoarse[1]))
        self.E3slider_coarse.setChecked(bool(aw.eventslidercoarse[2]))
        self.E4slider_coarse.setChecked(bool(aw.eventslidercoarse[3]))
        # set slider temp
        self.E1slider_temp.setChecked(bool(aw.eventslidertemp[0]))
        self.E2slider_temp.setChecked(bool(aw.eventslidertemp[1]))
        self.E3slider_temp.setChecked(bool(aw.eventslidertemp[2]))
        self.E4slider_temp.setChecked(bool(aw.eventslidertemp[3]))
        # set slider units
        self.E1unit.setText(aw.eventsliderunits[0])
        self.E2unit.setText(aw.eventsliderunits[1])
        self.E3unit.setText(aw.eventsliderunits[2])
        self.E4unit.setText(aw.eventsliderunits[3])
        
    def updateAnnotationsTab(self):
        # set event names
        self.E1AnnoVisibility.setText(self.etype0.text())
        self.E2Annovisibility.setText(self.etype1.text())
        self.E3Annovisibility.setText(self.etype2.text())
        self.E4Annovisibility.setText(self.etype3.text())
        # set annotation visibility
        self.E1AnnoVisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[0]))
        self.E2Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[1]))
        self.E3Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[2]))
        self.E4Annovisibility.setChecked(bool(aw.qmc.specialeventannovisibilities[3]))

    @pyqtSlot(int)
    def setElinethickness0(self,_):
        self.setElinethickness(0)
    @pyqtSlot(int)
    def setElinethickness1(self,_):
        self.setElinethickness(1)
    @pyqtSlot(int)
    def setElinethickness2(self,_):
        self.setElinethickness(2)
    @pyqtSlot(int)
    def setElinethickness3(self,_):
        self.setElinethickness(3)
        
    def setElinethickness(self,val):
        self.E1thicknessSpinBox.setDisabled(True)
        self.E2thicknessSpinBox.setDisabled(True)
        self.E3thicknessSpinBox.setDisabled(True)
        self.E4thicknessSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluelinethickness[0] = self.E1thicknessSpinBox.value()
        if val == 1:
            aw.qmc.Evaluelinethickness[1] = self.E2thicknessSpinBox.value()
        if val == 2:
            aw.qmc.Evaluelinethickness[2] = self.E3thicknessSpinBox.value()
        if val == 3:
            aw.qmc.Evaluelinethickness[3] = self.E4thicknessSpinBox.value()
        self.E1thicknessSpinBox.setDisabled(False)
        self.E2thicknessSpinBox.setDisabled(False)
        self.E3thicknessSpinBox.setDisabled(False)
        self.E4thicknessSpinBox.setDisabled(False)
        aw.qmc.redraw()

    @pyqtSlot(int)
    def setEmarkersize0(self,_):
        self.setEmarkersize(0)
    @pyqtSlot(int)
    def setEmarkersize1(self,_):
        self.setEmarkersize(1)
    @pyqtSlot(int)
    def setEmarkersize2(self,_):
        self.setEmarkersize(2)
    @pyqtSlot(int)
    def setEmarkersize3(self,_):
        self.setEmarkersize(3)

    def setEmarkersize(self,val):
        self.E1sizeSpinBox.setDisabled(True)
        self.E2sizeSpinBox.setDisabled(True)
        self.E3sizeSpinBox.setDisabled(True)
        self.E4sizeSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.EvalueMarkerSize[0] = self.E1sizeSpinBox.value()
        if val == 1:
            aw.qmc.EvalueMarkerSize[1] = self.E2sizeSpinBox.value()
        if val == 2:
            aw.qmc.EvalueMarkerSize[2] = self.E3sizeSpinBox.value()
        if val == 3:
            aw.qmc.EvalueMarkerSize[3] = self.E4sizeSpinBox.value()
        self.E1sizeSpinBox.setDisabled(False)
        self.E2sizeSpinBox.setDisabled(False)
        self.E3sizeSpinBox.setDisabled(False)
        self.E4sizeSpinBox.setDisabled(False)
        aw.qmc.redraw()

    @pyqtSlot(float)
    def setElinealpha0(self,_):
        self.setElinealpha(0)
    @pyqtSlot(float)
    def setElinealpha1(self,_):
        self.setElinealpha(1)
    @pyqtSlot(float)
    def setElinealpha2(self,_):
        self.setElinealpha(2)
    @pyqtSlot(float)
    def setElinealpha3(self,_):
        self.setElinealpha(3)

    def setElinealpha(self,val):
        self.E1alphaSpinBox.setDisabled(True)
        self.E2alphaSpinBox.setDisabled(True)
        self.E3alphaSpinBox.setDisabled(True)
        self.E4alphaSpinBox.setDisabled(True)
        if val == 0:
            aw.qmc.Evaluealpha[0] = self.E1alphaSpinBox.value()
        if val == 1:
            aw.qmc.Evaluealpha[1] = self.E2alphaSpinBox.value()
        if val == 2:
            aw.qmc.Evaluealpha[2] = self.E3alphaSpinBox.value()
        if val == 3:
            aw.qmc.Evaluealpha[3] = self.E4alphaSpinBox.value()
        self.E1alphaSpinBox.setDisabled(False)
        self.E2alphaSpinBox.setDisabled(False)
        self.E3alphaSpinBox.setDisabled(False)
        self.E4alphaSpinBox.setDisabled(False)
        aw.qmc.redraw()

    @pyqtSlot(bool)
    def transferbuttonstoSlot(self,_):
        self.transferbuttonsto()
    
    def transferbuttonsto(self,pindex=None):
        if pindex is None:
            pindex = self.transferpalettecombobox.currentIndex()
        copy = []
        copy.append(self.extraeventstypes[:])
        copy.append(self.extraeventsvalues[:])
        copy.append(self.extraeventsactions[:])
        copy.append(self.extraeventsvisibility[:])
        copy.append(self.extraeventsactionstrings[:])
        copy.append(self.extraeventslabels[:])
        copy.append(self.extraeventsdescriptions[:])
        copy.append(self.extraeventbuttoncolor[:])
        copy.append(self.extraeventbuttontextcolor[:])
        # added slider settings
        copy.append(self.eventslidervisibilities[:])
        copy.append(self.eventslideractions[:])
        copy.append(self.eventslidercommands[:])
        copy.append(self.eventslideroffsets[:])
        copy.append(self.eventsliderfactors[:])
        # added quantifier settings
        copy.append(self.eventquantifieractive[:])
        copy.append(self.eventquantifiersource[:])
        copy.append(self.eventquantifiermin[:])
        copy.append(self.eventquantifiermax[:])
        copy.append(self.eventquantifiercoarse[:])
        # added slider min/max
        copy.append(self.eventslidermin[:])
        copy.append(self.eventslidermax[:])
        # added slider coarse
        copy.append(self.eventslidercoarse[:])
        # added slider temp
        copy.append(self.eventslidertemp[:])
        # added slider unit
        copy.append(self.eventsliderunits[:])
              
        self.buttonpalette[pindex] = copy
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen

    def localSetbuttonsfrom(self,pindex):
        copy = self.buttonpalette[pindex][:]
        if len(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            # added slider settings
            if len(copy)>9 and len(copy[9]) == 4:
                self.eventslidervisibilities = copy[9][:]
            else:
                self.eventslidervisibilities = [0,0,0,0]
            if len(copy)>10 and len(copy[10]) == 4:
                self.eventslideractions = copy[10][:]
            else:
                self.eventslideractions = [0,0,0,0]
            if len(copy)>11 and len(copy[11]) == 4:
                self.eventslidercommands = copy[11][:]
            else:
                self.eventslidercommands = ["","","",""]
            if len(copy)>12 and len(copy[12]) == 4:
                self.eventslideroffsets = copy[12][:]
            else:
                self.eventslideroffsets = [0,0,0,0]
            if len(copy)>13 and len(copy[13]) == 4:
                self.eventsliderfactors = copy[13][:]
            else:
                self.eventsliderfactors = [1.0,1.0,1.0,1.0]
                
            if len(copy)>14 and len(copy[14]) == 4:
                self.eventquantifieractive = copy[14][:]
            else:
                self.eventquantifieractive = [0,0,0,0]
            if len(copy)>15 and len(copy[15]) == 4:
                self.eventquantifiersource = copy[15][:]
            else:
                self.eventquantifiersource = [0,0,0,0]
            if len(copy)>16 and len(copy[16]) == 4:
                self.eventquantifiermin = copy[16][:]
            else:
                self.eventquantifiermin = [0,0,0,0]
            if len(copy)>17 and len(copy[17]) == 4:
                self.eventquantifiermax = copy[17][:]
            else:
                self.eventquantifiermax = [100,100,100,100]
            if len(copy)>18 and len(copy[18]) == 4:
                self.eventquantifiercoarse = copy[18][:]
            else:
                self.eventquantifiercoarse = [0,0,0,0]
            if len(copy)>19 and len(copy[19]) == 4:
                self.eventslidermin = copy[19][:]
            else:
                self.eventslidermin = [0,0,0,0]
            if len(copy)>20 and len(copy[20]) == 4:
                self.eventslidermax = copy[20][:]
            else:
                self.eventslidermax = [100,100,100,100]
            if len(copy)>21 and len(copy[21]) == 4:
                self.eventslidercoarse = copy[21][:]
            else:
                self.eventslidercoarse = [0,0,0,0]
            if len(copy)>22 and len(copy[22]) == 4:
                self.eventslidertemp = copy[22][:]
            else:
                self.eventslidertemp = [0,0,0,0]
            if len(copy)>23 and len(copy[23]) == 4:
                self.eventsliderunits = copy[23][:]
            else:
                self.eventsliderunits = ["","","",""]
                
            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            return 1  #success
        else:
            return 0  #failed

    @pyqtSlot(bool)
    def setbuttonsfrom(self,_):
        pindex = self.transferpalettecombobox.currentIndex()
        answer = self.localSetbuttonsfrom(pindex)
        if answer:
            self.createEventbuttonTable()

    #applys a pattern of colors
    @pyqtSlot(int)
    def colorizebuttons(self,pattern=0):
        if self.changingcolorflag:
            n = self.colorSpinBox.value()
            self.colorSpinBox.setValue(n-1)
            return
        self.changingcolorflag = True

        if not pattern:
            pattern = self.colorSpinBox.value()

        ncolumns = aw.buttonlistmaxlen
        nbuttons = len(self.extraeventstypes)

        initbuttons = ncolumns - 9
        nrows,extra = divmod((nbuttons-initbuttons),ncolumns)

        step = pattern
        bcolor = []

        if extra:
            nrows += 1
        gap = int(-1*(230-50)/ncolumns)
        #Color
        for i in range(nrows):
            for f in range(230,50,gap):
                color = QColor()
                color.setHsv(step,255,f,255)
                bcolor.append(str(color.name()))
            step += pattern*2

        #Text Color
        tcolor = ["yellow"]*nbuttons

        #Apply Colors in Right Oder
        for i in range(nbuttons):
            visualIndex = self.eventbuttontable.visualRow(i)
            self.extraeventbuttoncolor[i]     = bcolor[visualIndex]
            self.extraeventbuttontextcolor[i]   = tcolor[visualIndex]

        self.changingcolorflag = False
        self.createEventbuttonTable()

    @pyqtSlot(int)
    def seteventmarker0(self,_):
        self.seteventmarker(0)
    @pyqtSlot(int)
    def seteventmarker1(self,_):
        self.seteventmarker(1)
    @pyqtSlot(int)
    def seteventmarker2(self,_):
        self.seteventmarker(2)
    @pyqtSlot(int)
    def seteventmarker3(self,_):
        self.seteventmarker(3)

    def seteventmarker(self,m):
        if m == 0 and self.marker1typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker1typeComboBox.currentIndex()])
        if m == 1 and self.marker2typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker2typeComboBox.currentIndex()])
        if m == 2 and self.marker3typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker3typeComboBox.currentIndex()])
        if m == 3 and self.marker4typeComboBox.currentIndex() != 0:
            aw.qmc.EvalueMarker[m] = str(self.markervals[self.marker4typeComboBox.currentIndex()])
        aw.qmc.redraw()

    @pyqtSlot(bool)
    def setcoloreventline0(self,_):
        self.setcoloreventline(0)
    @pyqtSlot(bool)
    def setcoloreventline1(self,_):
        self.setcoloreventline(1)
    @pyqtSlot(bool)
    def setcoloreventline2(self,_):
        self.setcoloreventline(2)
    @pyqtSlot(bool)
    def setcoloreventline3(self,_):
        self.setcoloreventline(3)
    
    def setcoloreventline(self,b):
        colorf = aw.colordialog(QColor(aw.qmc.EvalueColor[b]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.EvalueColor[b] = colorname
            aw.updateSliderColors()
            self.updateStyleTab()
            aw.qmc.redraw()

    @pyqtSlot(bool)
    def setcoloreventtext0(self,_):
        self.setcoloreventtext(0)
    @pyqtSlot(bool)
    def setcoloreventtext1(self,_):
        self.setcoloreventtext(1)
    @pyqtSlot(bool)
    def setcoloreventtext2(self,_):
        self.setcoloreventtext(2)
    @pyqtSlot(bool)
    def setcoloreventtext3(self,_):
        self.setcoloreventtext(3)
    
    def setcoloreventtext(self,b):
        colorf = aw.colordialog(QColor(aw.qmc.EvalueTextColor[b]))
        if colorf.isValid():
            colorname = str(colorf.name())
            aw.qmc.EvalueTextColor[b] = colorname
            aw.updateSliderColors()
            self.updateStyleTab()
            aw.qmc.redraw()

    @pyqtSlot(int)
    def setbuttonlistmaxlen(self,_):
        self.buttonlistmaxlen = self.nbuttonsSpinBox.value()

    def createEventbuttonTable(self):
        self.nbuttonsSpinBox.setValue(self.buttonlistmaxlen)
        nbuttons = len(self.extraeventstypes)

        # self.eventbuttontable.clear() # this crashes Ubuntu 16.04
#        if ndata != 0:
#            self.eventbuttontable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
#        self.eventbuttontable.clearSelection() # this seems to work also for Ubuntu 16.04

        self.eventbuttontable.setRowCount(nbuttons)
        self.eventbuttontable.setColumnCount(10)
        self.eventbuttontable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None),
                                                         QApplication.translate("Table","Description",None),
                                                         QApplication.translate("Table","Type",None),
                                                         QApplication.translate("Table","Value",None),
                                                         QApplication.translate("Table","Action",None),
                                                         QApplication.translate("Table","Documentation",None),
                                                         QApplication.translate("Table","Visibility",None),
                                                         QApplication.translate("Table","Color",None),
                                                         QApplication.translate("Table","Text Color",None),""])
        self.eventbuttontable.setAlternatingRowColors(True)
        self.eventbuttontable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eventbuttontable.setSelectionBehavior(QTableWidget.SelectRows)
        self.eventbuttontable.setSelectionMode(QTableWidget.SingleSelection)
        self.eventbuttontable.setShowGrid(True)

        self.eventbuttontable.verticalHeader().setSectionResizeMode(2)

        #Enable Drag Sorting
        self.eventbuttontable.setDragEnabled(True)
        self.eventbuttontable.verticalHeader().setSectionsMovable(True)
        self.eventbuttontable.verticalHeader().setDragDropMode(QTableWidget.InternalMove)

        visibility = [QApplication.translate("ComboBox","OFF",None),
                      QApplication.translate("ComboBox","ON",None)]

        std_extra_events = [self.etype0.text(),self.etype1.text(),self.etype2.text(),self.etype3.text(),"--"]
        std_extra_events += [uchr(177) + e for e in std_extra_events[:-1]] # chr(241)
        std_extra_events.insert(0,QApplication.translate("Label", "")) # we prepend the empty item that does not create an event entry


        for i in range(nbuttons):
            #label
            labeledit = QLineEdit(u(self.extraeventslabels[i]).replace(chr(10),"\\n"))
            labeledit.editingFinished.connect(self.setlabeleventbutton)

            #Description
            descriptionedit = QLineEdit(u(self.extraeventsdescriptions[i]))
            descriptionedit.editingFinished.connect(self.setdescriptioneventbutton)

            #Type
            typeComboBox = MyQComboBox()
            typeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            typeComboBox.addItems(std_extra_events)
            if self.extraeventstypes[i] == 9:  # we add an offset of +1 here to jump over the new EVENT entry
                idx = 5
            elif self.extraeventstypes[i] == 4:
                idx = 0
            else:
                idx = self.extraeventstypes[i]+1

            typeComboBox.setCurrentIndex(idx)
            typeComboBox.currentIndexChanged.connect(self.settypeeventbutton)

            #Values
            valueEdit = QLineEdit()
#            valueEdit.setValidator(QRegExpValidator(QRegExp(r"^100|\-?\d?\d?$"),self)) # QRegExp(r"^100|\d?\d?$"),self))
            valueEdit.setValidator(QIntValidator(-999, 999, valueEdit))
            valueEdit.setText(aw.qmc.eventsvalues(self.extraeventsvalues[i]))
            valueEdit.setAlignment(Qt.AlignRight)
            valueEdit.editingFinished.connect(self.setvalueeventbutton)

            #Action
            actionComboBox = MyQComboBox()
            actionComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            actionComboBox.addItems(["",
                                     QApplication.translate("ComboBox","Serial Command",None),
                                     QApplication.translate("ComboBox","Call Program",None),
                                     QApplication.translate("ComboBox","Multiple Event",None),
                                     QApplication.translate("ComboBox","Modbus Command",None),
                                     QApplication.translate("ComboBox","DTA Command",None),
                                     QApplication.translate("ComboBox","IO Command",None),
                                     QApplication.translate("ComboBox","Hottop Heater",None),
                                     QApplication.translate("ComboBox","Hottop Fan",None),
                                     QApplication.translate("ComboBox","Hottop Command",None),
                                     QApplication.translate("ComboBox","p-i-d",None),
                                     QApplication.translate("ComboBox","Fuji Command",None),
                                     QApplication.translate("ComboBox","PWM Command",None),
                                     QApplication.translate("ComboBox","VOUT Command",None),
                                     QApplication.translate("ComboBox","S7 Command",None),
                                     QApplication.translate("ComboBox","Aillio R1 Heater",None),
                                     QApplication.translate("ComboBox","Aillio R1 Fan",None),
                                     QApplication.translate("ComboBox","Aillio R1 Drum",None),
                                     QApplication.translate("ComboBox","Aillio R1 Command",None),
                                     QApplication.translate("ComboBox","Artisan Command",None),
                                     QApplication.translate("ComboBox","RC Command",None)])
            act = self.extraeventsactions[i]
            if act > 7:
                act = act - 1
            actionComboBox.setCurrentIndex(act)
            actionComboBox.currentIndexChanged.connect(self.setactioneventbutton)

            #Action Description
            actiondescriptionedit = QLineEdit(u(self.extraeventsactionstrings[i]))
            actiondescriptionedit.editingFinished.connect(self.setactiondescriptioneventbutton)

            #Visibility
            visibilityComboBox =  MyQComboBox()
            visibilityComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            visibilityComboBox.addItems(visibility)
            visibilityComboBox.setCurrentIndex(self.extraeventsvisibility[i])
            visibilityComboBox.currentIndexChanged.connect(self.setvisibilitytyeventbutton)
            #Color
            self.colorButton = QPushButton("Select")
            self.colorButton.setFocusPolicy(Qt.NoFocus)
            self.colorButton.clicked.connect(self.setbuttoncolor)
            label = u(self.extraeventslabels[i])[:]
            et = self.extraeventstypes[i]
            if et > 4 and et < 9:
                et = et - 5
            if et < 4:
                label = label.replace("\\t",aw.qmc.etypes[et])
            self.colorButton.setText(label)
            self.colorButton.setStyleSheet("background-color: %s; color: %s;"%(self.extraeventbuttoncolor[i],self.extraeventbuttontextcolor[i]))
            #Text Color
            self.colorTextButton = QPushButton("Select")
            self.colorTextButton.setFocusPolicy(Qt.NoFocus)
            self.colorTextButton.clicked.connect(self.setbuttontextcolor)
            self.colorTextButton.setText(label)
            self.colorTextButton.setStyleSheet("background-color: %s; color: %s;"%(self.extraeventbuttoncolor[i],self.extraeventbuttontextcolor[i]))
            #Empty Cell
            emptyCell = QLabel("")
            #add widgets to the table
            self.eventbuttontable.setCellWidget(i,0,labeledit)
            self.eventbuttontable.setCellWidget(i,1,descriptionedit)
            self.eventbuttontable.setCellWidget(i,2,typeComboBox)
            self.eventbuttontable.setCellWidget(i,3,valueEdit)
            self.eventbuttontable.setCellWidget(i,4,actionComboBox)
            self.eventbuttontable.setCellWidget(i,5,actiondescriptionedit)
            self.eventbuttontable.setCellWidget(i,6,visibilityComboBox)
            self.eventbuttontable.setCellWidget(i,7,self.colorButton)
            self.eventbuttontable.setCellWidget(i,8,self.colorTextButton)
            self.eventbuttontable.setCellWidget(i,9,emptyCell)

        self.eventbuttontable.horizontalHeader().setStretchLastSection(False)
        self.eventbuttontable.resizeColumnsToContents()
        self.eventbuttontable.horizontalHeader().setStretchLastSection(True)
        self.eventbuttontable.setColumnWidth(0,70)
        self.eventbuttontable.setColumnWidth(1,80)
        self.eventbuttontable.setColumnWidth(2,100)
        self.eventbuttontable.setColumnWidth(3,50)
        self.eventbuttontable.setColumnWidth(4,150)
        self.eventbuttontable.setColumnWidth(5,100)
        self.eventbuttontable.setColumnWidth(6,80)
        self.eventbuttontable.setColumnWidth(7,80)
        self.eventbuttontable.setColumnWidth(8,80)


        # remember the columnwidth
        for i in range(len(aw.eventbuttontablecolumnwidths)):
            try:
                self.eventbuttontable.setColumnWidth(i,aw.eventbuttontablecolumnwidths[i])
            except Exception:
                pass

    @pyqtSlot(bool)
    def copyEventButtonTabletoClipboard(self,_=False):
        nrows = self.eventbuttontable.rowCount() 
        ncols = self.eventbuttontable.columnCount() - 1 #there is a dummy column at the end on the right
        clipboard = ""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            tbl = prettytable.PrettyTable()
            fields = []
            fields.append(u(" "))  # this column shows the row number
            for c in range(ncols):
                fields.append(u(self.eventbuttontable.horizontalHeaderItem(c).text()))
            tbl.field_names = fields
            for r in range(nrows):
                rows = []
                rows.append(u(r+1))
                rows.append(u(self.eventbuttontable.cellWidget(r,0).text()))
                rows.append(u(self.eventbuttontable.cellWidget(r,1).text()))
                rows.append(u(self.eventbuttontable.cellWidget(r,2).currentText()))
                rows.append(u(self.eventbuttontable.cellWidget(r,3).text()))
                rows.append(u(self.eventbuttontable.cellWidget(r,4).currentText()))
                rows.append(u(self.eventbuttontable.cellWidget(r,5).text()))
                rows.append(u(self.eventbuttontable.cellWidget(r,6).currentText()))
                rows.append(u(self.eventbuttontable.cellWidget(r,7).palette().button().color().name()))
                rows.append(u(self.eventbuttontable.cellWidget(r,8).palette().button().color().name()))
                tbl.add_row(rows)
            clipboard = tbl.get_string()
        else:
            clipboard += u(" ") + '\t'  # this column shows the row number
            for c in range(ncols):
                clipboard += u(self.eventbuttontable.horizontalHeaderItem(c).text())
                if c != (ncols-1):
                    clipboard += '\t'
            clipboard += '\n'
            for r in range(nrows):
                clipboard += u(r+1) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,0).text()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,1).text()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,2).currentText()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,3).text()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,4).currentText()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,5).text()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,6).currentText()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,7).palette().button().color().name()) + '\t'
                clipboard += u(self.eventbuttontable.cellWidget(r,8).palette().button().color().name()) + '\n'
        # copy to the system clipboard
        sys_clip = QApplication.clipboard()
        sys_clip.setText(clipboard)
        aw.sendmessage(QApplication.translate("Message","Event Button table copied to clipboard",None))


    def savetableextraeventbutton(self):
        maxButton = len(self.extraeventstypes)
        #Clean Lists:
        #Labels
        aw.extraeventslabels         = [None] * maxButton
        #Description
        aw.extraeventsdescriptions   = [None] * maxButton
        #Types
        aw.extraeventstypes          = [None] * maxButton
        #Values
        aw.extraeventsvalues         = [None] * maxButton
        #Actions
        aw.extraeventsactions        = [None] * maxButton
        #Action Description
        aw.extraeventsactionstrings  = [None] * maxButton
        #Visibility
        aw.extraeventsvisibility     = [None] * maxButton
        #Color
        aw.extraeventbuttoncolor     = [None] * maxButton
        #Text Color
        aw.extraeventbuttontextcolor = [None] * maxButton

        #Sorting buttons based on the visualRow
        for i in range(maxButton):
            visualIndex = self.eventbuttontable.visualRow(i)

            #Labels
            aw.extraeventslabels[visualIndex]         = self.extraeventslabels[i]
            #Description
            aw.extraeventsdescriptions[visualIndex]   = self.extraeventsdescriptions[i]
            #Types
            aw.extraeventstypes[visualIndex]          = self.extraeventstypes[i]
            #Values
            aw.extraeventsvalues[visualIndex]         = self.extraeventsvalues[i]
            #Actions
            aw.extraeventsactions[visualIndex]        = self.extraeventsactions[i]
            #Action Description
            aw.extraeventsactionstrings[visualIndex]  = self.extraeventsactionstrings[i]
            #Visibility
            aw.extraeventsvisibility[visualIndex]     = self.extraeventsvisibility[i]
            #Color
            aw.extraeventbuttoncolor[visualIndex]     = self.extraeventbuttoncolor[i]
            #Text Color
            aw.extraeventbuttontextcolor[visualIndex] = self.extraeventbuttontextcolor[i]

        aw.buttonlistmaxlen = self.buttonlistmaxlen
        #Apply Event Button Changes
        aw.settooltip()
        aw.realignbuttons()
        aw.update_extraeventbuttons_visibility()

    @pyqtSlot()
    def setlabeleventbutton(self):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),0)
        if i is not None:
            labeledit = self.eventbuttontable.cellWidget(i,0)
            label = u(labeledit.text())
            label = label.replace("\\n", chr(10))
    
            if i < len(self.extraeventslabels):
                et = self.extraeventstypes[i]
                if et > 4 and et < 9:
                    et = et - 5
                self.extraeventslabels[i] = label
                if et < 4:
                    label = label[:].replace("\\t",aw.qmc.etypes[et])
    
            #Update Color Buttons
            self.eventbuttontable.cellWidget(i,7).setText(label)
            self.eventbuttontable.cellWidget(i,8).setText(label)

    @pyqtSlot()
    def setdescriptioneventbutton(self):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),1)
        if i is not None:
            descriptionedit = self.eventbuttontable.cellWidget(i,1)
            if i < len(self.extraeventsdescriptions):
                self.extraeventsdescriptions[i] = u(descriptionedit.text())

    @pyqtSlot(int)
    def settypeeventbutton(self,_):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),2)
        if i is not None:
            typecombobox = self.eventbuttontable.cellWidget(i,2)
            evType = typecombobox.currentIndex() - 1 # we remove again the offset of 1 here to jump over the new EVENT entry
            if i < len(self.extraeventstypes):
                if evType == -1:
                    evType = 4 # and map the first entry to 4
                elif evType == 4:
                    evType = 9 # and map the entry 4 to 9
                self.extraeventstypes[i] = evType
    
    @pyqtSlot()
    def setvalueeventbutton(self):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),3)
        if i is not None:
            valueedit = self.eventbuttontable.cellWidget(i,3)
            if i < len(self.extraeventsvalues):
                self.extraeventsvalues[i] = aw.qmc.str2eventsvalue(str(valueedit.text()))
    
    @pyqtSlot(int)
    def setactioneventbutton(self,_):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),4)
        if i is not None:
            actioncombobox = self.eventbuttontable.cellWidget(i,4)
            if i < len(self.extraeventsactions):
                self.extraeventsactions[i] = actioncombobox.currentIndex()
                if self.extraeventsactions[i] > 6: # increase action type as 7=CallProgramWithArg is not available for buttons
                    self.extraeventsactions[i] = self.extraeventsactions[i] + 1

    @pyqtSlot()
    def setactiondescriptioneventbutton(self):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),5)
        if i is not None:
            actiondescriptionedit = self.eventbuttontable.cellWidget(i,5)
            if i < len(self.extraeventsactionstrings):
                self.extraeventsactionstrings[i] = u(actiondescriptionedit.text())

    @pyqtSlot(int)
    def setvisibilitytyeventbutton(self,_):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),6)
        if i is not None:
            actioncombobox = self.eventbuttontable.cellWidget(i,6)
            if i < len(self.extraeventsvisibility):
                self.extraeventsvisibility[i] = actioncombobox.currentIndex()

    @pyqtSlot(bool)
    def setbuttoncolor(self,_):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),7)
        if i is not None and i < len(self.extraeventbuttoncolor):
            colorf = aw.colordialog(QColor(self.extraeventbuttoncolor[i]))
            if colorf.isValid():
                self.extraeventbuttoncolor[i] = str(colorf.name())
                textColor = self.extraeventbuttontextcolor[i]
                backColor =  self.extraeventbuttoncolor[i]
                label = self.extraeventslabels[i]
                style = "background-color: %s; color: %s;"%(backColor,textColor)
                self.eventbuttontable.cellWidget(i,7).setStyleSheet(style)
                self.eventbuttontable.cellWidget(i,8).setStyleSheet(style)
                aw.checkColors([(QApplication.translate("Label","Event button",None)+" "+ u(label), backColor, " "+QApplication.translate("Label","its text",None), textColor)])

    @pyqtSlot(bool)
    def setbuttontextcolor(self,_):
        i = aw.findWidgetsRow(self.eventbuttontable,self.sender(),8)
        if i is not None and i < len(self.extraeventbuttontextcolor):
            colorf = aw.colordialog(QColor(self.extraeventbuttontextcolor[i]))
            if colorf.isValid():
                self.extraeventbuttontextcolor[i] = str(colorf.name())
                textColor = self.extraeventbuttontextcolor[i]
                backColor =  self.extraeventbuttoncolor[i]
                label = self.extraeventslabels[i]
                style = "background-color: %s; color: %s;"%(backColor,textColor)
                self.eventbuttontable.cellWidget(i,7).setStyleSheet(style)
                self.eventbuttontable.cellWidget(i,8).setStyleSheet(style)
                aw.checkColors([(QApplication.translate("Label","Event button",None)+" "+ u(label), backColor, " "+QApplication.translate("Label","its text",None),textColor)])

    def disconnectTableItemActions(self):
        for x in range(self.eventbuttontable.rowCount()):
            try:
                self.eventbuttontable.cellWidget(x,0).editingFinished.disconnect() # label edit
                self.eventbuttontable.cellWidget(x,1).editingFinished.disconnect() # description edit
                self.eventbuttontable.cellWidget(x,2).currentIndexChanged.disconnect() # type combo
                self.eventbuttontable.cellWidget(x,3).editingFinished.disconnect() # value edit
                self.eventbuttontable.cellWidget(x,4).currentIndexChanged.disconnect() # action combo
                self.eventbuttontable.cellWidget(x,5).editingFinished.disconnect() # action description
                self.eventbuttontable.cellWidget(x,6).currentIndexChanged.disconnect() # visibility combo
                self.eventbuttontable.cellWidget(x,7).clicked.disconnect() # color button
                self.eventbuttontable.cellWidget(x,8).clicked.disconnect() # color text button
            except:
                pass

    @pyqtSlot(bool)
    def delextraeventbutton(self,_):
        self.disconnectTableItemActions() # we ensure that signals from to be deleted items are not fired anymore
        bindex = len(self.extraeventstypes)-1
        selected = self.eventbuttontable.selectedRanges()

        if len(selected) > 0:
            bindex = selected[0].topRow()

        if bindex >= 0:
            self.extraeventslabels.pop(bindex)
            self.extraeventsdescriptions.pop(bindex)
            self.extraeventstypes.pop(bindex)
            self.extraeventsvalues.pop(bindex)
            self.extraeventsactions.pop(bindex)
            self.extraeventsactionstrings.pop(bindex)
            self.extraeventsvisibility.pop(bindex)
            self.extraeventbuttoncolor.pop(bindex)
            self.extraeventbuttontextcolor.pop(bindex)

            self.createEventbuttonTable()

    @pyqtSlot(bool)
    def addextraeventbuttonSlot(self,_):
        self.insertextraeventbutton()

    @pyqtSlot(bool)
    def insertextraeventbuttonSlot(self,_):
        self.insertextraeventbutton(True)

    def insertextraeventbutton(self,insert=False):
        if len(self.extraeventstypes) >= aw.buttonlistmaxlen * 4: # max 4 rows of buttons of buttonlistmaxlen
            return

        bindex = len(self.extraeventstypes)
        selected = self.eventbuttontable.selectedRanges()

        # defaults for new entries
        event_description = ""
        event_type = 4
        event_value = 0
        event_action = 0
        event_string = ""
        event_visibility = 1
        event_buttoncolor = "#808080"
        event_textcolor = "white"
        event_label = "E"
        
        if len(selected) > 0:
            selected_idx = selected[0].topRow()
            if insert:
                bindex = selected_idx
            try:
                event_description = self.extraeventsdescriptions[selected_idx]
                event_type = self.extraeventstypes[selected_idx]
                event_value = self.extraeventsvalues[selected_idx]
                event_action = self.extraeventsactions[selected_idx]
                event_string = self.extraeventsactionstrings[selected_idx]
                event_visibility = self.extraeventsvisibility[selected_idx]
                event_buttoncolor = self.extraeventbuttoncolor[selected_idx]
                event_textcolor = self.extraeventbuttontextcolor[selected_idx]
                event_label = self.extraeventslabels[selected_idx]
            except:
                pass

        if bindex >= 0:
            self.extraeventsdescriptions.insert(bindex,event_description)
            self.extraeventstypes.insert(bindex,event_type)
            self.extraeventsvalues.insert(bindex,event_value)
            self.extraeventsactions.insert(bindex,event_action)
            self.extraeventsactionstrings.insert(bindex,event_string)
            self.extraeventsvisibility.insert(bindex,event_visibility)
            self.extraeventbuttoncolor.insert(bindex,event_buttoncolor)
            self.extraeventbuttontextcolor.insert(bindex,event_textcolor)
            self.extraeventslabels.insert(bindex,event_label)

            self.createEventbuttonTable()

    @pyqtSlot(int)
    def eventsbuttonflagChanged(self,_):
        if self.eventsbuttonflag.isChecked():
            aw.button_11.setVisible(True)
            aw.eventsbuttonflag = 1
        else:
            aw.button_11.setVisible(False)
            aw.eventsbuttonflag = 0

    @pyqtSlot(int)
    def eventsclampflagChanged(self,_):
        if self.eventsclampflag.isChecked():
            aw.qmc.clampEvents = True
        else:
            aw.qmc.clampEvents = False
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def eventslabelsflagChanged(self,_):
        if self.eventslabelsflag.isChecked():
            aw.qmc.renderEventsDescr = True
        else:
            aw.qmc.renderEventsDescr = False
        aw.qmc.redraw(recomputeAllDeltas=False)
        
    @pyqtSlot(int)
    def annotationsflagChanged(self,_):
        if self.annotationsflagbox.isChecked():
            aw.qmc.annotationsflag = 1
        else:
            aw.qmc.annotationsflag = 0
        aw.qmc.redraw(recomputeAllDeltas=False)
        
    @pyqtSlot(int)
    def showeventsonbtChanged(self,_):  
        if self.showeventsonbtbox.isChecked():
            aw.qmc.showeventsonbt = True
        else:
            aw.qmc.showeventsonbt = False
        aw.qmc.l_event_flags_dict = {} # clear the custom event flag position cache
        aw.qmc.redraw(recomputeAllDeltas=False)
    
    @pyqtSlot(int)
    def changeShowEtypes0(self,_):
        self.changeShowEtypes(0)
    @pyqtSlot(int)
    def changeShowEtypes1(self,_):
        self.changeShowEtypes(1)
    @pyqtSlot(int)
    def changeShowEtypes2(self,_):
        self.changeShowEtypes(2)
    @pyqtSlot(int)
    def changeShowEtypes3(self,_):
        self.changeShowEtypes(3)
    
    def changeShowEtypes(self,etype):
        aw.qmc.showEtypes[etype] = not aw.qmc.showEtypes[etype]
        aw.qmc.redraw(recomputeAllDeltas=False)
        
    @pyqtSlot(int)
    def minieventsflagChanged(self,_):
        if self.minieventsflag.isChecked():
            aw.minieventsflag = 1
        else:
            aw.minieventsflag = 0
        if aw.qmc.flagon:
            aw.update_minieventline_visibility()

    @pyqtSlot(int)
    def eventsGraphTypeflagChanged(self,_):
        aw.qmc.eventsGraphflag = self.bartypeComboBox.currentIndex() - 1
        if aw.qmc.eventsGraphflag > 1:
            self.eventsclampflag.setEnabled(True)
        else:
            self.eventsclampflag.setEnabled(False)
        if aw.qmc.eventsGraphflag == -1:
            aw.qmc.eventsGraphflag = 0
            aw.qmc.eventsshowflag = 0
        else:
            aw.qmc.eventsshowflag = 1
        aw.qmc.redraw(recomputeAllDeltas=False)

    def saveSliderSettings(self):
        aw.eventslidervisibilities[0] = int(self.E1visibility.isChecked())
        aw.eventslidervisibilities[1] = int(self.E2visibility.isChecked())
        aw.eventslidervisibilities[2] = int(self.E3visibility.isChecked())
        aw.eventslidervisibilities[3] = int(self.E4visibility.isChecked())
        aw.eventslideractions[0] = int(self.E1action.currentIndex())
        aw.eventslideractions[1] = int(self.E2action.currentIndex())
        aw.eventslideractions[2] = int(self.E3action.currentIndex())
        aw.eventslideractions[3] = int(self.E4action.currentIndex())
        aw.eventslidercommands[0] = u(self.E1command.text())
        aw.eventslidercommands[1] = u(self.E2command.text())
        aw.eventslidercommands[2] = u(self.E3command.text())
        aw.eventslidercommands[3] = u(self.E4command.text())
        aw.eventslideroffsets[0] = int(self.E1offset.value())
        aw.eventslideroffsets[1] = int(self.E2offset.value())
        aw.eventslideroffsets[2] = int(self.E3offset.value())
        aw.eventslideroffsets[3] = int(self.E4offset.value())
        aw.eventsliderfactors[0] = float(self.E1factor.value())
        if aw.eventsliderfactors[0] == 0: # a zero does not make much sense and might be a user error
            aw.eventsliderfactors[0] = 1.0
        aw.eventsliderfactors[1] = float(self.E2factor.value())
        if aw.eventsliderfactors[1] == 1: # a zero does not make much sense and might be a user error
            aw.eventsliderfactors[1] = 1.0
        aw.eventsliderfactors[2] = float(self.E3factor.value())
        if aw.eventsliderfactors[2] == 1: # a zero does not make much sense and might be a user error
            aw.eventsliderfactors[2] = 1.0
        aw.eventsliderfactors[3] = float(self.E4factor.value())
        if aw.eventsliderfactors[3] == 1: # a zero does not make much sense and might be a user error
            aw.eventsliderfactors[3] = 1.0
        aw.eventslidermin[0] = int(min(self.E1_min.value(),self.E1_max.value()))
        aw.eventslidermin[1] = int(min(self.E2_min.value(),self.E2_max.value()))
        aw.eventslidermin[2] = int(min(self.E3_min.value(),self.E3_max.value()))
        aw.eventslidermin[3] = int(min(self.E4_min.value(),self.E4_max.value()))
        aw.eventslidermax[0] = int(max(self.E1_min.value(),self.E1_max.value()))
        aw.eventslidermax[1] = int(max(self.E2_min.value(),self.E2_max.value()))
        aw.eventslidermax[2] = int(max(self.E3_min.value(),self.E3_max.value()))
        aw.eventslidermax[3] = int(max(self.E4_min.value(),self.E4_max.value()))
        aw.eventslidercoarse[0] = int(self.E1slider_coarse.isChecked())
        aw.eventslidercoarse[1] = int(self.E2slider_coarse.isChecked())
        aw.eventslidercoarse[2] = int(self.E3slider_coarse.isChecked())
        aw.eventslidercoarse[3] = int(self.E4slider_coarse.isChecked())
        aw.eventslidertemp[0] = int(self.E1slider_temp.isChecked())
        aw.eventslidertemp[1] = int(self.E2slider_temp.isChecked())
        aw.eventslidertemp[2] = int(self.E3slider_temp.isChecked())
        aw.eventslidertemp[3] = int(self.E4slider_temp.isChecked())
        aw.eventsliderunits[0] = u(self.E1unit.text())
        aw.eventsliderunits[1] = u(self.E2unit.text())
        aw.eventsliderunits[2] = u(self.E3unit.text())
        aw.eventsliderunits[3] = u(self.E4unit.text())
        aw.updateSliderMinMax()
        aw.slidersAction.setEnabled(any(aw.eventslidervisibilities) or aw.pidcontrol.svSlider)

    def saveQuantifierSettings(self):
        aw.clusterEventsFlag = bool(self.clusterEventsFlag.isChecked())
        aw.eventquantifieractive[0] = int(self.E1active.isChecked())
        aw.eventquantifieractive[1] = int(self.E2active.isChecked())
        aw.eventquantifieractive[2] = int(self.E3active.isChecked())
        aw.eventquantifieractive[3] = int(self.E4active.isChecked())
        aw.eventquantifiercoarse[0] = int(self.E1coarse.isChecked())
        aw.eventquantifiercoarse[1] = int(self.E2coarse.isChecked())
        aw.eventquantifiercoarse[2] = int(self.E3coarse.isChecked())
        aw.eventquantifiercoarse[3] = int(self.E4coarse.isChecked())
        aw.eventquantifiersource[0] = int(self.E1SourceComboBox.currentIndex())
        aw.eventquantifiersource[1] = int(self.E2SourceComboBox.currentIndex())
        aw.eventquantifiersource[2] = int(self.E3SourceComboBox.currentIndex())
        aw.eventquantifiersource[3] = int(self.E4SourceComboBox.currentIndex())
        aw.eventquantifiermin[0] = int(self.E1min.value())
        aw.eventquantifiermin[1] = int(self.E2min.value())
        aw.eventquantifiermin[2] = int(self.E3min.value())
        aw.eventquantifiermin[3] = int(self.E4min.value())
        aw.eventquantifiermax[0] = int(self.E1max.value())
        aw.eventquantifiermax[1] = int(self.E2max.value())
        aw.eventquantifiermax[2] = int(self.E3max.value())
        aw.eventquantifiermax[3] = int(self.E4max.value())
        aw.computeLinespaces()

    def saveAnnotationsSettings(self):
        checkedvisibilities = [0,0,0,0]
        #the following line does not work
        #checkedvisibilities = [int(self.E1AnnoVisibility.isChecked()),int(self.E3AnnoVisibility.isChecked()),int(self.E3AnnoVisibility.isChecked()),int(self.E4AnnoVisibility.isChecked())]
        checkedvisibilities[0] = int(self.E1AnnoVisibility.isChecked())
        checkedvisibilities[1] = int(self.E2Annovisibility.isChecked())
        checkedvisibilities[2] = int(self.E3Annovisibility.isChecked())
        checkedvisibilities[3] = int(self.E4Annovisibility.isChecked())
        if aw.qmc.specialeventannovisibilities == checkedvisibilities:
            redraw = False
        else:
            redraw = True
        aw.qmc.specialeventannovisibilities[0] = int(self.E1AnnoVisibility.isChecked())
        aw.qmc.specialeventannovisibilities[1] = int(self.E2Annovisibility.isChecked())
        aw.qmc.specialeventannovisibilities[2] = int(self.E3Annovisibility.isChecked())
        aw.qmc.specialeventannovisibilities[3] = int(self.E4Annovisibility.isChecked())
        if redraw:
            aw.qmc.redraw(recomputeAllDeltas=False)
    #the inverse to restoreState
    def storeState(self):
        # event configurations
        self.eventsbuttonflagstored = aw.eventsbuttonflag
        self.eventsshowflagstored = aw.qmc.eventsshowflag
        self.annotationsflagstored = aw.qmc.annotationsflag
        self.showeventsonbtstored = aw.qmc.showeventsonbt
        self.showEtypesstored = aw.qmc.showEtypes[:]
        self.minieventsflagstored = aw.minieventsflag
        self.eventsGraphflagstored = aw.qmc.eventsGraphflag
        self.etypesstored = aw.qmc.etypes
        self.etypeComboBoxstored = aw.etypeComboBox
        self.autoChargeFlagstored = aw.qmc.autoChargeFlag
        self.autoDropFlagstored = aw.qmc.autoDropFlag
        self.markTPFlagstored = aw.qmc.markTPflag
        # buttons
        self.extraeventslabels = aw.extraeventslabels[:]
        self.extraeventsdescriptions = aw.extraeventsdescriptions[:]
        self.extraeventstypes = aw.extraeventstypes[:]
        self.extraeventsvalues = aw.extraeventsvalues[:]
        self.extraeventsactions = aw.extraeventsactions[:]
        self.extraeventsactionstrings = aw.extraeventsactionstrings[:]
        self.extraeventsvisibility = aw.extraeventsvisibility[:]
        self.extraeventbuttoncolor = aw.extraeventbuttoncolor[:]
        self.extraeventbuttontextcolor = aw.extraeventbuttontextcolor[:]
        self.buttonlistmaxlen = aw.buttonlistmaxlen
        # sliders
        self.eventslidervisibilities = aw.eventslidervisibilities[:]
        self.eventslideractions = aw.eventslideractions[:]
        self.eventslidercommands = aw.eventslidercommands[:]
        self.eventslideroffsets = aw.eventslideroffsets[:]
        self.eventsliderfactors = aw.eventsliderfactors[:]
        self.eventslidermin = aw.eventslidermin[:]
        self.eventslidermax = aw.eventslidermax[:]
        self.eventslidercoarse = aw.eventslidercoarse[:]
        self.eventslidertemp = aw.eventslidertemp[:]
        self.eventsliderunits = aw.eventsliderunits[:]
        # quantifiers
        self.eventquantifieractive = aw.eventquantifieractive[:]
        self.eventquantifiersource = aw.eventquantifiersource[:]
        self.eventquantifiermin = aw.eventquantifiermin[:]
        self.eventquantifiermax = aw.eventquantifiermax[:]
        self.eventquantifiercoarse = aw.eventquantifiercoarse[:]
        # palettes
        self.buttonpalette = aw.buttonpalette[:]
        self.buttonpalettemaxlen = aw.buttonpalettemaxlen
        # styles
        self.EvalueColor = aw.qmc.EvalueColor[:]
        self.EvalueMarker = aw.qmc.EvalueMarker[:]
        self.Evaluelinethickness = aw.qmc.Evaluelinethickness[:]
        self.Evaluealpha = aw.qmc.Evaluealpha[:]
        self.EvalueMarkerSize = aw.qmc.EvalueMarkerSize[:]
        # event annotations
        self.specialeventannovisibilities = aw.qmc.specialeventannovisibilities[:]
        self.specialeventannotations = aw.qmc.specialeventannotations[:]

    #called from Cancel button
    @pyqtSlot()
    def restoreState(self):
        # event configurations
        aw.eventsbuttonflag = self.eventsbuttonflagstored
        aw.qmc.eventsshowflag = self.eventsshowflagstored
        aw.qmc.annotationsflag = self.annotationsflagstored
        aw.qmc.showeventsonbt = self.showeventsonbtstored
        aw.qmc.showEtypes = self.showEtypesstored[:]
        aw.minieventsflag = self.minieventsflagstored
        aw.qmc.eventsGraphflag = self.eventsGraphflagstored
        aw.qmc.etypes = self.etypesstored
        aw.etypeComboBox = self.etypeComboBoxstored
        aw.qmc.autoChargeFlag = self.autoChargeFlagstored
        aw.qmc.autoDropFlag = self.autoDropFlagstored
        aw.qmc.markTPflag = self.markTPFlagstored
        # buttons saved only if ok is pressed,so no restore needed
        # sliders
        aw.eventslidervisibilities = self.eventslidervisibilities
        aw.eventslideractions = self.eventslideractions
        aw.eventslidercommands = self.eventslidercommands
        aw.eventslideroffsets = self.eventslideroffsets
        aw.eventsliderfactors = self.eventsliderfactors
        aw.eventslidermin = self.eventslidermin
        aw.eventslidermax = self.eventslidermax
        aw.eventslidercoarse = self.eventslidercoarse
        aw.eventslidertemp = self.eventslidertemp
        aw.eventsliderunits = self.eventsliderunits
        # styles
        aw.qmc.EvalueColor = self.EvalueColor
        aw.qmc.EvalueMarker = self.EvalueMarker
        aw.qmc.Evaluelinethickness = self.Evaluelinethickness
        aw.qmc.Evaluealpha = self.Evaluealpha
        aw.qmc.EvalueMarkerSize = self.EvalueMarkerSize
        # event annotations
        aw.qmc.specialeventannovisibilities = self.specialeventannovisibilities[:]
        aw.qmc.specialeventannotations = self.specialeventannotations[:]
        self.close()

    #called from OK button
    @pyqtSlot()
    def updatetypes(self):
        try:
            self.closeHelp()
            aw.buttonsize = self.nbuttonsSizeBox.currentIndex()
            self.savetableextraeventbutton()
            # save column widths
            aw.eventbuttontablecolumnwidths = [self.eventbuttontable.columnWidth(c) for c in range(self.eventbuttontable.columnCount())]
            #save default buttons
            aw.qmc.buttonvisibility[0] = self.CHARGEbutton.isChecked()
            aw.button_8.setVisible(bool(aw.qmc.buttonvisibility[0]))
            aw.qmc.buttonvisibility[1] = self.DRYbutton.isChecked()
            aw.button_19.setVisible(bool(aw.qmc.buttonvisibility[1]))
            aw.qmc.buttonvisibility[2] = self.FCSbutton.isChecked()
            aw.button_3.setVisible(bool(aw.qmc.buttonvisibility[2]))
            aw.qmc.buttonvisibility[3] = self.FCEbutton.isChecked()
            aw.button_4.setVisible(bool(aw.qmc.buttonvisibility[3]))
            aw.qmc.buttonvisibility[4] = self.SCSbutton.isChecked()
            aw.button_5.setVisible(bool(aw.qmc.buttonvisibility[4]))
            aw.qmc.buttonvisibility[5] = self.SCEbutton.isChecked()
            aw.button_6.setVisible(bool(aw.qmc.buttonvisibility[5]))
            aw.qmc.buttonvisibility[6] = self.DROPbutton.isChecked()
            aw.button_9.setVisible(bool(aw.qmc.buttonvisibility[6]))
            aw.qmc.buttonvisibility[7] = self.COOLbutton.isChecked()
            aw.button_20.setVisible(bool(aw.qmc.buttonvisibility[7]))
            #save sliders   
            self.saveSliderSettings()
            self.saveQuantifierSettings()
            # save palettes
            aw.buttonpalette = self.buttonpalette[:]
            aw.buttonpalettemaxlen = self.buttonpalettemaxlen
            #
            aw.qmc.buttonactions[0] = self.CHARGEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[1] = self.DRYbuttonActionType.currentIndex()
            aw.qmc.buttonactions[2] = self.FCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[3] = self.FCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[4] = self.SCSbuttonActionType.currentIndex()
            aw.qmc.buttonactions[5] = self.SCEbuttonActionType.currentIndex()
            aw.qmc.buttonactions[6] = self.DROPbuttonActionType.currentIndex()
            aw.qmc.buttonactions[7] = self.COOLbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[0] = self.ONbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[1] = self.OFFbuttonActionType.currentIndex()
            aw.qmc.extrabuttonactions[2] = self.SAMPLINGbuttonActionType.currentIndex()
            aw.qmc.xextrabuttonactions[0] = self.RESETbuttonActionType.currentIndex()
            aw.qmc.xextrabuttonactions[1] = self.STARTbuttonActionType.currentIndex()
            aw.qmc.buttonactionstrings[0] = u(self.CHARGEbuttonActionString.text())
            aw.qmc.buttonactionstrings[1] = u(self.DRYbuttonActionString.text())
            aw.qmc.buttonactionstrings[2] = u(self.FCSbuttonActionString.text())
            aw.qmc.buttonactionstrings[3] = u(self.FCEbuttonActionString.text())
            aw.qmc.buttonactionstrings[4] = u(self.SCSbuttonActionString.text())
            aw.qmc.buttonactionstrings[5] = u(self.SCEbuttonActionString.text())
            aw.qmc.buttonactionstrings[6] = u(self.DROPbuttonActionString.text())
            aw.qmc.buttonactionstrings[7] = u(self.COOLbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[0] = u(self.ONbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[1] = u(self.OFFbuttonActionString.text())
            aw.qmc.extrabuttonactionstrings[2] = u(self.SAMPLINGbuttonActionString.text())
            try:
                aw.qmc.extra_event_sampling_delay = self.sampling_delays[self.SAMPLINGbuttonActionInterval.currentIndex()]
            except Exception:
                pass
            aw.qmc.xextrabuttonactionstrings[0] = u(self.RESETbuttonActionString.text())
            aw.qmc.xextrabuttonactionstrings[1] = u(self.STARTbuttonActionString.text())
            
            aw.qmc.eventslabelschars = self.eventslabelscharsSpinner.value()
            
            aw.buttonpalette_shortcuts = self.switchPaletteByNumberKey.isChecked()
            #save etypes
            if len(u(self.etype0.text())) and len(u(self.etype1.text())) and len(u(self.etype2.text())) and len(u(self.etype3.text())):
                aw.qmc.etypes[0] = u(self.etype0.text())
                aw.qmc.etypes[1] = u(self.etype1.text())
                aw.qmc.etypes[2] = u(self.etype2.text())
                aw.qmc.etypes[3] = u(self.etype3.text())
                colorPairsToCheck = []
                for i in range(len(aw.qmc.EvalueColor)):
                    colorPairsToCheck.append(
                        (aw.qmc.etypes[i] + " Event", aw.qmc.EvalueColor[i], 'Background', aw.qmc.palette['background']),
                    )                           
                    colorPairsToCheck.append(
                        (aw.qmc.etypes[i] + " Text", aw.qmc.EvalueTextColor[i], aw.qmc.etypes[i] + " Event", aw.qmc.EvalueColor[i]),
                    )   
                aw.checkColors(colorPairsToCheck)
                # update minieditor event type ComboBox
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(aw.qmc.etypes)
                #update mini editor
                aw.etypeComboBox.clear()
                aw.etypeComboBox.addItems(aw.qmc.etypes)
                #update autoCharge/Drop flag
                aw.qmc.autoChargeFlag = self.autoCharge.isChecked()
                aw.qmc.autoDropFlag = self.autoDrop.isChecked()
                aw.qmc.markTPflag = self.markTP.isChecked()
                #save quantifiers
                aw.updateSlidersProperties() # set visibility and event names on slider widgets
                # we save the current button and slider definitions to palette 0
                self.transferbuttonsto(0)
                aw.qmc.redraw(recomputeAllDeltas=False)
                aw.sendmessage(QApplication.translate("Message","Event configuration saved", None))
                self.close()
            else:
                aw.sendmessage(QApplication.translate("Message","Found empty event type box", None))
                #save quantifiers
                aw.updateSlidersProperties() # set visibility and event names on slider widgets
            #save special event annotations   
            self.saveAnnotationsSettings()
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " updatetypes(): {0}").format(str(e)),exc_tb.tb_lineno)

    def closeEvent(self,_):
        self.closeHelp()
        settings = QSettings()
        #save window geometry
        settings.setValue("EventsGeometry",self.saveGeometry())


    @pyqtSlot(bool)
    def showEventbuttonhelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = eventbuttonsHelpDlg(self)
        except:
            self.helpdialog = eventbuttonsHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    @pyqtSlot(bool)
    def showSliderHelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = eventslidersHelpDlg(self)
        except:
            self.helpdialog = eventslidersHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    @pyqtSlot(bool)
    def showEventannotationhelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = eventannotationHelpDlg(self)
        except:
            self.helpdialog = eventannotationHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    @pyqtSlot()
    def eventannotationhelp(self):
        if not aw.qmc.eventannotationhelpisOpen:
            self.helpdialog = eventannotationHelpDlg(self)
            self.helpdialog.show()
            aw.qmc.eventannotationhelpisOpen = True
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

########################################################################################
#####################  EVENT CUSTOM BUTTONS HELP DLG ###################################
########################################################################################
class eventbuttonsHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(eventbuttonsHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Event Custom Buttons Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("eventbuttonsHelpGeometry"):
            self.restoreGeometry(settings.value("eventbuttonsHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','EVENT CUSTOM BUTTONS',None)) + "</b>"
        tbl_Buttons = prettytable.PrettyTable()
        tbl_Buttons.field_names = [u(QApplication.translate('HelpDlg','COL1',None)),u(QApplication.translate('HelpDlg','COL2',None))]
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Button Label',None)),u(QApplication.translate('HelpDlg','Enter \\n to create labels with multiple lines. \\t is substituted by the event type.',None))])
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Event Description',None)),u(QApplication.translate('HelpDlg','Description of the Event to be recorded.< br>Event type Type of event to be recorded.',None))])
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Event Value',None)),u(QApplication.translate('HelpDlg','Value of event (1-100) to be recorded',None))])
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Action',None)),u(QApplication.translate('HelpDlg','Perform an action at the time of the event',None))])
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Documentation',None)),'&#160;'])
        tbl_Buttons.add_row([u(QApplication.translate('HelpDlg','Button Visibility',None)),u(QApplication.translate('HelpDlg','Hides/shows individual button',None))])
        helpstr += tbl_Buttons.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','COMMANDS',None)) + "</b>"
        tbl_Commands = prettytable.PrettyTable()
        tbl_Commands.field_names = [u(QApplication.translate('HelpDlg','Command Type',None)),u(QApplication.translate('HelpDlg','Command',None))]
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Serial',None)),u(QApplication.translate('HelpDlg','ASCII serial command or binary a2b_uu(serial command)',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Call Program',None)),u(QApplication.translate('HelpDlg','A program/script path (absolute or relative)',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Multiple Event',None)),u(QApplication.translate('HelpDlg','Adds events of other button numbers separated by a comma: 1,2,..',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Modbus',None)),u(QApplication.translate('HelpDlg','write([slaveId,registe r,value],..,[slaveId,register,value]) \nwrite register: MODBUS function 6 (int) or function 16 (float)',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','wcoil(slaveId,register,<bool>) \nwrite coil: MODB US function 5',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','wcoils(slaveId,register,[<bool>,..,<bool>]) \nwrite coils: MODBUS function 15',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','mwrite(slaveId,register,andMask,orMask) \nmask write register: MODBUS function 22',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writem(slaveId,register,value) or writem(slaveId,register,[<int>,..,<int>]) \nwrite registers: MODBUS function 16',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writeWord(slaveId,register,value) \nwrite 32bit float to two 16bit int registers: MODBUS function 16',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','S7',None)),u(QApplication.translate('HelpDlg','getDBint(<dbnumber>,<start>) \nread int from S7 DB',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','getDBfloat(<dbnumber>,<start>) \nread fl oat from S7 DB',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','setDBint(<dbnumber>,<start>,<value>) \nwrite int to S7 DB',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','setDBfloat(<dbnumber>,<start>,<value>) \nwrite float to S7 DB',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','DTA',None)),u(QApplication.translate('HelpDlg','Insert Data address : value, ex. 4701:1000 and sv is 100. \nAlways multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','IO',None)),u(QApplication.translate('HelpDlg','set(n,0 ), set(n,1), toggle(n), pulse(n,t) to set Phidget IO digital output n',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','PWM',None)),u(QApplication.translate('HelpDlg',' out(n,v), toggle(n), pulse(n,t) set digital output channel n to PWM value v (0-100) on a Phidget OUT1100 \nouthub(n,v), togglehub(n), pulsehub(n,t) on a Phidget HUB',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','VOUT',None)),u(QApplication.translate('HelpDlg','out(n,v) set analog output channel n to output voltage value v in V (eg. 5.5 for 5.5V) on a Phidget OUT1000/OUT1001/OUT1002',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Hotop',None)),u(QApplication.translate('HelpDlg','Hottop Heater: sets heater to value',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','Hottop Fan: sets fan to value',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','Hottop Command: motor(n),solenoid(n),stirrer(n),heater(h),fan(f) with n={0 ,1},h={0,..100},f={0,..10}',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','PID',None)),u(QApplication.translate('HelpDlg','p-i-d: configures PID to the values <p>;<i>;<d>',None))])
        helpstr += tbl_Commands.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("eventbuttonsHelpGeometry",self.saveGeometry())


########################################################################################
#####################  EVENT CUSTOM SLIDERS HELP DLG ###################################
########################################################################################
class eventslidersHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(eventslidersHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Event Custom Sliders Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("eventslidersHelpGeometry"):
            self.restoreGeometry(settings.value("eventslidersHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','EVENT CUSTOM SLIDERS',None)) + "</b>"
        tbl_Sliders = prettytable.PrettyTable()
        tbl_Sliders.field_names = [u(QApplication.translate('HelpDlg','Command Type',None)),u(QApplication.translate('HelpDlg','Command',None))]
        tbl_Sliders.add_row([u(QApplication.translate('HelpDlg','Event',None)),u(QApplication.translate('HelpDlg','Hide or show the corresponding slider',None))])
        tbl_Sliders.add_row([u(QApplication.translate('HelpDlg','Action',None)),u(QApplication.translate('HelpDlg','Perform an action on the slider release',None))])
        helpstr += tbl_Sliders.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "<br/><br/><b>" + u(QApplication.translate('HelpDlg','Commands',None)) + "</b>"
        tbl_Commandstop = prettytable.PrettyTable()
        tbl_Commandstop.header = False
        tbl_Commandstop.add_row([u(QApplication.translate('HelpDlg',' Command depends on the action type ("{}" is replaced by value*factor + offset)',None))])
        helpstr += tbl_Commandstop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Commands = prettytable.PrettyTable()
        tbl_Commands.field_names = [u(QApplication.translate('HelpDlg','Command Type',None)),u(QApplication.translate('HelpDlg','Command',None))]
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Serial',None)),u(QApplication.translate('HelpDlg','ASCII serial command or binary a2b_uu(serial command)',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','Modbus',None)),u(QApplication.translate('HelpDlg','write([slaveId,register,value],..,[slaveId,register,value]) \nwrite register: MODBUS function 6 (int) or function 16 (float)',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','wcoil(slaveId,register,<bool>) \nwrite coil: MODBUS function 5',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','wcoils(slaveId,register,[<bool>,..,<bool>]) \nwrite coils: MODBUS function 15',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg',' ',None)),u(QApplication.translate('HelpDlg','mwrite(slaveId,register,andMask,orMask) \nmask write register: MODBUS function 22',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writem(slaveId,register,value) or writem(slaveId,register,[<int>,..,<int>]) \nwrite registers: MODBUS function 16',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writeBCD(slaveId,register,value) or writeBCD(slaveId,register,[<int>,..,<int>]) \nwrite BCD encoded int register: MODBUS function 16 (BCD)',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writeWord(slaveId,register,value) \nwrite 32bit float to two 16bit int registers: MODBUS function 16',None))])
        tbl_Commands.add_row(['&#160;',u(QApplication.translate('HelpDlg','writes values to the registers in slaves specified by the given id',None))])
        tbl_Commands.add_row([u(QApplication.translate('HelpDlg','DTA',None)),u(QApplication.translate('HelpDlg','nsert Data address : value, ex. 4701:1000 and sv is 100. always multiply with 10 if value Unit: 0.1 / ex. 4719:0 stops heating',None))])
        helpstr += tbl_Commands.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Commandsbottom = prettytable.PrettyTable()
        tbl_Commandsbottom.header = False
        tbl_Commandsbottom.add_row([u(QApplication.translate('HelpDlg','Offset added as offset to the slider value',None))+newline+u(QApplication.translate('HelpDlg','Factor multiplicator of the slider value',None))])
        helpstr += tbl_Commandsbottom.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("eventslidersHelpGeometry",self.saveGeometry())


##########################################################################################
#####################  Event Annotation HELP DLG  ########################################
##########################################################################################
class eventannotationHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(eventannotationHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Event Annotation Help",None)) 
        self.setModal(False)

        settings = QSettings()
        if settings.contains("eventannotationHelpGeometry"):
            self.restoreGeometry(settings.value("eventannotationHelpGeometry"))
        
        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','EVENT ANNOTATIONS',None)) + "</b>"
        tbl_Annotations = prettytable.PrettyTable()
        tbl_Annotations.field_names = [u(QApplication.translate('HelpDlg','Prefix Field',None)),u(QApplication.translate('HelpDlg','Source',None)),u(QApplication.translate('HelpDlg','Example',None))]
        tbl_Annotations.add_row(['~E1',u(QApplication.translate('HelpDlg','The value of Event type 1',None)),u(QApplication.translate('HelpDlg','Air',None))])
        tbl_Annotations.add_row(['~E2',u(QApplication.translate('HelpDlg','The value of Event type 2',None)),u(QApplication.translate('HelpDlg','Drum',None))])
        tbl_Annotations.add_row(['~E3',u(QApplication.translate('HelpDlg','The value of Event type 3',None)),u(QApplication.translate('HelpDlg','Damper',None))])
        tbl_Annotations.add_row(['~E4',u(QApplication.translate('HelpDlg','The value of Event type 4',None)),u(QApplication.translate('HelpDlg','Burner',None))])
        tbl_Annotations.add_row(['~Y1',u(QApplication.translate('HelpDlg','ET value',None)),420])
        tbl_Annotations.add_row(['~Y2',u(QApplication.translate('HelpDlg','BT value',None)),372])
        tbl_Annotations.add_row(['~dCHARGE',u(QApplication.translate('HelpDlg','Number of seconds since CHARGE',None)),522])
        tbl_Annotations.add_row(['~dFCs',u(QApplication.translate('HelpDlg','Number of seconds after FCs \nBest used inside double quotes (see notes below) \nDisplays &#39;*&#39; prior to FCs',None)),47])
        tbl_Annotations.add_row(['~preFCs',u(QApplication.translate('HelpDlg','Number of seconds before FCs \nBest used inside single quotes or back ticks (see notes below) \nDisplays &#39;*&#39; after FCs',None)),50])
        tbl_Annotations.add_row(['~DTR',u(QApplication.translate('HelpDlg','Development time ratio. Note: DTR=0 before FCs \n100*(t{Event}-t{FCs})/(t{FCs}-t{CHARGE})',None)),12])
        tbl_Annotations.add_row(['~deg',u(QApplication.translate('HelpDlg','The degree symbol',None)),'\u00b0'])
        tbl_Annotations.add_row(['~mode',u(QApplication.translate('HelpDlg','Temperature mode (&#39;C&#39; or &#39;F&#39;)',None)),'F'])
        tbl_Annotations.add_row(['~degmode',u(QApplication.translate('HelpDlg','Degree symbol with Temperature mode',None)),'\u00b0C'])
        tbl_Annotations.add_row(['~quot',u(QApplication.translate('HelpDlg','Quote symbol',None)),'"'])
        tbl_Annotations.add_row(['~squot',u(QApplication.translate('HelpDlg','Single quote symbol',None)),'&#39;'])
        helpstr += tbl_Annotations.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Annotationsbottom = prettytable.PrettyTable()
        tbl_Annotationsbottom.header = False
        tbl_Annotationsbottom.add_row([u(QApplication.translate('HelpDlg','NOTES:',None))+newline+u(QApplication.translate('HelpDlg','-Event annotations apply for &#39;Step&#39;, &#39;Step+&#39;, and &#39;Combo&#39; Events settings',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Anything between double quotes " will show only after FCs. Example: "~E1 @~DTR%"',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Anything between single quotes &#39; will show only before FCs. Example: &#39;~E1 @~degmode&#39;',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Anything between back ticks ` will show only within 90 seconds before FCs. Example: &#39;~E1 `FCs~dFCs sec`&#39;',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-When combining back ticks with single or double quotes the back ticks should be inside the quotes.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Background event annotations can be seen during a roast when &#39;Annotations&#39; is checked in the Profile Background window.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Simple scaling of the fields E1, E2, E3, and E4 is possible. Use a single math operator (&#39;*&#39;, &#39;/&#39;, &#39;+&#39; or &#39;-&#39;) immediately following the field name.',None))+newline+u(QApplication.translate('HelpDlg','Examples:',None))+newline+u(QApplication.translate('HelpDlg','&#39;~E1/10&#39; will divide the E1 value by 10.',None))+newline+u(QApplication.translate('HelpDlg','&#39;~E2+5&#39; adds 5 to the the value of E2.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','-Another style of annotations allows to replace an event&#39;s numeric value with a text string. One example where this can be useful is when an event is used to record sensory milestones. The value 20 might be used for &#39;Fresh Cut Grass&#39; aroma, 50 for &#39;Hay&#39;, 80 for &#39;Baking Bread&#39;, and 100 to represent the &#39;A Point&#39;. ',None))+newline+u(QApplication.translate('HelpDlg','This form of annotation must be enclosed in curly brackets &#39;{}&#39;. The first entry must be one the event fields ~E1, ~E2, ~E3, or ~E4 followed immediately by the vertical bar &#39;|&#39;, a numeric value and the text to use for the annotation. This may be followed by additional groups of vertical bars, numeric values, and text. ',None))+newline+u(QApplication.translate('HelpDlg','The following Annotation string (without the quote marks) implements this example assuming E4 is used to record the sensory milestones. Note that the BT is added to the annotation.',None))+newline+u(QApplication.translate('HelpDlg','{~E4|20Fresh Cut Grass|50Hay|80Baking Bread|100A Point} @~Y2~degmode',None))])
        helpstr += tbl_Annotationsbottom.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;", r"&",helpstr)

        # autogenerated help pasted above
                
        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)        
        self.setLayout(hLayout)

    @pyqtSlot()
    def closeEvent(self, _):
        aw.qmc.eventannotationhelpisOpen = False
        settings = QSettings()
        #save window geometry
        settings.setValue("eventannotationHelpGeometry",self.saveGeometry())


##########################################################################
#####################  PHASES GRAPH EDIT DLG  ############################
##########################################################################

class phasesGraphDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(phasesGraphDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Roast Phases",None))
        self.setModal(True)
        # remember initial values for Cancel action
        self.phases = list(aw.qmc.phases)
        self.org_phasesbuttonflag = bool(aw.qmc.phasesbuttonflag)
        self.org_fromBackgroundflag = bool(aw.qmc.phasesfromBackgroundflag)
        self.org_watermarksflag = bool(aw.qmc.watermarksflag)
        self.org_phasesLCDflag = bool(aw.qmc.phasesLCDflag)
        self.org_autoDRYflag = bool(aw.qmc.autoDRYflag)
        self.org_autoFCsFlag = bool(aw.qmc.autoFCsFlag)
        self.org_phasesLCDmode_l = list(aw.qmc.phasesLCDmode_l)
        self.org_phasesLCDmode_all = list(aw.qmc.phasesLCDmode_all)
        #
        dryLabel = QLabel(QApplication.translate("Label", "Drying",None))
        midLabel = QLabel(QApplication.translate("Label", "Maillard",None))
        finishLabel = QLabel(QApplication.translate("Label", "Finishing",None))
        minf = QLabel(QApplication.translate("Label", "min",None))
        maxf = QLabel(QApplication.translate("Label", "max",None))
        self.startdry = QSpinBox()
        self.startdry.setAlignment(Qt.AlignRight)
        self.startdry.setMinimumWidth(80)
        self.enddry = QSpinBox()
        self.enddry.setAlignment(Qt.AlignRight)
        self.enddry.setMinimumWidth(80)
        self.startmid = QSpinBox()
        self.startmid.setAlignment(Qt.AlignRight)
        self.startmid.setMinimumWidth(80)
        self.endmid = QSpinBox()
        self.endmid.setAlignment(Qt.AlignRight)
        self.endmid.setMinimumWidth(80)
        self.startfinish = QSpinBox()
        self.startfinish.setAlignment(Qt.AlignRight)
        self.startfinish.setMinimumWidth(80)
        self.endfinish = QSpinBox()
        self.endfinish.setAlignment(Qt.AlignRight)
        self.endfinish.setMinimumWidth(80) 
        if aw.qmc.mode == "F":
            self.startdry.setSuffix(" F")
            self.enddry.setSuffix(" F")
            self.startmid.setSuffix(" F")
            self.endmid.setSuffix(" F")
            self.startfinish.setSuffix(" F")
            self.endfinish.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.startdry.setSuffix(" C")
            self.enddry.setSuffix(" C")
            self.startmid.setSuffix(" C")
            self.endmid.setSuffix(" C")
            self.startfinish.setSuffix(" C")
            self.endfinish.setSuffix(" C")
        self.startdry.setRange(0,1000)    #(min,max)
        self.enddry.setRange(0,1000)
        self.startmid.setRange(0,1000)
        self.endmid.setRange(0,1000)
        self.startfinish.setRange(0,1000)
        self.endfinish.setRange(0,1000)
        self.enddry.valueChanged.connect(self.startmid.setValue)
        self.startmid.valueChanged.connect(self.enddry.setValue)
        self.endmid.valueChanged.connect(self.startfinish.setValue)
        self.startfinish.valueChanged.connect(self.endmid.setValue)
        self.pushbuttonflag = QCheckBox(QApplication.translate("CheckBox","Auto Adjusted",None))
        self.pushbuttonflag.setChecked(bool(aw.qmc.phasesbuttonflag))
        self.pushbuttonflag.stateChanged.connect(self.pushbuttonflagChanged)
        self.fromBackgroundflag = QCheckBox(QApplication.translate("CheckBox","From Background",None))
        self.fromBackgroundflag.setChecked(bool(aw.qmc.phasesfromBackgroundflag))
        self.fromBackgroundflag.stateChanged.connect(self.fromBackgroundflagChanged)
        self.watermarksflag = QCheckBox(QApplication.translate("CheckBox","Watermarks",None))
        self.watermarksflag.setChecked(bool(aw.qmc.watermarksflag))
        self.phasesLCDflag = QCheckBox(QApplication.translate("CheckBox","Phases LCDs",None))
        self.phasesLCDflag.setChecked(bool(aw.qmc.phasesLCDflag))
        self.autoDRYflag = QCheckBox(QApplication.translate("CheckBox","Auto DRY",None))
        self.autoDRYflag.setChecked(bool(aw.qmc.autoDRYflag))
        self.autoFCsFlag = QCheckBox(QApplication.translate("CheckBox","Auto FCs",None))
        self.autoFCsFlag.setChecked(bool(aw.qmc.autoFCsFlag))
        self.watermarksflag.stateChanged.connect(self.watermarksflagChanged)
        self.phasesLCDflag.stateChanged.connect(self.phasesLCDsflagChanged)
        self.autoDRYflag.stateChanged.connect(self.autoDRYflagChanged)
        self.autoFCsFlag.stateChanged.connect(self.autoFCsFlagChanged)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.updatephases)
        self.dialogbuttons.rejected.connect(self.cancel)
        setDefaultButton = self.dialogbuttons.addButton(QDialogButtonBox.RestoreDefaults)
        setDefaultButton.clicked.connect(self.setdefault)
        if aw.locale not in aw.qtbase_locales:
            setDefaultButton.setText(QApplication.translate("Button","Default Temperatures", None))
        
        phaseLayout = QGridLayout()
        phaseLayout.addWidget(minf,0,1,Qt.AlignHCenter|Qt.AlignBottom)
        phaseLayout.addWidget(maxf,0,2,Qt.AlignHCenter|Qt.AlignBottom)
        phaseLayout.addWidget(dryLabel,1,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startdry,1,1)
        phaseLayout.addWidget(self.enddry,1,2)
        phaseLayout.addWidget(midLabel,2,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startmid,2,1)
        phaseLayout.addWidget(self.endmid,2,2)
        phaseLayout.addWidget(finishLabel,3,0,Qt.AlignRight)
        phaseLayout.addWidget(self.startfinish,3,1)
        phaseLayout.addWidget(self.endfinish,3,2)

        lcdmodes = [QApplication.translate("ComboBox","Time",None),
                    QApplication.translate("ComboBox","Percentage",None),
                    QApplication.translate("ComboBox","Temp",None)]

        lcdmode = QLabel(QApplication.translate("Label", "Phases\nLCDs Mode",None))
        phaseLayout.addWidget(lcdmode,0,3,Qt.AlignCenter)
        lcdmode = QLabel(QApplication.translate("Label", "Phases\nLCDs All",None))
        phaseLayout.addWidget(lcdmode,0,4,Qt.AlignCenter)

        self.lcdmodeComboBox_dry = QComboBox()
        self.lcdmodeComboBox_dry.setFocusPolicy(Qt.NoFocus)
        self.lcdmodeComboBox_dry.addItems(lcdmodes)
        self.lcdmodeComboBox_dry.currentIndexChanged.connect(self.lcdmodeComboBox_dryChanged)
        self.lcdmodeComboBox_mid = QComboBox()
        self.lcdmodeComboBox_mid.setFocusPolicy(Qt.NoFocus)
        self.lcdmodeComboBox_mid.addItems(lcdmodes)
        self.lcdmodeComboBox_mid.currentIndexChanged.connect(self.lcdmodeComboBox_midChanged)
        self.lcdmodeComboBox_fin = QComboBox()
        self.lcdmodeComboBox_fin.setFocusPolicy(Qt.NoFocus)
        self.lcdmodeComboBox_fin.addItems(lcdmodes)
        self.lcdmodeComboBox_fin.currentIndexChanged.connect(self.lcdmodeComboBox_finChanged)
        phaseLayout.addWidget(self.lcdmodeComboBox_dry,1,3)
        phaseLayout.addWidget(self.lcdmodeComboBox_mid,2,3)
        phaseLayout.addWidget(self.lcdmodeComboBox_fin,3,3)

        self.lcdmodeComboBox_dry.setCurrentIndex(aw.qmc.phasesLCDmode_l[0])
        self.lcdmodeComboBox_dry.setEnabled(not bool(aw.qmc.phasesLCDmode_all[0]))
        self.lcdmodeComboBox_mid.setCurrentIndex(aw.qmc.phasesLCDmode_l[1])
        self.lcdmodeComboBox_mid.setEnabled(not bool(aw.qmc.phasesLCDmode_all[1]))
        self.lcdmodeComboBox_fin.setCurrentIndex(aw.qmc.phasesLCDmode_l[2])
        self.lcdmodeComboBox_fin.setEnabled(not bool(aw.qmc.phasesLCDmode_all[2]))
        
        self.lcdmodeFlag_all_fin = QCheckBox()
        self.lcdmodeFlag_all_fin.setFocusPolicy(Qt.NoFocus)
        self.lcdmodeFlag_all_fin.setChecked(aw.qmc.phasesLCDmode_all[2])
        self.lcdmodeFlag_all_fin.stateChanged.connect(self.lcdmodeFlagFinChanged)
        phaseLayout.addWidget(self.lcdmodeFlag_all_fin,3,4,Qt.AlignCenter)
               
        self.events2phases()
        
        boxedPhaseLayout = QHBoxLayout()
        boxedPhaseLayout.addStretch()
        boxedPhaseLayout.addLayout(phaseLayout)
        boxedPhaseLayout.addStretch()
        boxedPhaseFlagGrid = QGridLayout()
        boxedPhaseFlagGrid.addWidget(self.pushbuttonflag,0,0)
        boxedPhaseFlagGrid.addWidget(self.fromBackgroundflag,0,1)
        boxedPhaseFlagGrid.addWidget(self.autoDRYflag,1,0)
        boxedPhaseFlagGrid.addWidget(self.autoFCsFlag,1,1)
        boxedPhaseFlagGrid.addWidget(self.watermarksflag,2,0)
        boxedPhaseFlagGrid.addWidget(self.phasesLCDflag,2,1)
        boxedPhaseFlagLayout = QHBoxLayout()
        boxedPhaseFlagLayout.addStretch()
        boxedPhaseFlagLayout.addLayout(boxedPhaseFlagGrid)
        boxedPhaseFlagLayout.addStretch()
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(self.dialogbuttons)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(boxedPhaseLayout)
        mainLayout.addLayout(boxedPhaseFlagLayout)
        mainLayout.addStretch()
        mainLayout.addSpacing(10)
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)
        self.getphases()
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
        
    @pyqtSlot(int)
    def lcdmodeFlagFinChanged(self,value):
        aw.qmc.phasesLCDmode_all[2] = bool(value)
        self.lcdmodeComboBox_fin.setEnabled(not bool(aw.qmc.phasesLCDmode_all[2]))
    
    @pyqtSlot(int)
    def lcdmodeComboBox_dryChanged(self,_):
        aw.qmc.phasesLCDmode_l[0] = self.lcdmodeComboBox_dry.currentIndex()
        aw.qmc.phasesLCD = aw.qmc.phasesLCDmode_l[0]

    @pyqtSlot(int)
    def lcdmodeComboBox_midChanged(self,_):
        aw.qmc.phasesLCDmode_l[1] = self.lcdmodeComboBox_mid.currentIndex()

    @pyqtSlot(int)
    def lcdmodeComboBox_finChanged(self,_):
        aw.qmc.phasesLCDmode_l[2] = self.lcdmodeComboBox_fin.currentIndex()

    def savePhasesSettings(self):
        if not aw.qmc.phasesbuttonflag:
            settings = QSettings()
            #save phases
            settings.setValue("Phases",aw.qmc.phases)

    def bevents2phases(self):
        if aw.qmc.phasesfromBackgroundflag and aw.qmc.background:
            # adjust phases by DryEnd and FCs events from background profile
            if aw.qmc.timeindexB[1]:
                aw.qmc.phases[1] = int(round(aw.qmc.temp2B[aw.qmc.timeindexB[1]]))
            if aw.qmc.timeindexB[2]:
                aw.qmc.phases[2] = int(round(aw.qmc.temp2B[aw.qmc.timeindexB[2]]))
            
    def events2phases(self):
        if aw.qmc.phasesbuttonflag:
            # adjust phases by DryEnd and FCs events
            if aw.qmc.timeindex[1]:
                aw.qmc.phases[1] = int(round(aw.qmc.temp2[aw.qmc.timeindex[1]]))
            self.enddry.setDisabled(True)
            self.startmid.setDisabled(True)
            if aw.qmc.timeindex[2]:
                aw.qmc.phases[2] = int(round(aw.qmc.temp2[aw.qmc.timeindex[2]]))
            self.endmid.setDisabled(True)
            self.startfinish.setDisabled(True)

    @pyqtSlot(int)
    def watermarksflagChanged(self,_):
        aw.qmc.watermarksflag = not aw.qmc.watermarksflag
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def phasesLCDsflagChanged(self,_):
        aw.qmc.phasesLCDflag = not aw.qmc.phasesLCDflag
        if aw.qmc.flagstart:
            if aw.qmc.phasesLCDflag:
                aw.phasesLCDs.show()
            else:
                aw.phasesLCDs.hide()

    @pyqtSlot(int)
    def autoDRYflagChanged(self,_):
        aw.qmc.autoDRYflag = not aw.qmc.autoDRYflag
        if aw.qmc.autoDRYflag:
            self.pushbuttonflag.setChecked(False)
        
    @pyqtSlot(int)
    def autoFCsFlagChanged(self,_):
        aw.qmc.autoFCsFlag = not aw.qmc.autoFCsFlag
        if aw.qmc.autoFCsFlag:
            self.pushbuttonflag.setChecked(False)

    @pyqtSlot(int)
    def fromBackgroundflagChanged(self,i):
        if i:
            aw.qmc.phasesfromBackgroundflag = True
            self.bevents2phases()
            self.getphases()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.phasesfromBackgroundflag = False
    
    @pyqtSlot(int)
    def pushbuttonflagChanged(self,i):
        if i:
            aw.qmc.phasesbuttonflag = True
            self.events2phases()
            self.getphases()
            aw.qmc.redraw(recomputeAllDeltas=False)
        else:
            aw.qmc.phasesbuttonflag = False
            self.enddry.setEnabled(True)
            self.startmid.setEnabled(True)
            self.endmid.setEnabled(True)
            self.startfinish.setEnabled(True)
        if aw.qmc.phasesbuttonflag:
            self.autoDRYflag.setChecked(False)
            self.autoFCsFlag.setChecked(False)

    @pyqtSlot()
    def updatephases(self):
        aw.qmc.phases[0] = self.startdry.value()
        aw.qmc.phases[1] = self.enddry.value()
        aw.qmc.phases[2] = self.endmid.value()
        aw.qmc.phases[3] = self.endfinish.value()

        if self.pushbuttonflag.isChecked():
            aw.qmc.phasesbuttonflag = True
        else:
            aw.qmc.phasesbuttonflag = False
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.accept()

    @pyqtSlot()
    def cancel(self):
        aw.qmc.phases = list(self.phases)
        aw.qmc.phasesbuttonflag = bool(self.org_phasesbuttonflag)
        aw.qmc.phasesfromBackgroundflag = bool(self.org_fromBackgroundflag)
        aw.qmc.watermarksflag = bool(self.org_watermarksflag)
        aw.qmc.phasesLCDflag = bool(self.org_phasesLCDflag)
        aw.qmc.autoDRYflag = bool(self.org_autoDRYflag)
        aw.qmc.autoFCsFlag = bool(self.org_autoFCsFlag)
        aw.qmc.phasesLCDmode_l = list(self.org_phasesLCDmode_l)
        aw.qmc.phasesLCDmode_all = list(self.org_phasesLCDmode_all)
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.savePhasesSettings()
        self.reject()

    def getphases(self):
        self.startdry.setValue(aw.qmc.phases[0])
        self.startdry.repaint()
        self.enddry.setValue(aw.qmc.phases[1])
        self.enddry.repaint()
        self.endmid.setValue(aw.qmc.phases[2])
        self.endmid.repaint()
        self.endfinish.setValue(aw.qmc.phases[3])
        self.endfinish.repaint()
        
    @pyqtSlot(bool)
    def setdefault(self,_):
        if aw.qmc.mode == "F":
            aw.qmc.phases = list(aw.qmc.phases_fahrenheit_defaults)
        elif aw.qmc.mode == "C":
            aw.qmc.phases = list(aw.qmc.phases_celsius_defaults)
        self.events2phases()
        self.getphases()
        aw.sendmessage(QApplication.translate("Message","Phases changed to {0} default: {1}",None).format(aw.qmc.mode,str(aw.qmc.phases)))
        aw.qmc.redraw(recomputeAllDeltas=False)

############################################################################
#####################   FLAVOR STAR PROPERTIES DIALOG   ####################
############################################################################

class flavorDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(flavorDlg,self).__init__(parent)
        self.setModal(True)
        rcParams['path.effects'] = []
        #avoid questionm mark context help
        flags = self.windowFlags()
        helpFlag = Qt.WindowContextHelpButtonHint
        flags = flags & (~helpFlag)
        self.setWindowFlags(flags)
        self.setWindowTitle(QApplication.translate("Form Caption","Cup Profile",None))
        
        settings = QSettings()
        if settings.contains("FlavorProperties"):
            self.restoreGeometry(settings.value("FlavorProperties"))
            
        defaultlabel = QLabel(QApplication.translate("Label","Default",None))
        self.defaultcombobox = QComboBox()
        self.defaultcombobox.addItems(["","Artisan","SCCA","CQI","SweetMarias","C","E","CoffeeGeek","Intelligentsia","IIAC","WCRC","*CUSTOM*"])
        self.defaultcombobox.setCurrentIndex(0)
        self.lastcomboboxIndex = 0
        self.defaultcombobox.currentIndexChanged.connect(self.setdefault)
        self.flavortable = QTableWidget()
        self.flavortable.setTabKeyNavigation(True)
        self.createFlavorTable()
        leftButton = QPushButton("<")
        leftButton.setFocusPolicy(Qt.NoFocus)
        leftButton.clicked.connect(self.moveLeft)
        rightButton = QPushButton(">")
        rightButton.setFocusPolicy(Qt.NoFocus)
        rightButton.clicked.connect(self.moveRight)
        addButton = QPushButton(QApplication.translate("Button","Add",None))
        addButton.setFocusPolicy(Qt.NoFocus)
        addButton.clicked.connect(self.addlabel)
        delButton = QPushButton(QApplication.translate("Button","Del",None))
        delButton.setFocusPolicy(Qt.NoFocus)
        delButton.clicked.connect(self.poplabel)
        saveImgButton = QPushButton(QApplication.translate("Button","Save Image",None))
        saveImgButton.setFocusPolicy(Qt.NoFocus)
        #saveImgButton.clicked.connect(aw.resizeImg_0_1) # save as PNG (raster)
        saveImgButton.clicked.connect(aw.saveVectorGraph_PDF) # save as PDF (vector)
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.close)
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Background", None))
        if aw.qmc.flavorbackgroundflag:
            self.backgroundCheck.setChecked(True)
        self.backgroundCheck.clicked.connect(self.showbackground)
        aspectlabel = QLabel(QApplication.translate("Label","Aspect Ratio",None))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.flavoraspect)
        self.aspectSpinBox.valueChanged.connect(self.setaspect)
        flavorLayout = QHBoxLayout()
        flavorLayout.addWidget(self.flavortable)
        comboLayout = QHBoxLayout()
        comboLayout.addWidget(defaultlabel)
        comboLayout.addWidget(self.defaultcombobox)
        comboLayout.addStretch()
        aspectLayout = QHBoxLayout()
        aspectLayout.addWidget(self.backgroundCheck)
        aspectLayout.addWidget(aspectlabel)
        aspectLayout.addWidget(self.aspectSpinBox)
        aspectLayout.addStretch()
        blayout1 = QHBoxLayout()
        blayout1.addStretch()
        blayout1.addWidget(addButton)
        blayout1.addWidget(delButton)  
        blayout1.addStretch()
        extralayout = QVBoxLayout()
        extralayout.addLayout(comboLayout)
        extralayout.addLayout(aspectLayout)
        extraGroupLayout = QGroupBox()
        extraGroupLayout.setLayout(extralayout)
        blayout = QHBoxLayout()
        blayout.addStretch()
        blayout.addWidget(leftButton)
        blayout.addWidget(rightButton)
        blayout.addStretch()
        mainButtonsLayout = QHBoxLayout()
        mainButtonsLayout.addWidget(saveImgButton)
        mainButtonsLayout.addStretch()
        mainButtonsLayout.addWidget(self.dialogbuttons)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(flavorLayout)
        mainLayout.addLayout(blayout1)
        mainLayout.addWidget(extraGroupLayout)
        mainLayout.addLayout(blayout)
#        mainLayout.addStretch()
        mainLayout.addLayout(mainButtonsLayout)
        self.setLayout(mainLayout)
        aw.qmc.flavorchart()
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    @pyqtSlot(float)
    def setaspect(self,_):
        aw.qmc.flavoraspect = self.aspectSpinBox.value()
        aw.qmc.flavorchart()

    def createFlavorTable(self):
        nflavors = len(aw.qmc.flavorlabels)
        
        # self.flavortable.clear() # this crashes Ubuntu 16.04
#        if ndata != 0:
#            self.flavortable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
        self.flavortable.clearSelection() # this seems to work also for Ubuntu 16.04
        
        if nflavors:
            self.flavortable.setRowCount(nflavors)
            self.flavortable.setColumnCount(3)
            self.flavortable.setHorizontalHeaderLabels([QApplication.translate("Table", "Label",None),
                                                        QApplication.translate("Table", "Value",None),
                                                        ""])
            self.flavortable.setAlternatingRowColors(True)
            self.flavortable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.flavortable.setSelectionBehavior(QTableWidget.SelectRows)
            self.flavortable.setSelectionMode(QTableWidget.SingleSelection)
            self.flavortable.setShowGrid(True)
            #self.flavortable.verticalHeader().setSectionResizeMode(2)
            #populate table
            for i in range(nflavors):
                labeledit = QLineEdit(u(aw.qmc.flavorlabels[i]))
                labeledit.textChanged.connect(self.setlabel)
                valueSpinBox = MyQDoubleSpinBox()
                valueSpinBox.setRange(0.,10.)
                valueSpinBox.setSingleStep(.25)
                valueSpinBox.setAlignment(Qt.AlignRight)
                val = aw.qmc.flavors[i]
                if aw.qmc.flavors[0] < 1. and aw.qmc.flavors[-1] < 1.: # < 0.5.0 version style compatibility
                    val *= 10.
                valueSpinBox.setValue(val)
                valueSpinBox.valueChanged.connect(self.setvalue)
                #add widgets to the table
                self.flavortable.setCellWidget(i,0,labeledit)
                self.flavortable.setCellWidget(i,1,valueSpinBox)
            self.flavortable.resizeColumnsToContents()
            header = self.flavortable.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.Stretch)

    @pyqtSlot(bool)
    def showbackground(self,_):
        if self.backgroundCheck.isChecked():
            if not aw.qmc.background:
                message = QApplication.translate("Message","Background profile not found", None)
                aw.sendmessage(message)
                self.backgroundCheck.setChecked(False)
            else:
                if len(aw.qmc.backgroundFlavors) != len(aw.qmc.flavors):
                    message = QApplication.translate("Message","Background does not match number of labels", None)
                    aw.sendmessage(message)
                    aw.qmc.flavorbackgroundflag = False
                    self.backgroundCheck.setChecked(False)
                else:
                    aw.qmc.flavorbackgroundflag = True
                    aw.qmc.flavorchart()
        else:
            aw.qmc.flavorbackgroundflag = False
            aw.qmc.flavorchart()

    @pyqtSlot(bool)
    def moveLeft(self,_):
        aw.qmc.flavorstartangle += 5
        aw.qmc.flavorchart()
    
    @pyqtSlot(bool)
    def moveRight(self,_):
        aw.qmc.flavorstartangle -= 5
        aw.qmc.flavorchart()

    def savetable(self):
        for i in range(len(aw.qmc.flavorlabels)):
            labeledit = self.flavortable.cellWidget(i,0)
            valueSpinBox = self.flavortable.cellWidget(i,1)
            label = u(labeledit.text())
            if "\\n" in label:              #make multiple line text if "\n" found in label string
                parts = label.split("\\n")
                label = chr(10).join(parts)
            aw.qmc.flavorlabels[i] = label
            aw.qmc.flavors[i] = valueSpinBox.value()
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels

    @pyqtSlot()
    @pyqtSlot("QString")
    def setlabel(self,_):
        x = aw.findWidgetsRow(self.flavortable,self.sender(),0)
        if x is not None:
            labeledit = self.flavortable.cellWidget(x,0)
            aw.qmc.flavorlabels[x] = labeledit.text()
            aw.qmc.updateFlavorchartLabel(x) # fast incremental redraw

    @pyqtSlot(float)
    def setvalue(self,_):
        x = aw.findWidgetsRow(self.flavortable,self.sender(),1)
        if x is not None:
            valueSpinBox = self.flavortable.cellWidget(x,1)
            aw.qmc.flavors[x] = valueSpinBox.value()
#            aw.qmc.flavorchart() # slow full redraw
            aw.qmc.updateFlavorchartValues() # fast incremental redraw

    @pyqtSlot(int)
    def setdefault(self,_):
        if self.lastcomboboxIndex == 10:
            # store the current labels as *CUSTOM*
            aw.qmc.customflavorlabels = aw.qmc.flavorlabels
        dindex =  self.defaultcombobox.currentIndex()
        #["","Artisan","SCCA","CQI","SweetMarias","C","E","coffeegeek","Intelligentsia","WCRC"]
        if dindex > 0 or dindex < 11:
            aw.qmc.flavorstartangle = 90
        if dindex == 1:
            aw.qmc.flavorlabels = list(aw.qmc.artisanflavordefaultlabels)
        elif dindex == 2:
            aw.qmc.flavorlabels = list(aw.qmc.SCCAflavordefaultlabels)
        elif dindex == 3:
            aw.qmc.flavorlabels = list(aw.qmc.CQIflavordefaultlabels)
        elif dindex == 4:
            aw.qmc.flavorlabels = list(aw.qmc.SweetMariasflavordefaultlabels)
        elif dindex == 5:
            aw.qmc.flavorlabels = list(aw.qmc.Cflavordefaultlabels)
        elif dindex == 6:
            aw.qmc.flavorlabels = list(aw.qmc.Eflavordefaultlabels)
        elif dindex == 7:
            aw.qmc.flavorlabels = list(aw.qmc.coffeegeekflavordefaultlabels)
        elif dindex == 8:
            aw.qmc.flavorlabels = list(aw.qmc.Intelligentsiaflavordefaultlabels)
        elif dindex == 9:
            aw.qmc.flavorlabels = list(aw.qmc.IstitutoInternazionaleAssaggiatoriCaffe)
        elif dindex == 10:
            aw.qmc.flavorlabels = list(aw.qmc.WorldCoffeeRoastingChampionship)
        elif dindex == 11:
            aw.qmc.flavorlabels = list(aw.qmc.customflavorlabels)
        else:
            return
        aw.qmc.flavors = [5.]*len(aw.qmc.flavorlabels)
        self.createFlavorTable()
        aw.qmc.flavorchart()
        self.lastcomboboxIndex = dindex

    @pyqtSlot(bool)
    def addlabel(self,_):
        aw.qmc.flavorlabels.append("???")
        aw.qmc.flavors.append(5.)
        self.createFlavorTable()
        aw.qmc.flavorchart()

    @pyqtSlot(bool)
    def poplabel(self):
        fn = len(aw.qmc.flavors)
        aw.qmc.flavors = aw.qmc.flavors[:(fn-1)]
        aw.qmc.flavorlabels = aw.qmc.flavorlabels[:(fn -1)]
        self.createFlavorTable()
        aw.qmc.flavorchart()

    def closeEvent(self,_):
        self.close()

    @pyqtSlot()
    def close(self):
        settings = QSettings()
        #save window geometry
        settings.setValue("FlavorProperties",self.saveGeometry())
        self.savetable()
        aw.qmc.fileDirty()
        if aw.qmc.ax1 is not None:
            try:
                aw.qmc.fig.delaxes(self.aw.qmc.ax1)
            except:
                pass
        aw.qmc.fig.clf()
        aw.qmc.clearFlavorChart()
        aw.redrawOnResize = True
        aw.qmc.redraw(recomputeAllDeltas=False)
        aw.showControls()
        self.accept()

#################################################################
#################### BACKGROUND DIALOG  #########################
#################################################################

class backgroundDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(backgroundDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Profile Background", None))
        self.setModal(True)
        
        settings = QSettings()
        if settings.contains("BackgroundGeometry"):
            self.restoreGeometry(settings.value("BackgroundGeometry"))
        
        #TAB 1
        self.pathedit = QLineEdit(aw.qmc.backgroundpath)
        self.pathedit.setStyleSheet("background-color:'lightgrey';")
        self.pathedit.setReadOnly(True)
        self.pathedit.setFocusPolicy(Qt.NoFocus)
        self.filename = ""
        self.backgroundCheck = QCheckBox(QApplication.translate("CheckBox","Show", None))
        self.backgroundDetails = QCheckBox(QApplication.translate("CheckBox","Annotations", None))
        self.backgroundeventsflag = QCheckBox(QApplication.translate("CheckBox","Events", None))
        self.backgroundDeltaETflag = QCheckBox()
        backgroundDeltaETflagLabel = QLabel(deltaLabelPrefix + QApplication.translate("Label","ET", None))
        self.backgroundDeltaBTflag = QCheckBox()
        backgroundDeltaBTflagLabel = QLabel(deltaLabelPrefix + QApplication.translate("Label","BT", None))
        self.backgroundETflag = QCheckBox(QApplication.translate("CheckBox","ET", None))
        self.backgroundBTflag = QCheckBox(QApplication.translate("CheckBox","BT", None))
        self.backgroundCheck.setChecked(aw.qmc.background)
        self.backgroundDetails.setChecked(aw.qmc.backgroundDetails)
        self.backgroundeventsflag.setChecked(aw.qmc.backgroundeventsflag)
        self.backgroundDeltaETflag.setChecked(aw.qmc.DeltaETBflag)
        self.backgroundDeltaBTflag.setChecked(aw.qmc.DeltaBTBflag)
        self.backgroundETflag.setChecked(aw.qmc.backgroundETcurve)
        self.backgroundBTflag.setChecked(aw.qmc.backgroundBTcurve)
        loadButton = QPushButton(QApplication.translate("Button","Load", None))
        loadButton.setFocusPolicy(Qt.NoFocus)
        delButton = QPushButton(QApplication.translate("Button","Delete", None))
        delButton.setFocusPolicy(Qt.NoFocus)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        
        alignButton = QPushButton(QApplication.translate("Button","Align", None))
        alignButton.setFocusPolicy(Qt.NoFocus)
        self.alignComboBox = QComboBox()
        alignnames = [
            QApplication.translate("Label","CHARGE", None),
            QApplication.translate("Label","DRY", None),
            QApplication.translate("Label","FCs", None),
            QApplication.translate("Label","FCe", None),
            QApplication.translate("Label","SCs", None),
            QApplication.translate("Label","SCe", None),
            QApplication.translate("Label","DROP", None),
            QApplication.translate("Label","ALL", None),
            ]
        self.alignComboBox.addItems(alignnames)
        self.alignComboBox.setCurrentIndex(aw.qmc.alignEvent)
        self.alignComboBox.currentIndexChanged.connect(self.changeAlignEventidx)
        loadButton.clicked.connect(self.load)
        alignButton.clicked.connect(self.timealign)
        
        self.speedSpinBox = QSpinBox()
        self.speedSpinBox.setAlignment(Qt.AlignRight)
        self.speedSpinBox.setRange(1,90)
        self.speedSpinBox.setSingleStep(5)
        self.speedSpinBox.setValue(aw.qmc.backgroundmovespeed)
        self.xtcurvelabel = QLabel(QApplication.translate("Label", "Extra",None))
        self.xtcurveComboBox = QComboBox()
        self.xtcurveComboBox.setToolTip(QApplication.translate("Tooltip","For loaded backgrounds with extra devices only",None))
        self.xtcurveComboBox.setMinimumWidth(120)
        curvenames = [""] # first entry is the empty one, no extra curve displayed
        for i in range(min(len(aw.qmc.extraname1B),len(aw.qmc.extraname2B),len(aw.qmc.extratimexB))):
            curvenames.append("B" + str(2*i+3) + ": " + aw.qmc.extraname1B[i])
            curvenames.append("B" + str(2*i+4) + ": " + aw.qmc.extraname2B[i])
        self.xtcurveComboBox.addItems(curvenames)
        if aw.qmc.xtcurveidx < len(curvenames):
            self.xtcurveComboBox.setCurrentIndex(aw.qmc.xtcurveidx)
        self.xtcurveComboBox.currentIndexChanged.connect(self.changeXTcurveidx)
        self.upButton = QPushButton(QApplication.translate("Button","Up",None))
        self.upButton.setFocusPolicy(Qt.NoFocus)
        self.downButton = QPushButton(QApplication.translate("Button","Down",None))
        self.downButton.setFocusPolicy(Qt.NoFocus)
        self.leftButton = QPushButton(QApplication.translate("Button","Left",None))
        self.leftButton.setFocusPolicy(Qt.NoFocus)
        self.rightButton = QPushButton(QApplication.translate("Button","Right",None))
        self.rightButton.setFocusPolicy(Qt.NoFocus)
        self.backgroundCheck.clicked.connect(self.readChecks)
        self.backgroundDetails.clicked.connect(self.readChecks)
        self.backgroundeventsflag.clicked.connect(self.readChecks)
        self.backgroundDeltaETflag.clicked.connect(self.readChecks)
        self.backgroundDeltaBTflag.clicked.connect(self.readChecks)
        self.backgroundETflag.clicked.connect(self.readChecks)
        self.backgroundBTflag.clicked.connect(self.readChecks)
        delButton.clicked.connect(self.delete)
        self.upButton.clicked.connect(self.moveUp)
        self.downButton.clicked.connect(self.moveDown)
        self.leftButton.clicked.connect(self.moveLeft)
        self.rightButton.clicked.connect(self.moveRight)
        #TAB 2 EVENTS
        #table for showing events
        self.eventtable = QTableWidget()
        self.eventtable.setTabKeyNavigation(True)
        #self.createEventTable()
        self.copyeventTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copyeventTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copyeventTableButton.setFocusPolicy(Qt.NoFocus)
        self.copyeventTableButton.setMaximumSize(self.copyeventTableButton.sizeHint())
        self.copyeventTableButton.setMinimumSize(self.copyeventTableButton.minimumSizeHint())
        self.copyeventTableButton.clicked.connect(self.copyEventTabletoClipboard)
        #TAB 3 DATA
        #table for showing data
        self.datatable = QTableWidget()
        self.datatable.setTabKeyNavigation(True)
        self.createDataTable()
        self.copydataTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copydataTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copydataTableButton.setFocusPolicy(Qt.NoFocus)
        self.copydataTableButton.setMaximumSize(self.copydataTableButton.sizeHint())
        self.copydataTableButton.setMinimumSize(self.copydataTableButton.minimumSizeHint())
        self.copydataTableButton.clicked.connect(self.copyDataTabletoClipboard)
        #TAB 4
        self.replayComboBox = QComboBox()
        replayVariants = [
            QApplication.translate("Label","by time", None),
            QApplication.translate("Label","by BT", None),
            QApplication.translate("Label","by ET", None),
            ]
        self.replayComboBox.addItems(replayVariants)
        self.replayComboBox.setCurrentIndex(aw.qmc.replayType)
        self.replayComboBox.currentIndexChanged.connect(self.changeReplayTypeidx)
                
        self.backgroundReproduce = QCheckBox(QApplication.translate("CheckBox","Playback Aid",None))
        self.backgroundReproduce.setChecked(aw.qmc.backgroundReproduce)
        self.backgroundReproduce.setFocusPolicy(Qt.NoFocus)
        self.backgroundReproduce.stateChanged.connect(self.setreproduce)
        self.backgroundReproduceBeep = QCheckBox(QApplication.translate("CheckBox","Beep",None))
        self.backgroundReproduceBeep.setChecked(aw.qmc.backgroundReproduce)
        self.backgroundReproduceBeep.setFocusPolicy(Qt.NoFocus)
        self.backgroundReproduceBeep.stateChanged.connect(self.setreproduceBeep)
        self.backgroundPlaybackEvents = QCheckBox(QApplication.translate("CheckBox","Playback Events",None))
        self.backgroundPlaybackEvents.setChecked(aw.qmc.backgroundPlaybackEvents)
        self.backgroundPlaybackEvents.setFocusPolicy(Qt.NoFocus)
        self.backgroundPlaybackEvents.stateChanged.connect(self.setplaybackevent)
        self.backgroundPlaybackDROP = QCheckBox(QApplication.translate("CheckBox","Playback DROP",None))
        self.backgroundPlaybackDROP.setChecked(aw.qmc.backgroundPlaybackDROP)
        self.backgroundPlaybackDROP.setFocusPolicy(Qt.NoFocus)
        self.backgroundPlaybackDROP.stateChanged.connect(self.setplaybackdrop)
        etimelabel =QLabel(QApplication.translate("Label", "Text Warning",None))
        etimeunit =QLabel(QApplication.translate("Label", "sec",None))
        self.etimeSpinBox = QSpinBox()
        self.etimeSpinBox.setRange(1,60)
        self.etimeSpinBox.setValue(aw.qmc.detectBackgroundEventTime)
        self.etimeSpinBox.valueChanged.connect(self.setreproduce)
        #LAYOUT MANAGERS
        movelayout = QGridLayout()
        movelayout.addWidget(self.upButton,0,1)
        movelayout.addWidget(self.leftButton,1,0)
        movelayout.addWidget(self.speedSpinBox,1,1)
        movelayout.addWidget(self.rightButton,1,2)
        movelayout.addWidget(self.downButton,2,1)
        movelayout.setSpacing(20)
        checkslayout1 = QHBoxLayout()
        checkslayout1.addStretch()
        checkslayout1.addWidget(self.backgroundCheck)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundDetails)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundeventsflag)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundETflag)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundBTflag)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundDeltaETflag)
        checkslayout1.addWidget(backgroundDeltaETflagLabel)
        checkslayout1.addSpacing(5)
        checkslayout1.addWidget(self.backgroundDeltaBTflag)
        checkslayout1.addWidget(backgroundDeltaBTflagLabel)
        checkslayout1.addStretch()
        checkslayout1.setSpacing(15)
        layout = QGridLayout()
        layoutBoxedH = QHBoxLayout()
        layoutBoxedH.addStretch()
        layoutBoxedH.addLayout(movelayout)
        layoutBoxedH.addLayout(layout)
        layoutBoxedH.addStretch()
        layoutBoxed = QVBoxLayout()
        layoutBoxed.addStretch()
        layoutBoxed.addLayout(checkslayout1)
        layoutBoxed.addStretch()
        layoutBoxed.addLayout(layoutBoxedH)
        layoutBoxed.addStretch()
        alignButtonBoxed = QHBoxLayout()
        alignButtonBoxed.addWidget(self.xtcurvelabel)
        alignButtonBoxed.addWidget(self.xtcurveComboBox)
        alignButtonBoxed.addStretch()
        alignButtonBoxed.addWidget(alignButton)
        alignButtonBoxed.addWidget(self.alignComboBox)
        tab4content = QHBoxLayout()
        tab4content.addWidget(self.backgroundReproduce)
        tab4content.addSpacing(10)
        tab4content.addWidget(self.backgroundReproduceBeep)
        tab4content.addSpacing(10)
        tab4content.addWidget(etimelabel)
        tab4content.addWidget(self.etimeSpinBox)
        tab4content.addWidget(etimeunit)
        tab4content.addSpacing(20)
        tab4content.addStretch()
        tab4content.addWidget(self.backgroundPlaybackEvents)
        tab4content.addSpacing(10)
        tab4content.addWidget(self.backgroundPlaybackDROP)
        tab4content.addSpacing(10)
        tab4content.addWidget(self.replayComboBox)
        tab1layout = QVBoxLayout()
        tab1layout.addLayout(layoutBoxed)
#        tab1layout.addStretch()
        tab1layout.addLayout(alignButtonBoxed)
        tab1layout.addLayout(tab4content)
        tab1layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        eventbuttonLayout = QHBoxLayout()
        eventbuttonLayout.addWidget(self.copyeventTableButton)
        eventbuttonLayout.addStretch()
        tab2layout = QVBoxLayout()
        tab2layout.addWidget(self.eventtable)
        tab2layout.addLayout(eventbuttonLayout)
        tab2layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        databuttonLayout = QHBoxLayout()
        databuttonLayout.addWidget(self.copydataTableButton)
        databuttonLayout.addStretch()
        tab3layout = QVBoxLayout()
        tab3layout.addWidget(self.datatable)
        tab3layout.addLayout(databuttonLayout)
        tab3layout.setContentsMargins(5, 0, 5, 0) # left, top, right, bottom
        #tab layout
        tab1layout.setSpacing(5)
        self.TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1layout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab","Config",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2layout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab","Events",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3layout)
        self.TabWidget.addTab(C3Widget,QApplication.translate("Tab","Data",None))
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(loadButton)
        buttonLayout.addWidget(delButton)
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(self.TabWidget) 
        mainLayout.addWidget(self.pathedit)
        mainLayout.addLayout(buttonLayout)
        mainLayout.setContentsMargins(5, 10, 5, 5) # left, top, right, bottom 
        self.setLayout(mainLayout)
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
    
    @pyqtSlot(bool)
    def timealign(self,_):
        aw.qmc.timealign()
    
    #keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work 
    def keyPressEvent(self,event):
        if event.matches(QKeySequence.Copy):
            if self.TabWidget.currentIndex() == 2: # datatable
                aw.copy_cells_to_clipboard(self.datatable)
                aw.sendmessage(QApplication.translate("Message","Data table copied to clipboard",None))
        else:
            super(backgroundDlg,self).keyPressEvent(event)

    @pyqtSlot()
    def accept(self):
        aw.qmc.backgroundmovespeed = self.speedSpinBox.value()
        self.close()
        
    def closeEvent(self,_):
        settings = QSettings()
        #save window geometry
        settings.setValue("BackgroundGeometry",self.saveGeometry())
        
    def getColorIdx(self,c):
        try:
            return self.defaultcolorsmapped.index(c)
        except Exception:
            try:
                return self.colors.index(c) + 5
            except Exception: 
                return 0

    @pyqtSlot(int)
    def setplaybackevent(self,_):
        s = None
        if self.backgroundPlaybackEvents.isChecked():
            aw.qmc.backgroundPlaybackEvents = True
            msg = QApplication.translate("Message","Playback Events set ON",None)
        else:
            aw.qmc.backgroundPlaybackEvents = False
            msg = QApplication.translate("StatusBar","Playback Events set OFF",None)
            s = "background-color:'transparent';"
        aw.sendmessage(msg, style=s)

    @pyqtSlot(int)
    def setplaybackdrop(self,_):
        s = None
        if self.backgroundPlaybackDROP.isChecked():
            aw.qmc.backgroundPlaybackDROP = True
            msg = QApplication.translate("Message","Playback DROP set ON",None)
        else:
            aw.qmc.backgroundPlaybackDROP = False
            msg = QApplication.translate("StatusBar","Playback DROP set OFF",None)
            s = "background-color:'transparent';"
        aw.sendmessage(msg, style=s)
                
    @pyqtSlot(int)
    def setreproduceBeep(self,_):
        if self.backgroundReproduceBeep.isChecked():
            aw.qmc.backgroundReproduceBeep = True
        else:
            aw.qmc.backgroundReproduceBeep = False

    @pyqtSlot(int)
    def setreproduce(self,_):
        aw.qmc.detectBackgroundEventTime = self.etimeSpinBox.value()
        s = None
        if self.backgroundReproduce.isChecked():
            aw.qmc.backgroundReproduce = True
            msg = QApplication.translate("Message","Playback Aid set ON at {0} secs",None).format(str(aw.qmc.detectBackgroundEventTime))
        else:
            aw.qmc.backgroundReproduce = False
            msg = QApplication.translate("StatusBar","Playback Aid set OFF",None)
            s = "background-color:'transparent';"
        aw.sendmessage(msg, style=s)

    def adjustcolor(self,curve):
        
        curve = str(curve).lower()

        etcolor = str(self.metcolorComboBox.currentText()).lower()
        btcolor = str(self.btcolorComboBox.currentText()).lower()
        deltabtcolor = str(self.deltabtcolorComboBox.currentText()).lower()
        deltaetcolor = str(self.deltaetcolorComboBox.currentText()).lower()
        xtcolor = str(self.xtcolorComboBox.currentText()).lower()

        defaults =  ["et","bt","deltaet","deltabt"]
        
        if curve == "et":
            if etcolor in defaults:
                aw.qmc.backgroundmetcolor = aw.qmc.palette[etcolor]
            else:
                aw.qmc.backgroundmetcolor = etcolor
                
        elif curve == "bt":
            if btcolor in defaults:
                aw.qmc.backgroundbtcolor = aw.qmc.palette[btcolor]
            else:
                aw.qmc.backgroundbtcolor = btcolor

        elif curve == "deltaet":
            if deltaetcolor in defaults:
                aw.qmc.backgrounddeltaetcolor = aw.qmc.palette[deltaetcolor]
            else:
                aw.qmc.backgrounddeltaetcolor = deltaetcolor
            
        elif curve == "deltabt":
            if deltabtcolor in defaults:
                aw.qmc.backgrounddeltabtcolor = aw.qmc.palette[deltabtcolor]
            else:
                aw.qmc.backgrounddeltabtcolor = deltabtcolor

        elif curve == "xt":
            if xtcolor in defaults:
                aw.qmc.backgroundxtcolor = aw.qmc.palette[xtcolor]
            else:
                aw.qmc.backgroundxtcolor = xtcolor 
                
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(bool)
    def delete(self,_):
        self.pathedit.setText("")
# we should not overwrite the users app settings here, right:
# but we have to deactivate the show flag
        self.backgroundCheck.setChecked(False)
        aw.qmc.background = False
        aw.qmc.backgroundprofile = None
        self.xtcurveComboBox.blockSignals(True)
        self.xtcurveComboBox.clear()
        aw.deleteBackground()
        self.eventtable.clear()
        self.createEventTable()
        self.createDataTable()
        aw.qmc.resetlinecountcaches()
        self.xtcurveComboBox.blockSignals(False)
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(bool)
    def moveUp(self,_):
        self.upButton.setDisabled(True)
        self.move("up")
        self.upButton.setDisabled(False)
    @pyqtSlot(bool)
    def moveDown(self,_):
        self.downButton.setDisabled(True)
        self.move("down")
        self.downButton.setDisabled(False)
    @pyqtSlot(bool)
    def moveLeft(self,_):
        self.leftButton.setDisabled(True)
        self.move("left")
        self.leftButton.setDisabled(False)
    @pyqtSlot(bool)
    def moveRight(self,_):
        self.rightButton.setDisabled(True)
        self.move("right")
        self.rightButton.setDisabled(False)
    
    def move(self,m):
        step = self.speedSpinBox.value()
        aw.qmc.movebackground(m,step)
        self.createEventTable()
        self.createDataTable()
        aw.qmc.redraw(recomputeAllDeltas=False)

    def readChecks(self):
        aw.qmc.background = bool(self.backgroundCheck.isChecked())
        aw.qmc.backgroundDetails = bool(self.backgroundDetails.isChecked())
        aw.qmc.backgroundeventsflag = bool(self.backgroundeventsflag.isChecked())
        aw.qmc.DeltaETBflag = bool(self.backgroundDeltaETflag.isChecked())
        aw.qmc.DeltaBTBflag = bool(self.backgroundDeltaBTflag.isChecked())
        aw.qmc.backgroundETcurve = bool(self.backgroundETflag.isChecked())
        aw.qmc.backgroundBTcurve = bool(self.backgroundBTflag.isChecked())
        aw.qmc.redraw(recomputeAllDeltas=True)
    
    @pyqtSlot(int)
    def changeAlignEventidx(self,i):
        aw.qmc.alignEvent = i
        
    @pyqtSlot(int)
    def changeReplayTypeidx(self,i):
        aw.qmc.replayType = i

    @pyqtSlot(int)
    def changeXTcurveidx(self,i):
        aw.qmc.xtcurveidx = i
        self.createDataTable()
        aw.qmc.redraw(recomputeAllDeltas=False,smooth=True)

    @pyqtSlot(bool)
    def load(self,_):
        self.filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Load Background",None),ext_alt=".alog")
        if len(u(self.filename)) == 0:
            return
        aw.sendmessage(QApplication.translate("Message","Reading background profile...",None))
        aw.qmc.resetlinecountcaches()
        aw.loadbackground(u(self.filename))
        self.xtcurveComboBox.blockSignals(True)
        # reset XT curve popup
        self.xtcurveComboBox.clear()
        curvenames = [""] # first entry is the empty one (no extra curve displayed)
        for i in range(min(len(aw.qmc.extraname1B),len(aw.qmc.extraname2B),len(aw.qmc.extratimexB))):
            curvenames.append("B" + str(2*i+3) + ": " + aw.qmc.extraname1B[i])
            curvenames.append("B" + str(2*i+4) + ": " + aw.qmc.extraname2B[i])
        self.xtcurveComboBox.addItems(curvenames)
        if aw.qmc.xtcurveidx < len(curvenames):
            self.xtcurveComboBox.setCurrentIndex(aw.qmc.xtcurveidx)
        self.xtcurveComboBox.blockSignals(False)
        self.pathedit.setText(u(self.filename))
        self.backgroundCheck.setChecked(True)
        aw.qmc.timealign(redraw=False)
        self.readChecks()
        self.createEventTable()
        self.createDataTable()

    def createEventTable(self):
        ndata = len(aw.qmc.backgroundEvents)
        
        # self.eventtable.clear() # this crashes Ubuntu 16.04
#        if ndata != 0:
#            self.eventtable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
        self.eventtable.clearSelection() # this seems to work also for Ubuntu 16.04
        
        self.eventtable.setRowCount(ndata)
        self.eventtable.setColumnCount(6)
        self.eventtable.setHorizontalHeaderLabels([QApplication.translate("Table","Time",None),
                                                   QApplication.translate("Table", "ET", None),
                                                   QApplication.translate("Table", "BT", None),
                                                   QApplication.translate("Table","Description",None),
                                                   QApplication.translate("Table","Type",None),
                                                   QApplication.translate("Table","Value",None)])
        self.eventtable.setAlternatingRowColors(True)
        self.eventtable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eventtable.setSelectionBehavior(QTableWidget.SelectRows)
        self.eventtable.setSelectionMode(QTableWidget.ExtendedSelection)
        self.eventtable.setShowGrid(True)
        self.eventtable.verticalHeader().setSectionResizeMode(2)
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        for i in range(ndata):
            timez = QTableWidgetItem(aw.qmc.stringfromseconds(int(aw.qmc.timeB[aw.qmc.backgroundEvents[i]]-start)))
            timez.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
    
            if aw.qmc.LCDdecimalplaces:
                fmtstr = "%.1f"
            else:
                fmtstr = "%.0f"
            
            etline = QTableWidgetItem(fmtstr%(aw.qmc.temp1B[aw.qmc.backgroundEvents[i]]) + aw.qmc.mode)
            etline.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
            
            btline = QTableWidgetItem(fmtstr%(aw.qmc.temp2B[aw.qmc.backgroundEvents[i]]) + aw.qmc.mode)
            btline.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
            
            description = QTableWidgetItem(aw.qmc.backgroundEStrings[i])
            etype = QTableWidgetItem(aw.qmc.Betypesf(aw.qmc.backgroundEtypes[i]))
            evalue = QTableWidgetItem(aw.qmc.eventsvalues(aw.qmc.backgroundEvalues[i]))
            evalue.setTextAlignment(Qt.AlignRight + Qt.AlignVCenter)
            #add widgets to the table
            self.eventtable.setItem(i,0,timez)
            self.eventtable.setItem(i,1,etline)
            self.eventtable.setItem(i,2,btline)
            self.eventtable.setItem(i,3,description)
            self.eventtable.setItem(i,4,etype)
            self.eventtable.setItem(i,5,evalue)
        # improve width of Time column
        self.eventtable.setColumnWidth(1,175)
        header = self.eventtable.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)
        header.setSectionResizeMode(1, QHeaderView.Fixed)
        header.setSectionResizeMode(2, QHeaderView.Fixed)
        header.setSectionResizeMode(3, QHeaderView.Stretch)
        header.setSectionResizeMode(4, QHeaderView.Fixed)
        header.setSectionResizeMode(5, QHeaderView.Fixed)
        self.eventtable.resizeColumnsToContents()
        self.eventtable.setColumnWidth(1,65)
        self.eventtable.setColumnWidth(2,65)

    def createDataTable(self):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            
            ndata = len(aw.qmc.timeB)
            
            # self.datatable.clear() # this crashes Ubuntu 16.04
    #        if ndata != 0:
    #            self.datatable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
            self.datatable.clearSelection() # this seems to work also for Ubuntu 16.04
    
            if aw.qmc.timeindexB[0] != -1 and len(aw.qmc.timeB) > aw.qmc.timeindexB[0]:
                start = aw.qmc.timeB[aw.qmc.timeindexB[0]]
            else:
                start = 0
            self.datatable.setRowCount(ndata)
            headers = [QApplication.translate("Table","Time",None),
                                                      QApplication.translate("Table","ET",None),
                                                      QApplication.translate("Table","BT",None),
                                                      deltaLabelUTF8 + QApplication.translate("Table","ET",None),
                                                      deltaLabelUTF8 + QApplication.translate("Table","BT",None)]
            xtcurve = False # no XT curve
            if aw.qmc.xtcurveidx > 0: # 3rd background curve set?
                idx3 = aw.qmc.xtcurveidx - 1
                n3 = idx3 // 2
                if len(aw.qmc.temp1BX) > n3 and len(aw.qmc.extratimexB) > n3:
                    xtcurve = True
                    if aw.qmc.xtcurveidx % 2:
                        headers.append(aw.qmc.extraname1B[n3])
                    else:
                        headers.append(aw.qmc.extraname2B[n3])
            headers.append("") # dummy column that stretches
            self.datatable.setColumnCount(len(headers))
            self.datatable.setHorizontalHeaderLabels(headers)
            self.datatable.setAlternatingRowColors(True)
            self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
            self.datatable.setSelectionMode(QTableWidget.ExtendedSelection) # QTableWidget.SingleSelection, ContiguousSelection, MultiSelection
            self.datatable.setShowGrid(True)
            self.datatable.verticalHeader().setSectionResizeMode(2)
            for i in range(ndata):
                Rtime = QTableWidgetItem(aw.qmc.stringfromseconds(aw.qmc.timeB[i]-start))
                Rtime.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                if aw.qmc.LCDdecimalplaces:
                    fmtstr = "%.1f"
                else:
                    fmtstr = "%.0f"
                ET = QTableWidgetItem(fmtstr%aw.qmc.temp1B[i])
                BT = QTableWidgetItem(fmtstr%aw.qmc.temp2B[i])
                ET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                BT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                if i:
                    d = (aw.qmc.timeB[i]-aw.qmc.timeB[i-1])
                    if d == 0:
                        dET = 0.
                        dBT = 0.
                    else:
                        dET = (60*(aw.qmc.temp1B[i]-aw.qmc.temp1B[i-1])/d)
                        dBT = (60*(aw.qmc.temp2B[i]-aw.qmc.temp2B[i-1])/d)
                    deltaET = QTableWidgetItem("%.1f"%dET)
                    deltaBT = QTableWidgetItem("%.1f"%dBT)
                else:
                    deltaET = QTableWidgetItem("--")
                    deltaBT = QTableWidgetItem("--")
                deltaET.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                deltaBT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                self.datatable.setItem(i,0,Rtime)
                        
                if i:
                    #identify by color and add notation
                    if i == aw.qmc.timeindexB[0] != -1:
                        self.datatable.item(i,0).setBackground(QColor('#f07800'))
                        text = QApplication.translate("Table", "CHARGE",None)
                    elif i == aw.qmc.timeindexB[1]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "DRY END",None)
                    elif i == aw.qmc.timeindexB[2]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "FC START",None)
                    elif i == aw.qmc.timeindexB[3]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "FC END",None)
                    elif i == aw.qmc.timeindexB[4]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "SC START",None)
                    elif i == aw.qmc.timeindexB[5]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "SC END",None)
                    elif i == aw.qmc.timeindexB[6]:
                        self.datatable.item(i,0).setBackground(QColor('#f07800'))
                        text = QApplication.translate("Table", "DROP",None)
                    elif i == aw.qmc.timeindexB[7]:
                        self.datatable.item(i,0).setBackground(QColor('orange'))
                        text = QApplication.translate("Table", "COOL",None)
                    elif i in aw.qmc.backgroundEvents:
                        self.datatable.item(i,0).setBackground(QColor('yellow'))
                        index = aw.qmc.backgroundEvents.index(i)
                        text = QApplication.translate("Table", "#{0} {1}{2}",None).format(str(index+1),aw.qmc.Betypesf(aw.qmc.backgroundEtypes[index])[0],aw.qmc.eventsvalues(aw.qmc.backgroundEvalues[index]))
                    else:
                        text = ""
                    Rtime.setText(text + u(" " + Rtime.text()))
                self.datatable.setItem(i,1,ET)
                self.datatable.setItem(i,2,BT)
                self.datatable.setItem(i,3,deltaET)
                self.datatable.setItem(i,4,deltaBT)
                
                if xtcurve and len(aw.qmc.temp1BX[n3]) > i: # an XT column is availble, fill it with data
                    if aw.qmc.xtcurveidx % 2:
                        XT = QTableWidgetItem("%.0f"%aw.qmc.temp1BX[n3][i])
                    else:
                        XT = QTableWidgetItem("%.0f"%aw.qmc.temp2BX[n3][i])
                    XT.setTextAlignment(Qt.AlignRight|Qt.AlignVCenter)
                    self.datatable.setItem(i,5,XT)
                    
            header = self.datatable.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.Fixed)
            header.setSectionResizeMode(1, QHeaderView.Fixed)
            header.setSectionResizeMode(2, QHeaderView.Fixed)
            header.setSectionResizeMode(3, QHeaderView.Fixed)
            header.setSectionResizeMode(4, QHeaderView.Fixed)
            if xtcurve:
                header.setSectionResizeMode(5, QHeaderView.Fixed)
                header.setSectionResizeMode(6, QHeaderView.Stretch)
            else:
                header.setSectionResizeMode(5, QHeaderView.Stretch)
            self.datatable.resizeColumnsToContents()
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)

    @pyqtSlot(bool)
    def copyDataTabletoClipboard(self,_=False):
        self.datatable.selectAll()
        aw.copy_cells_to_clipboard(self.datatable,adjustment=7)
        self.datatable.clearSelection()
        aw.sendmessage(QApplication.translate("Message","Data table copied to clipboard",None))

    @pyqtSlot(bool)
    def copyEventTabletoClipboard(self,_=False):
        aw.copy_cells_to_clipboard(self.eventtable,adjustment=0)
        aw.sendmessage(QApplication.translate("Message","Event table copied to clipboard",None))


#############################################################################
################  Statistics DIALOG ########################
#############################################################################

class StatisticsDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(StatisticsDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Statistics",None))
        self.setModal(True)
        self.timez = QCheckBox(QApplication.translate("CheckBox","Time",None))
        self.bar = QCheckBox(QApplication.translate("CheckBox","Bar",None))
        self.ror = QCheckBox(aw.qmc.mode + QApplication.translate("CheckBox","/min",None))
        self.ts = QCheckBox(QApplication.translate("CheckBox","AUC",None))
        self.area = QCheckBox(QApplication.translate("CheckBox","Characteristics",None))
        self.ShowStatsSummary = QCheckBox(QApplication.translate("CheckBox", "Summary",None))
        self.ShowStatsSummary.setChecked(aw.qmc.statssummary)
        self.ShowStatsSummary.stateChanged.connect(self.changeStatsSummary)         #toggle
        #temp fix for possible bug aw.qmc.statisticsflags=[] > empty list out of range
        if aw.qmc.statisticsflags:
            if aw.qmc.statisticsflags[0]:
                self.timez.setChecked(True)
            if aw.qmc.statisticsflags[1]:
                self.bar.setChecked(True)
            if aw.qmc.statisticsflags[3]:
                self.area.setChecked(True)
            if aw.qmc.statisticsflags[4]:
                self.ror.setChecked(True)
            if aw.qmc.statisticsflags[5]:
                self.ts.setChecked(True)
        else:
            aw.qmc.statisticsflags = [1,1,0,1,1,0]
            self.timez.setChecked(True)
            self.bar.setChecked(True)
            self.area.setChecked(True)
            self.ror.setChecked(True)
            self.ts.setChecked(False)
        self.timez.stateChanged.connect(self.changeStatisticsflag)
        self.bar.stateChanged.connect(self.changeStatisticsflag)
        # flag 2 not used anymore
        self.area.stateChanged.connect(self.changeStatisticsflag)
        self.ror.stateChanged.connect(self.changeStatisticsflag)
        self.ts.stateChanged.connect(self.changeStatisticsflag)
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        flagsLayout = QGridLayout()
        flagsLayout.addWidget(self.timez,0,0)
        flagsLayout.addWidget(self.bar,0,1)
        flagsLayout.addWidget(self.ror,0,2)
        flagsLayout.addWidget(self.ts,0,3)
        flagsLayout.addWidget(self.area,0,4)
        flagsLayout.addWidget(self.ShowStatsSummary,0,5)
        
        beginlabel =QLabel(QApplication.translate("Label", "From",None))
        beginitems = [
                    QApplication.translate("Label","CHARGE",None),
                    QApplication.translate("Label","TP",None),
                    QApplication.translate("Label","DRY END",None),
                    QApplication.translate("Label","FC START",None)]
        self.beginComboBox = QComboBox()
        self.beginComboBox.setFocusPolicy(Qt.NoFocus)
        self.beginComboBox.setMaximumWidth(120)
        self.beginComboBox.addItems(beginitems)
        self.beginComboBox.setCurrentIndex(aw.qmc.AUCbegin)
        baselabel =QLabel(QApplication.translate("Label", "Base",None))
        self.baseedit = QSpinBox()
        self.baseedit.setAlignment(Qt.AlignRight)
        self.baseedit.setRange(0,999)
        self.baseedit.setValue(aw.qmc.AUCbase)
        if aw.qmc.mode == "F":
            self.baseedit.setSuffix(" F")
        else:
            self.baseedit.setSuffix(" C")
        self.baseFlag = QCheckBox(QApplication.translate("CheckBox","From Event", None))
        self.baseedit.setEnabled(not aw.qmc.AUCbaseFlag)
        self.baseFlag.setChecked(aw.qmc.AUCbaseFlag)
        self.baseFlag.stateChanged.connect(self.switchAUCbase)
        targetlabel =QLabel(QApplication.translate("Label", "Target",None))
        self.targetedit = QSpinBox()
        self.targetedit.setAlignment(Qt.AlignRight)
        self.targetedit.setRange(0,9999)
        self.targetedit.setValue(aw.qmc.AUCtarget)
        self.targetFlag = QCheckBox(QApplication.translate("CheckBox","Background", None))
        self.targetedit.setEnabled(not aw.qmc.AUCtargetFlag)
        self.targetFlag.setChecked(aw.qmc.AUCtargetFlag)        
        self.targetFlag.stateChanged.connect(self.switchAUCtarget)
        self.guideFlag = QCheckBox(QApplication.translate("CheckBox","Guide", None))
        self.guideFlag.setChecked(aw.qmc.AUCguideFlag)
        self.AUClcdFlag = QCheckBox(QApplication.translate("CheckBox","LCD", None))
        self.AUClcdFlag.setChecked(aw.qmc.AUClcdFlag)
        self.AUClcdFlag.stateChanged.connect(self.AUCLCFflagChanged)
        self.AUCshowFlag = QCheckBox(QApplication.translate("CheckBox","Show Area", None))
        self.AUCshowFlag.setChecked(aw.qmc.AUCshowFlag)
        self.AUCshowFlag.stateChanged.connect(self.changeAUCshowFlag)

        statsmaxchrperlinelabel =QLabel(QApplication.translate("Label", "Max characters per line",None))
        self.statsmaxchrperlineedit = QSpinBox()
        self.statsmaxchrperlineedit.setAlignment(Qt.AlignRight)
        self.statsmaxchrperlineedit.setRange(1,120)
        self.statsmaxchrperlineedit.setValue(aw.qmc.statsmaxchrperline)
        self.statsmaxchrperlineedit.setFocusPolicy(Qt.StrongFocus)
        statsmaxchrperlineHorizontal = QHBoxLayout()
        statsmaxchrperlineHorizontal.addWidget(statsmaxchrperlinelabel)
        statsmaxchrperlineHorizontal.addWidget(self.statsmaxchrperlineedit)
        statsmaxchrperlineHorizontal.addStretch()
        statsmaxchrperlineGroupLayout = QGroupBox(QApplication.translate("GroupBox","Stats Summary",None))
        statsmaxchrperlineGroupLayout.setLayout(statsmaxchrperlineHorizontal)

        AUCgrid = QGridLayout()
        AUCgrid.addWidget(beginlabel,0,0,Qt.AlignRight)
        AUCgrid.addWidget(self.beginComboBox,0,1,1,2)
        AUCgrid.addWidget(baselabel,1,0,Qt.AlignRight)
        AUCgrid.addWidget(self.baseedit,1,1)
        AUCgrid.addWidget(self.baseFlag,1,2)
        AUCgrid.addWidget(targetlabel,2,0,Qt.AlignRight)
        AUCgrid.addWidget(self.targetedit,2,1)
        AUCgrid.addWidget(self.targetFlag,2,2)
        AUCgrid.addWidget(self.AUClcdFlag,4,1)
        AUCgrid.addWidget(self.guideFlag,4,2)
        AUCgrid.addWidget(self.AUCshowFlag,5,1)
        AUCgrid.setRowMinimumHeight(3, 20)
        AUCvertical = QVBoxLayout()
        AUCvertical.addLayout(AUCgrid)
        AUCvertical.addStretch()
        AUCgroupLayout = QGroupBox(QApplication.translate("GroupBox","AUC",None))
        AUCgroupLayout.setLayout(AUCvertical)
        displayGroupLayout = QGroupBox(QApplication.translate("GroupBox","Display",None))
        displayGroupLayout.setLayout(flagsLayout)
        buttonsLayout = QHBoxLayout()
        buttonsLayout.addWidget(self.dialogbuttons)
        vgroupLayout = QVBoxLayout()
        vgroupLayout.addWidget(AUCgroupLayout)
        vgroupLayout.addWidget(statsmaxchrperlineGroupLayout)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(displayGroupLayout)
        mainLayout.addLayout(vgroupLayout)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def AUCLCFflagChanged(self,_):
        aw.qmc.AUClcdFlag = not aw.qmc.AUClcdFlag
        if aw.qmc.flagstart:
            if aw.qmc.AUClcdFlag:
                aw.AUCLCD.show()
            else:
                aw.AUCLCD.hide()
        if aw.largePhasesLCDs_dialog is not None:
            aw.largePhasesLCDs_dialog.updateVisiblitiesPhases()

    @pyqtSlot(int)
    def changeAUCshowFlag(self,_):
        aw.qmc.AUCshowFlag = not aw.qmc.AUCshowFlag
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot(int)
    def switchAUCbase(self,i):
        if i:
            self.baseedit.setEnabled(False)
        else:
            self.baseedit.setEnabled(True)
            
    @pyqtSlot(int)
    def switchAUCtarget(self,i):
        if i:
            self.targetedit.setEnabled(False)
        else:
            self.targetedit.setEnabled(True)

    @pyqtSlot(int)
    def changeStatsSummary(self,_):
        aw.qmc.statssummary = not aw.qmc.statssummary
        # IF Auto is set for the axis the recompute it
        if aw.qmc.autotimex and not aw.qmc.statssummary:
            aw.autoAdjustAxis()
        aw.qmc.redraw(recomputeAllDeltas=False)
        if aw.qmc.statssummary and not aw.qmc.flagon:
            aw.savestatisticsAction.setEnabled(True)
        else:
            aw.savestatisticsAction.setEnabled(False)
    
    @pyqtSlot(int)
    def changeStatisticsflag(self,value):
        sender = self.sender()
        if sender == self.timez:
            i = 0
        elif sender == self.bar:
            i = 1
        elif sender == self.area:
            i = 3
        elif sender == self.ror:
            i = 4
        elif sender == self.ts:
            i = 5
        else:
            return
        aw.qmc.statisticsflags[i] = value
        aw.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def accept(self):
        aw.qmc.statsmaxchrperline = self.statsmaxchrperlineedit.value()
        aw.qmc.AUCbegin = self.beginComboBox.currentIndex()
        aw.qmc.AUCbase = self.baseedit.value()
        aw.qmc.AUCbaseFlag = self.baseFlag.isChecked()
        aw.qmc.AUCtarget = self.targetedit.value()
        aw.qmc.AUCtargetFlag = self.targetFlag.isChecked()
        aw.qmc.AUCguideFlag = self.guideFlag.isChecked()
        aw.qmc.AUClcdFlag = self.AUClcdFlag.isChecked()
        try:
            if aw.qmc.TP_time_B:
                _,_,auc,_ = aw.ts(tp=aw.qmc.backgroundtime2index(aw.qmc.TP_time_B),background=True)
            else:
                _,_,auc,_ = aw.ts(tp=0,background=True)
            aw.qmc.AUCbackground = auc
        except:
            pass
        if self.timez.isChecked(): 
            aw.qmc.statisticsflags[0] = 1
        else:
            aw.qmc.statisticsflags[0] = 0
            
        if self.bar.isChecked(): 
            aw.qmc.statisticsflags[1] = 1
        else:
            aw.qmc.statisticsflags[1] = 0
            
        if self.area.isChecked(): 
            aw.qmc.statisticsflags[3] = 1
        else:
            aw.qmc.statisticsflags[3] = 0
            
        if self.ror.isChecked(): 
            aw.qmc.statisticsflags[4] = 1
        else:
            aw.qmc.statisticsflags[4] = 0
            
        if self.ts.isChecked(): 
            aw.qmc.statisticsflags[5] = 1
        else:
            aw.qmc.statisticsflags[5] = 0
        aw.qmc.redraw(recomputeAllDeltas=False)
        self.close()

class extraserialport(object):
    def __init__(self):
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 19200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 1.0
        self.devicefunctionlist = {}
        self.device = None
        self.SP = None

    def confport(self):
        self.SP.port = self.comport
        self.SP.baudrate = self.baudrate
        self.SP.bytesize = self.bytesize
        self.SP.parity = self.parity
        self.SP.stopbits = self.stopbits
        self.SP.timeout = self.timeout

    def openport(self):
        try:
            self.confport()
            #open port
            if not self.SP.isOpen():
                self.SP.open()
        except Exception:
            self.SP.close()            
#            libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port get's disabled
            error = QApplication.translate("Error Message","Serial Exception:",None)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(error + " Unable to open serial port",exc_tb.tb_lineno)

    def closeport(self):
        if self.SP is not None:
            self.SP.close()
            libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port get's disabled

    # this one is called from scale and color meter code
    def connect(self,error=True):
        if self.SP is None:
            try:
                import serial  # @UnusedImport
                self.SP = serial.Serial()
            except Exception as e:
                if error:
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Serial Exception:",None) + " connect() {0}").format(str(e)),exc_tb.tb_lineno)
        if self.SP is not None:
            try:
                self.openport()
                if self.SP.isOpen():
                    return True
                else:
                    return False
            except Exception as e:
                if error:
                    _, _, exc_tb = sys.exc_info()
                    aw.qmc.adderror((QApplication.translate("Error Message","Serial Exception:",None) + " connect() {0}").format(str(e)),exc_tb.tb_lineno)
                return False
        else:
            return False



class scaleport(extraserialport):
    """ this class handles the communications with the scale"""
    def __init__(self):
        super(scaleport, self).__init__()
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 19200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 0.2
        self.devicefunctionlist = {
            "None" : None,
            "KERN NDE" : self.readKERN_NDE,
            "acaia" : self.readAcaia,
            #"Shore 930" : self.readShore930,
        }

    def closeport(self):
        if u(self.device) == "acaia":
            # disconnect from acaia scale
            try:
                if self.SP.isOpen():
                    self.SP.write(str2cmd('BTDS\r\n'))
            except Exception:
                pass
        super(scaleport, self).closeport()
        
    # returns one of weight (g), density (g/l), or moisture (%).  Others return -1.
    def readWeight(self,scale_weight=None):
        if scale_weight != None:
            return scale_weight,-1,-1
        else:
            if self.device is not None and self.device != "None" and self.device != "" and self.device != "acaia":
                wei,den,moi = self.devicefunctionlist[u(self.device)]()
                if moi is not None and moi > -1:
                    return -1, -1, aw.float2float(moi)
                elif den is not None and den > -1:
                    return -1, aw.float2float(den), -1
                elif wei is not None and wei > -1:
                    return aw.float2float(wei), -1, -1
                else:
                    return -1,-1,-1
            else:
                return -1,-1,-1
            
    def readLine(self):
        return str(self.SP.readline().decode('ascii'))

    # replaced by BLE direct implementation
    def readAcaia(self):
        pass

    def readKERN_NDE(self):
        try:
            if not self.SP:
                self.connect()
            if self.SP:
                if not self.SP.isOpen():
                    self.openport()
                if self.SP.isOpen():
                    #self.SP.write(str2cmd('s')) # only stable
                    self.SP.write(str2cmd('w')) # any weight
                    v = self.SP.readline()
                    if len(v) == 0:
                        return -1,-1,-1
                    sa = v.decode('ascii').split('g')
                    if len(sa) == 2:
                        return int(sa[0].replace(" ", "")), -1, -1
                    else:
                        # some times the unit is just missing, we assume it is g
                        sa = v.decode('ascii').split('\r\n')
                        if len(sa) == 2:
                            return int(sa[0].replace(" ", "")),-1,-1
                        return -1, -1, -1
        except Exception:
            return -1, -1, -1

    def readShore930(self):
        try:
            if not self.SP:
                self.connect()
            if self.SP:
                if not self.SP.isOpen():
                    self.openport()
                if self.SP.isOpen():
                    line1 = self.SP.readline()
                    weight = re.search(r'Current Weight:',str(line1))
                    if weight:                    
                        w = re.findall(r'([0-9\.]+)',str(line1))
                        if len(w) == 1:
                            return toFloat(w[0]),-1,-1
                        else:
                            return -1,-1,-1

                    density = re.search(r'Test Weight',str(line1))
                    if density:
                        line2 = self.SP.readline()
                        d = re.findall(r'[0-9\.\-]+',str(line2))
                        if len(d) == 1:
                            den = toFloat(d[0]) *12.8718597   # convert from LBS/BU to g/
                            return -1,toFloat(den),-1
                        else:
                            return -1,-1,-1

                    moisture = re.search(r'Beans',str(line1))
                    if moisture:
                        line2 = self.SP.readline()
                        m = re.findall(r'[0-9\.\-]+',str(line2))
#                        line3 = self.SP.readline() # unused!
                        if len(m) == 1:
                            return -1,-1,toFloat(m[0])
                        else:
                            return -1,-1,-1

                    else:
                        return -1,-1,-1
        except Exception:
            return -1,-1,-1


class colorport(extraserialport):
    """ this class handles the communications with the color meter"""
    def __init__(self):
        super(colorport, self).__init__()
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "/dev/cu.usbserial-FTFKDA5O"      #NOTE: this string should not be translated.
        self.baudrate = 115200
        self.bytesize = 8
        self.parity= 'N'
        self.stopbits = 1
        self.timeout = 2
        self.devicefunctionlist = {
            "None" : None,
            "Tiny Tonino" : self.readTonino,
            "Classic Tonino" : self.readTonino
        }

    # returns color as int or -1 if something went wrong
    def readColor(self):
        if self.device is not None and self.device != "None" and self.device != "":
            return self.devicefunctionlist[u(self.device)]()
        else:
            return -1

    def readline_terminated(self,eol=b'\r'):
        leneol = len(eol)
        line = bytearray()
        while True:
            c = self.SP.read(1)
            if c:
                line += c
                if line[-leneol:] == eol:
                    break
            else:
                break
        return bytes(line)

    def readTonino(self,retry=2):
        try:
            if not self.SP:
                self.connect()
                libtime.sleep(2)
                # put Tonino into PC mode on first connect
                self.SP.write(str2cmd('\nTONINO\n'))
                #self.SP.flush()
                self.readline_terminated(b'\n')
            if self.SP:
                if not self.SP.isOpen():
                    self.openport()
                if self.SP.isOpen():
                    self.SP.reset_input_buffer()
                    self.SP.reset_output_buffer()
                    self.SP.write(str2cmd('\nSCAN\n'))
                    #self.SP.flush()
                    v = self.readline_terminated(b'\n').decode('ascii')
                    if "SCAN" in v:
                        n = int(v.split(":")[1]) # response should have format "SCAN:128"
                        return n
                    elif retry > 0:
                        return self.readTonino(self,retry-1)
                    else:
                        return -1
        except Exception:
            return -1


###########################################################################################
##################### YOCTO ASYNC THREAD ##################################################
###########################################################################################

class YoctoThread(threading.Thread):
    def __init__(self):
        self._stopevent = threading.Event()
        threading.Thread.__init__(self)
    
    def run(self):
        errmsg = YRefParam()
        while not self._stopevent.isSet():
            YAPI.UpdateDeviceList(errmsg)  # traps plug/unplug events
            YAPI.Sleep(500, errmsg)  # traps others events

    def join(self, timeout=None):
        self._stopevent.set()
        threading.Thread.join(self, timeout)

###########################################################################################
##################### SERIAL PORT #########################################################
###########################################################################################

class serialport(object):
    """ this class handles the communications with all the devices"""

    __slots__ = ['comport','baudrate','bytesize','parity','stopbits','timeout','SP','COMsemaphore','commavailable',\
        'PhidgetTemperatureSensor','Phidget1048values','Phidget1048lastvalues','Phidget1048semaphores',\
        'PhidgetIRSensor','PhidgetIRSensorIC','Phidget1045values','Phidget1045lastvalue','Phidget1045tempIRavg',\
        'Phidget1045semaphore','PhidgetBridgeSensor','Phidget1046values','Phidget1046lastvalues','Phidget1046semaphores',\
        'PhidgetIO','PhidgetIOvalues','PhidgetIOlastvalues','PhidgetIOsemaphores','PhidgetDigitalOut',\
        'PhidgetDigitalOutLastPWM','PhidgetDigitalOutLastToggle','PhidgetDigitalOutHub','PhidgetDigitalOutLastPWMhub',\
        'PhidgetDigitalOutLastToggleHub','PhidgetAnalogOut','PhidgetDCMotor','PhidgetRCServo','PhidgetBinaryOut',\
        'YOCTOlibImported','YOCTOsensor','YOCTOchan1','YOCTOchan2','YOCTOtempIRavg','YOCTOvalues','YOCTOlastvalues','YOCTOsemaphores',\
        'YOCTOthread','YOCTOvoltageOutputs','YOCTOcurrentOutputs','YOCTOrelays','YOCTOservos','YOCTOpwmOutputs','HH506RAid','MS6514PrevTemp1','MS6514PrevTemp2','DT301PrevTemp','EXTECH755PrevTemp',\
        'controlETpid','readBTpid','useModbusPort','showFujiLCDs','arduinoETChannel','arduinoBTChannel','arduinoATChannel',\
        'ArduinoIsInitialized','ArduinoFILT','HH806Winitflag','R1','devicefunctionlist','externalprogram',\
        'externaloutprogram','externaloutprogramFlag']

    def __init__(self):
        
        #default initial settings. They are changed by settingsload() at initiation of program acording to the device chosen
        self.comport = "COM4"      #NOTE: this string should not be translated. It is an argument for lib Pyserial
        self.baudrate = 9600
        self.bytesize = 8
        self.parity= 'O'
        self.stopbits = 1
        self.timeout=1.0
        #serial port for ET/BT
        import serial  # @UnusedImport
        self.SP = serial.Serial()
        #used only in devices that also control the roaster like PIDs or arduino (possible to recieve asynchrous comands from GUI commands and thread sample()). 
        self.COMsemaphore = QSemaphore(1) 
        #list of comm ports available after Scan
        self.commavailable = []
        ##### SPECIAL METER FLAGS ########
        #stores the Phidget 1048 TemperatureSensor object (None if not initialized)
        self.PhidgetTemperatureSensor = None # either None or a list containing one PhidgetTemperatureSensor() object per channel
        self.Phidget1048values = [[],[],[],[]] # the values for each of the 4 channels gathered by registered change triggers in the last period
        self.Phidget1048lastvalues = [-1]*4 # the last async values returned
        self.Phidget1048semaphores = [QSemaphore(1),QSemaphore(1),QSemaphore(1),QSemaphore(1)] # semaphores protecting the access to self.Phidget1048values per channel
        # list of (serial,port) tuples filled on attaching the corresponding main device and consumed on attaching the other channel pairs
        #stores the Phidget 1045 TemperatureSensor object (None if not initialized)
        self.PhidgetIRSensor = None
        self.PhidgetIRSensorIC = None
        self.Phidget1045values = [] # async values of the one channel
        self.Phidget1045lastvalue = -1
        self.Phidget1045tempIRavg = None
        self.Phidget1045semaphore = QSemaphore(1) # semaphore protecting the access to self.Phidget1045values per channel
        #stores the Phidget BridgeSensor object (None if not initialized)
        self.PhidgetBridgeSensor = None
        self.Phidget1046values = [[],[],[],[]] # the values for each of the 4 channels gathered by registered change triggers in the last period
        self.Phidget1046lastvalues = [-1]*4 # the last async values returned
        self.Phidget1046semaphores = [QSemaphore(1),QSemaphore(1),QSemaphore(1),QSemaphore(1)] # semaphores protecting the access to self.Phidget1046values per channel
        #stores the Phidget IO object (None if not initialized)
        self.PhidgetIO = None
        self.PhidgetIOvalues = [[],[],[],[],[],[],[],[]] # the values gathered by registered change triggers
        self.PhidgetIOlastvalues = [-1]*8 # the values gathered by registered change triggers
        self.PhidgetIOsemaphores = [QSemaphore(1),QSemaphore(1),QSemaphore(1),QSemaphore(1)] # semaphores protecting the access to self.Phidget1048values per channel
        #stores the Phidget Digital Output PMW objects (None if not initialized)
        self.PhidgetDigitalOut = {} # a dict associating out serials with lists of channels
        self.PhidgetDigitalOutLastPWM = {} # a dict assocating out serials with the list of last PWMs per channel
        self.PhidgetDigitalOutLastToggle = {} # a dict associating out serials with the list of last toggles per channel; if not None, channel was last toggled OFF and the value indicates that lastPWM on switching OFF
        self.PhidgetDigitalOutHub = {} # a dict associating hub serials with lists of channels
        self.PhidgetDigitalOutLastPWMhub = {} # a dict assocating hub serials with the list of last PWMs per port of the hub
        self.PhidgetDigitalOutLastToggleHub = {} # a dict associating hub serials with the list of last toggles per port of the hub; if not None, channel was last toggled OFF and the value indicates that lastPWM on switching OFF
        #store the Phidget Analog Output objects
        self.PhidgetAnalogOut = {} # a dict associating serials with lists of channels
        #store the servo objects
        self.PhidgetRCServo = {} # a dict associating serials with lists of channels
        #store the Phidget IO Binary Output objects
        self.PhidgetBinaryOut = {} # a dict associating binary out serials with lists of channels
        #store the Phidget DCMotor objects
        self.PhidgetDCMotor = {} # a dict associating serials with lists of channels
        #Yoctopuce channels
        self.YOCTOlibImported = False # ensure that the YOCTOlib is only imported once
        self.YOCTOsensor = None
        self.YOCTOchan1 = None
        self.YOCTOchan2 = None
        self.YOCTOtempIRavg = None # averages IR module temperature channel to eliminate noise

        self.YOCTOvalues = [[],[]] # the values for each of the 2 channels gathered by registered change triggers in the last period
        self.YOCTOlastvalues = [-1]*2 # the last async values returned
        self.YOCTOsemaphores = [QSemaphore(1),QSemaphore(1)] # semaphores protecting the access to YOCTO per channel
        self.YOCTOthread = None
        
        self.YOCTOvoltageOutputs = []
        self.YOCTOcurrentOutputs = []
        self.YOCTOrelays = []
        self.YOCTOservos = []
        self.YOCTOpwmOutputs = []

        #stores the _id of the meter HH506RA as a string
        self.HH506RAid = "X"
        #MS6514 variables
        self.MS6514PrevTemp1 = -1
        self.MS6514PrevTemp2 = -1
        #DT301 variable
        self.DT301PrevTemp = -1
        #EXPTECH755 variable
        self.EXTECH755PrevTemp = -1
        #select PID type that controls the roaster.
        # Reads/Controls ET
        self.controlETpid = [0,1]        # index0: type of pid: 0 = FujiPXG, 1 = FujiPXR3, 2 = DTA, 3 = not used, 4 = PXF
#                                        # index1: RS485 unitID: Can be changed in device menu.
        # Reads BT
        self.readBTpid = [1,2]           # index 0: type: FujiPXG, 1 = FujiPXR3, 2 = None, 3 = DTA, 4 = PXF
#                                        # index 1: RS485 unitID. Can be changed in device menu. 
        # Reuse Modbus-meter port
        self.useModbusPort = False
        self.showFujiLCDs = True
        #Initialization for ARDUINO and TC4 meter
        self.arduinoETChannel = "1"
        self.arduinoBTChannel = "2"
        self.arduinoATChannel = "None" # the channel the Ambient Temperature of the Arduino TC4 is reported as (this value will overwrite the corresponding real channel)
        self.ArduinoIsInitialized = 0
        self.ArduinoFILT = [70,70,70,70] # Arduino Filter settings per channel in %
        self.HH806Winitflag = 0
        self.R1 = None
        #list of functions calls to read temperature for devices.
        # device 0 (with index 0 bellow) is Fuji Pid
        # device 1 (with index 1 bellow) is Omega HH806
        # device 2 (with index 2 bellow) is omega HH506
        # etc
        # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
        # - add to self.devicefunctionlist
        self.devicefunctionlist = [self.fujitemperature,    #0
                                   self.HH806AU,            #1
                                   self.HH506RA,            #2
                                   self.CENTER309,          #3
                                   self.CENTER306,          #4
                                   self.CENTER305,          #5
                                   self.CENTER304,          #6
                                   self.CENTER303,          #7
                                   self.CENTER302,          #8
                                   self.CENTER301,          #9
                                   self.CENTER300,          #10
                                   self.VOLTCRAFTK204,      #11
                                   self.VOLTCRAFTK202,      #12
                                   self.VOLTCRAFT300K,      #13
                                   self.VOLTCRAFT302KJ,     #14
                                   self.EXTECH421509,       #15
                                   self.HH802U,             #16
                                   self.HH309,              #17
                                   self.NONE,               #18
                                   self.ARDUINOTC4,         #19
                                   self.TEVA18B,            #20
                                   self.CENTER309_34,       #21
                                   self.piddutycycle,       #22
                                   self.HHM28,              #23
                                   self.K204_34,            #24
                                   self.virtual,            #25
                                   self.DTAtemperature,     #26
                                   self.callprogram,        #27
                                   self.ARDUINOTC4_34,      #28
                                   self.MODBUS,             #29
                                   self.VOLTCRAFTK201,      #30
                                   self.AmprobeTMD56,       #31
                                   self.ARDUINOTC4_56,      #32
                                   self.MODBUS_34,          #33
                                   self.PHIDGET1048,        #34
                                   self.PHIDGET1048_34,     #35
                                   self.PHIDGET1048_AT,     #36
                                   self.PHIDGET1046,        #37
                                   self.PHIDGET1046_34,     #38
                                   self.MastechMS6514,      #39
                                   self.PHIDGET1018,        #40
                                   self.PHIDGET1018_34,     #41
                                   self.PHIDGET1018_56,     #42
                                   self.PHIDGET1018_78,     #43
                                   self.ARDUINOTC4_78,      #44
                                   self.YOCTO_thermo,       #45
                                   self.YOCTO_pt100,        #46
                                   self.PHIDGET1045,        #47
                                   self.callprogram_34,     #48
                                   self.callprogram_56,     #49
                                   self.DUMMY,              #50
                                   self.CENTER304_34,       #51
                                   self.PHIDGET1051,        #52
                                   self.HOTTOP_BTET,        #53
                                   self.HOTTOP_HF,          #54
                                   self.MODBUS_56,          #55
                                   self.DT301,              #56
                                   self.EXTECH755,          #57
                                   self.PHIDGET_TMP1101,    #58
                                   self.PHIDGET_TMP1101_34, #59
                                   self.PHIDGET_TMP1101_AT, #60
                                   self.PHIDGET_TMP1100,    #61
                                   self.PHIDGET1011,        #62
                                   self.PHIDGET_HUB0000,    #63
                                   self.PHIDGET_HUB0000_34, #64
                                   self.PHIDGET_HUB0000_56, #65
                                   self.HH806W,             #66
                                   self.VOLTCRAFTPL125T2,   #67
                                   self.PHIDGET_TMP1200,    #68
                                   self.PHIDGET1018_D,        #69
                                   self.PHIDGET1018_D_34,     #70
                                   self.PHIDGET1018_D_56,     #71
                                   self.PHIDGET1018_D_78,     #72
                                   self.PHIDGET1011_D,        #73
                                   self.PHIDGET_HUB0000_D,    #74
                                   self.PHIDGET_HUB0000_D_34, #75
                                   self.PHIDGET_HUB0000_D_56, #76
                                   self.VOLTCRAFTPL125T4,     #77
                                   self.VOLTCRAFTPL125T4_34,  #78
                                   self.S7,                   #79
                                   self.S7_34,                #80
                                   self.S7_56,                #81
                                   self.S7_78,                #82
                                   self.R1_DTBT,              #83
                                   self.R1_HF,                #84
                                   self.R1_DRUM_BTROR,        #85
                                   self.R1_EXIT_TEMP_VOLT,    #86
                                   self.R1_RPM_STATE,         #87
                                   self.callprogram_78,       #88
                                   self.callprogram_910,      #89
                                   self.slider_01,            #90
                                   self.slider_23,            #91
                                   self.probat_middleware,    #92
                                   self.probat_middleware_burner_drum,  #93
                                   self.probat_middleware_fan_pressure, #94
                                   self.PHIDGET_DAQ1400_CURRENT,   #95
                                   self.PHIDGET_DAQ1400_FREQUENCY, #96 
                                   self.PHIDGET_DAQ1400_DIGITAL,   #97 
                                   self.PHIDGET_DAQ1400_VOLTAGE,   #98
                                   self.R1_BTIBTS,            # 99
                                   self.YOCTO_IR,             #100
                                   self.BEHMOR_BTET,          #101
                                   self.BEHMOR_34,            #102
                                   self.VICTOR86B,            #103
                                   self.BEHMOR_56,            #104
                                   self.BEHMOR_78,            #105
                                   self.PHIDGET_HUB0000_0,    #106
                                   self.PHIDGET_HUB0000_D_0,  #107
                                   self.YOCTO_generic,        #108
                                   self.MODBUS_78,            #109
                                   self.S7_910,               #110
                                   ]
        #string with the name of the program for device #27
        self.externalprogram = "test.py"
        self.externaloutprogram = "out.py" # this program is called with arguments <ET>,<BT>,<ETB>,<BTB> values on each sampling
        self.externaloutprogramFlag = False # if true the externaloutprogram will be called on each sample()

#####################  FUNCTIONS  ############################
    ######### functions used by Fuji PIDs
    def sendFUJIcommand(self,binstring,nbytes):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(binstring)
                r = self.SP.read(nbytes)
                #serTX.close()
                libtime.sleep(0.035)                     #this garantees a minimum of 35 miliseconds between readings (for all Fujis)
                lenstring = len(r)
                if lenstring:
                    # CHECK FOR RECEIVED ERROR CODES
                    if r[1] == 128:
                        if r[2] == 1:
                            errorcode = QApplication.translate("Error Message","F80h Error",None) + u(" 1: A nonexistent function code was specified. Please check the function code.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None) + u(" SendFUJIcommand() 1: Illegal Function in unit {0}")).format(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if r[2] == 2:
                            errorcode = QApplication.translate("Error Message","F80h Error",None) + u(" 2: Faulty address for coil or resistor: The specified relative address for the coil number or resistor\n number cannot be used by the specified function code.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None) + u(" SendFUJIcommand() 2 Illegal Address for unit {0}")).format(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                        if r[2] == 3:
                            errorcode = QApplication.translate("Error Message","F80h Error",None) + u(" 3: Faulty coil or resistor number: The specified number is too large and specifies a range that does not contain\n coil numbers or resistor numbers.")
                            errorcode += (QApplication.translate("Error Message","Exception:",None) + u(" SendFUJIcommand() 3 Illegal Data Value for unit {0}")).format(ord(binstring[0]))
                            aw.qmc.adderror(errorcode)
                    else:
                        #Check crc16
                        crcRx =  hex2int(r[-1],r[-2])
                        crcCal1 = aw.fujipid.fujiCrc16(r[:-2])
                        if crcCal1 == crcRx:
                            return r           #OK. Return r after it has been checked for errors
                        else:
                            aw.qmc.adderror(QApplication.translate("Error Message","CRC16 data corruption ERROR. TX does not match RX. Check wiring",None))
                            return "0"
                else:
                    aw.qmc.adderror(QApplication.translate("Error Message","No RX data received",None))
                    return "0"
            else:
                return "0"
        except Exception:
            timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
            error = QApplication.translate("Error Message","Serial Exception:",None) + " ser.sendFUJIcommand()"
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return "0"
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)                
                aw.addserial("Fuji: " + settings + " || Tx = " + cmd2str(binascii.hexlify(binstring)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    #finds time, ET and BT when using Fuji PID. Updates sv (set value) LCD. Finds power duty cycle
    def fujitemperature(self):
        #update ET SV LCD 6
        aw.qmc.currentpidsv = aw.fujipid.readcurrentsv()
        #get time of temperature reading in seconds from start; .elapsed() returns miliseconds
        tx = aw.qmc.timeclock.elapsed()/1000.
        # get the temperature for ET. aw.fujipid.gettemperature(unitID)
        t1 = aw.fujipid.gettemperature(self.controlETpid[0],self.controlETpid[1])/10.  #Need to divide by 10 because using 1 decimal point in Fuji (ie. received 843 = 84.3)
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2 or self.readBTpid[0] == 4:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[0],self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### arguments to create command to READ TEMPERATURE
            unitID = self.readBTpid[1]
            function = 3
            address = aw.dtapid.dtamem["pv"][1]  #index 1; ascii string
            ndata = 1
            ### create command
            command = aw.dtapid.message2send(unitID,function,address,ndata)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = -1
        #get current duty cycle and update LCD 7
        try:
            dc = aw.fujipid.readdutycycle()
            if dc != -1: # on wrong reading we just keep the previous one
                aw.qmc.dutycycle = max(0,min(100,dc))
            aw.qmc.dutycycleTX = aw.qmc.timeclock.elapsed()/1000.
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","",None) + " fujitemperature() {0}").format(str(ex)),exc_tb.tb_lineno)
        return tx,t1,t2

    #especial function that collects extra duty cycle % and SV
    def piddutycycle(self):
        if aw.qmc.device == 0: # FUJI
            #return saved readings from device 0
            return aw.qmc.dutycycleTX, aw.qmc.dutycycle, aw.qmc.currentpidsv
        elif not aw.pidcontrol.pidActive:
            return aw.qmc.timeclock.elapsed()/1000.,-1,-1
        elif (aw.qmc.device == 19 and not aw.pidcontrol.externalPIDControl()) or \
                (aw.qmc.device == 53) or \
                (aw.qmc.device == 29 and not aw.pidcontrol.externalPIDControl()):
                # TC4, HOTTOP or MODBUS with Artisan Software PID
            return aw.qmc.timeclock.elapsed()/1000., min(100,max(-100,aw.qmc.pid.getDuty())), aw.qmc.pid.target
        else:
            if aw.pidcontrol.sv is not None:
                sv = aw.pidcontrol.sv
            else:
                sv = -1
            if aw.qmc.device == 29: # external MODBUS PID
                duty = -1
            else:
                duty = min(100,max(-100,aw.qmc.pid.getDuty()))
            return aw.qmc.timeclock.elapsed()/1000.,duty,sv
            

    def DTAtemperature(self):
        ###########################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        aw.qmc.currentpidsv = self.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = aw.qmc.currentpidsv    #index 0
        #sv LCD is updated in qmc.updadegraphics()
        #give some time to rest
        libtime.sleep(.1)
        ##############################################################
        ### create command
        command = aw.dtapid.message2send(self.controlETpid[1],3,aw.dtapid.dtamem["pv"][1],1)
        #read
        t1 = self.sendDTAcommand(command)
        tx = aw.qmc.timeclock.elapsed()/1000.
        #if Fuji for BT is not None (0= PXG, 1 = PXR, 2 = None 3 = DTA)
        if self.readBTpid[0] < 2:                    
            t2 = aw.fujipid.gettemperature(self.readBTpid[0],self.readBTpid[1])/10.
        elif self.readBTpid[0] == 3:
            ### create command
            command = aw.dtapid.message2send(self.readBTpid[1],3,aw.dtapid.dtamem["pv"][1],1)
            t2 = self.sendDTAcommand(command)
        else:
            t2 = aw.qmc.currentpidsv  #return 
        ################################################################
        if t1 is None:
            t1 = -1
        if t2 is None:
            t2 = -1
        return tx,t1,t2

    def sendDTAcommand(self,command):
        try:
            ###  lock resources ##
            self.COMsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                nrxbytes = 15
                #clear
                self.SP.reset_input_buffer()
                self.SP.reset_input_buffer()
                #SEND (tx)
                self.SP.write(str2cmd(command))
                #READ n bytes(rx)
                r = self.SP.read(nrxbytes).decode('utf-8')
##                command = ":010347000001B4"
##                r =       ":01030401900067"
                if len(r) == nrxbytes:
                    #READ and WRITE commands are different
                    #READ command
                    if command[4] == "3":
                        #CRCreceived = int(r[13:15],16)  #bytes 14&15
                        #CRCcalculated = aw.dtapid.DTACalcChecksum(r[1:11]) #bytes 1-10
                        #if CRCreceived == CRCcalculated:
                        t1 = float(int(r[7:11], 16))*0.1    #convert ascii string from bytes 8-11 (4 bytes) to a float
                        return t1
##                        else:
##                            aw.qmc.adderror(QApplication.translate("Error Message","DTAtemperature(): Data corruption. Check wiring",None))            
##                            if len(aw.qmc.timex) > 2:
##                                return aw.qmc.temp1[-1]
##                            else:
##                                return 0.
                    #WRITE COMMAND. Under Test
##                    if command[4] == "4":
##                        #received  data is equal to sent command
##                        if r == command:
##                            aw.sendmessage("Write operation OK")
##                            return 1
##                        else:
##                            aw.sendmessage("Write operation BAD")
##                            return 0
                else:
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","DTAcommand(): {0} bytes received but 15 needed",None).format(nbytes))
                    if len(aw.qmc.timex) > 2:
                        return aw.qmc.temp1[-1]
                    else:
                        return -1.
        except Exception:
            error = QApplication.translate("Error Message","Serial Exception:",None) + " ser.sendDTAcommand()"
            timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Delta DTA: " + settings + " || Tx = " + cmd2str(command) + " || Rx = " + str(r))



    def callprogram(self):
        try:
#            output = os.popen(aw.ser.externalprogram,"r").readline()
            # we try to set the users standard environment, replacing the one pointing to the restrictive python build in Artisan
            my_env = aw.calc_env()
        
            # hide the console window on Windows 
            startupinfo = None  
            if platf == 'Windows':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess.STARTF_USESHOWWINDOW
                startupinfo.wShowWindow = subprocess.SW_HIDE
            
            if platf == 'Windows':
                cmd_str = os.path.expanduser(aw.ser.externalprogram)
                p = subprocess.Popen(cmd_str,env=my_env,stdout=subprocess.PIPE,startupinfo=startupinfo,shell=True)
            else:
                p = subprocess.Popen([os.path.expanduser(c) for c in shlex.split(aw.ser.externalprogram)],env=my_env,stdout=subprocess.PIPE,startupinfo=startupinfo)
            output = p.communicate()[0].decode('UTF-8')
            
            tx = aw.qmc.timeclock.elapsed()/1000.
            if "," in output:
                parts = output.split(",")
                if len(parts) > 2:
                    aw.qmc.program_t3 = float(parts[2].strip())
                    if len(parts) > 3:
                        aw.qmc.program_t4 = float(parts[3].strip())
                        if len(parts) > 4:
                            aw.qmc.program_t5 = float(parts[4].strip())
                            if len(parts) > 5:
                                aw.qmc.program_t6 = float(parts[5].strip())
                                if len(parts) > 6:
                                    aw.qmc.program_t7 = float(parts[6].strip())
                                    if len(parts) > 7:
                                        aw.qmc.program_t8 = float(parts[7].strip())
                                        if len(parts) > 8:
                                            aw.qmc.program_t9 = float(parts[8].strip())
                                            if len(parts) > 9:
                                                aw.qmc.program_t10 = float(parts[9].strip())
                return tx,float(parts[0].strip()),float(parts[1].strip())
            else:
                return tx,0.,float(output)
        except Exception as e:
            tx = aw.qmc.timeclock.elapsed()/1000.
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " callprogram(): {0} ").format(str(e)),exc_tb.tb_lineno)
            aw.qmc.adderror((QApplication.translate("Error Message", "callprogram() received:",None) + " {0} ").format(str(output)),exc_tb.tb_lineno)
            return tx,0.,0.
            
    def callprogram_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t3
        t2 = aw.qmc.program_t4
        return tx,t2,t1

    def callprogram_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t5
        t2 = aw.qmc.program_t6
        return tx,t2,t1

    def callprogram_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t7
        t2 = aw.qmc.program_t8
        return tx,t2,t1

    def callprogram_910(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.program_t9
        t2 = aw.qmc.program_t10
        return tx,t2,t1

    def slider_01(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.slider1.value()
        t2 = aw.slider2.value()
        return tx,t2,t1

    def slider_23(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.slider3.value()
        t2 = aw.slider4.value()
        return tx,t2,t1

    def virtual(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        return tx,1.,1.

    def HH506RA(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def HH806AU(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def AmprobeTMD56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1 

    def MastechMS6514(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.MS6514temperature()
        return tx,t2,t1 

    def DT301(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.DT301temperature()
        return tx,t2,t1 

    def HH806W(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806Wtemperature()
        return tx,t2,t1
    
    def DUMMY(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        return tx,0,0
        
    def PHIDGET1045(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,a = self.PHIDGET1045temperature(DeviceID.PHIDID_1045)
        return tx,a,t

    def PHIDGET1048(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_1048,0)
        return tx,t1,t2 # time, ET (chan2), BT (chan1)

    def PHIDGET1048_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_1048,1)
        return tx,t1,t2

    def PHIDGET1048_AT(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_1048,2)
        return tx,t1,t2

    def PHIDGET1046(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1046temperature(0)
        return tx,t1,t2

    def PHIDGET1046_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1046temperature(1)
        return tx,t1,t2
        
    def PHIDGET1051(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,a = self.PHIDGET1045temperature(DeviceID.PHIDID_1051)
        return tx,a,t
        
    def PHIDGET1011(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1011,0,"voltage")
        return tx,v1,v2
                
    def PHIDGET1018(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,0,"voltage")
        return tx,v1,v2

    def PHIDGET1018_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,1,"voltage")
        return tx,v1,v2

    def PHIDGET1018_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,2,"voltage")
        return tx,v1,v2

    def PHIDGET1018_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,3,"voltage")
        return tx,v1,v2
        
    def PHIDGET1011_D(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1011,0,"digital")
        return tx,v1,v2
        
    def PHIDGET1018_D(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,0,"digital")
        return tx,v1,v2

    def PHIDGET1018_D_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,1,"digital")
        return tx,v1,v2

    def PHIDGET1018_D_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,2,"digital")
        return tx,v1,v2

    def PHIDGET1018_D_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_1010_1013_1018_1019,3,"digital")
        return tx,v1,v2
        
    def PHIDGET_HUB0000_D(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,0,"digital")
        return tx,v1,v2

    def PHIDGET_HUB0000_D_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,1,"digital")
        return tx,v1,v2

    def PHIDGET_HUB0000_D_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,2,"digital")
        return tx,v1,v2   
        
    def PHIDGET_HUB0000_D_0(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,0,API="digital",retry=False,single=True)
        return tx,v1,v2     

    def PHIDGET_TMP1101(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_TMP1101,0)
        return tx,t1,t2 # time, ET (chan2), BT (chan1)
        
    def PHIDGET_TMP1101_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_TMP1101,1)
        return tx,t1,t2
            
    def PHIDGET_TMP1101_AT(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.PHIDGET1048temperature(DeviceID.PHIDID_TMP1101,2)
        return tx,t1,t2

    def PHIDGET_TMP1100(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,a = self.PHIDGET1045temperature(DeviceID.PHIDID_TMP1100)
        return tx,a,t

    def PHIDGET_TMP1200(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,a = self.PHIDGET1045temperature(DeviceID.PHIDID_TMP1200)
        return tx,a,t
        
    def PHIDGET_HUB0000(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1  = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,0,"voltage")
        return tx,v1,v2

    def PHIDGET_HUB0000_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,1,"voltage")
        return tx,v1,v2

    def PHIDGET_HUB0000_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,2,"voltage")
        return tx,v1,v2
        
    def PHIDGET_HUB0000_0(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1  = self.PHIDGET1018values(DeviceID.PHIDID_HUB0000,0,API="voltage",retry=False,single=True)
        return tx,v1,v2

    def PHIDGET_DAQ1400_CURRENT(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1,_ = self.PHIDGET1018values(DeviceID.PHIDID_DAQ1400,0,"current")
        return tx,v1,v2

    def PHIDGET_DAQ1400_FREQUENCY(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_DAQ1400,0,"frequency")
        return tx,v1,v2

    def PHIDGET_DAQ1400_DIGITAL(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_DAQ1400,0,"digital")
        return tx,v1,v2

    def PHIDGET_DAQ1400_VOLTAGE(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.PHIDGET1018values(DeviceID.PHIDID_DAQ1400,0,"voltage")
        return tx,v1,v2

    def HOTTOP_BTET(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HOTTOPtemperatures()
        aw.qmc.hottop_TX = tx
        return tx,t1,t2 # time, ET (chan2), BT (chan1)
        
    def HOTTOP_HF(self):
        return aw.qmc.hottop_TX,aw.qmc.hottop_MAIN_FAN,aw.qmc.hottop_HEATER # time, Fan (chan2), Heater (chan1)
        
    def BEHMOR_BTET(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.BEHMORtemperatures(8,9)
        return tx,t1,t2 # time, ET (chan2), BT (chan1)
    
    def BEHMOR_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.BEHMORtemperatures(10,11)
        return tx,t1,t2 # time, chan2, chan1

    def BEHMOR_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.BEHMORtemperatures(1,2)
        return tx,t1,t2 # time, chan2, chan1

    def BEHMOR_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.BEHMORtemperatures(3,4)
        return tx,t1,t2 # time, chan2, chan1
    
    def VICTOR86B(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t,_= self.HHM28multimeter()  #NOTE: val and symbols are type strings
        if "L" in t:  #L = Out of Range
            return tx, -1, -1
        else:
            return tx,-1,float(t)

    def S7(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.S7read(0)
        return tx,t2,t1
    
    def S7_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.S7read(1)
        return tx,t2,t1
        
    def S7_56(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.S7read(2)
        return tx,t2,t1

    def S7_78(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.S7read(3)
        return tx,t2,t1

    def S7_910(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.S7read(4)
        return tx,t2,t1

    def R1_DTBT(self):
        if self.R1 is None:
            from artisanlib.aillio import AillioR1
            self.R1 = AillioR1()
        tx = aw.qmc.timeclock.elapsed()/1000.
        try:
            if aw.qmc.batchcounter != -1:
                aw.qmc.batchcounter = self.R1.get_roast_number()
            aw.qmc.R1_BT = self.R1.get_bt()
            aw.qmc.R1_DT = self.R1.get_dt()
            aw.qmc.R1_DRUM = self.R1.get_drum() * 10
            aw.qmc.R1_VOLTAGE = self.R1.get_voltage()
            aw.qmc.R1_HEATER = self.R1.get_heater() * 10
            aw.qmc.R1_FAN = self.R1.get_fan() * 10
            aw.qmc.R1_BT_ROR = self.R1.get_bt_ror()
            aw.qmc.R1_EXIT_TEMP = self.R1.get_exit_temperature()
            aw.qmc.R1_STATE = self.R1.get_state()
            aw.qmc.R1_FAN_RPM = self.R1.get_fan_rpm()
            aw.qmc.R1_TX = tx
            newstate = self.R1.get_state_string()
            if newstate != aw.qmc.R1_STATE_STR:
                aw.qmc.R1_STATE_STR = newstate
                aw.sendmessage(QApplication.translate("Message", "R1 state: " + newstate, None))
            if aw.qmc.mode == "F":
                aw.qmc.R1_DT = aw.qmc.fromCtoF(aw.qmc.R1_DT)
                aw.qmc.R1_BT = aw.qmc.fromCtoF(aw.qmc.R1_BT)
                aw.qmc.R1_EXIT_TEMP = aw.qmc.fromCtoF(aw.qmc.R1_EXIT_TEMP)
                aw.qmc.R1_BT_ROR = aw.qmc.RoRfromCtoF(aw.qmc.R1_BT_ROR)
        except Exception as exception:
            error = QApplication.translate("Error Message", "Aillio R1: " + str(exception), None)
            aw.qmc.adderror(error)
        return tx, aw.qmc.R1_DT, aw.qmc.R1_BT

    def R1_BTIBTS(self):
        self.R1_DTBT()
        tx = aw.qmc.timeclock.elapsed()/1000.
        # DT is being used as IBTS.
        return tx, aw.qmc.R1_BT, aw.qmc.R1_DT

    def R1_DRUM_BTROR(self):
        tx = aw.qmc.R1_TX
        return tx, aw.qmc.R1_DRUM, aw.qmc.R1_BT_ROR

    def R1_HF(self):
        tx = aw.qmc.R1_TX
        return tx, aw.qmc.R1_FAN, aw.qmc.R1_HEATER

    def R1_EXIT_TEMP_VOLT(self):
        tx = aw.qmc.R1_TX
        return tx, aw.qmc.R1_EXIT_TEMP, aw.qmc.R1_VOLTAGE

    def R1_RPM_STATE(self):
        tx = aw.qmc.R1_TX
        return tx, aw.qmc.R1_FAN_RPM, aw.qmc.R1_STATE
    
    def MODBUS(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.MODBUSread()
        return tx,t2,t1

    def MODBUS_34(self):
        return aw.qmc.extraMODBUStx,aw.qmc.extraMODBUStemps[3],aw.qmc.extraMODBUStemps[2]
        
    def MODBUS_56(self):
        return aw.qmc.extraMODBUStx,aw.qmc.extraMODBUStemps[5],aw.qmc.extraMODBUStemps[4]
        
    def MODBUS_78(self):
        return aw.qmc.extraMODBUStx,aw.qmc.extraMODBUStemps[7],aw.qmc.extraMODBUStemps[6]

    def HH802U(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH806AUtemperature()
        return tx,t2,t1

    def HH309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER309(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #special function that collects extra T3 and T4 from center 309 while keeping compatibility
    def CENTER309_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    #special function that collects extra T3 and T4 from center 304 while keeping compatibility
    def CENTER304_34(self):
        return self.CENTER309_34()

    def CENTER306(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER305(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def CENTER304(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    def CENTER303(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER302(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def CENTER301(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def CENTER300(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK204(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER309temperature()
        return tx,t2,t1

    #especial function that collects extra T3 and T4 from Vol K204 while keeping compatibility
    def K204_34(self):
        #return saved readings collected at self.CENTER309temperature()
        return aw.qmc.extra309TX,aw.qmc.extra309T4,aw.qmc.extra309T3

    def VOLTCRAFTK201(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFTK202(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER306temperature()
        return tx,t2,t1

    def VOLTCRAFT300K(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER302temperature()
        return tx,t2,t1

    def VOLTCRAFT302KJ(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.CENTER303temperature()
        return tx,t2,t1

    def VOLTCRAFTPL125T2(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.VOLTCRAFTPL125T2temperature()
        return tx,t2,t1

    def VOLTCRAFTPL125T4(self):
        t2,t1 = self.VOLTCRAFTPL125T4temperature()
        return aw.qmc.extraPL125T4TX,t2,t1

    #especial function that collects extra T3 and T4 from Vol PL125-T4 while keeping compatibility
    def VOLTCRAFTPL125T4_34(self):
        #return saved readings collected at self.VOLTCRAFTPL125T4temperature()
        return aw.qmc.extraPL125T4TX,aw.qmc.extraPL125T4T4,aw.qmc.extraPL125T4T3

    def EXTECH421509(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.HH506RAtemperature()
        return tx,t2,t1

    def NONE(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.NONEtmp()
        return tx,t2,t1

    def ARDUINOTC4(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.ARDUINOTC4temperature()
        return tx,t2,t1

    def ARDUINOTC4_34(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT1
        t2 = aw.qmc.extraArduinoT2
        return tx,t2,t1

    def ARDUINOTC4_56(self): # heater / fan DUTY %
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT3
        t2 = aw.qmc.extraArduinoT4
        return tx,t2,t1

    def ARDUINOTC4_78(self): # PID SV / internal temp
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.extraArduinoT5
        t2 = aw.qmc.extraArduinoT6
        return tx,t2,t1

    def probat_middleware(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = -1
        t2 = -1
        self.ProbatMiddleware_burner = -1
        self.ProbatMiddleware_drum = -1
        self.ProbatMiddleware_fan = -1
        self.ProbatMiddleware_pressure = -1
        if aw.qmc.probatManager is None:
            from artisanlib.probat import ProbatMiddleware
            aw.qmc.probatManager = ProbatMiddleware()
        if aw.qmc.probatManager is not None:
            connected = aw.qmc.probatManager.isConnected()
            if not connected:
                connected = aw.qmc.probatManager.connect()
                if connected:
                    name = aw.qmc.probatManager.getRoasterName()
                    if name is None:
                        name = ""
                    aw.sendmessage(QApplication.translate("Message","Probat Middleware roaster {} connected".format(name),None))
            if connected:
                url = aw.qmc.probatManager.getRoasterURL()
                if url is not None:
                    try:
                        data = aw.qmc.probatManager.getJSON(url)
                        roastData = data["roastingProcess"]
                        if "productTemperature" in roastData:
                            t1 = roastData["productTemperature"]
                        if "exhaustTemperature" in roastData:
                            t2 = roastData["exhaustTemperature"]
                        if "underPressure" in roastData:
                            aw.qmc.ProbatMiddleware_pressure = roastData["underPressure"]
                        if "burnerCapacity" in roastData:
                            aw.qmc.ProbatMiddleware_burner = roastData["burnerCapacity"]
                        if "drumSpeed" in roastData:
                            aw.qmc.ProbatMiddleware_drum = roastData["drumSpeed"]
                        if "exhaustFanSpeed" in roastData:
                            aw.qmc.ProbatMiddleware_fan = roastData["exhaustFanSpeed"]
                    except:
                        aw.qmc.probatManager.disconnect()
                        aw.sendmessage(QApplication.translate("Message","Probat Middleware disconnected",None))
        return tx,t2,t1

    def probat_middleware_burner_drum(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.ProbatMiddleware_burner
        t2 = aw.qmc.ProbatMiddleware_drum
        return tx,t2,t1

    def probat_middleware_fan_pressure(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t1 = aw.qmc.ProbatMiddleware_fan
        t2 = aw.qmc.ProbatMiddleware_pressure
        return tx,t2,t1
        
    def YOCTO_thermo(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(0)
        return tx,v1,v2
        
    def YOCTO_generic(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(4)
        return tx,v1,v2

    def YOCTO_pt100(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(1)
        return tx,v1,v2

    def YOCTO_IR(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        v2,v1 = self.YOCTOtemperatures(2)
        return tx,v2,v1

    def TEVA18B(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.TEVA18Btemperature()
        return tx,t2,t1
        
    def EXTECH755(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        t2,t1 = self.EXTECH755pressure()
        return tx,t2,t1

    # EXTECH755 Device
    # returns t1,t2 from EXTECH 755. By Bailey Glen
    def EXTECH755pressure(self, retry=2):
        try:
            r = ''
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(b'\x56\xaa\x01')
                r = self.SP.read(10)
                if len(r) == 10:
                    ##Single  line to return pressure twice. obviously only need to do this once.
                    # Takes the last 5 of the 10 byte signal, which is ascii for a float
                    try:
                        self.EXTECH755PrevTemp = float(r[5:])
                        return self.EXTECH755PrevTemp, self.EXTECH755PrevTemp
                    except:
                        if retry:
                            return self.EXTECH755pressure(retry=retry - 1)
                        else:
                            nbytes = len(r)
                            aw.qmc.adderror(QApplication.translate("Error Message",
                                                               "Extech755pressure(): conversion error, {0} bytes received",
                                                               None).format(nbytes))
                            if self.EXTECH755PrevTemp != -1:
                                s = self.EXTECH755PrevTemp
                                self.EXTECH755PrevTemp = -1
                                return s,s
                            else:
                                return -1,-1                       
                else:
                    if retry:
                        return self.EXTECH755pressure(retry=retry - 1)
                    else:
                        nbytes = len(r)
                        aw.qmc.adderror(QApplication.translate("Error Message",
                                                               "Extech755pressure(): {0} bytes received but 10 needed",
                                                               None).format(nbytes))
                        if self.EXTECH755PrevTemp != -1:
                            s = self.EXTECH755PrevTemp
                            self.EXTECH755PrevTemp = -1
                            return s,s
                        else:
                            return -1,-1
            else:
                return -1, -1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",
                                                    None) + " ser.EXTECH755pressure() {0}").format(str(ex)),
                            exc_tb.tb_lineno)
            self.closeport()
            return -1, -1
        finally:
            # note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize) + "," + str(
                    self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial(
                    "EXTECH755: " + settings + " || Tx = " + cmd2str(binascii.hexlify(b'\x56\xaa\x01')) + " || Rx = " + cmd2str(
                        binascii.hexlify(r[5:])))        

    #multimeter
    def HHM28(self):
        tx = aw.qmc.timeclock.elapsed()/1000.
        val,symbols= self.HHM28multimeter()  #NOTE: val and symbols are type strings
        #temporary fix to display the output
        aw.sendmessage(val + symbols)
        if "L" in val:  #L = Out of Range
            return tx, 0., 0.
##        else:
##            #read quantifier symbols
##            if "n" in symbols:
##                val /= 1000000000.
##            elif "u" in symbols:
##                val /= 1000000.
##            elif "m" in symbols:
##                val /= 1000.
##            elif "k" in symbols:
##                val *= 1000.
##            elif "M" in symbols:
##                val *= 1000000.
            ### not finished
        else:
            return tx, 0., float(val)   #send a 0. as second reading because the meter only returns one reading

    # connects to a Yocto Meteo, returns current humidity value
    def YoctoMeteoHUM(self):
        try:
            self.YOCTOimportLIB() # first import the lib
            from yoctopuce.yocto_humidity import YHumidity
            HUMsensor = YHumidity.FirstHumidity()
            if HUMsensor is not None and HUMsensor.isOnline():
                return HUMsensor.get_currentValue()
            else:
                return None
        except:
            return None
            
    # connects to a Yocto Meteo, returns current temperature value
    def YoctoMeteoTEMP(self):
        try:
            self.YOCTOimportLIB() # first via import the lib
            from yoctopuce.yocto_temperature import YTemperature
            METEOsensor = self.getNextYOCTOsensorOfType(3,[],YTemperature.FirstTemperature())
            if METEOsensor is not None and METEOsensor.isOnline():
                serial = METEOsensor.get_module().get_serialNumber()
                tempCh = YTemperature.FindTemperature(serial + '.temperature')
                if tempCh.isOnline():
                    return tempCh.get_currentValue()
                else:
                    return None
            else:
                return None
        except:
            return None
            
    # connects to a Yocto Meteo, returns current pressure value
    def YoctoMeteoPRESS(self):
        try:
            self.YOCTOimportLIB() # first via import the lib
            from yoctopuce.yocto_pressure import YPressure
            PRESSsensor = YPressure.FirstPressure()
            if PRESSsensor is not None and PRESSsensor.isOnline():
                return PRESSsensor.get_currentValue()
            else:
                return None
        except:
            return None

    # connects to a Phidgets HUM1000, returns current temperature value and disconnects
    def PhidgetHUM1000temperature(self):
        try:
            # Temperature
            tempSensor = PhidgetTemperatureSensor()
            ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetTemperatureSensor',DeviceID.PHIDID_HUM1000,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if ser:
                tempSensor.setDeviceSerialNumber(ser)
                tempSensor.setHubPort(port)   #explicitly set the port to where the HUM is attached
                if aw.qmc.phidgetRemoteFlag:
                    self.addPhidgetServer() 
                if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                    tempSensor.setIsRemote(True)
                    tempSensor.setIsLocal(False)
                tempSensor.openWaitForAttachment(1500)
                if tempSensor.getAttached():
                    libtime.sleep(0.3)
                    res = tempSensor.getTemperature()
                    tempSensor.close()
                    return res
                else:
                    return None
            else:
                return None
        except Exception:
            return None
            
    # connects to a Phidgets HUM1000, returns current humidity value and disconnects
    def PhidgetHUM1000humidity(self):
        try:
            # Humidity
            humSensor = PhidgetHumiditySensor()
            ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetHumiditySensor',DeviceID.PHIDID_HUM1000,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if ser:
                humSensor.setDeviceSerialNumber(ser)
                humSensor.setHubPort(port)   #explicitly set the port to where the HUM is attached
                if aw.qmc.phidgetRemoteFlag:
                    self.addPhidgetServer() 
                if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                    humSensor.setIsRemote(True)
                    humSensor.setIsLocal(False)
                humSensor.openWaitForAttachment(1500)
                if humSensor.getAttached():
                    libtime.sleep(0.3)
                    res = humSensor.getHumidity()
                    humSensor.close()
                    return res
                else:
                    return None
            else:
                return None
        except Exception:
            return None

    # connects to a Phidgets PRE1000, returns current pressure value and disconnects
    def PhidgetPRE1000pressure(self):
        try:
            pressSensor = PhidgetPressureSensor()
            ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetPressureSensor',DeviceID.PHIDID_PRE1000,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if ser:
                pressSensor.setDeviceSerialNumber(ser)
                pressSensor.setHubPort(port)   #explicitly set the port to where the PRE is attached  
                if aw.qmc.phidgetRemoteFlag:
                    self.addPhidgetServer() 
                if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                    pressSensor.setIsRemote(True)
                    pressSensor.setIsLocal(False)
                pressSensor.openWaitForAttachment(1500)
                if pressSensor.getAttached():
                    libtime.sleep(0.3)
                    res = pressSensor.getPressure()
                    pressSensor.close()
                    return res
                else:
                    return None
            else:
                return None
        except Exception:
            return None

############################################################################
    def openport(self):
        try:
            self.confport()
            self.ArduinoIsInitialized = 0  # Assume the Arduino has to be reinitialized
            #open port
            if not self.SP.isOpen():
                self.SP.open()
                if aw.seriallogflag:
                    settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                    aw.addserial("serial port openend: " + settings) 
                libtime.sleep(.2) # avoid possible hickups on startup
        except Exception:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            self.SP.close()
            libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port get's disabled
            error = QApplication.translate("Error Message","Serial Exception:",None) + QApplication.translate("Error Message","Unable to open serial port",None)
            aw.qmc.adderror(error)

    #loads configuration to ports
    def confport(self):
        self.SP.port = self.comport
        self.SP.baudrate = self.baudrate
        self.SP.bytesize = self.bytesize
        self.SP.parity = self.parity
        self.SP.stopbits = self.stopbits
        self.SP.timeout = self.timeout

    def closeport(self):
        try:
            if self.SP and self.SP.isOpen():
                self.SP.close()
                libtime.sleep(0.1) # on OS X opening a serial port too fast after closing the port get's disabled
        except Exception:
            pass

    def closeEvent(self,_):
        try:
            self.closeport() 
        except Exception:
            pass

    def binary(self, n, digits=8):
        return "{0:0>{1}}".format(bin(n)[2:], digits)

    #similar to Omega HH806
    def MS6514temperature(self, retry=2):
        try:
#            command = str2cmd("#0A0000NA2\r\n")  #"#0A0101NA4\r\n"
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
#                self.SP.reset_output_buffer()
#                self.SP.write(command)
                r = self.SP.read(18)
                index = -1
                if(len(r) == 18 and r[0] == 101 and r[1] == 20):  # 101="\x65"  20="\x14"
                    index = 0
                else:
                    if(len(r) >= 9):
                        # find 0x65 0x14
                        for i in range(len(r)-1):
                            if(r[i] == 101 and r[i+1] == 20): # "\x65" and "\x14"
                                index = i
                                break
                
                    if index > 0:
                        r += self.SP.read(index)
                    else:
                        r += self.SP.read(18-1)     # maybe last character is 0x65. otherwise error.
                
                        if(len(r) >= 9):
                            # find 0x65 0x14
                            for i in range(len(r)-1):
                                if (r[i] == 101 and r[i+1] == 20):  # "\x65" and "\x14"
                                    index = i
                                    break
                
                if(index >= 0 and len(r) >= index+18):
                    if (r[index+16] == 13 and r[index+17] == 10):  # 13="\x0d" and  10="\x0a"
                        #convert to binary to hex string
                        # Display [5-6] [7-8]  [11]                                          [12]
                        #   T1     T1    T2    T1: OK(08), NC(40)                            T2: OK(08), NC(40)
                        #   T2     T2    T1    T2: OK(09), NC(41)                            T1: OK(08), NC(40)
                        #  T1-T2  T1-T2  T1    T1+T2: OK+(0A), OK-(8A), T1NC(42), T2NC(C2)   T1: OK(08), NC(40)
                        #  T1-T2  T1-T2  T2    T1-T2: OK+(0B), OK-(8B), T1NC(43), T2NC(C3)   T2: OK(08), NC(40)
                        s1 = hex2int(r[index+5],r[index+6])/10.
                        s2 = hex2int(r[index+7],r[index+8])/10.

                        # 64="\x40"  67="\x43" 194="\xC2" 195="\xC3"
                        if ((r[index+11] >= 64 and r[index+11] <= 67) or (r[index+11] >= 194 and r[index+11] <= 195)):
                            s1 = -1
                    
                        if(r[index+12] == 64): # 64="\x40"
                            s2 = -1

                        #return original T1 T2
                        if(r[index+11] == 9 or r[index+11] == 65): # 9="\x09" 65="\x41"
                            temp = s2
                            s2 = s1
                            s1 = temp
                        elif(r[index+11] == 10): # 10="\x0a"
                            temp = s2
                            s2 = s2-s1
                            s1 = temp
                        elif(r[index+11] == 138): # 138="\x8a"
                            temp = s2
                            s2 = s2+s1
                            s1 = temp
                        elif(r[index+11] == 66 or r[index+11] == 194):  # 66="\x42" and 194="\xc2"
                            s1 = s2
                            s2 = -1
                        elif(r[index+11] == 11): # 11="\x0b"
                            s1 += s2
                        elif(r[index+11] == 139): # 139="\x8b"
                            s1 = s2-s1

                        #we convert the strings to integers. Divide by 10.0 (decimal position)
                        self.MS6514PrevTemp1 = s1
                        self.MS6514PrevTemp2 = s2
                        return s1,s2
                
                if retry:
                    if retry < 2:
                        self.closeport()
                        libtime.sleep(.05)
                    a,b = self.MS6514temperature(retry=retry-1)
                    return a,b                    
                else:
                    # error but return previous temperature
                    if(self.MS6514PrevTemp1 != -1 or self.MS6514PrevTemp2 != -1):
                        s1 = self.MS6514PrevTemp1
                        s2 = self.MS6514PrevTemp2
                        self.MS6514PrevTemp1 = -1
                        self.MS6514PrevTemp2 = -1
                        return s1,s2
                        
                    # error
                    nbytes = len(r)
                    aw.qmc.adderror(QApplication.translate("Error Message","MS6514temperature(): {0} bytes received but 18 needed",None).format(nbytes))
                    return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.MS6514temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("MS6514: " + settings + " || Rx = " + cmd2str(binascii.hexlify(r))) 


    def DT301temperature(self, retry=2):
        try:
            temp = 0
            command = b"\xEC\xD0\xF3"
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.write(command)
                libtime.sleep(0.01)  # this may not be necessary but works well
                r = self.SP.read(11)
                if len(r)==11:
                    data = bytearray(r)
                    if len(data)==11 and data[0] == 0xfc and data[1] == 0x13 and data[10] == 0xf3:
                        for i in range(2,6):
                            temp = (temp << 4) | (data[i] & 0xf)
                        self.DT301PrevTemp = temp/10.0,0
                        return self.DT301PrevTemp,-1
                if retry:
                    self.SP.reset_input_buffer()
                    self.SP.reset_output_buffer()
                    libtime.sleep(.05)
                    return self.DT301temperature(retry=retry-1)
                else:
                    self.closeport()
                    # error but return previous temperature
                    if self.DT301PrevTemp != -1:
                        s = self.DT301PrevTemp
                        self.DT301PrevTemp = -1
                        return s,0
                        
                    # error
                    nbytes = len(data)
                    aw.qmc.adderror(QApplication.translate("Error Message","DT301temperature(): {0} bytes received but 11 needed",None).format(nbytes))
                    return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.DT301temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("DT301: " + settings + " || Rx = " + cmd2str(binascii.hexlify(data))) 

    # if serial input is not \0 terminated standard pyserial readline returns only after the timeout
    def readline_terminated(self,eol=b'\r'):
        leneol = len(eol)
        line = bytearray()
        while True:
            c = self.SP.read(1)
            if c:
                line += c
                if line[-leneol:] == eol:
                    break
            else:
                break
        return bytes(line)
    
    def BEHMORtemperatures(self,ch1,ch2):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            command = ""
            if not aw.ser.SP.isOpen():
                aw.ser.openport()
            temps = [-1,-1]
            if aw.ser.SP.isOpen():
                for i,c in [(0,ch1),(1,ch2)]:
                    try:
                        command = "gts," + str(c) + "\r\n"
                        aw.ser.SP.reset_input_buffer()
                        aw.ser.SP.reset_output_buffer()
                        aw.ser.SP.write(str2cmd(command))
                        res = aw.ser.readline_terminated(b'\r') # .decode('utf-8', 'ignore')
                        #res = aw.ser.SP.readline() # takes at least the timeout period as line is not \n terminated!
                        #res = aw.ser.SP.read_until('\r') # takes at least the timeout period!
                        t = float(res)
                        if aw.qmc.mode == "F":
                            t = aw.qmc.fromCtoF(t)
                        temps[i] = t
                        if aw.seriallogflag:
                            settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                            aw.addserial("Behmor: " + settings + " || Tx = " + str(command) + " || Rx = " + str(res) + " || Ts= %.2f"%t)
                    except:
                        pass
            return temps[0],temps[1]
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " ser.BEHMORtemperatures(): {0}").format(str(e)),exc_tb.tb_lineno)
            aw.ser.closeport()
            return -1.,-1.
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)

    
    def HOTTOPtemperatures(self):
        try:
            from artisanlib.hottop import getHottop
            BT, ET, heater, main_fan = getHottop()
            aw.qmc.hottop_HEATER = heater
            aw.qmc.hottop_MAIN_FAN = main_fan
            aw.qmc.hottop_ET = ET
            aw.qmc.hottop_BT = BT
            if aw.qmc.mode == "F":
                aw.qmc.hottop_ET = aw.qmc.fromCtoF(aw.qmc.hottop_ET)
                aw.qmc.hottop_BT = aw.qmc.fromCtoF(aw.qmc.hottop_BT)
            return aw.qmc.hottop_BT,aw.qmc.hottop_ET
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HOTTOPtemperatures() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    #t2 and t1 from Omega HH806, HH802 or Amprobe TMD56 meter 
    def HH806AUtemperature(self, retry=2):
        try:
            command = str2cmd("#0A0000NA2\r\n")
            r = ""
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(.05)
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(16)
                if len(r) == 16 and hex2int(r[0])==62 and hex2int(r[1])==15:
                    #convert to binary to hex string
                    s1 = hex2int(r[5],r[6])/10.
                    s2 = hex2int(r[10],r[11])/10.
                    #we convert the strings to integers. Divide by 10.0 (decimal position)
                    return s1,s2
                else:
                    # first try to resync data (shift to right assuming some extra bytes were appended):
                    for i in range(4):
                        if len(r) > 12+i and hex2int(r[1+i])==62 and hex2int(r[2+i])==15:
                            s1 = hex2int(r[6+i],r[7+i])/10.
                            s2 = hex2int(r[11+i],r[12+i])/10.
                            return s1,s2
                    if retry:
                        if retry < 2:
                            self.closeport()
                            libtime.sleep(.05)
                        a,b = self.HH806AUtemperature(retry=retry-1)
                        return a,b
                    else:
                        nbytes = len(r)
                        aw.qmc.adderror(QApplication.translate("Error Message","HH806AUtemperature(): {0} bytes received",None).format(nbytes))
                        return -1,-1                                    #return something out of scope to avoid function error (expects two values)
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HH806AUtemperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HH806Winit(self):
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("#0A0000RA6\r\n"))
                libtime.sleep(.3)
                self.SP.write(str2cmd("\x21\x05\x00\x58\x7E"))
                libtime.sleep(2.)
                self.HH806Winitflag = 1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HH806Winit() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                command = "#0A0000RA6\r\n #0A0000RA6\r\n \x21\x05\x00\x58\x7E"
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Winit: " + settings + " || Tx = " + command + " || Rx = ")

    #UNDER WORK 806 wireless meter
    def HH806Wtemperature(self):
        if self.HH806Winitflag == 0:
            self.HH806Winit()
            if self.HH806Winitflag == 0:
                aw.qmc.adderror(QApplication.translate("Error Message","HH806Wtemperature(): Unable to initiate device",None))
                return -1,-1
        try:
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                for _ in range(27):
                    rcode = self.SP.read(1)
                    #locate first byte
                    if rcode == "\x3d":
                        r = self.SP.read(25)
                        if len(r) == 25:
                            r1 = hex2int(r[11],r[12])/10.
                            r2 = hex2int(r[19],r[20])/10.
                            #GOOD
                            return r1,r2
                #BAD
                return -1.,-1.
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HH806Wtemperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H806Wtemperature: " + settings + " || Rx = " + binascii.hexlify(r))

    # input: value x; divider d; mode m
    # returns processed value
    def processChannelData(self,x,d,m):
        if x is None:
            res = -1
        else:            
            # apply divider
            if d==1: # apply divider
                res = x / 10.
            elif d==2: # apply divider
                res = x / 100.
            else:
                res = x
            # convert temperature scale
            if m == "C" and aw.qmc.mode == "F":
                res = aw.qmc.fromCtoF(res)
            elif m == "F" and aw.qmc.mode == "C":
                res = aw.qmc.fromFtoC(res)
        return res
        
    #returns v1,v2 from a connected S7 device
    # mode=0 to read ch1+2
    # mode=1 to read ch3+4
    # mode=2 to read ch5+6
    # mode=3 to read ch7+8
    # mode=4 to read ch9+10
    def S7read(self,mode):
        # fill the S7 optimizer (if active) with data for all read requests specified in the device S7 tab using block reads
        aw.s7.readActiveRegisters()
        res = []
        for i in range(mode*2,mode*2+2):
            if aw.s7.area[i]:
                if aw.s7.type[i]:
                    v = aw.s7.readFloat(aw.s7.area[i]-1,aw.s7.db_nr[i],aw.s7.start[i])
                else:
                    v = aw.s7.readInt(aw.s7.area[i]-1,aw.s7.db_nr[i],aw.s7.start[i])
                v = self.processChannelData(v,aw.s7.div[i],("C" if aw.s7.mode[i]==1 else ("F" if aw.s7.mode[i]==2 else "")))
                res.append(v)
            else:
                res.append(-1)
        return res[1], res[0]

    #returns v1,v2 from a connected MODBUS device
    def MODBUSread(self):
        # fill the MODBUS optimizer (if active) with data for all read requests specified in the device MODBUS tab using block reads
        aw.modbus.readActiveRegisters()
        
        just_send = False
        res = [-1]*aw.modbus.channels
        
        for i in range(aw.modbus.channels):
            if aw.modbus.inputSlaves[i]:
                if just_send and not aw.modbus.optimizer:
                    aw.modbus.sleepBetween()
                if not aw.modbus.optimizer:
                    aw.modbus.sleepBetween() # we start with a sleep, as it could be that just a send command happend before the semaphore was catched
                if aw.modbus.inputFloats[i]:
                    res[i] = aw.modbus.readFloat(aw.modbus.inputSlaves[i],aw.modbus.inputRegisters[i],aw.modbus.inputCodes[i])
                elif aw.modbus.inputBCDs[i]:
                    res[i] = aw.modbus.readBCD(aw.modbus.inputSlaves[i],aw.modbus.inputRegisters[i],aw.modbus.inputCodes[i])
                else:
                    res[i] = aw.modbus.readSingleRegister(aw.modbus.inputSlaves[i],aw.modbus.inputRegisters[i],aw.modbus.inputCodes[i])
                res[i] = self.processChannelData(res[i],aw.modbus.inputDivs[i],aw.modbus.inputModes[i])
                just_send = True
        
        aw.qmc.extraMODBUStemps = res[:]
        aw.qmc.extraMODBUStx = aw.qmc.timeclock.elapsed()/1000.
        return res[1], res[0]

    def NONEtmp(self):
        dialogx = nonedevDlg()
        
        # NOT CORRECT:
        ##from sys import getsizeof  # getsizesof not reporting the full size here!
        ##print(getsizeof(dialogx)) # 192bytes using slots; 152bytes without slots;
        
        # # sudo -H python3 -m pip install pympler 
        #from pympler import asizeof
        #print(asizeof.asizeof(dialogx)) # 2440 using slots; 2568 without using slots
        if dialogx.exec_():
            try:
                ET = (int(str(dialogx.etEdit.text())) * 10)/10.
            except Exception:
                ET = 0
            try:
                BT = (int(str(dialogx.btEdit.text())) * 10)/10.
            except Exception:
                BT = 0
            try:
                dialogx.okButton.disconnect()
                dialogx.cancelButton.disconnect()
                QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                try: # sip not supported on older PyQt versions (RPi!)
                    sip.delete(dialogx)
                    #print(sip.isdeleted(dialogx))
                except:
                    pass
                del dialogx
            except:
                pass
            return ET, BT
        else:
            try:
                dialogx.okButton.disconnect()
                dialogx.cancelButton.disconnect()
                QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
                try: # sip not supported on older PyQt versions (RPi!)
                    sip.delete(dialogx)
                    #print(sip.isdeleted(dialogx))
                except:
                    pass
                del dialogx
            except:
                pass
            return -1, -1

    #reads once the id of the HH506RA meter and stores it in the serial variable self.HH506RAid.
    def HH506RAGetID(self):
        try:
            ID = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                sync = None
                while sync != b"Err\r\n":
                    self.SP.write(b"\r\n")
                    sync = self.SP.read(5)
                    libtime.sleep(1)
                self.SP.write(b"%000R")
                ID = self.SP.read(5)
                if len(ID) == 5:
                    self.HH506RAid = ID[0:3]               # Assign new id to self.HH506RAid
                else:
                    nbytes = len(ID)
                    aw.qmc.adderror(QApplication.translate("Error Message","HH506RAGetID: {0} bytes received but 5 needed",None).format(nbytes))
        except Exception as ex:
            self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HH506RAGetID() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506: " + settings + " || Rx = " + str(ID))

    #HH506RA Device
    #returns t1,t2 from Omega HH506 meter
    def HH506RAtemperature(self, retry=2):
        #if initial id "X" has not changed then get a new one;
        if self.HH506RAid == "X":
            self.HH506RAGetID()                       # obtain new id one time; self.HH506RAid should not be "X" any more
            if self.HH506RAid == "X":                 # if self.HH506RAGetID() went wrong and self.HH506RAid is still "X"
                aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): Unable to get id from HH506RA device ",None))
                return -1,-1
        try:
            command = b"#" + self.HH506RAid + b"N" # + "\r\n" this seems not to be needed
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(14)
                if len(r) == 14:
                    #we convert the hex strings to integers. Divide by 10.0 (decimal position)
                    r = r.replace(str2cmd(' '),str2cmd('0'))
                    return int(r[1:5],16)/10., int(r[7:11],16)/10.
                else:
                    if retry:
                        return self.HH506RAtemperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        aw.qmc.adderror(QApplication.translate("Error Message","HH506RAtemperature(): {0} bytes received but 14 needed",None).format(nbytes))               
                        return -1,-1
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HH506RAtemperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("H506: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def CENTER302temperature(self,retry=2):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(7)                                   #NOTE: different
                if len(r) == 7:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(r[2])              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    return T1,0
                else:
                    if retry:
                        return self.CENTER302temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        error = QApplication.translate("Error Message","CENTER302temperature(): {0} bytes received but 7 needed",None).format(nbytes)
                        timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                        aw.qmc.adderror(timez + " " + error)
                        return -1,-1 
            else:
                return -1,-1 
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " CENTER302temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER302: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER303temperature(self,retry=2):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(8) #NOTE: different to CENTER306
                if len(r) == 8:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(r[2])              #bit"[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B56 = cmd2str(binascii.hexlify(r[5:7])) # select byte 5 and 6; NOTE: different to CENTER303
                    if B56[0].isdigit():
                        T2 = float(B56)
                    else:
                        T2 = float(B56[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    if retry:
                        return self.CENTER303temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        error = QApplication.translate("Error Message","CENTER303temperature(): {0} bytes received but 8 needed",None).format(nbytes)
                        timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                        aw.qmc.adderror(timez + " " + error)
                        return -1,-1
            else:
                return -1,-1 
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " CENTER303temperature() {0}").format(str(ex)),exc_tb.tb_lineno)            
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER303: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))


    def VOLTCRAFTPL125T2temperature(self,retry=2):
        try:
            command = bytearray([244, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(26)
                if len(r) == 26 and hex2int(r[0],r[1]) == 43605: # filter out bad/strange data
                    #extract T1
                    T1 = hex2int(r[19],r[18])/10. # select byte 19 and 18
                    #extract T2
                    T2 = hex2int(r[21],r[20])/10.# select byte 21 and 20 
                    return T1,T2
                else:
                    if retry:
                        libtime.sleep(.05)
                        return self.VOLTCRAFTPL125T2temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        error = QApplication.translate("Error Message","VOLTCRAFTPL125T2temperature(): {0} bytes received but 26 needed",None).format(nbytes)
                        timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                        _,_, exc_tb = sys.exc_info()
                        aw.qmc.adderror(timez + " " + error)
                        return -1,-1
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " VOLTCRAFTPL125T2temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("VOLTCRAFTPL125T2: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def VOLTCRAFTPL125T4temperature(self,retry=2):
        try:
            command = bytearray([244, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(26)
                if len(r) == 26 and hex2int(r[0],r[1]) == 43605: # filter out bad/strange data
                    aw.qmc.extraPL125T4TX = aw.qmc.timeclock.elapsed()/1000.
                    #extract T1
                    T1 = hex2int(r[23],r[22])/10.# select byte 23 and 22
                    #extract T2
                    T2 = hex2int(r[25],r[24])/10.# select byte 25 and 24
                    aw.qmc.extraPL125T4T4 = hex2int(r[21],r[20])/10.# select byte 21 and 20
                    aw.qmc.extraPL125T4T3 = hex2int(r[19],r[18])/10. # select byte 19 and 18
                    return T1,T2
                else:
                    if retry:
                        libtime.sleep(.05)
                        return self.VOLTCRAFTPL125T4temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        error = QApplication.translate("Error Message","VOLTCRAFTPL125T4temperature(): {0} bytes received but 26 needed",None).format(nbytes)
                        timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                        _,_, exc_tb = sys.exc_info()
                        aw.qmc.adderror(timez + " " + error)
                        return -1,-1
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " VOLTCRAFTPL125T4temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("VOLTCRAFTPL125T4: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))


    def CENTER306temperature(self,retry=2):
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(10) #NOTE: different to CENTER303
                if len(r) == 10:
                    #DECIMAL POINT
                    #if bit 2 of byte 3 = 1 then T1 = ####      (don't divide by 10)
                    #if bit 2 of byte 3 = 0 then T1 = ###.#     ( / by 10)
                    #if bit 5 of byte 3 = 1 then T2 = ####
                    #if bit 5 of byte 3 = 0 then T2 = ###.#
                    #extract bit 2, and bit 5 of BYTE 3
                    b3bin = self.binary(r[2])          #bits string order "[7][6][5][4][3][2][1][0]"
                    bit2 = b3bin[5]
                    bit5 = b3bin[2]
                    #extract T1
                    B34 = cmd2str(binascii.hexlify(r[3:5])) # select byte 3 and 4
                    if B34[0].isdigit():
                        T1 = float(B34)
                    else:
                        T1 = float(B34[1:])
                    #extract T2
                    B78 = cmd2str(binascii.hexlify(r[7:9])) # select byte 7 and 9; NOTE: different to CENTER303
                    if B78[0].isdigit():
                        T2 = float(B78)
                    else:
                        T2 = float(B78[1:])
                    #check decimal point
                    if bit2 == "0":
                        T1 /= 10.
                    if bit5 == "0":
                        T2 /= 10.
                    return T1,T2
                else:
                    if retry:
                        return self.CENTER306temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        error = QApplication.translate("Error Message","CENTER306temperature(): {0} bytes received but 10 needed",None).format(nbytes)
                        timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
                        _,_, exc_tb = sys.exc_info()
                        aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
                        return -1,-1
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " CENTER306temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER306: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def CENTER309temperature(self, retry=1):
        ##    command = "\x4B" returns 4 bytes . Model number.
        ##    command = "\x48" simulates HOLD button
        ##    command = "\x4D" simulates MAX/MIN button
        ##    command = "\x4E" simulates EXIT MAX/MIN button
        ##    command = "\x52" simulates TIME button
        ##    command = "\x43" simulates C/F button
        ##    command = "\x55" dump all memmory
        ##    command = "\x50" Load recorded data
        ##    command = "\x41" returns 45 bytes (8x5 + 5 = 45) as follows:
        ##    
        ##    "\x02\x80\xUU\xUU\xUU\xUU\xUU\xAA"  \x80 means "Celsi" (if \x00 then "Faren") UUs unknown
        ##    "\xAA\xBB\xBB\xCC\xCC\xDD\xDD\x00"  Temprerature T1 = AAAA, T2=BBBB, T3= CCCC, T4 = DDDD
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown (possible data containers but found empty)
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x00\x00\x00\x00\x00"  unknown
        ##    "\x00\x00\x00\x0E\x03"              The byte r[43] \x0E changes depending on what thermocouple(s) are connected.
        ##                                        If T1 thermocouple connected alone, then r[43]  = \x0E = 14
        ##                                        If T2 thermocouple connected alone, then r[43]  = \x0D = 13
        ##                                        If T1 + T2 thermocouples connected, then r[43]  = \x0C = 12
        ##                                        If T3 thermocouple connected alone, then r[43]  = \x0B = 11
        ##                                        If T4 thermocouple connected alone, then r[43]  = \x07 = 7
        ##                                        Note: Print r[43] if you want to find other connect-combinations
        ##                                        THIS ONLY WORKS WHEN TEMPERATURE < 200. If T >= 200 r[43] changes
        try:
            command = str2cmd("\x41")
            r = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(command)
                r = self.SP.read(45)
                if len(r) == 45:
                    T1 = T2 = T3 = T3 = -1
                    try:
                        T1 = hex2int(r[7],r[8])/10.
                    except Exception:
                        pass
                    try:
                        T2 = hex2int(r[9],r[10])/10.
                    except Exception:
                        pass
                    try:
                        T3 = hex2int(r[11],r[12])/10.
                    except Exception:
                        pass
                    try:
                        T4 = hex2int(r[13],r[14])/10.
                    except Exception:
                        pass
                    #save these variables if using T3 and T4
                    aw.qmc.extra309T3 = T3
                    aw.qmc.extra309T4 = T4
                    aw.qmc.extra309TX = aw.qmc.timeclock.elapsed()/1000.
                    return T1,T2
                else:
                    if retry:
                        return self.CENTER309temperature(retry=retry-1)
                    else:
                        nbytes = len(r)
                        aw.qmc.adderror(QApplication.translate("Error Message","CENTER309temperature(): {0} bytes received but 45 needed",None).format(nbytes))            
                        return -1,-1 
            else:
                return -1,-1
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " CENTER309temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            self.closeport()
            return -1,-1
        finally:
            #note: logged chars should be unicode not binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("CENTER309: " + settings + " || Tx = " + cmd2str(binascii.hexlify(command)) + " || Rx = " + cmd2str((binascii.hexlify(r))))

    def addPhidgetServer(self):
        if not aw.qmc.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            PhidgetNetwork.addServer("PhidgetServer",aw.qmc.phidgetServerID,aw.qmc.phidgetPort,aw.qmc.phidgetPassword,0)
            aw.qmc.phidgetServerAdded = True

    def removePhidgetServer(self):
        if aw.qmc.phidgetServerAdded:
            from Phidget22.Net import Net as PhidgetNetwork
            PhidgetNetwork.removeServer("PhidgetServer")
            aw.qmc.phidgetServerAdded = False

#---

    def phidget1045TemperatureChanged(self,_,t):
        try:
            #### lock shared resources #####
            self.Phidget1045semaphore.acquire(1)
            self.Phidget1045values.append(t)
        finally:
            if self.Phidget1045semaphore.available() < 1:
                self.Phidget1045semaphore.release(1)
          
    # applies given emissivity to the IR temperature value assuming the given ambient temperature
    def IRtemp(self,emissivity,temp,ambient):
        return (temp - ambient) * emissivity + ambient

    def configure1045(self):
        self.Phidget1045values = []
        self.Phidget1045lastvalue = -1
        self.Phidget1045tempIRavg = None
        if self.PhidgetIRSensor is not None:
            try:
                if aw.qmc.phidget1045_async:
                    self.PhidgetIRSensor.setTemperatureChangeTrigger(aw.qmc.phidget1045_changeTrigger)
                else:
                    self.PhidgetIRSensor.setTemperatureChangeTrigger(0)
            except:
                pass
            try:
                if aw.qmc.phidget1045_async:
                    self.PhidgetIRSensor.setOnTemperatureChangeHandler(self.phidget1045TemperatureChanged)
                else:
                    self.PhidgetIRSensor.setOnTemperatureChangeHandler(lambda *_:None)
            except:
                pass
            # set rate
            try:
                self.PhidgetIRSensor.setDataInterval(aw.qmc.phidget1045_dataRate)
            except Exception:
                pass
            
    def configureOneTC(self):
        self.Phidget1045values = []
        self.Phidget1045lastvalue = -1
        self.PhidgetIRSensor.setThermocoupleType(PHIDGET_THERMOCOUPLE_TYPE(aw.qmc.phidget1048_types[0]))
        if aw.qmc.phidget1048_async[0]:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(aw.qmc.phidget1048_changeTriggers[0])
        else:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(0)
        if aw.qmc.phidget1048_async[0]:
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(self.phidget1045TemperatureChanged)
        else:
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(lambda *_:None)
        # set rate
        try:
            self.PhidgetIRSensor.setDataInterval(aw.qmc.phidget1048_dataRate)
        except Exception:
            pass
            
    def configureOneRTD(self):
        self.Phidget1045values = []
        self.Phidget1045lastvalue = -1
        self.PhidgetIRSensor.setRTDType(PHIDGET_RTD_TYPE(aw.qmc.phidget1200_formula))
        self.PhidgetIRSensor.setRTDWireSetup(PHIDGET_RTD_WIRE(aw.qmc.phidget1200_wire))
        if aw.qmc.phidget1200_async:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(aw.qmc.phidget1200_changeTrigger)
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(self.phidget1045TemperatureChanged)
        else:
            self.PhidgetIRSensor.setTemperatureChangeTrigger(0)
            self.PhidgetIRSensor.setOnTemperatureChangeHandler(lambda *_:None)
        # set rate
        try:
            self.PhidgetIRSensor.setDataInterval(aw.qmc.phidget1200_dataRate)
        except Exception:
            pass

    def phidget1045attached(self,serial,port,deviceType):
        try:
            aw.qmc.phidgetManager.reserveSerialPort(serial,port,0,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if deviceType != DeviceID.PHIDID_TMP1200:
                aw.qmc.phidgetManager.reserveSerialPort(serial,port,1,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if deviceType == DeviceID.PHIDID_1045:
                self.configure1045()
                aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor IR attached",None))
            elif deviceType == DeviceID.PHIDID_1051:
                self.configureOneTC()
                aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 1-input attached",None))
            elif deviceType == DeviceID.PHIDID_TMP1100:
                self.configureOneTC()
                aw.sendmessage(QApplication.translate("Message","Phidget Isolated Thermocouple 1-input attached",None))
            elif deviceType == DeviceID.PHIDID_TMP1200:
                self.configureOneRTD()
                aw.sendmessage(QApplication.translate("Message","Phidget VINT RTD 1-input attached",None))
        except:
            pass

    def phidget1045detached(self,serial,port,deviceType):
        try:
            aw.qmc.phidgetManager.releaseSerialPort(serial,port,0,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if deviceType != DeviceID.PHIDID_TMP1200:
                aw.qmc.phidgetManager.releaseSerialPort(serial,port,1,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
            if deviceType == DeviceID.PHIDID_1045:
                aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor IR detached",None))
            elif deviceType == DeviceID.PHIDID_1051:
                aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 1-input detached",None))
            elif deviceType == DeviceID.PHIDID_TMP1100:
                aw.sendmessage(QApplication.translate("Message","Phidget Isolated Thermocouple 1-input detached",None))
            elif deviceType == DeviceID.PHIDID_TMP1200:
                aw.sendmessage(QApplication.translate("Message","Phidget VINT RTD 1-input detached",None))
        except:
            pass

    # this one is reused for the 1045 (IR), the 1051 (1xTC), TMP1100 (1xTC), and TMP1200 (1xRTD)
    def PHIDGET1045temperature(self,deviceType=DeviceID.PHIDID_1045,retry=True):
        try:
            if not self.PhidgetIRSensor and aw.qmc.phidgetManager is not None:
                ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetTemperatureSensor',deviceType,
                            remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if ser:
                    self.PhidgetIRSensor = PhidgetTemperatureSensor()
                    if deviceType == DeviceID.PHIDID_TMP1200:
                        self.PhidgetIRSensorIC = None # the TMP1200 does not has an internal temperature sensor
                    else:
                        self.PhidgetIRSensorIC = PhidgetTemperatureSensor()
                    try:
                        self.PhidgetIRSensor.setOnAttachHandler(lambda _:self.phidget1045attached(ser,port,deviceType))
                        self.PhidgetIRSensor.setOnDetachHandler(lambda _:self.phidget1045detached(ser,port,deviceType))
                        if aw.qmc.phidgetRemoteFlag:
                            self.addPhidgetServer()
                        if port is not None:
                            self.PhidgetIRSensor.setHubPort(port)
                            if deviceType != DeviceID.PHIDID_TMP1200:
                                self.PhidgetIRSensorIC.setHubPort(port)
                        self.PhidgetIRSensor.setDeviceSerialNumber(ser)
                        self.PhidgetIRSensor.setChannel(0) # attache to the IR channel
                        try:
                            if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                                self.PhidgetIRSensor.setIsRemote(True)
                                self.PhidgetIRSensor.setIsLocal(False)
                            self.PhidgetIRSensor.open() #.openWaitForAttachment(timeout) # wait attach for the TMP1200 takes about 1sec on USB
                        except:
                            pass
                        if deviceType != DeviceID.PHIDID_TMP1200:
                            self.PhidgetIRSensorIC.setDeviceSerialNumber(ser)
                            self.PhidgetIRSensorIC.setChannel(1) # attache to the IC channel
                            if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                                self.PhidgetIRSensorIC.setIsRemote(True)
                                self.PhidgetIRSensorIC.setIsLocal(False)
                            try:
                                self.PhidgetIRSensorIC.open() #.openWaitForAttachment(timeout)
                            except:
                                pass
                        # we need to give this device a bit time to attach, otherwise it will be considered for another Artisan channel of the same type
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                    except Exception as ex:
                        _, _, exc_tb = sys.exc_info()
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1045temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
                        try:
                            if self.PhidgetIRSensor and self.PhidgetIRSensor.getAttached():
                                self.PhidgetIRSensor.close()
                            if self.PhidgetIRSensorIC and self.PhidgetIRSensorIC.getAttached():
                                self.PhidgetIRSensorIC.close()
                        except Exception:
                            pass
                        self.PhidgetIRSensor = None
                        self.Phidget1045values = []
                        self.Phidget1045lastvalue = -1
                        self.PhidgetIRSensorIC = None
                        self.Phidget1045tempIRavg = None
            if self.PhidgetIRSensor and self.PhidgetIRSensor.getAttached():
                res = -1
                ambient = -1
                try:
                    if (deviceType == DeviceID.PHIDID_1045 and aw.qmc.phidget1045_async) or \
                        (deviceType in [DeviceID.PHIDID_1051,DeviceID.PHIDID_TMP1100] and aw.qmc.phidget1048_async[0]) or \
                        (deviceType == DeviceID.PHIDID_TMP1200 and aw.qmc.phidget1200_async):
                        async_res = None
                        try:
                            #### lock shared resources #####
                            self.Phidget1045semaphore.acquire(1)
                            if len(self.Phidget1045values) > 0:
                                async_res = numpy.average(self.Phidget1045values)
                                if deviceType == DeviceID.PHIDID_1045:
                                    rate = aw.qmc.phidget1045_dataRate
                                elif deviceType == DeviceID.PHIDID_TMP1200:
                                    rate = aw.qmc.phidget1200_dataRate
                                else:
                                    rate = aw.qmc.phidget1048_dataRate
                                self.Phidget1045values = self.Phidget1045values[-round((aw.qmc.delay/rate)):]
                        except:
                            self.Phidget1045values = []
                        finally:
                            if self.Phidget1045semaphore.available() < 1:
                                self.Phidget1045semaphore.release(1)
                        if async_res is None:
                            if self.Phidget1045lastvalue == -1: # there is no last value yet, we take a sync value
                                probe = self.PhidgetIRSensor.getTemperature()
                                self.Phidget1045lastvalue = self.PhidgetIRSensor.getTemperature()
                            else:
                                probe = self.Phidget1045lastvalue
                        else:
                            self.Phidget1045lastvalue = async_res
                            probe = async_res
                    else:
                        probe = self.PhidgetIRSensor.getTemperature()
                    if aw.qmc.mode == "F":
                        probe = aw.qmc.fromCtoF(probe)
                    res = probe
                except Exception:
                    pass
                try:
                    if self.PhidgetIRSensorIC is not None and self.PhidgetIRSensorIC.getAttached():
                        ambient = self.PhidgetIRSensorIC.getTemperature()
                        # we heavily average this ambient temperature IC readings not to introduce additional noise via emissivity calc to the IR reading
                        if self.Phidget1045tempIRavg is None:
                            self.Phidget1045tempIRavg = ambient
                        else:
                            self.Phidget1045tempIRavg = (20*self.Phidget1045tempIRavg + ambient) / 21.0
                            ambient = self.Phidget1045tempIRavg
                        if aw.qmc.mode == "F":
                            ambient = aw.qmc.fromCtoF(ambient)
                except Exception:
                    pass
                if deviceType == DeviceID.PHIDID_TMP1200:
                    ambient = res
                if ambient == -1:
                    return -1,-1
                else:
                    if deviceType == DeviceID.PHIDID_1045:
                        return self.IRtemp(aw.qmc.phidget1045_emissivity,res,ambient),ambient
                    else:
                        return res,ambient
            elif retry:
                libtime.sleep(0.1)
                return self.PHIDGET1045temperature(deviceType,retry=False)
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                if self.PhidgetIRSensor and self.PhidgetIRSensor.getAttached():
                    self.PhidgetIRSensor.close()
                if self.PhidgetIRSensorIC and self.PhidgetIRSensorIC.getAttached():
                    self.PhidgetIRSensorIC.close()
            except Exception:
                pass
            self.PhidgetIRSensor = None
            self.Phidget1045values = []
            self.Phidget1045lastvalue = -1
            self.PhidgetIRSensorIC = None
            self.Phidget1045tempIRavg = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1045temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

#----

    def phidget1048TemperatureChanged(self,t,channel):
        try:
            #### lock shared resources #####
            self.Phidget1048semaphores[channel].acquire(1)
            self.Phidget1048values[channel].append(t)
        finally:
            if self.Phidget1048semaphores[channel].available() < 1:
                self.Phidget1048semaphores[channel].release(1)

    def phidget1048getSensorReading(self,channel,idx):
        if aw.qmc.phidget1048_async[channel]:
            res = None
            try:
                #### lock shared resources #####
                self.Phidget1048semaphores[channel].acquire(1)
                if len(self.Phidget1048values[channel]) > 0:
                    res = numpy.average(self.Phidget1048values[channel])
                    
#                    data = self.Phidget1048values[channel]
#                    data_mean, data_std = numpy.mean(data), numpy.std(data)
#                    if data_std > 0:
#                        cut_off = data_std * 0.9
#                        lower, upper = data_mean - cut_off, data_mean + cut_off
#                        outliers_removed = [x for x in data if x > lower and x < upper]
#                        if len(outliers_removed) < 3:
#                            outliers_removed = data
#                    else:
#                        outliers_removed = data
#                    res = numpy.average(outliers_removed)

                    self.Phidget1048values[channel] = self.Phidget1048values[channel][-round((aw.qmc.delay/aw.qmc.phidget1048_dataRate)):]
            except:
                self.Phidget1048values[channel] = []
            finally:
                if self.Phidget1048semaphores[channel].available() < 1:
                    self.Phidget1048semaphores[channel].release(1)
            if res is None:
                if self.Phidget1048lastvalues[channel] == -1: # there is no last value yet, we take a sync value
                    res = self.PhidgetTemperatureSensor[idx].getTemperature()
                    self.Phidget1048lastvalues[channel] = res
                    return res
                else:
                    return self.Phidget1048lastvalues[channel] # return the previous result
            else:
                self.Phidget1048lastvalues[channel] = res
                return res
        else:
            return self.PhidgetTemperatureSensor[idx].getTemperature()
    
    # each channel is configured separately
    def configure1048(self,idx):
        if self.PhidgetTemperatureSensor and len(self.PhidgetTemperatureSensor) > idx:
            # reset async values
            channel = self.PhidgetTemperatureSensor[idx].getChannel()
            if channel < 4: # the ambient temperature sensor does not need to be configured
                # set probe type
                self.PhidgetTemperatureSensor[idx].setThermocoupleType(PHIDGET_THERMOCOUPLE_TYPE(aw.qmc.phidget1048_types[channel]))
                # set rate
                try:
                    self.PhidgetTemperatureSensor[idx].setDataInterval(aw.qmc.phidget1048_dataRate)
                except Exception:
                    pass
                # set change trigger
                try:
                    if aw.qmc.phidget1048_async[channel]:
                        self.PhidgetTemperatureSensor[idx].setTemperatureChangeTrigger(aw.qmc.phidget1048_changeTriggers[channel])
                        self.PhidgetTemperatureSensor[idx].setOnTemperatureChangeHandler(lambda _,t: self.phidget1048TemperatureChanged(t,channel))
                    else:
                        self.PhidgetTemperatureSensor[idx].setTemperatureChangeTrigger(0)
                        self.PhidgetTemperatureSensor[idx].setOnTemperatureChangeHandler(lambda *_:None)
                except:
                    pass
                self.Phidget1048values[channel] = []
                self.Phidget1048lastvalues[channel] = -1

    def phidget1048attached(self,serial,port,deviceType,idx):
        try:
            self.configure1048(idx)
            if self.PhidgetTemperatureSensor is not None and len(self.PhidgetTemperatureSensor) > idx:
                channel = self.PhidgetTemperatureSensor[idx].getChannel()
                aw.qmc.phidgetManager.reserveSerialPort(serial,port,channel,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 4-input attached",None))
        except:
            pass
        
    def phidget1048detached(self,serial,port,deviceType,idx):
        try:
            if self.PhidgetTemperatureSensor is not None and len(self.PhidgetTemperatureSensor) > idx:
                channel = self.PhidgetTemperatureSensor[idx].getChannel()
                aw.qmc.phidgetManager.releaseSerialPort(serial,port,channel,"PhidgetTemperatureSensor",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    aw.sendmessage(QApplication.translate("Message","Phidget Temperature Sensor 4-input detached",None))
        except:
            pass

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4; mode 2 for Ambient Temperature
    # works for the 4xTC USB_Phidget 1048 and the 4xTC VINT Phidget TMP1101
    def PHIDGET1048temperature(self,deviceType=DeviceID.PHIDID_1048,mode=0,retry=True):
        try:
            if not self.PhidgetTemperatureSensor and aw.qmc.phidgetManager is not None:
                ser = None
                port = None 
                if mode == 0:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetTemperatureSensor',deviceType,0,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                # in all other cases, we check for existing serial/port pairs from attaching the main channels 1+2 of the device
                elif mode == 1: 
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetTemperatureSensor',deviceType,2,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                elif mode == 2:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetTemperatureSensor',deviceType,4,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if ser:
                    self.PhidgetTemperatureSensor = [PhidgetTemperatureSensor()]
                    if mode != 2:
                        self.PhidgetTemperatureSensor.append(PhidgetTemperatureSensor())
                    try:
                        self.PhidgetTemperatureSensor[0].setOnAttachHandler(lambda _:self.phidget1048attached(ser,port,deviceType,0))
                        self.PhidgetTemperatureSensor[0].setOnDetachHandler(lambda _:self.phidget1048detached(ser,port,deviceType,0))
                        if mode != 2:                            
                            self.PhidgetTemperatureSensor[1].setOnAttachHandler(lambda _:self.phidget1048attached(ser,port,deviceType,1))
                            self.PhidgetTemperatureSensor[1].setOnDetachHandler(lambda _:self.phidget1048detached(ser,port,deviceType,1))
                        if aw.qmc.phidgetRemoteFlag:
                            self.addPhidgetServer()
                        if port is not None:
                            self.PhidgetTemperatureSensor[0].setHubPort(port)
                            if mode != 2:
                                self.PhidgetTemperatureSensor[1].setHubPort(port)
                        self.PhidgetTemperatureSensor[0].setDeviceSerialNumber(ser)
                        self.PhidgetTemperatureSensor[0].setChannel(mode*2)
                        if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                            self.PhidgetTemperatureSensor[0].setIsRemote(True)
                            self.PhidgetTemperatureSensor[0].setIsLocal(False)
                        try:
                            self.PhidgetTemperatureSensor[0].open() #.openWaitForAttachment(timeout)
                        except:
                            pass
                        if mode != 2:
                            self.PhidgetTemperatureSensor[1].setDeviceSerialNumber(ser)
                            self.PhidgetTemperatureSensor[1].setChannel(mode*2 + 1)
                            if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                                self.PhidgetTemperatureSensor[1].setIsRemote(True)
                                self.PhidgetTemperatureSensor[1].setIsLocal(False)
                            try:
                                self.PhidgetTemperatureSensor[1].open() # .openWaitForAttachment(timeout)
                            except:
                                pass
                        # we need to give this device a bit time to attach, otherwise it will be considered for another Artisan channel of the same type
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                    except Exception as ex:
                        #_, _, exc_tb = sys.exc_info()
                        #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1048temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
                        try:
                            if self.PhidgetTemperatureSensor and self.PhidgetTemperatureSensor[0].getAttached():
                                self.PhidgetTemperatureSensor[0].close()
                            if mode != 2 and self.PhidgetTemperatureSensor and len(self.PhidgetTemperatureSensor)> 1 and self.PhidgetTemperatureSensor[1].getAttached():
                                self.PhidgetTemperatureSensor[1].close()
                        except Exception:
                            pass
                        self.Phidget1048values = [[],[],[],[]]
                        self.Phidget1048lastvalues = [-1]*4
                        self.PhidgetTemperatureSensor = None
            if self.PhidgetTemperatureSensor and ((mode == 2) or (len(self.PhidgetTemperatureSensor)>1 and self.PhidgetTemperatureSensor[0].getAttached() and self.PhidgetTemperatureSensor[1].getAttached())):
                # now just harvest both temps (or one in case type is 2)
                if mode in [0,1]:
                    probe1 = probe2 = -1
                    try:
                        probe1 = self.phidget1048getSensorReading(mode*2,0)
                        if aw.qmc.mode == "F":
                            probe1 = aw.qmc.fromCtoF(probe1)
                    except Exception:
                        pass
                    try:
                        probe2 = self.phidget1048getSensorReading(mode*2 + 1,1)
                        if aw.qmc.mode == "F":
                            probe2 = aw.qmc.fromCtoF(probe2)
                    except Exception:
                        pass
                    return probe1, probe2
                elif mode == 2:
                    try:
                        at = self.PhidgetTemperatureSensor[0].getTemperature()
                        if aw.qmc.mode == "F":
                            at = aw.qmc.fromCtoF(at)
                        return at,-1
                    except Exception:
                        return -1,-1
                else:
                    return -1,-1
            elif retry:
                libtime.sleep(0.1)
                return self.PHIDGET1048temperature(deviceType,mode,False)
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                if self.PhidgetTemperatureSensor and self.PhidgetTemperatureSensor[0].getAttached():
                    self.PhidgetTemperatureSensor[0].close()
                if mode != 2 and self.PhidgetTemperatureSensor and len(self.PhidgetTemperatureSensor)>1 and self.PhidgetTemperatureSensor[1].getAttached():
                    self.PhidgetTemperatureSensor[1].close()
            except Exception:
                pass
            self.Phidget1048values = [[],[],[],[]]
            self.Phidget1048lastvalues = [-1]*4
            self.PhidgetTemperatureSensor = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1048temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

#--- code for the Phidgets 1046

    # takes a bridge value in mV/V and returns the resistance of the corresponding RTD, assuming the RTD is connected
    # via a Wheatstone Bridge build from 1K ohm resistors
    # http://en.wikipedia.org/wiki/Wheatstone_bridge
    # Note: the 1046 returns the bridge value in mV/V
    def R_RTD_WS(self,bv):
        return (1000 * (1000 - 2 * bv))/(1000 + 2 * bv)
    
    # takes a bridge value in mV/V and returns the resistance of the corresponding RTD, assuming the RTD is connected
    # via a Voltage Divider build from 1K ohm resistors
    # http://en.wikipedia.org/wiki/Voltage_divider
    # Note: the 1046 returns the bridge value in mV/V
    def R_RTD_DIV(self,bv):
        return (2000 * bv) / (1000 - bv)
        
    # this formula results from a direct mathematical linearization of the Callendar-Van Dusen equation
    # see Analog Devices Application Note AN-709 http://www.analog.com/static/imported-files/application_notes/AN709_0.pdf
    # Wikipedia http://en.wikipedia.org/wiki/Resistance_thermometer
    #  or http://www.abmh.de
    def rRTD2PT100temp(self,R_RTD):
        Z1 = -3.9083e-03
        Z2 = 1.76e-05
        Z3 = -2.31e-08
        Z4 = -1.155e-06
        try:
            return (Z1 + math.sqrt(abs(Z2 + (Z3 * R_RTD))))/Z4
        except Exception:
            return -1

    # convert the BridgeValue given by the PhidgetBridge to a temperature value assuming a PT100 probe
    # see http://www.phidgets.com/docs/3175_User_Guide
    # this one is a simpler and less accurate approximation as above that directly gives the temperature for a given bridge value in mV/V,
    # that works only for the Voltage Divider case
#    def bridgeValue2PT100(self,bv):
#        bvf = bv / (1000 - bv)
#        return 4750.3 * bvf * bvf + 4615.6 * bvf - 242.615

    def phidget1046TemperatureChanged(self,v,channel):
        try:
            #### lock shared resources #####
            self.Phidget1046semaphores[channel].acquire(1)
            temp = self.bridgeValue2Temperature(channel,v*1000) # Note in Phidgets API v22 this factor 1000 has to be added
            if aw.qmc.mode == "F" and aw.qmc.phidget1046_formula[channel] != 2:
                temp = aw.qmc.fromCtoF(temp)
            self.Phidget1046values[channel].append(temp)
        finally:
            if self.Phidget1046semaphores[channel].available() < 1:
                self.Phidget1046semaphores[channel].release(1)

    def bridgeValue2Temperature(self,i,bv):
        v = -1
        try:
            if aw.qmc.phidget1046_formula[i] == 0:
                v = self.rRTD2PT100temp(self.R_RTD_WS(abs(bv)))  # we add the abs() here to support inverted wirings
            elif aw.qmc.phidget1046_formula[i] == 1:
                v = self.rRTD2PT100temp(self.R_RTD_DIV(abs(bv)))  # we add the abs() here to support inverted wirings
            elif aw.qmc.phidget1046_formula[i] == 2:
                v = bv # no abs() for raw values
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " bridgeValue2Temperature(): {0}").format(str(e)),exc_tb.tb_lineno)            
        return v

    def phidget1046getTemperature(self,i,idx):
        v = -1
        try:
            bv = self.PhidgetBridgeSensor[idx].getVoltageRatio() * 1000 # Note in Phidgets API v22 this factor 1000 has to be added
            
# test values for the bridge value to temperature conversion
#            bv = 51.77844 # about room temperature for Voltage Divider wiring
#            bv = 400.2949 # about room temperature for Wheatstone Bridge

            v = self.bridgeValue2Temperature(i,bv)
            if aw.qmc.mode == "F" and aw.qmc.phidget1046_formula[i] != 2:
                v = aw.qmc.fromCtoF(v)
        except:
            v = -1
        return v
                        
    def phidget1046getSensorReading(self,channel,idx):
        if aw.qmc.phidget1046_async[channel]:
            res = None
            try:
                #### lock shared resources #####
                self.Phidget1046semaphores[channel].acquire(1)
                if len(self.Phidget1046values[channel]) > 0:
                    res = numpy.average(self.Phidget1046values[channel])
                    self.Phidget1046values[channel] = self.Phidget1046values[channel][-round((aw.qmc.delay/aw.qmc.phidget1046_dataRate)):] 
            except:
                self.Phidget1046values[channel] = []
            finally:
                if self.Phidget1046semaphores[channel].available() < 1:
                    self.Phidget1046semaphores[channel].release(1)
            if res is None:
                if self.Phidget1046lastvalues[channel] == -1: # there is no last value yet, we take a sync value
                    res = self.phidget1046getTemperature(channel,idx)
                    self.Phidget1046lastvalues[channel] = res
                    return res
                else:
                    return self.Phidget1046lastvalues[channel]
            else:
                self.Phidget1046lastvalues[channel] = res
                return res
        else:
            return self.phidget1046getTemperature(channel,idx)

    def configure1046(self,idx):
        if self.PhidgetBridgeSensor and len(self.PhidgetBridgeSensor) > idx:
            channel = self.PhidgetBridgeSensor[idx].getChannel()
            if channel < 4:
                # set gain
                try:
                    self.PhidgetBridgeSensor[idx].setBridgeGain(PHIDGET_GAIN_VALUE(aw.qmc.phidget1046_gain[channel]))
                except Exception:
                    pass
                # set rate
                try:
                    self.PhidgetBridgeSensor[idx].setDataInterval(aw.qmc.phidget1046_dataRate)
                except Exception:
                    pass
                # set voltage ratio change trigger to 0 (fire every DataInterval)
                try:
                    self.PhidgetBridgeSensor[idx].setVoltageChangeTrigger(0)
                except Exception:
                    pass
                # enable channel
                try:
                    self.PhidgetBridgeSensor[idx].setBridgeEnabled(channel, True)
                except Exception:
                    pass
                if aw.qmc.phidget1046_async[channel]:
                    self.PhidgetBridgeSensor[idx].setOnVoltageRatioChangeHandler(lambda _,v:self.phidget1046TemperatureChanged(v,channel))
                else:
                    self.PhidgetBridgeSensor[idx].setOnVoltageRatioChangeHandler(lambda *_:None)
                # reset async value
                self.Phidget1046values[channel] = []
                self.Phidget1046lastvalues[channel] = -1

    def phidget1046attached(self,serial,port,deviceType,idx):
        try:
            self.configure1046(idx)
            if self.PhidgetBridgeSensor is not None:
                channel = self.PhidgetBridgeSensor[idx].getChannel()
                aw.qmc.phidgetManager.reserveSerialPort(serial,port,channel,"PhidgetVoltageRatioInput",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    aw.sendmessage(QApplication.translate("Message","Phidget Bridge 4-input attached",None))
        except:
            pass
        
    def phidget1046detached(self,serial,port,deviceType,idx):
        try:
            if self.PhidgetBridgeSensor is not None:
                channel = self.PhidgetBridgeSensor[idx].getChannel()
                aw.qmc.phidgetManager.releaseSerialPort(serial,port,channel,"PhidgetVoltageRatioInput",deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    aw.sendmessage(QApplication.translate("Message","Phidget Bridge 4-input detached",None))
        except:
            pass

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4
    def PHIDGET1046temperature(self,mode=0,retry=True):
        try:
            if not self.PhidgetBridgeSensor and aw.qmc.phidgetManager is not None:
                ser = None
                port = None 
                if mode == 0:
                    # we scan for available main device
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageRatioInput',DeviceID.PHIDID_1046,0,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                # in all other cases, we check for existing serial/port pairs from attaching the main channels 1+2 of the device
                elif mode == 1:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageRatioInput',DeviceID.PHIDID_1046,2,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if ser:
                    self.PhidgetBridgeSensor = [VoltageRatioInput(),VoltageRatioInput()]
                
                    try:
                        for i in [0,1]:
                            if aw.qmc.phidgetRemoteFlag:
                                self.addPhidgetServer()
                            if port is not None:
                                self.PhidgetBridgeSensor[i].setHubPort(port)
                            self.PhidgetBridgeSensor[i].setDeviceSerialNumber(ser)
                            self.PhidgetBridgeSensor[i].setChannel(mode*2+i)
                            if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                                self.PhidgetBridgeSensor[i].setIsRemote(True)
                                self.PhidgetBridgeSensor[i].setIsLocal(False)
                            self.PhidgetBridgeSensor[i].setOnAttachHandler(lambda _,x=i:self.phidget1046attached(ser,port,DeviceID.PHIDID_1046,x))
                            self.PhidgetBridgeSensor[i].setOnDetachHandler(lambda _,x=i:self.phidget1046detached(ser,port,DeviceID.PHIDID_1046,x))
                            libtime.sleep(.1)
                            try:
                                self.PhidgetBridgeSensor[i].open() #.openWaitForAttachment(timeout)
                            except:
                                pass
                        # we need to give this device a bit time to attach, otherwise it will be considered for another Artisan channel of the same type
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                    except Exception as ex:
                        #_, _, exc_tb = sys.exc_info()
                        #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1046temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
                        try:
                            if self.PhidgetBridgeSensor and self.PhidgetBridgeSensor[0].getAttached():
                                self.PhidgetBridgeSensor[0].close()
                            if self.PhidgetBridgeSensor and len(self.PhidgetBridgeSensor)>1 and self.PhidgetBridgeSensor[1].getAttached():
                                self.PhidgetBridgeSensor[1].close()
                        except Exception:
                            pass
                        self.Phidget1046values = [[],[],[],[]]
                        self.Phidget1046lastvalues = [-1]*4
                        self.PhidgetBridgeSensor = None
            if self.PhidgetBridgeSensor and len(self.PhidgetBridgeSensor) == 2 and self.PhidgetBridgeSensor[0].getAttached() and self.PhidgetBridgeSensor[1].getAttached():
                if mode in [0,1]:
                    probe1 = probe2 = -1
                    try:
                        probe1 = self.phidget1046getSensorReading(mode*2,0)
                    except Exception:
                        pass
                    try:
                        probe2 = self.phidget1046getSensorReading(mode*2+1,1)
                    except Exception:
                        pass
                    return probe1, probe2
                else:
                    return -1,-1
            elif retry:
                libtime.sleep(0.1)
                return self.PHIDGET1046temperature(mode,False)
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                if self.PhidgetBridgeSensor and self.PhidgetBridgeSensor[0].getAttached():
                    self.PhidgetBridgeSensor[0].close()
                if self.PhidgetBridgeSensor and len(self.PhidgetBridgeSensor)>1 and self.PhidgetBridgeSensor[1].getAttached():
                    self.PhidgetBridgeSensor[1].close()
            except Exception:
                pass
            self.Phidget1046values = [[],[],[],[]]
            self.Phidget1046lastvalues = [-1]*4
            self.PhidgetBridgeSensor = None
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1046temperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    # takes a string of the form "<serial>[:<hubport>]" or None and returns serial and hubport numbers
    def serialString2serialPort(self,serial):
        if serial is None:
            return None, None
        else:
            serial_split = serial.split(":")
            s = None
            p = None
            try:
                s = int(serial_split[0])
            except:
                pass
            try:
                p = int(serial_split[1])
            except:
                pass
            return s,p
            
    # takes serial and hubport as integers and returns the composed serial string
    def serialPort2serialString(self,serial,port):
        if serial is None and port is None:
            return None
        elif port is None:
            return str(serial)
        else:
            return str(serial) + ":" + str(port)
    
    def phidgetOUTattached(self,ch):
        aw.qmc.phidgetManager.reserveSerialPort(
            ch.getDeviceSerialNumber(), # serial
            ch.getHubPort(), # port
            ch.getChannel(), # channel
            ch.getChannelClassName(), # phidget_class_name
            ch.getDeviceID(), # device_id
            remote=aw.qmc.phidgetRemoteFlag,
            remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
    
    def phidgetOUTdetached(self,ch):
        aw.qmc.phidgetManager.releaseSerialPort(
            ch.getDeviceSerialNumber(), # serial
            ch.getHubPort(), # port
            ch.getChannel(), # channel
            ch.getChannelClassName(), # phidget_class_name
            ch.getDeviceID(), # device_id
            remote=aw.qmc.phidgetRemoteFlag,
            remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)

#--- Phidget IO Binay Output
#  only supporting (trying to attach in this order)
#      4 channel Phidget 1014, OUT1100, REL1000, REL1100, REL1101
#      8 channel Phidget 1017
#      8 channel Phidget 1010, 1013, 1018, 1019 modules
#  commands: set(n,0), set(n,1), toggle(n) with n channel number

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetBinaryOUTattach(self,channel,serial=None):
        if not serial in aw.ser.PhidgetBinaryOut:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                ser = None
                s,p = self.serialString2serialPort(serial)
                for phidget_id in [DeviceID.PHIDID_1014,DeviceID.PHIDID_OUT1100,DeviceID.PHIDID_REL1000,DeviceID.PHIDID_REL1100]:
                    if ser is None:
                        ser,_ = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',phidget_id,channel,
                                remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                ports = 4
                if ser is None:
                    ser,_ = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',DeviceID.PHIDID_1017,
                                remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 8
                # try to attach up to 8 IO channels of the first Phidget 1010, 1013, 1018, 1019 module
                if ser is None:
                    ser,_ = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',DeviceID.PHIDID_1010_1013_1018_1019,
                                remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 8
                # try to attach up to 16 IO channels of the first Phidget REL1101 module
                if ser is None:
                    ser,_ = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',DeviceID.PHIDID_REL1100,
                                remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 16
                if ser is not None:
                    aw.ser.PhidgetBinaryOut[serial] = []
                    for i in range(ports):
                        do = DigitalOutput()
                        do.setChannel(i)
                        do.setDeviceSerialNumber(ser)
                        if aw.qmc.phidgetRemoteFlag:
                            do.setIsRemote(True)
                            do.setIsLocal(False)
                        elif not aw.qmc.phidgetRemoteFlag:
                            do.setIsRemote(False)
                            do.setIsLocal(True)
                        aw.ser.PhidgetBinaryOut[serial].append(do)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetBinaryOut[str(ser)] = aw.ser.PhidgetBinaryOut[None]
        try:
            ch = aw.ser.PhidgetBinaryOut[serial][channel]
            ch.setOnAttachHandler(self.phidgetOUTattached)
            ch.setOnDetachHandler(self.phidgetOUTdetached)
            if not ch.getAttached():
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1000)
                if serial is None and ch.getAttached():
                    # we make this also accessible via its serial number + port
                    s = self.serialPort2serialString(ch.getDeviceSerialNumber(),ch.getHubPort()) # NOTE: ch.getHubPort() returns -1 if not yet attached
                    aw.ser.PhidgetBinaryOut[s] = aw.ser.PhidgetBinaryOut[None]
        except:
            pass

    def phidgetBinaryOUTpulse(self,channel,millis,serial=None):
        self.phidgetBinaryOUTset(channel,1,serial)
#        QTimer.singleShot(millis,lambda : self.phidgetBinaryOUTset(channel,0))
        # QTimer (which does not work being called from a QThread) call replaced by the next 2 lines (event actions are now started in an extra thread)
        # the following solution has the drawback to block the eventaction thread
#        libtime.sleep(millis/1000.)
#        self.phidgetBinaryOUTset(channel,0)
        # so we use a QTimer.singleShot running in the main thread
        if serial is None:
            aw.singleShotPhidgetsPulseOFF.emit(channel,millis,"BinaryOUTset")
        else:
            aw.singleShotPhidgetsPulseOFFSerial.emit(channel,millis,"BinaryOUTset",serial)

    # value: True or False
    def phidgetBinaryOUTset(self,channel,value,serial=None):
        res = False
        self.phidgetBinaryOUTattach(channel,serial)
        if serial in aw.ser.PhidgetBinaryOut:
            # set state of the given channel
            out = aw.ser.PhidgetBinaryOut[serial]
            try:
                if len(out) > channel and out[channel] and out[channel].getAttached():
                    out[channel].setState(value)
                    res = True
            except:
                res = False
        return res

    # returns: True or False (default)
    def phidgetBinaryOUTget(self,channel,serial=None):
        self.phidgetBinaryOUTattach(channel,serial)
        res = False
        if serial in aw.ser.PhidgetBinaryOut:
            # get state of the given channel
            out = aw.ser.PhidgetBinaryOut[serial]
            try:
                if len(out) > channel and out[channel] and out[channel].getAttached():
                    res = out[channel].getState()
            except:
                pass
        return res
    
    def phidgetBinaryOUTtoggle(self,channel,serial=None):
        self.phidgetBinaryOUTset(channel,not self.phidgetBinaryOUTget(channel,serial),serial)
        
    def phidgetBinaryOUTclose(self):
        for o in aw.ser.PhidgetBinaryOut:
            out = aw.ser.PhidgetBinaryOut[o]
            if out is not None:
                for i in range(len(out)):
                    try:
                        if out[i].getAttached():
                            self.phidgetOUTdetached(out[i])
                        out[i].close()
                    except Exception:
                        pass
        aw.ser.PhidgetBinaryOut = {}
    
    
#--- Phidget Digital PWM Output
#  only supporting 
#           4 channel Phidget OUT1100, REL1100
#          16 channel Phidget REL1101
#  commands: out(n,v) and toggle(n) with n channel number and value v from [0-100]
#    toggle switches between last value != 0 and 0

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetOUTattach(self,channel,serial=None):
        if not serial in aw.ser.PhidgetDigitalOut:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                # try to attach the 4 channels of the Phidget OUT1100 module
                ser = None
                s,p = self.serialString2serialPort(serial)
                port = None
                for phidget_id in [DeviceID.PHIDID_OUT1100,DeviceID.PHIDID_REL1100]:
                    if ser is None:
                        ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',phidget_id,channel,
                                remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    else:
                        break
                ports = 4
                if ser is None:
                    ports = 16
                    for phidget_id in [DeviceID.PHIDID_REL1101]:
                        if ser is None:
                            ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',phidget_id,channel,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                        else:
                            break
                if ser is not None:
                    aw.ser.PhidgetDigitalOut[serial] = []
                    aw.ser.PhidgetDigitalOutLastPWM[serial] = [0]*ports # 0-100
                    aw.ser.PhidgetDigitalOutLastToggle[serial] = [None]*ports
                    for i in range(ports):
                        do = DigitalOutput()
                        if port is not None:
                            do.setHubPort(port)
                        do.setChannel(i)
                        do.setDeviceSerialNumber(ser)
                        if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                            do.setIsRemote(True)
                            do.setIsLocal(False)
                        elif not aw.qmc.phidgetRemoteFlag:
                            do.setIsRemote(False)
                            do.setIsLocal(True)
                        aw.ser.PhidgetDigitalOut[serial].append(do)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetDigitalOut[str(ser)] = aw.ser.PhidgetDigitalOut[None]
        try:
            ch = aw.ser.PhidgetDigitalOut[serial][channel]
            if not ch.getAttached():
                ch.setOnAttachHandler(self.phidgetOUTattached)
                ch.setOnDetachHandler(self.phidgetOUTdetached)
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1200)
                if serial is None and ch.getAttached():
                    # we make this also accessible via its serial number + port
                    s = self.serialPort2serialString(ch.getDeviceSerialNumber(),ch.getHubPort())
                    aw.ser.PhidgetDigitalOut[s] = aw.ser.PhidgetDigitalOut[None]
        except:
            pass

    def phidgetOUTtogglePWM(self,channel,serial=None):
        self.phidgetOUTattach(channel,serial) # this is to ensure that the lastToggle/lastPWM structures are allocated
        if serial in aw.ser.PhidgetDigitalOut:
            lastPWM = aw.ser.PhidgetDigitalOutLastPWM[serial][channel]
            lastToggle = aw.ser.PhidgetDigitalOutLastToggle[serial][channel]
            if lastPWM == 0:
                # we switch on
                if lastToggle is None:
                    self.phidgetOUTsetPWM(channel,100,serial)
                else:
                    # we have a lastPWM from before toggling off
                    self.phidgetOUTsetPWM(channel,lastToggle,serial)
            else:
                # we switch off
                self.phidgetOUTsetPWM(channel,0,serial)
                aw.ser.PhidgetDigitalOutLastToggle[serial][channel] = lastPWM # remember lastPWM to be able to switch on again
                if serial is None:
                    # also establish for the entry with serial number
                    s = aw.ser.PhidgetDigitalOut[serial][channel].getDeviceSerialNumber()
                    ser = self.serialPort2serialString(s,aw.ser.PhidgetDigitalOut[serial][channel].getHubPort())
                    aw.ser.PhidgetDigitalOutLastToggle[ser][channel] = lastPWM # remember lastPWM to be able to switch on again
                    aw.ser.PhidgetDigitalOutLastToggle[str(s)][channel] = lastPWM # remember lastPWM to be able to switch on again
    
    def phidgetOUTpulsePWM(self,channel,millis,serial=None):
        self.phidgetOUTsetPWM(channel,100,serial)
#        QTimer.singleShot(millis,lambda : self.phidgetOUTsetPWM(channel,0))
#        # QTimer (which does not work being called from a QThread) call replaced by the next 2 lines (event actions are now started in an extra thread)
        # the following solution has the drawback to block the eventaction thread
#        libtime.sleep(millis/1000.)
#        self.phidgetOUTsetPWM(channel,0)
        if serial is None:
            aw.singleShotPhidgetsPulseOFF.emit(channel,millis,"OUTsetPWM")
        else:
            aw.singleShotPhidgetsPulseOFFSerial.emit(channel,millis,"OUTsetPWM",serial)

    # value: 0-100
    def phidgetOUTsetPWM(self,channel,value,serial=None):
        self.phidgetOUTattach(channel,serial)
        if serial in aw.ser.PhidgetDigitalOut:
            out = aw.ser.PhidgetDigitalOut[serial]
            # set PWM of the given channel
            try:
                if len(out) > channel and out[channel].getAttached():
                    out[channel].setDutyCycle(value/100.)
                    aw.ser.PhidgetDigitalOutLastPWM[serial][channel] = value
                    aw.ser.PhidgetDigitalOutLastToggle[serial][channel] = None # clears the lastToggle value
                    if serial is None:
                        # also establish for the entry with serial number
                        s = out[channel].getDeviceSerialNumber()
                        sr = self.serialPort2serialString(s,out[channel].getHubPort())
                        aw.ser.PhidgetDigitalOutLastPWM[sr][channel] = value
                        aw.ser.PhidgetDigitalOutLastToggle[sr][channel] = None # clears the lastToggle value
                        aw.ser.PhidgetDigitalOutLastPWM[str(s)][channel] = value
                        aw.ser.PhidgetDigitalOutLastToggle[str(s)][channel] = None # clears the lastToggle value
            except Exception:
                pass
    
    def phidgetOUTclose(self):
        for m in aw.ser.PhidgetDigitalOut:
            out = aw.ser.PhidgetDigitalOut[m]
            if out is not None:
                for i in range(len(out)):
                    try:
                        if out[i].getAttached():
                            self.phidgetOUTdetached(out[i])
                        out[i].close()
                    except Exception:
                        pass
        aw.ser.PhidgetDigitalOut = {}
        aw.ser.PhidgetDigitalOutLastPWM = {}
        aw.ser.PhidgetDigitalOutLastToggle = {}


#--- Phidget Digital PWMhub Output
#  only supporting 6 channel Phidget HUB module

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetOUTattachHub(self,channel,serial=None):
        if not serial in aw.ser.PhidgetDigitalOutHub:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                # try to attach the 6 channels of the Phidget HUB module
                s,p = self.serialString2serialPort(serial)
                ser,_ = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDigitalOutput',DeviceID.PHIDID_DIGITALOUTPUT_PORT,channel,
                            remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                if ser is not None:
                    aw.ser.PhidgetDigitalOutHub[serial] = [DigitalOutput(),DigitalOutput(),DigitalOutput(),DigitalOutput(),DigitalOutput(),DigitalOutput()]
                    aw.ser.PhidgetDigitalOutLastPWMhub[serial] = [0]*6 # 0-100
                    aw.ser.PhidgetDigitalOutLastToggleHub[serial] = [None]*6
                    for i in range(6):
                        aw.ser.PhidgetDigitalOutHub[serial][i].setChannel(0)
                        aw.ser.PhidgetDigitalOutHub[serial][i].setHubPort(i)
                        aw.ser.PhidgetDigitalOutHub[serial][i].setDeviceSerialNumber(ser)
                        aw.ser.PhidgetDigitalOutHub[serial][i].setIsHubPortDevice(True)
                        if aw.qmc.phidgetRemoteFlag and aw.qmc.phidgetRemoteOnlyFlag:
                            aw.ser.PhidgetDigitalOutHub[serial][i].setIsRemote(True)
                            aw.ser.PhidgetDigitalOutHub[serial][i].setIsLocal(False)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetDigitalOutHub[str(ser)] = aw.ser.PhidgetDigitalOutHub[None]
                        aw.ser.PhidgetDigitalOutLastPWMhub[str(ser)] = aw.ser.PhidgetDigitalOutLastPWMhub[None]
                        aw.ser.PhidgetDigitalOutLastToggleHub[str(ser)] = aw.ser.PhidgetDigitalOutLastToggleHub[None]
        try:
            ch = aw.ser.PhidgetDigitalOutHub[serial][channel]
            ch.setOnAttachHandler(self.phidgetOUTattached)
            ch.setOnDetachHandler(self.phidgetOUTdetached)
            if not ch.getAttached():
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1000)
        except:
            pass
    
    def phidgetOUTtogglePWMhub(self,channel,serial=None):
        self.phidgetOUTattachHub(channel,serial) # this is to ensure that the lastToggle/lastPWM structures are allocated
        if serial in aw.ser.PhidgetDigitalOutHub:
            lastToggle = aw.ser.PhidgetDigitalOutLastToggleHub[serial][channel]
            lastPWM = aw.ser.PhidgetDigitalOutLastPWMhub[serial][channel]
            if lastPWM == 0:
                # we switch on
                if lastToggle is None:
                    self.phidgetOUTsetPWMhub(channel,100,serial)
                else:
                    # we have a lastPWM from before toggling off
                    self.phidgetOUTsetPWMhub(channel,lastToggle,serial)
            else:
                # we switch off
                self.phidgetOUTsetPWMhub(channel,0,serial)
                aw.ser.PhidgetDigitalOutLastToggleHub[serial][channel] = lastPWM # remember lastPWM to be able to switch on again
                if serial is None:
                    # also establish for the entry with serial number
                    ser = aw.ser.PhidgetDigitalOutHub[serial][channel].getDeviceSerialNumber()
                    aw.ser.PhidgetDigitalOutLastToggleHub[str(ser)][channel] = lastPWM # remember lastPWM to be able to switch on again
    

    def phidgetOUTpulsePWMhub(self,channel,millis,serial=None):
        self.phidgetOUTsetPWMhub(channel,100,serial)
#        QTimer.singleShot(millis,lambda : self.phidgetOUTsetPWMhub(channel,0))
        # QTimer (which does not work being called from a QThread) call replaced by the next 2 lines (event actions are now started in an extra thread)
        # the following solution has the drawback to block the eventaction thread
#        libtime.sleep(millis/1000.)
#        self.phidgetOUTsetPWMhub(channel,0)
        if serial is None:
            aw.singleShotPhidgetsPulseOFF.emit(channel,millis,"OUTsetPWMhub")
        else:
            aw.singleShotPhidgetsPulseOFFSerial.emit(channel,millis,"OUTsetPWMhub",serial)
    
    # channel: 0-5
    # value: 0-100
    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetOUTsetPWMhub(self,channel,value,serial=None):
        self.phidgetOUTattachHub(channel,serial)
        if serial in aw.ser.PhidgetDigitalOutHub:
            outHub = aw.ser.PhidgetDigitalOutHub[serial]
            # set PWM of the given channel
            try:
                if len(outHub) > channel and outHub[channel] and outHub[channel].getAttached():
                    outHub[channel].setDutyCycle(value/100.)
                    aw.ser.PhidgetDigitalOutLastPWMhub[serial][channel] = value
                    aw.ser.PhidgetDigitalOutLastToggleHub[serial][channel] = None # clears the lastToggle value
                    if serial is None:
                        # also establish for the entry with serial number
                        sr = outHub[channel].getDeviceSerialNumber()
                        aw.ser.PhidgetDigitalOutLastPWMhub[str(sr)][channel] = value
                        aw.ser.PhidgetDigitalOutLastToggleHub[str(sr)][channel] = None # clears the lastToggle value
            except:
                pass
    
    def phidgetOUTcloseHub(self):
        for h in aw.ser.PhidgetDigitalOutHub:
            outHub = aw.ser.PhidgetDigitalOutHub[h]
            if outHub is not None:
                for i in range(len(outHub)):
                    try:
                        if outHub[i].getAttached():
                            self.phidgetOUTdetached(outHub[i])
                        outHub[i].close()
                    except:
                        pass
        aw.ser.PhidgetDigitalOutHub = {}
        aw.ser.PhidgetDigitalOutLastPWMhub = {}
        aw.ser.PhidgetDigitalOutLastToggleHub = {}


#--- Phidget Analog Voltage Output
#  only supporting 
#     1 channel Phidget OUT1000, OUT1001 and OUT1002
#     4 channel USB Phidget 1002
#  commands: out(n,v[,serial]) with n channel number and value v voltage in V as a float, and serial the optional serial/port number of the addressed module

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetVOUTattach(self,channel,serial):
        if not serial in aw.ser.PhidgetAnalogOut:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                # try to attach the Phidget OUT100x module
                s,p = self.serialString2serialPort(serial)
                ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageOutput',DeviceID.PHIDID_OUT1000,
                            remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                ports = 1
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageOutput',DeviceID.PHIDID_OUT1001,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 1
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageOutput',DeviceID.PHIDID_OUT1002,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 1
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetVoltageOutput',DeviceID.PHIDID_1002,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 4
                if ser is not None:
                    aw.ser.PhidgetAnalogOut[serial] = []
                    for i in range(ports):
                        vo = VoltageOutput()
                        if port is not None:
                            vo.setHubPort(port)
                        vo.setDeviceSerialNumber(ser)
                        vo.setChannel(i)
                        if aw.qmc.phidgetRemoteOnlyFlag and aw.qmc.phidgetRemoteFlag:
                            vo.setIsRemote(True)
                            vo.setIsLocal(False)
                        elif not aw.qmc.phidgetRemoteFlag:
                            vo.setIsRemote(False)
                            vo.setIsLocal(True)
                        aw.ser.PhidgetAnalogOut[serial].append(vo)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetAnalogOut[str(ser)] = aw.ser.PhidgetAnalogOut[None]
        try:
            ch = aw.ser.PhidgetAnalogOut[serial][channel]
            ch.setOnAttachHandler(self.phidgetOUTattached)
            ch.setOnDetachHandler(self.phidgetOUTdetached)
            if not ch.getAttached():
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1200)
                if serial is None and ch.getAttached():
                    # we make this also accessible via its serial number + port
                    s = self.serialPort2serialString(ch.getDeviceSerialNumber(),ch.getHubPort())
                    aw.ser.PhidgetAnalogOut[s] = aw.ser.PhidgetAnalogOut[None]
        except:
            pass

    # value: float
    # returns True or False indicating set status
    def phidgetVOUTsetVOUT(self,channel,value,serial=None):
        res = False
        self.phidgetVOUTattach(channel,serial)
        if serial in aw.ser.PhidgetAnalogOut:
            out = aw.ser.PhidgetAnalogOut[serial]
            # set voltage output
            try:
                if len(out) > channel and out[channel].getAttached():
                    if value == 0:
                        out[channel].setVoltage(0)
                        out[channel].setEnabled(False)
                    else:
                        out[channel].setVoltage(value)
                        out[channel].setEnabled(True)
                    res = True
            except Exception:
                res = False
        return res

    def phidgetVOUTclose(self):
        for c in aw.ser.PhidgetAnalogOut:
            out = aw.ser.PhidgetAnalogOut[c]
            for i in range(len(out)):
                try:
                    if out[i].getAttached():
                        out[i].setEnabled(False)
                        self.phidgetOUTdetached(out[i])
                    out[i].close()
                except Exception:
                    pass
        aw.ser.PhidgetAnalogOut = {}


#--- Phidget DCMotor
#  only supporting
#     1 channel VINT DCC1000 and DCC1002
#     2 channel VINT DCC1003
#  commands: 
#     accel(c,v[,sn]) with c channel number and v acceleration as a float, and sn serial the optional serial/port number of the addressed module
#     vel(c,v[,sn])   with c channel number and v target velocity as a float, and sn serial the optional serial/port number of the addressed module

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetDCMotorAttach(self,channel,serial):
        if not serial in aw.ser.PhidgetDCMotor:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                # try to attach the DCMotor modules
                s,p = self.serialString2serialPort(serial)
                ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDCMotor',DeviceID.PHIDID_DCC1000,
                            remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                ports = 1
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDCMotor',DeviceID.PHIDID_DCC1002,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 1
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetDCMotor',DeviceID.PHIDID_DCC1003,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 2
                if ser is not None:
                    aw.ser.PhidgetDCMotor[serial] = []
                    for i in range(ports):
                        dcm = DCMotor()
                        if port is not None:
                            dcm.setHubPort(port)
                        dcm.setDeviceSerialNumber(ser)
                        dcm.setChannel(i)
                        if aw.qmc.phidgetRemoteOnlyFlag and aw.qmc.phidgetRemoteFlag:
                            dcm.setIsRemote(True)
                            dcm.setIsLocal(False)
                        elif not aw.qmc.phidgetRemoteFlag:
                            dcm.setIsRemote(False)
                            dcm.setIsLocal(True)
                        aw.ser.PhidgetDCMotor[serial].append(dcm)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetDCMotor[str(ser)] = aw.ser.PhidgetDCMotor[None]
        try:
            ch = aw.ser.PhidgetDCMotor[serial][channel]
            ch.setOnAttachHandler(self.phidgetOUTattached)
            ch.setOnDetachHandler(self.phidgetOUTdetached)
            if not ch.getAttached():
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1200)
                if serial is None and ch.getAttached():
                    # we make this also accessible via its serial number + port
                    s = self.serialPort2serialString(ch.getDeviceSerialNumber(),ch.getHubPort())
                    aw.ser.PhidgetDCMotor[s] = aw.ser.PhidgetDCMotor[None]
        except:
            pass

    # value: float
    def phidgetDCMotorSetAcceleration(self,channel,value,serial=None):
        self.phidgetDCMotorAttach(channel,serial)
        if serial in aw.ser.PhidgetDCMotor:
            dcm = aw.ser.PhidgetDCMotor[serial]
            # set velocity
            try:
                if len(dcm) > channel and dcm[channel].getAttached():
                    dcm[channel].setAcceleration(value)
            except Exception:
                pass

    # value: float
    def phidgetDCMotorSetVelocity(self,channel,value,serial=None):
        self.phidgetDCMotorAttach(channel,serial)
        if serial in aw.ser.PhidgetDCMotor:
            dcm = aw.ser.PhidgetDCMotor[serial]
            aw.sendmessage("dcm found")
            # set velocity
            try:
                if len(dcm) > channel and dcm[channel].getAttached():
                    dcm[channel].setTargetVelocity(value)
            except:
                pass
    
    def phidgetDCMotorClose(self):
        for c in aw.ser.PhidgetDCMotor:
            dcm = aw.ser.PhidgetDCMotor[c]
            for i in range(len(dcm)):
                try:
                    if dcm[i].getAttached():
                        self.phidgetOUTdetached(dcm[i])
                    dcm[i].close()
                except Exception:
                    pass
        aw.ser.PhidgetDCMotor = {}




#--- Yoctopuce Voltage Output
#  only supporting 
#     2 channel Yocto-0-10V-Tx
#  commands: vout(c,v[,sn]) with c the channel (1 or 2), v voltage in V as a float [0.0-10.0], and sn the modules serial number or its logical name

    # module_id is a string that is either None, a module serial number or a module logical name
    # it is assumed that the modules two channels do not have custom function names different from
    # voltageOutput1 and voltageOutput2
    def yoctoVOUTattach(self,c,module_id):
        # check if VoltageOutput object for channel c and module_id is already attached
        voltageOutputs = aw.ser.YOCTOvoltageOutputs
        m = next((x for x in voltageOutputs if 
                x.get_functionId() == "voltageOutput"+str(c) and 
                (module_id is None or module_id == x.get_serialNumber() or module_id == x.get_logicalName())),
                None)
        if m is not None:
            return m
        # the module/channel is not yet attached search for it
        self.YOCTOimportLIB() # first import the lib
        from yoctopuce.yocto_voltageoutput import YVoltageOutput
        if module_id is None:
            vout = YVoltageOutput.FirstVoltageOutput()
            if vout is None:
                return None
            m = vout.get_module()
            target = m.get_serialNumber()
        else:
            target = module_id
        YOCTOvoltageOutput = YVoltageOutput.FindVoltageOutput(target + '.voltageOutput' + str(c))
        if YOCTOvoltageOutput.isOnline():
            aw.ser.YOCTOvoltageOutputs.append(YOCTOvoltageOutput)
            return YOCTOvoltageOutput
        else:
            return None
    
    def yoctoVOUTsetVOUT(self,c,v,module_id=None):
        try:
            m = self.yoctoVOUTattach(c,module_id)
            if m is not None and m.isOnline():
                m.set_currentVoltage(v) # with v a voltage in V [0.0-10.0]
        except:
            pass
    
    def yoctoVOUTclose(self):
        aw.ser.YOCTOvoltageOutputs = []
        try:
            YAPI.FreeAPI() 
        except:
            pass


#--- Yoctopuce Current Output
#  only supporting 
#     1 channel Yocto-4-20mA-Tx
#  commands: cout(c[,sn]) with c current in mA as a float [3.0-21.0], and sn the modules serial number or its logical name

    # module_id is a string that is either None, a module serial number or a module logical name
    # it is assumed that the modules two channels do not have custom function names different from
    # voltageOutput1 and voltageOutput2
    def yoctoCOUTattach(self,module_id):
        # check if YOCTOcurrentOutput object for module_id is already attached
        currentOutputs = aw.ser.YOCTOcurrentOutputs
        m = next((x for x in currentOutputs if 
                x.get_functionId() == "currentLoopOutput" and 
                (module_id is None or module_id == x.get_serialNumber() or module_id == x.get_logicalName())),
                None)
        if m is not None:
            return m
        # the module/channel is not yet attached search for it
        self.YOCTOimportLIB() # first import the lib
        from yoctopuce.yocto_currentloopoutput import YCurrentLoopOutput
        if module_id is None:
            cout = YCurrentLoopOutput.FirstCurrentLoopOutput()
            if cout is None:
                return None
            m = cout.get_module()
            target = m.get_serialNumber()
        else:
            target = module_id
        YOCTOcurrentOutput = YCurrentLoopOutput.FindCurrentLoopOutput(target + '.currentLoopOutput')
        if YOCTOcurrentOutput.isOnline():
            aw.ser.YOCTOcurrentOutputs.append(YOCTOcurrentOutput)
            return YOCTOcurrentOutput
        else:
            return None

    def yoctoCOUTsetCOUT(self,c,module_id=None):
        try:
            m = self.yoctoCOUTattach(module_id)
            if m is not None and m.isOnline():
                m.set_current(c) # with c a current in mA [3.0-21.0]
        except:
            pass

    def yoctoCOUTclose(self):
        aw.ser.YOCTOcurrentOutputs = []
        try:
            YAPI.FreeAPI() 
        except:
            pass


#--- Yoctopuce PWM Output
#  only supporting 
#     2 channel Yocto-PWM-Tx
#  commands:
#     enabled(c,b[,sn])
#     freq(c,f[,sn])
#     duty(c,d[,sn])
#     move(c,d,t[,sn]) 
#    with 
#     c the channel (1 or 2)
#     b a bool given as 0, 1, False or True
#     f the frequency in Hz as an integer [0-1000000]
#     d the duty cycle in % as a float [0.0-100.0]
#     t the time as an integer in milliseconds
#     sn the modules serial number or its logical name

    # module_id is a string that is either None, a module serial number or a module logical name
    # it is assumed that the modules two channels do not have custom function names different from
    # pwmOutput1 and pwmOutput2
    def yoctoPWMattach(self,c,module_id):
        # check if YPwmOutput object for channel c and module_id is already attached
        pwmOutputs = aw.ser.YOCTOpwmOutputs
        m = next((x for x in pwmOutputs if 
                x.get_functionId() == "pwmOutput"+str(c) and 
                (module_id is None or module_id == x.get_serialNumber() or module_id == x.get_logicalName())),
                None)
        if m is not None:
            return m
        # the module/channel is not yet attached search for it
        self.YOCTOimportLIB() # first import the lib
        from yoctopuce.yocto_pwmoutput import YPwmOutput
        if module_id is None:
            vout = YPwmOutput.FirstPwmOutput()
            if vout is None:
                return None
            m = vout.get_module()
            target = m.get_serialNumber()
        else:
            target = module_id
        YOCTOpwmOutput = YPwmOutput.FindPwmOutput(target + '.pwmOutput' + str(c))
        if YOCTOpwmOutput.isOnline():
            aw.ser.YOCTOpwmOutputs.append(YOCTOpwmOutput)
            return YOCTOpwmOutput
        else:
            return None
    
    def yoctoPWMenabled(self,c,b,module_id=None):
        try:
            m = self.yoctoPWMattach(c,module_id)
            if m is not None and m.isOnline():
                from yoctopuce.yocto_pwmoutput import YPwmOutput
                if b:
                    m.set_enabled(YPwmOutput.ENABLED_TRUE)
                else:
                    m.set_enabled(YPwmOutput.ENABLED_FALSE)
        except:
            pass
    
    def yoctoPWMsetFrequency(self,c,f,module_id=None):
        try:
            m = self.yoctoPWMattach(c,module_id)
            if m is not None and m.isOnline():
                m.set_frequency(f) # with f the frequency in Hz as an integer [0-1000000]
        except:
            pass
    
    def yoctoPWMsetDuty(self,c,d,module_id=None):
        try:
            m = self.yoctoPWMattach(c,module_id)
            if m is not None and m.isOnline():
                m.set_dutyCycle(d) # d the duty cycle in % as a float [0.0-100.0]
        except:
            pass
    
    def yoctoPWMmove(self,c,d,t,module_id=None):
        try:
            m = self.yoctoPWMattach(c,module_id)
            if m is not None and m.isOnline():
                m.dutyCycleMove(d,t) # d the duty cycle in % as a float [0.0-100.0] and t the time as an integer in milliseconds
        except:
            pass
    
    def yoctoPWMclose(self):
        aw.ser.YOCTOpwmOutputs = []
        try:
            YAPI.FreeAPI() 
        except:
            pass


#--- Yoctopuce Relay Output
#  supporting
#     2 channel Yocto-Relay
#     1 channel Yocto-LatchedRelay
#     8 channel Yocto-MaxiCoupler-V2
#     1 channel Yocto-PowerRelay-V2
#     1 channel Yocto-PowerRelay-V3
#     5 channel Yocto-MaxiPowerRelay
#  commands: 
#      on(c[,sn])
#      off(c[,sn])
#      flip(c[,sn])
#      pulse(c,delay,duration[,sn])
#    with c the channel, delay and duration in milliseconds, sn the option module serial number or its logical name as string

    # module_id is a string that is either None, a module serial number or a module logical name
    # it is assumed that the modules two channels do not have custom function names different from
    # relay1, relay2,...
    def yoctoRELattach(self,c,module_id):
        # check if Relay object for channel c and module_id is already attached
        relays = aw.ser.YOCTOrelays
        m = next((x for x in relays if 
                x.get_functionId() == "relay"+str(c) and 
                (module_id is None or module_id == x.get_serialNumber() or module_id == x.get_logicalName())),
                None)
        if m is not None:
            return m
        # the module/channel is not yet attached search for it
        self.YOCTOimportLIB() # first import the lib
        from yoctopuce.yocto_relay import YRelay
        if module_id is None:
            rel = YRelay.FirstRelay()
            if rel is None:
                return None
            m = rel.get_module()
            target = m.get_serialNumber()
        else:
            target = module_id
        YOCTOrelay = YRelay.FindRelay(target + '.relay' + str(c))
        module = YOCTOrelay.get_module()
        module.isOnline()
        if YOCTOrelay.isOnline():
            aw.ser.YOCTOrelays.append(YOCTOrelay)
            return YOCTOrelay
        else:
            return None

    def yoctoRELon(self,c,module_id=None):
        try:
            m = self.yoctoRELattach(c,module_id)
            if m is not None and m.isOnline():
                from yoctopuce.yocto_relay import YRelay
                m.set_state(YRelay.STATE_B)
                #m.set_output(YRelay.OUTPUT_ON)
        except:
            pass
    
    def yoctoRELoff(self,c,module_id=None):
        try:
            m = self.yoctoRELattach(c,module_id)
            if m is not None and m.isOnline():
                from yoctopuce.yocto_relay import YRelay
                m.set_state(YRelay.STATE_A)
                #m.set_output(YRelay.OUTPUT_OFF)
        except:
            pass
    
    def yoctoRELflip(self,c,module_id=None):
        try:
            m = self.yoctoRELattach(c,module_id)
            if m is not None and m.isOnline():
                m.toggle()
        except:
            pass
    
    def yoctoRELpulse(self,c,delay,duration,module_id=None):
        try:
            m = self.yoctoRELattach(c,module_id)
            if m is not None and m.isOnline():
                m.delayedPulse(delay,duration)
        except:
            pass

    def yoctoRELclose(self):
        aw.ser.YOCTOrelays = []
        try:
            YAPI.FreeAPI() 
        except:
            pass


#--- Yoctopuce Servo Output
#  supporting
#     5 channel Yocto-Servo
#  commands: 
#      enabled(c,b[,sn])
#      move(c,p[,t][,sn])
#      neutral(c,n[,sn])
#      range(c,r[,sn])
#    with c the channel, delay and duration in milliseconds, sn the option module serial number or its logical name as string

    # module_id is a string that is either None, a module serial number or a module logical name
    # it is assumed that the modules two channels do not have custom function names different from
    # relay1, relay2,...
    def yoctoSERVOattach(self,c,module_id):
        # check if Servo object for channel c and module_id is already attached
        servos = aw.ser.YOCTOservos
        m = next((x for x in servos if 
                x.get_functionId() == "servo"+str(c) and 
                (module_id is None or module_id == x.get_serialNumber() or module_id == x.get_logicalName())),
                None)
        if m is not None:
            return m
        # the module/channel is not yet attached search for it
        self.YOCTOimportLIB() # first import the lib
        from yoctopuce.yocto_servo import YServo
        if module_id is None:
            srv = YServo.FirstServo()
            if srv is None:
                return None
            m = srv.get_module()
            target = m.get_serialNumber()
        else:
            target = module_id
        YOCTOservo = YServo.FindServo(target + '.servo' + str(c))
        module = YOCTOservo.get_module()
        module.isOnline()
        if YOCTOservo.isOnline():
            aw.ser.YOCTOservos.append(YOCTOservo)
            return YOCTOservo
        else:
            return None

    def yoctoSERVOenabled(self,c,b,module_id=None):
        try:
            m = self.yoctoSERVOattach(c,module_id)
            if m is not None and m.isOnline():
                m.enabled(b)
        except:
            pass

    def yoctoSERVOposition(self,c,p,module_id=None):
        try:
            m = self.yoctoSERVOattach(c,module_id)
            if m is not None and m.isOnline():
                m.set_position(p)
        except:
            pass

    def yoctoSERVOmove(self,c,p,t,module_id=None):
        try:
            m = self.yoctoSERVOattach(c,module_id)
            if m is not None and m.isOnline():
                m.move(p,t)
        except:
            pass

    def yoctoSERVOneutral(self,c,n,module_id=None):
        try:
            m = self.yoctoSERVOattach(c,module_id)
            if m is not None and m.isOnline():
                m.neutral(n)
        except:
            pass

    def yoctoSERVOrange(self,c,r,module_id=None):
        try:
            m = self.yoctoSERVOattach(c,module_id)
            if m is not None and m.isOnline():
                m.range(r)
        except:
            pass

    def yoctoSERVOclose(self):
        aw.ser.YOCTOservos = []
        try:
            YAPI.FreeAPI() 
        except:
            pass


#--- Phidget RC (only one supported for now)
#  supporting up to 16 channels like those of the RCC1000
#  commands: 
#     pulse(ch,min,max[,sn]) # sets min/max pulse width
#     pos(ch,min,max[,sn])   # sets min/max position
#     engaged(ch,state[,sn]) # engage channel
#     set(ch,pos[,sn])       # sets position
#     ramp(ch,b[,sn])        # activates or deactivates the speed ramping state
#     volt(ch,v[,sn])        # set the voltage to one of 5, 6 or 7.4 in Volt
#     accel(ch,accel[,sn])   # set the acceleration 
#     veloc(ch,v[,sn])       # set the velocity

    # serial: optional Phidget HUB serial number with optional port number as string of the form "<serial>[:<port>]"
    def phidgetRCattach(self,channel,serial=None):
        if not serial in aw.ser.PhidgetRCServo:
            if aw.qmc.phidgetManager is None:
                aw.qmc.startPhidgetManager()
            if aw.qmc.phidgetManager is not None:
                # try to attach an Phidget RCC1000 module
                s,p = self.serialString2serialPort(serial)
                ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetRCServo',DeviceID.PHIDID_RCC1000,
                            remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                ports = 16
                # try to attach an Phidget RC 1061 module
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetRCServo',DeviceID.PHIDID_1061,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 8
                # try to attach an Phidget RC 1066 module
                if ser is None:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget('PhidgetRCServo',DeviceID.PHIDID_1066,
                                    remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag,serial=s,hubport=p)
                    ports = 1
                if ser is not None:
                    aw.ser.PhidgetRCServo[serial] = []
                    for i in range(ports):
                        rcservo = RCServo()
                        if port is not None:
                            rcservo.setHubPort(port)
                        rcservo.setDeviceSerialNumber(ser)
                        rcservo.setChannel(i)
                        if aw.qmc.phidgetRemoteOnlyFlag and aw.qmc.phidgetRemoteFlag:
                            rcservo.setIsRemote(True)
                            rcservo.setIsLocal(False)
                        aw.ser.PhidgetRCServo[serial].append(rcservo)
                    if serial is None:
                        # we make this also accessible via its serial number
                        aw.ser.PhidgetRCServo[str(ser)] = aw.ser.PhidgetRCServo[None]
        try:
            ch = aw.ser.PhidgetRCServo[serial][channel]
            ch.setOnAttachHandler(self.phidgetOUTattached)
            ch.setOnDetachHandler(self.phidgetOUTdetached)
            if not ch.getAttached():
                if aw.qmc.phidgetRemoteFlag:
                    ch.openWaitForAttachment(3000)
                else:
                    ch.openWaitForAttachment(1500)
                if serial is None and ch.getAttached():
                    # we make this also accessible via its serial number + port
                    s = self.serialPort2serialString(ch.getDeviceSerialNumber(),ch.getHubPort())
                    aw.ser.PhidgetRCServo[s] = aw.ser.PhidgetRCServo[None]
        except:
            pass

    # sets min/max pulse width
    def phidgetRCpulse(self,channel,min_pulse,max_pulse,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setMinPulseWidth(min_pulse)
            aw.ser.PhidgetRCServo[serial][channel].setMaxPulseWidth(max_pulse)

    # sets min/max position
    def phidgetRCpos(self,channel,min_pos,max_pos,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setMinPosition(min_pos)
            aw.ser.PhidgetRCServo[serial][channel].setMaxPosition(max_pos)

    # engage channel
    def phidgetRCengaged(self,channel,state,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setEngaged(state)

    # sets position
    def phidgetRCset(self,channel,position,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setTargetPosition(position)

    # set speed rampling state per channel
    def phidgetRCspeedRamping(self,channel,state,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setSpeedRampingState(state)

    # set voltage per channel
    def phidgetRCvoltage(self,channel,volt,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            from Phidget22.RCServoVoltage import RCServoVoltage
            if volt>6:
                # set to 7.4V
                v = RCServoVoltage.RCSERVO_VOLTAGE_7_4V
            elif volt < 6:
                # set to 5V
                v = RCServoVoltage.RCSERVO_VOLTAGE_5V
            else:
                # set to 6V
                v = RCServoVoltage.RCSERVO_VOLTAGE_6V
            aw.ser.PhidgetRCServo[serial][channel].setVoltage(v)
            
    # sets acceleration
    def phidgetRCaccel(self,channel,accel,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setAcceleration(accel)
            
    # sets velocity
    def phidgetRCveloc(self,channel,veloc,serial=None):
        self.phidgetRCattach(channel,serial)
        if serial in aw.ser.PhidgetRCServo and len(aw.ser.PhidgetRCServo[serial])>channel:
            aw.ser.PhidgetRCServo[serial][channel].setVelocityLimit(veloc)

    def phidgetRCclose(self):
        for c in aw.ser.PhidgetRCServo:
            rc = aw.ser.PhidgetRCServo[c]
            for i in range(len(rc)):
                try:
                    if rc[i].getAttached():
                        rc[i].setEngaged(False)
                        self.phidgetOUTdetached(rc[i])
                    rc[i].close()
                except Exception:
                    pass
            aw.ser.PhidgetRCServo = {}
        
#---

    def phidget1018SensorChanged(self,v,channel,idx,API):
        if self.PhidgetIO and len(self.PhidgetIO) > idx:
            if API == "current" or (API == "voltage" and not aw.qmc.phidget1018_ratio[channel]):
                v = v * aw.qmc.phidget1018valueFactor
            try:
                #### lock shared resources #####
                self.PhidgetIOsemaphores[channel].acquire(1)
                self.PhidgetIOvalues[channel].append(v)
            finally:
                if self.PhidgetIOsemaphores[channel].available() < 1:
                    self.PhidgetIOsemaphores[channel].release(1)

    def phidget1018getSensorReading(self,i,idx,deviceType,API="voltage"):
        if self.PhidgetIO and len(self.PhidgetIO) > idx: 
            if API != "digital" and aw.qmc.phidget1018_async[i]:
                res = None
                try:
                    #### lock shared resources #####
                    self.PhidgetIOsemaphores[i].acquire(1)
                    if len(self.PhidgetIOvalues[i]) > 0:
                        res = numpy.average(self.PhidgetIOvalues[i])
                        self.PhidgetIOvalues[i] = self.PhidgetIOvalues[i][-round((aw.qmc.delay/aw.qmc.phidget1018_dataRates[i])):] 
                except Exception:
                    self.PhidgetIOvalues[i] = []
                finally:
                    if self.PhidgetIOsemaphores[i].available() < 1:
                        self.PhidgetIOsemaphores[i].release(1)
                if res is None:
                    if self.PhidgetIOlastvalues[i] == -1: # there is no last value yet, we take a sync value
                        if API == "current":
                            res = self.PhidgetIO[idx].getCurrent() * aw.qmc.phidget1018valueFactor
                        elif API == "frequency":
                            res = self.PhidgetIO[idx].getFrequency()
                        else:
                            if aw.qmc.phidget1018_ratio[i] and deviceType != DeviceID.PHIDID_DAQ1400:
                                res = self.PhidgetIO[idx].getVoltageRatio()
                            else:
                                res = self.PhidgetIO[idx].getVoltage() * aw.qmc.phidget1018valueFactor
                        self.PhidgetIOlastvalues[i] = res
                        return res
                    else:
                        return self.PhidgetIOlastvalues[i] # return the previous result
                else:
                    self.PhidgetIOlastvalues[i] = res
                    return res
            else:
                if API == "digital":
                    v = self.PhidgetIOvalues[i] = int(self.PhidgetIO[idx].getState())
                elif API == "current":
                    v = self.PhidgetIO[idx].getCurrent() * aw.qmc.phidget1018valueFactor
                elif API == "frequency":
                    v = self.PhidgetIO[idx].getFrequency()
                else:
                    if aw.qmc.phidget1018_ratio[i] and deviceType != DeviceID.PHIDID_DAQ1400:
                        v = self.PhidgetIO[idx].getVoltageRatio()
                    else:
                        v = self.PhidgetIO[idx].getVoltage() * aw.qmc.phidget1018valueFactor
                return v
        else:
            return -1

    def configure1018(self,deviceType,idx,API="voltage"):
        # set data rates of all active inputs to 4ms
        if self.PhidgetIO and len(self.PhidgetIO) > idx:
            # reset async values
            if deviceType in [DeviceID.PHIDID_HUB0000]:
                # on VINT HUBs we use the
                channel = self.PhidgetIO[idx].getHubPort()
            else:
                channel = self.PhidgetIO[idx].getChannel()
            # set rate
            try:
                self.PhidgetIO[idx].setDataInterval(aw.qmc.phidget1018_dataRates[channel])
            except Exception:
                pass
            # set the PowerSupply for the DAQ1400
            if deviceType == DeviceID.PHIDID_DAQ1400:
                try:
                    from Phidget22.PowerSupply import PowerSupply
                    power_idx = aw.qmc.phidgetDAQ1400_powerSupply
                    if power_idx == 0:
                        power = PowerSupply.POWER_SUPPLY_OFF
                    elif power_idx == 1:
                        power = PowerSupply.POWER_SUPPLY_12V
                    else: # power_idx == 2:
                        power = PowerSupply.POWER_SUPPLY_24V
                    self.PhidgetIO[idx].setPowerSupply(power)
                except:
                    pass
            if API == "voltage":
                if aw.qmc.phidget1018_async[channel]:
                    try:
                        if aw.qmc.phidget1018_ratio[channel] and deviceType != DeviceID.PHIDID_DAQ1400:
                            ct = max(min(float(aw.qmc.phidget1018_changeTriggers[channel]/100.0),self.PhidgetIO[idx].getMaxVoltageRatioChangeTrigger()),self.PhidgetIO[idx].getMinVoltageRatioChangeTrigger())
                            self.PhidgetIO[idx].setVoltageRatioChangeTrigger(ct)
                        else:
                            ct = max(min(float(aw.qmc.phidget1018_changeTriggers[channel]/100.0),self.PhidgetIO[idx].getMaxVoltageChangeTrigger()),self.PhidgetIO[idx].getMinVoltageChangeTrigger())
                            self.PhidgetIO[idx].setVoltageChangeTrigger(ct)
                    except:
                        pass
                    if aw.qmc.phidget1018_ratio[channel] and deviceType != DeviceID.PHIDID_DAQ1400:                    
                        self.PhidgetIO[idx].setOnVoltageRatioChangeHandler(lambda _,t: self.phidget1018SensorChanged(t,channel,idx,API))
                    else:
                        self.PhidgetIO[idx].setOnVoltageChangeHandler(lambda _,t: self.phidget1018SensorChanged(t,channel,idx,API))
                else:
                    if aw.qmc.phidget1018_ratio[channel] and deviceType != DeviceID.PHIDID_DAQ1400:
                        self.PhidgetIO[idx].setVoltageRatioChangeTrigger(0.0)
                    else:
                        self.PhidgetIO[idx].setVoltageChangeTrigger(0.0)
                    if aw.qmc.phidget1018_ratio[channel] and deviceType != DeviceID.PHIDID_DAQ1400:
                        self.PhidgetIO[idx].setOnVoltageRatioChangeHandler(lambda *_:None) 
                    else:
                        self.PhidgetIO[idx].setOnVoltageChangeHandler(lambda *_:None) 
            elif API == "current":
                if aw.qmc.phidget1018_async[channel]:
                    ct = max(min(float(aw.qmc.phidget1018_changeTriggers[channel]/100.0),self.PhidgetIO[idx].getMaxCurrentChangeTrigger()),self.PhidgetIO[idx].getMinCurrentChangeTrigger())
                    self.PhidgetIO[idx].setCurrentChangeTrigger(ct)
                    self.PhidgetIO[idx].setOnCurrentChangeHandler(lambda _,t: self.phidget1018SensorChanged(t,channel,idx,API))
                else:
                    self.PhidgetIO[idx].setCurrentChangeTrigger(0.0)
                    self.PhidgetIO[idx].setOnCurrentChangeHandler(lambda *_:None)
            elif API == "frequency":
                if deviceType == DeviceID.PHIDID_DAQ1400:
                    # set the InputMode for the DAQ1400
                    self.setDAQ1400inputMode(idx)
                if aw.qmc.phidget1018_async[channel]:
                    self.PhidgetIO[idx].setOnFrequencyChangeHandler(lambda _,t: self.phidget1018SensorChanged(t,channel,idx,API))
                else:
                    self.PhidgetIO[idx].setOnFrequencyChangeHandler(lambda *_:None)
            elif API == "digital":
                if deviceType == DeviceID.PHIDID_DAQ1400:
                    # set the InputMode for the DAQ1400
                    self.setDAQ1400inputMode(idx)
            self.PhidgetIOvalues[channel] = [[],[],[],[],[],[],[],[]]
            self.PhidgetIOlastvalues = [-1]*8

    def setDAQ1400inputMode(self,idx):
        try:
            from Phidget22.InputMode import InputMode
            mode_idx = aw.qmc.phidgetDAQ1400_inputMode
            if mode_idx == 0:
                mode = InputMode.INPUT_MODE_NPN
            elif mode_idx == 1:
                mode = InputMode.INPUT_MODE_PNP
            self.PhidgetIO[idx].setInputMode(mode)
        except:
            pass

    def phidget1018attached(self,serial,port,className,deviceType,idx,API="voltage"):
        try:
            self.configure1018(deviceType,idx,API)
            if self.PhidgetIO is not None:
                channel = self.PhidgetIO[idx].getChannel()
                aw.qmc.phidgetManager.reserveSerialPort(serial,port,channel,className,deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    if deviceType == DeviceID.PHIDID_1011:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 2/2/2 attached",None))
                    elif deviceType == DeviceID.PHIDID_HUB0000:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 6/6/6 attached",None))
                    elif deviceType == DeviceID.PHIDID_1010_1013_1018_1019:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 8/8/8 attached",None))
                    elif deviceType == DeviceID.PHIDID_DAQ1400:
                        aw.sendmessage(QApplication.translate("Message","Phidget DAQ1400 attached",None))
                    else:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO attached",None))
        except:
            pass

    def phidget1018detached(self,serial,port,className,deviceType,idx):
        try:
            if self.PhidgetIO is not None:
                channel = self.PhidgetIO[idx].getChannel()
                aw.qmc.phidgetManager.releaseSerialPort(serial,port,channel,className,deviceType,remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if channel == 0:
                    if deviceType == DeviceID.PHIDID_1011:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 2/2/2 detached",None))
                    elif deviceType == DeviceID.PHIDID_HUB0000:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 6/6/6 detached",None))
                    elif deviceType == DeviceID.PHIDID_1010_1013_1018_1019:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO 8/8/8 detached",None))
                    elif deviceType == DeviceID.PHIDID_DAQ1400:
                        aw.sendmessage(QApplication.translate("Message","Phidget DAQ1400 detached",None))
                    else:
                        aw.sendmessage(QApplication.translate("Message","Phidget IO detached",None))
        except:
            pass

    # mode = 0 for probe 1 and 2; mode = 1 for probe 3 and 4; mode 2 for probe 5 and 6; mode 3 for probe 7 and 8
    # access of the VoltageInput, DigitalInput or VoltageRatioInput for the following IO Phidgets
    #  - Phidget IO 8/8/8 (1010,1013,1018,1019,SBC): DeviceID.PHIDID_1010_1013_1018_1019
    #  - Phidget IO 6/6/6 (HUB0000): DeviceID.PHIDID_HUB0000
    #  - Phidget IO 2/2/2 (1011): DeviceID.PHIDID_1011
    # the API parameter is one of "voltage", "digital", "current", "frequency"
    # if single is set, only the first channel of the two is allocated
    def PHIDGET1018values(self,deviceType=DeviceID.PHIDID_1010_1013_1018_1019,mode=0, API="voltage", retry=True, single=False):
        try:
            if self.PhidgetIO is None and aw.qmc.phidgetManager is not None:
                ser = None
                port = None 
                if API == "digital":
                    tp = "PhidgetDigitalInput"
                elif API == "current":
                    tp = "PhidgetCurrentInput"
                elif API == "frequency":
                    tp = "PhidgetFrequencyCounter"
                else:
                    if aw.qmc.phidget1018_ratio[mode*2] and deviceType != DeviceID.PHIDID_DAQ1400:
                        tp = "PhidgetVoltageRatioInput"
                    else:
                        tp = "PhidgetVoltageInput"
                if mode == 0:
                    # we scan for available main device
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget(tp,deviceType,0,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                elif mode == 1:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget(tp,deviceType,2,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                elif mode == 2:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget(tp,deviceType,4,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                elif mode == 3:
                    ser,port = aw.qmc.phidgetManager.getFirstMatchingPhidget(tp,deviceType,6,
                        remote=aw.qmc.phidgetRemoteFlag,remoteOnly=aw.qmc.phidgetRemoteOnlyFlag)
                if ser:
                    if API == "digital":
                        self.PhidgetIO = [DigitalInput(),DigitalInput()]
                    elif API == "current":
                        self.PhidgetIO = [CurrentInput(),CurrentInput()]
                    elif API == "frequency":
                        self.PhidgetIO = [FrequencyCounter(),FrequencyCounter()]
                    else: # voltage
                        if aw.qmc.phidget1018_ratio[mode*2] and deviceType != DeviceID.PHIDID_DAQ1400:
                            ch1 = VoltageRatioInput()
                        else:
                            ch1 = VoltageInput()
                        if aw.qmc.phidget1018_ratio[mode*2+1] and deviceType != DeviceID.PHIDID_DAQ1400:
                            ch2 = VoltageRatioInput()
                        else:
                            ch2 = VoltageInput()
                        self.PhidgetIO = [ch1,ch2]
                    try: 
                        self.PhidgetIO[0].setOnAttachHandler(lambda _:self.phidget1018attached(ser,port,tp,deviceType,0,API))
                        self.PhidgetIO[0].setOnDetachHandler(lambda _:self.phidget1018detached(ser,port,tp,deviceType,0))
                        if deviceType != DeviceID.PHIDID_DAQ1400 and not single:
                            self.PhidgetIO[1].setOnAttachHandler(lambda _:self.phidget1018attached(ser,port,tp,deviceType,1,API))
                            self.PhidgetIO[1].setOnDetachHandler(lambda _:self.phidget1018detached(ser,port,tp,deviceType,1))
                        if deviceType in [DeviceID.PHIDID_HUB0000]:
                            # we are looking to attach a HUB port
                            self.PhidgetIO[0].setIsHubPortDevice(1)
                            self.PhidgetIO[1].setIsHubPortDevice(1)
                            # on VINT HUB devices we have to set the port
                            self.PhidgetIO[0].setHubPort(mode*2)
                            self.PhidgetIO[1].setHubPort(mode*2+1)
                        else:
                            self.PhidgetIO[0].setChannel(mode*2)
                            self.PhidgetIO[1].setChannel(mode*2+1)
                            if port is not None:
                                self.PhidgetIO[0].setHubPort(port)
                                self.PhidgetIO[1].setHubPort(port)
                        if aw.qmc.phidgetRemoteFlag:
                            self.addPhidgetServer()
                        self.PhidgetIO[0].setDeviceSerialNumber(ser)
                        try:
                            self.PhidgetIO[0].open() #.openWaitForAttachment(timeout)
                        except:
                            pass
                        self.PhidgetIO[1].setDeviceSerialNumber(ser)
                        if deviceType != DeviceID.PHIDID_DAQ1400 and not single:
                            try:
                                self.PhidgetIO[1].open() #.openWaitForAttachment(timeout)
                            except:
                                pass
                        # we need to give this device a bit time to attach, otherwise it will be considered for another Artisan channel of the same type
                        if aw.qmc.phidgetRemoteOnlyFlag:
                            libtime.sleep(.8)
                        else:
                            libtime.sleep(.5)
                    except Exception as ex:
                        #_, _, exc_tb = sys.exc_info()
                        #aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1018values() {0}").format(str(ex)),exc_tb.tb_lineno)
                        try:
                            if self.PhidgetIO and self.PhidgetIO[0].getAttached():
                                self.PhidgetIO[0].close()
                            if self.PhidgetIO and len(self.PhidgetIO)> 1 and self.PhidgetIO[1].getAttached():
                                self.PhidgetIO[1].close()
                        except Exception:
                            pass
                        self.PhidgetIO = None
                        self.PhidgetIOvalues = [[],[],[],[],[],[],[],[]]
                        self.PhidgetIOlastvalues = [-1]*8
            if deviceType == DeviceID.PHIDID_DAQ1400 and self.PhidgetIO is not None and self.PhidgetIO and self.PhidgetIO[0].getAttached():
                probe = -1
                try:
                    probe = self.phidget1018getSensorReading(0,0,deviceType,API)
                except Exception:
                    pass
                return probe, -1
            elif deviceType != DeviceID.PHIDID_DAQ1400 and self.PhidgetIO is not None and self.PhidgetIO and len(self.PhidgetIO)>1 and self.PhidgetIO[0].getAttached() and (single or self.PhidgetIO[1].getAttached()):
                probe1 = probe2 = -1
                try:
                    probe1 = self.phidget1018getSensorReading(mode*2,0,deviceType,API)
                except:
                    pass
                if not single:
                    try:
                        probe2 = self.phidget1018getSensorReading(mode*2 + 1,1,deviceType,API)
                    except Exception:
                        pass
                return probe1, probe2
            elif retry:
                libtime.sleep(0.1)
                self.PHIDGET1018values(deviceType,mode,API,False)
            else:
                return -1,-1
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                if self.PhidgetIO and self.PhidgetIO[0].getAttached():
                    self.PhidgetIO[0].close()
                if not single and self.PhidgetIO and len(self.PhidgetIO)> 1 and self.PhidgetIO[1].getAttached():
                    self.PhidgetIO[1].close()                            
            except Exception:
                pass
            self.PhidgetIO = None
            self.PhidgetIOlastvalues = [[],[],[],[],[],[],[],[]] 
            self.PhidgetIOlastvalues = [-1]*8
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PHIDGET1018values() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

#---

    # given the YOCTOsensor, return the first of the given mode
    #   mode=0 => Yocto-Thermocouple
    #   mode=1 => Yocto-Pt100
    #   mode=2 => Yocto-IR
    #   mode=3 => Yocto-Meteo
    #   mode=4 => Yocto-4-20mA-Rx
    # that is not in the list of already connected ones
    def getNextYOCTOsensorOfType(self,mode,connected_yoctos,YOCTOsensor):
        if mode == 4:
            from yoctopuce.yocto_genericsensor import YGenericSensor
        else:
            from yoctopuce.yocto_temperature import YTemperature
        if YOCTOsensor:
            productName = YOCTOsensor.get_module().get_productName()
            if not (YOCTOsensor.get_module().get_serialNumber() in connected_yoctos) and  \
                ((mode == 0 and productName == "Yocto-Thermocouple") or (mode == 1 and productName == "Yocto-PT100") or \
                 (mode == 2 and productName == "Yocto-Temperature-IR") or \
                 (mode == 3 and productName.startswith("Yocto-Meteo")) or \
                 (mode == 4 and productName.startswith("Yocto-4-20mA-Rx"))):
                return YOCTOsensor
            else:
                if mode == 4:
                    return self.getNextYOCTOsensorOfType(mode,connected_yoctos,YGenericSensor.nextGenericSensor(YOCTOsensor))
                else:
                    return self.getNextYOCTOsensorOfType(mode,connected_yoctos,YTemperature.nextTemperature(YOCTOsensor))
        else:
            return None
            
    def YOCTOimportLIB(self):
        errmsg=YRefParam()
        if not self.YOCTOlibImported:
            # import Yoctopuce Python library (installed form PyPI)
            #aw.sendmessage(str(errmsg))
            YAPI.DisableExceptions
            ## WINDOWS/Linux DLL HACK BEGIN
            arch = platform.architecture()[0]
            machine = platform.machine()
            libpath = os.path.dirname(sys.executable)
            if platf == 'Windows' and appFrozen():
                if arch == '32bit':
                    YAPI._yApiCLibFile = libpath + "\\lib\\yapi.dll"
                else:
                    YAPI._yApiCLibFile = libpath + "\\lib\\yapi64.dll"
                YAPI._yApiCLibFileFallback = libpath + "\\lib\\yapi.dll"
            elif platf == "Linux" and appFrozen():
                if machine.find("arm") >= 0: # Raspberry
                    YAPI._yApiCLibFile = libpath + "/libyapi-armhf.so"
                    YAPI._yApiCLibFileFallback = libpath + "/libyapi-armel.so"
                elif machine.find("mips") >= 0:
                    YAPI._yApiCLibFile = libpath + "/libyapi-mips.so"
                    YAPI._yApiCLibFileFallback = ""
                elif machine == 'x86_32' or (machine[0] == 'i' and machine[-2:] == '86'):
                    YAPI._yApiCLibFile = libpath + "/libyapi-i386.so"
                    YAPI._yApiCLibFileFallback = libpath + "/libyapi-amd64.so"  # just in case
                elif machine == 'x86_64':
                    YAPI._yApiCLibFile = libpath + "/libyapi-amd64.so"
                    YAPI._yApiCLibFileFallback = libpath + "/libyapi-i386.so"  # just in case
            ## WINDOWS/Linux DLL HACK END
        try:
            if aw.qmc.yoctoRemoteFlag:
                YAPI.RegisterHub(aw.qmc.yoctoServerID,errmsg)
            else:
                YAPI.RegisterHub("usb", errmsg)
            self.YOCTOlibImported = True
        except Exception as e:
            aw.sendmessage(str(e))

    def yoctoTimedCallback(self,_, measure,channel):
        try:
            #### lock shared resources #####
            self.YOCTOsemaphores[channel].acquire(1)
            self.YOCTOvalues[channel].append(measure.get_averageValue())
        finally:
            if self.YOCTOsemaphores[channel].available() < 1:
                self.YOCTOsemaphores[channel].release(1)
    
    # mode = 0 for 2x thermocouple model; mode = 1 for 1x PT100 type probe; mode = 2 for IR sensor; mode = 4 for the Yocto-4-20mA-Rx
    def YOCTOtemperatures(self,mode=0):
        try: 
            if not self.YOCTOsensor:
                self.YOCTOimportLIB()
                try:
                    if mode == 4:
                        from yoctopuce.yocto_genericsensor import YGenericSensor
                    else:
                        from yoctopuce.yocto_temperature import YTemperature
                    YAPI.DisableExceptions
                    # already connected YOCTOsensors?
                    if not aw.ser.YOCTOsensor:
                        connected_yoctos = []
                    else:
                        connected_yoctos = [aw.ser.YOCTOsensor.get_module().get_serialNumber()]
                    for s in aw.extraser:
                        if s.YOCTOsensor is not None:
                            connected_yoctos.append(s.YOCTOsensor.get_module().get_serialNumber())
                    
                    # search for the next one of the required type, but not yet connected
                    if mode == 4:
                        self.YOCTOsensor = self.getNextYOCTOsensorOfType(mode,connected_yoctos,YGenericSensor.FirstGenericSensor())
                    else:
                        self.YOCTOsensor = self.getNextYOCTOsensorOfType(mode,connected_yoctos,YTemperature.FirstTemperature())
                    
                    yocto_res = 0.0001 # while 0.001 seems to be the maximum accepted, but just returning mostly 2 decimals!?
                    if mode in [0,2] and self.YOCTOsensor is not None and self.YOCTOsensor.isOnline():
                        serial=self.YOCTOsensor.get_module().get_serialNumber()
                        self.YOCTOchan1 = YTemperature.FindTemperature(serial + '.temperature1')
                        self.YOCTOchan2 = YTemperature.FindTemperature(serial + '.temperature2')
                        if mode == 0:
                            aw.sendmessage(QApplication.translate("Message","Yocto Thermocouple attached",None))
                        elif mode == 2:
                            aw.sendmessage(QApplication.translate("Message","Yocto IR attached",None))
                        # increase the resolution
                        try:
                            self.YOCTOchan1.set_resolution(yocto_res)
                            self.YOCTOchan2.set_resolution(yocto_res)
                        except:
                            pass
                        # get units
                        try:
                            unit1 = self.YOCTOchan1.get_unit()
                            if unit1 is not None and len(unit1) > 0 and unit1[-1] != "C":
                                aw.qmc.YOCTOchan1Unit = "F"
                            else:
                                aw.qmc.YOCTOchan1Unit = "C"
                            unit2 = self.YOCTOchan2.get_unit()
                            if unit2 is not None and len(unit2) > 0 and unit2[-1] != "C":
                                aw.qmc.YOCTOchan2Unit = "F"
                            else:
                                aw.qmc.YOCTOchan2Unit = "C"
                        except:
                            pass
                        if aw.qmc.YOCTO_dataRate > 1000:
                            reportFrequency = "60/m" # in this mode the average of a measurements over the last second is returned
                        else:
                            reportFrequency = "{}/s".format(int(round(1000/aw.qmc.YOCTO_dataRate)))   # 30/s => 30ms
                            # if reportFrequency is set to "1/s", every second the last measurement sampled by the device is returned
                            # note that this is different from "60/m" which returns an average over many values

                        if aw.qmc.YOCTO_async[0]:
                            self.YOCTOchan1.set_reportFrequency(reportFrequency)
                            self.YOCTOchan1.registerTimedReportCallback(lambda fct,measure: self.yoctoTimedCallback(fct,measure,0))
                        else:
                            self.YOCTOchan1.registerTimedReportCallback(lambda *_:None)
                        if aw.qmc.YOCTO_async[0]: # flag for channel 1 is ignored and only that of channel 0 is respected for both channels
                            self.YOCTOchan2.set_reportFrequency(reportFrequency)
                            self.YOCTOchan2.registerTimedReportCallback(lambda fct,measure: self.yoctoTimedCallback(fct,measure,1))
                        else:
                            self.YOCTOchan2.registerTimedReportCallback(lambda *_:None)
                        if aw.qmc.YOCTO_async[0]:# or aw.qmc.YOCTO_async[1]: # flag for channel 1 is ignored and only that of channel 0 is respected for both channels
                            if self.YOCTOthread is None:
                                self.YOCTOthread = YoctoThread()
                            self.YOCTOthread.start()
                    elif mode == 1 and self.YOCTOsensor is not None and self.YOCTOsensor.isOnline():
                        aw.sendmessage(QApplication.translate("Message","Yocto PT100 attached",None))  
                        # increase the resolution
                        try:
                            self.YOCTOsensor.set_resolution(yocto_res)
                            self.YOCTOsensor.set_resolution(yocto_res)
                        except:
                            pass  
                        # get units
                        try:
                            unit = self.YOCTOchan.get_unit()
                            if unit is not None and len(unit) > 0 and unit[-1] != "C":
                                aw.qmc.YOCTOchanUnit = "F"
                            else:
                                aw.qmc.YOCTOchanUnit = "C"
                        except:
                            pass
                        if aw.qmc.YOCTO_async[0]:
                            if aw.qmc.YOCTO_dataRate > 1000:
                                reportFrequency = "60/m" # in this mode the average of a measurements over the last second is returned
                            else:
                                reportFrequency = "{}/s".format(int(round(1000/aw.qmc.YOCTO_dataRate)))   # 30/s => 30ms
                                # if reportFrequency is set to "1/s", every second the last measurement sampled by the device is returned
                                # note that this is different from "60/m" which returns an average over many values
                            self.YOCTOsensor.set_reportFrequency(reportFrequency)
                            self.YOCTOsensor.registerTimedReportCallback(lambda fct,measure: self.yoctoTimedCallback(fct,measure,0))
                            if self.YOCTOthread is None:
                                self.YOCTOthread = YoctoThread()
                            self.YOCTOthread.start()
                    elif mode == 4 and self.YOCTOsensor is not None and self.YOCTOsensor.isOnline():
                        serial=self.YOCTOsensor.get_module().get_serialNumber()
                        self.YOCTOchan1 = YGenericSensor.FindGenericSensor(serial + '.genericSensor1')
                        self.YOCTOchan2 = YGenericSensor.FindGenericSensor(serial + '.genericSensor2')
                        aw.sendmessage(QApplication.translate("Message","Yocto 4-20mA-Rx attached",None))
                except:
                    if self.YOCTOthread is not None:
                        self.YOCTOthread.join()
                        self.YOCTOthread = None
            probe1 = -1
            probe2 = -1
            if mode in [0,2]:
                try:
                    if aw.qmc.YOCTO_async[0]:
                        try:
                            #### lock shared resources #####
                            self.YOCTOsemaphores[0].acquire(1)
                            if len(self.YOCTOvalues[0]) > 0:
                                probe1 = numpy.average(self.YOCTOvalues[0])
                                self.YOCTOvalues[0] = self.YOCTOvalues[0][-max(1,round((aw.qmc.delay/aw.qmc.YOCTO_dataRate))):]
                        except:
                            self.YOCTOvalues[0] = []
                        finally:
                            if self.YOCTOsemaphores[0].available() < 1:
                                self.YOCTOsemaphores[0].release(1)
                        if probe1 == -1:
                            probe1 = self.YOCTOlastvalues[0]
                        else:
                            self.YOCTOlastvalues[0] = probe1
                    if probe1 == -1 and self.YOCTOchan1 and self.YOCTOchan1.isOnline():
                        probe1 = self.YOCTOchan1.get_currentValue()
                    if probe1 != -1:
                        if mode == 2:
                            # we average this module temperature channel for the IR module to remove noise
                            if self.YOCTOtempIRavg is None:
                                self.YOCTOtempIRavg = probe1
                            else:
                                self.YOCTOtempIRavg = (20* self.YOCTOtempIRavg + probe1) / 21.0
                                probe1 = self.YOCTOtempIRavg
                        # convert temperature scale
                        if aw.qmc.YOCTOchan1Unit == "C" and aw.qmc.mode == "F":
                            probe1 = aw.qmc.fromCtoF(probe1)
                        elif aw.qmc.YOCTOchan1Unit == "F" and aw.qmc.mode == "C":
                            probe1 = aw.qmc.fromFtoC(probe1)
                except:
                    pass
                try:
                    if aw.qmc.YOCTO_async[0]: # flag for channel 1 is ignored and only that of channel 0 is respected for both channels
                        try:
                            #### lock shared resources #####
                            self.YOCTOsemaphores[1].acquire(1)
                            if len(self.YOCTOvalues[1]) > 0:
                                probe2 = numpy.average(self.YOCTOvalues[1])
                                self.YOCTOvalues[1] = self.YOCTOvalues[1][-round((aw.qmc.delay/aw.qmc.YOCTO_dataRate)):]
                        except:
                            self.YOCTOvalues[1] = []
                        finally:
                            if self.YOCTOsemaphores[1].available() < 1:
                                self.YOCTOsemaphores[1].release(1)
                        if probe2 == -1:
                            probe2 = self.YOCTOlastvalues[1]
                        else:
                            self.YOCTOlastvalues[1] = probe2
                    if probe2 == -1 and self.YOCTOchan2 and self.YOCTOchan2.isOnline():
                        probe2 = self.YOCTOchan2.get_currentValue()
                    if probe2 != -1:
                        # convert temperature scale
                        if aw.qmc.YOCTOchan2Unit == "C" and aw.qmc.mode == "F":
                            probe2 = aw.qmc.fromCtoF(probe2)
                        elif aw.qmc.YOCTOchan2Unit == "F" and aw.qmc.mode == "C":
                            probe2 = aw.qmc.fromFtoC(probe2)
                except Exception:
                    pass
            elif mode == 1:
                try:
                    if aw.qmc.YOCTO_async[0]:
                        try:
                            #### lock shared resources #####
                            self.YOCTOsemaphores[0].acquire(1)
                            if len(self.YOCTOvalues[0]) > 0:
                                probe1 = numpy.average(self.YOCTOvalues[0])
                                self.YOCTOvalues[0] = self.YOCTOvalues[0][-round((aw.qmc.delay/aw.qmc.YOCTO_dataRate)):]
                        except:
                            self.YOCTOvalues[0] = []
                        finally:
                            if self.YOCTOsemaphores[0].available() < 1:
                                self.YOCTOsemaphores[0].release(1)
                        if probe1 == -1:
                            probe1 = self.YOCTOlastvalues[0]
                        else:
                            self.YOCTOlastvalues[0] = probe1
                    if probe1 == -1 and self.YOCTOsensor and self.YOCTOsensor.isOnline():
                        probe1 = self.YOCTOsensor.get_currentValue()
                    if probe1 != -1:
                        # convert temperature scale
                        if aw.qmc.YOCTOchanUnit == "C" and aw.qmc.mode == "F":
                            probe1 = aw.qmc.fromCtoF(probe1)
                        elif aw.qmc.YOCTOchanUnit == "F" and aw.qmc.mode == "C":
                            probe1 = aw.qmc.fromFtoC(probe1)
                except Exception:
                    pass
            elif mode == 4:
                try:
                    if self.YOCTOchan1 and self.YOCTOchan1.isOnline():
                        probe1 = self.YOCTOchan1.get_currentValue()
                except:
                    pass
                try:
                    if self.YOCTOchan2 and self.YOCTOchan2.isOnline():
                        probe2 = self.YOCTOchan2.get_currentValue()
                except:
                    pass
            # apply the emissivity to the IR value
            if mode == 2 and probe1 != -1 and probe2 != -1:
                probe2 = self.IRtemp(aw.qmc.YOCTO_emissivity,probe2,probe1)
            return probe1, probe2
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            try:
                if self.YOCTOthread is not None:
                    self.YOCTOthread.join()
                    self.YOCTOthread = None
                self.YOCTOsensor = None
                self.YOCTOchan1 = None
                self.YOCTOchan2 = None
                self.YOCOTtempIRavg = None
                self.YOCTOvalues = [[],[]]
                self.YOCTOlastvalues = [-1]*2
                YAPI.FreeAPI()
            except Exception:
                pass
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " YOCTOtemperatures() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1

    def ARDUINOTC4temperature(self):
        try:
            #### lock shared resources #####
            self.COMsemaphore.acquire(1)
            command = ""
            res = ""
            result = ""
            t1,t2 = 0.,0.
            if not self.SP.isOpen():
                self.openport()
                #libtime.sleep(1)
                #Reinitialize Arduino in case communication was interupted
                self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                #INITIALIZE (ONLY ONCE)
                if not self.ArduinoIsInitialized:
#                    self.SP.reset_input_buffer()
#                    self.SP.reset_output_buffer()
                    #build initialization command
                    et_channel = self.arduinoETChannel
                    if et_channel == "None":
                        et_channel = "0"
                    bt_channel = self.arduinoBTChannel
                    if bt_channel == "None":
                        bt_channel = "0"
                    #If extra device +ArduinoTC4_XX present. read all 4 Ts
                    if 28 in aw.qmc.extradevices: # +ArduinoTC4_34
                        vals = ["1","2","3","4"]
                        try:
                            if self.arduinoETChannel and self.arduinoETChannel != "None" and self.arduinoETChannel in vals:
                                vals.pop(vals.index(self.arduinoETChannel))
                            if self.arduinoBTChannel and self.arduinoBTChannel != "None" and self.arduinoBTChannel in vals:
                                vals.pop(vals.index(self.arduinoBTChannel))
                        except:
                            pass
                        command = "CHAN;" + et_channel + bt_channel + vals[0] + vals[1]
                    else:
                    #no extra device +ArduinoTC4_XX present. reads ambient T, ET, BT
                        command = "CHAN;" + et_channel + bt_channel + "00"
                    #libtime.sleep(0.3)
                    self.SP.write(str2cmd(command + "\n"))       #send command
                    #self.SP.flush()
                    #libtime.sleep(.1)
                    result = self.SP.readline().decode('utf-8')[:-2]  #read
                    if (not len(result) == 0 and not result.startswith("#")):
                        raise Exception(QApplication.translate("Error Message","Arduino could not set channels",None))
                    elif result.startswith("#"):
                        #OK. NOW SET UNITS
#                        self.SP.reset_input_buffer()
#                        self.SP.reset_output_buffer()
                        command = "UNITS;" + aw.qmc.mode + "\n"   #Set units
                        self.SP.write(str2cmd(command))
                        result = self.SP.readline().decode('utf-8')[:-2]
                        if (not len(result) == 0 and not result.startswith("#")):
                            raise Exception(QApplication.translate("Error Message","Arduino could not set temperature unit",None))
                        else:
                            #OK. NOW SET FILTER
#                            self.SP.reset_input_buffer()
#                            self.SP.reset_output_buffer()
                            filt =  ",".join(map(str,aw.ser.ArduinoFILT))
                            command = "FILT;" + filt + "\n"   #Set filters
                            self.SP.write(str2cmd(command))
                            result = self.SP.readline().decode('utf-8')[:-2]
                            if (not len(result) == 0 and not result.startswith("#")):
                                raise Exception(QApplication.translate("Error Message","Arduino could not set filters",None))
                            else:
                                ### EVERYTHING OK  ###
                                self.ArduinoIsInitialized = 1
                        aw.sendmessage(QApplication.translate("Message","TC4 initialized",None))
                #READ TEMPERATURE
                command = "READ\n"  #Read command.
                self.SP.reset_input_buffer()
                self.SP.reset_output_buffer()
                self.SP.write(str2cmd(command))
                rl = self.SP.readline().decode('utf-8', 'ignore')[:-2]
                res = rl.rsplit(',')
                #response: list ["t0","t1","t2"]  with t0 = internal temp; t1 = ET; t2 = BT on "CHAN;1200" 
                #response: list ["t0","t1","t2","t3","t4"]  with t0 = internal temp; t1 = ET; t2 = BT, t3 = chan3, t4 = chan4 on "CHAN;1234" if ArduinoTC4_34 is configured
                # after PID_ON: + [,"Heater", "Fan", "SV"]
                if self.arduinoETChannel == "None":
                    t1 = -1
                else:
                    try:
                        t1 = float(res[1])
                    except Exception:
                        t1 = -1
                if self.arduinoBTChannel == "None":
                    t2 = -1
                else:
                    try:
                        t2 = float(res[2])
                    except Exception:
                        t2 = -1
                #if extra device +ArduinoTC4_34
                if 28 in aw.qmc.extradevices:
                    #set the other values to extra temp variables
                    try:
                        aw.qmc.extraArduinoT1 = float(res[3])
                        aw.qmc.extraArduinoT2 = float(res[4])
                    except Exception:
                        aw.qmc.extraArduinoT1 = 0
                        aw.qmc.extraArduinoT2 = 0
                    if 32 in aw.qmc.extradevices: # +ArduinoTC4_56
                        try:
                            aw.qmc.extraArduinoT3 = float(res[5])
                            aw.qmc.extraArduinoT4 = float(res[6])
                        except Exception:
                            aw.qmc.extraArduinoT3 = 0
                            aw.qmc.extraArduinoT4 = 0
                    if 44 in aw.qmc.extradevices: # +ArduinoTC4_78
                        # report SV as extraArduinoT5
                        try:
                            aw.qmc.extraArduinoT5 = float(res[7])
                        except Exception:
                            aw.qmc.extraArduinoT5 = 0
                        # report Ambient Temperature as extraArduinoT6
                        try:
                            aw.qmc.extraArduinoT6 = float(res[0])
                        except Exception:
                            aw.qmc.extraArduinoT6 = 0
                else:
                    aw.qmc.extraArduinoT1 = -1.
                    aw.qmc.extraArduinoT2 = -1.
                    if 32 in aw.qmc.extradevices: # +ArduinoTC4_56
                        try:
                            aw.qmc.extraArduinoT3 = float(res[3])
                            aw.qmc.extraArduinoT4 = float(res[4])
                        except Exception:
                            aw.qmc.extraArduinoT3 = 0
                            aw.qmc.extraArduinoT4 = 0
                    else:
                        aw.qmc.extraArduinoT3 = -1.
                        aw.qmc.extraArduinoT4 = -1.
                    if 44 in aw.qmc.extradevices: # +ArduinoTC4_78
                        # report SV as extraArduinoT5
                        try:
                            aw.qmc.extraArduinoT5 = float(res[5])
                        except Exception:
                            aw.qmc.extraArduinoT5 = 0
                        # report Ambient Temperature as extraArduinoT6
                        try:
                            aw.qmc.extraArduinoT6 = float(res[0])
                        except Exception:
                            aw.qmc.extraArduinoT6 = 0
                # overwrite temps by AT internal Ambient Temperature
                if aw.ser.arduinoATChannel != "None":
                    if aw.ser.arduinoATChannel == "T1":
                        t1 = float(res[0])
                    elif aw.ser.arduinoATChannel == "T2":
                        t2 = float(res[0])
                    elif (28 in aw.qmc.extradevices or (32 in aw.qmc.extradevices and not 28 in aw.qmc.extradevices)) and aw.ser.arduinoATChannel == "T3":
                        aw.qmc.extraArduinoT1 = float(res[0])
                    elif (28 in aw.qmc.extradevices or (32 in aw.qmc.extradevices and not 28 in aw.qmc.extradevices)) and aw.ser.arduinoATChannel == "T4":
                        aw.qmc.extraArduinoT2 = float(res[0])
                    elif (28 in aw.qmc.extradevices and 32 in aw.qmc.extradevices) and aw.ser.arduinoATChannel == "T5":
                        aw.qmc.extraArduinoT3 = float(res[0])
                    elif (28 in aw.qmc.extradevices and 32 in aw.qmc.extradevices) and aw.ser.arduinoATChannel == "T6":
                        aw.qmc.extraArduinoT4 = float(res[0])
                return t1, t2
        except Exception as e:
            # self.closeport() # closing the port on error is to serve as the Arduino needs time to restart and has to be reinitialized!
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " ser.ARDUINOTC4temperature(): {0}").format(str(e)),exc_tb.tb_lineno)
            return -1.,-1.
        finally:
            if self.COMsemaphore.available() < 1:
                self.COMsemaphore.release(1)
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("ArduinoTC4: " + settings + " || Tx = " + str(command) + " || Rx = " + str(res) + "|| Ts= %.2f, %.2f, %.2f, %.2f, %.2f, %.2f"%(t1,t2,aw.qmc.extraArduinoT1,aw.qmc.extraArduinoT2,aw.qmc.extraArduinoT3,aw.qmc.extraArduinoT4))


    def TEVA18Bconvert(self, seg):
        if seg == 0x7D:
            return 0
        elif seg == 0x05:
            return 1
        elif seg == 0x5B:
            return 2
        elif seg == 0x1F:
            return 3
        elif seg == 0x27:
            return 4
        elif seg == 0x3E:
            return 5
        elif seg == 0x7E:
            return 6
        elif seg == 0x15:
            return 7
        elif seg == 0x7F:
            return 8
        elif seg == 0x3F:
            return 9
        else:
            return -1

    def TEVA18Btemperature(self):
        try:
            r = ""
            run = 1
            counter = 0
            while(run):
                
                #MaWa
                #really interesting:
                #need this sleep. without artisan hungs after 20 to 40 seconds.
                #seems like iam running the loop forever, forever .... with sleep it is ok
                #seen this sometimes in communication between threads in C or C++. --> volatile problem?
                if counter > 0:
                    libtime.sleep(0.7)
                counter = counter + 1
                if not self.SP.isOpen():
                    self.openport()    
                    libtime.sleep(1)
                if self.SP.isOpen():
                    self.SP.reset_input_buffer() # self.SP.flushInput() # deprecated in v3
                    r = self.SP.read(14)
                    if len(r) != 14:
                        continue
#                    s200 = binascii.hexlify(r[0])
                    s201 = binascii.hexlify(r[1])
                    s202 = binascii.hexlify(r[2])
                    s203 = binascii.hexlify(r[3])
                    s204 = binascii.hexlify(r[4])
                    s205 = binascii.hexlify(r[5])
                    s206 = binascii.hexlify(r[6])
                    s207 = binascii.hexlify(r[7])
                    s208 = binascii.hexlify(r[8])
    #                s209 = binascii.hexlify(r[9])
    #                s210 = binascii.hexlify(r[10])
    #                s211 = binascii.hexlify(r[11])
    #                s212 = binascii.hexlify(r[12])
                    s213 = binascii.hexlify(r[13])
#                   t200 = int(s200,16)
                    t201 = int(s201,16)
                    t202 = int(s202,16)
                    t203 = int(s203,16)
                    t204 = int(s204,16)
                    t205 = int(s205,16)
                    t206 = int(s206,16)
                    t207 = int(s207,16)
                    t208 = int(s208,16)
    #                t209 = int(s209,16)
    #                t210 = int(s210,16)
    #                t211 = int(s211,16)
    #                t212 = int(s212,16)
                    t213 = int(s213,16)
                    # is meter in temp mode?
                    # first check byte order
                    if(((t213 & 0xf0) >> 4) != 14):
                        #ERROR try again .....
                        continue
#                    elif(((t213 & 0x0f) & 0x02) != 2):
#                        #ERROR
#                        # device seems not to be in temp mode, break here
#                        raise ValueError
                    # convert
                    bNegative = 0
                    iDivisor = 0
                    # first lets check the byte order
                    # seg1 bytes
                    if (((t201 & 0xf0) >> 4) == 2) and (((t202 & 0xf0) >> 4) == 3):
                        seg1 = ((t201 & 0x0f) << 4) + (t202 & 0x0f)
                    else:
                        continue
                    # seg2 bytes
                    if (((t203 & 0xf0) >> 4) == 4) and (((t204 & 0xf0) >> 4) == 5):
                        seg2 = ((t203 & 0x0f) << 4) + (t204 & 0x0f)
                    else:
                        continue
                    # seg3 bytes
                    if (((t205 & 0xf0) >> 4) == 6) and (((t206 & 0xf0) >> 4) == 7):
                        seg3 = ((t205 & 0x0f) << 4) + (t206 & 0x0f)
                    else:
                        continue
                    # seg4 bytes
                    if (((t207 & 0xf0) >> 4) == 8) and (((t208 & 0xf0) >> 4) == 9):
                        seg4 = ((t207 & 0x0f) << 4) + (t208 & 0x0f)
                    else:
                        continue
                    # is negative?
                    if (seg1 & 0x80):
                        bNegative = 1
                        seg1 = seg1 & ~0x80
                    # check divisor
                    if (seg2 & 0x80):
                        iDivisor = 1000.
                        seg2 = seg2 & ~0x80
                    elif (seg3 & 0x80):
                        iDivisor = 100.
                        seg3 = seg3 & ~0x80
                    elif (seg4 & 0x80):
                        iDivisor = 10.
                        seg4 = seg4 & ~0x80
                    iValue = 0
                    fReturn = 0
                    i = self.TEVA18Bconvert(seg1)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = i * 1000
                    i = self.TEVA18Bconvert(seg2)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 100)
                    i = self.TEVA18Bconvert(seg3)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + (i * 10)
                    i = self.TEVA18Bconvert(seg4)
                    if (i < 0):
                        # recv nonsense, try again
                        continue
                    iValue = iValue + i
                    # what about the divisor?
                    if (iDivisor > 0):
                        fReturn = iValue / iDivisor
                    # is value negative?
                    if (fReturn):
                        if (bNegative):
                            fReturn = fReturn * (-1)
                    #ok seems we got valid value
                    # break loop here
                    run = 0
            #Since the meter reads only one temperature, send 0 as ET and fReturn as BT
            if fReturn:
                return 0.,fReturn    #  **** RETURN T HERE  ******
            else:
                raise ValueError
        except ValueError:
            #self.closeport()
            error = QApplication.translate("Error Message","Value Error:",None) + " ser.TEVA18Btemperature()"
            timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            return -1,-1 
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.TEVA18Btemperature() {0}").format(str(ex)),exc_tb.tb_lineno)
            return -1,-1
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("TEVA18B: " + settings + " || Tx = " + "No command" + " || Rx = " + cmd2str(binascii.hexlify(r)))

    def HHM28multimeter(self):
        # This meter sends a continuos frame byte by byte. It only transmits data. It does not receive commands.
        # A frame is composed of 14 ordered bytes. A byte is represented bellow enclosed in "XX"
        # FRAME  = ["1A","2B","3C","4D","5E","6F","7G","8H","9I","10J","11K","12L","13M","14N"]
        # The first 4 bits of each byte are dedicated to identify the byte in the frame by using a number.
        # The last 4 bits of each byte are dedicated to carry Data. Depending on the byte number, the meaning of data changes.
        # Bytes 2,3,4,5,6,7,8,9 carry data bits that represent actual segments of the four LCD numbers of the meter display.
        # Bytes 1,10,11,12,13 carry data bits that represent other symbols like F (for Farad), u (for micro), M (for Mega), etc, of the meter display
        try:
            r, r2 = "",""
            frame = ""
            if not self.SP.isOpen():
                self.openport()
            if self.SP.isOpen():
                self.SP.reset_input_buffer() # self.SP.flushInput() # deprecated in v3
                self.SP.reset_output_buffer() # self.SP.flushOutput() # deprecated in v3
            #keep reading till the first byte of next frame (till we read an actual 1 in 1A )
            for i in range(28):  #any number > 14 will be OK
                r = self.SP.read(1)
                if r:
                    fb = (r[0] & 0xf0) >> 4
                    if fb == 1:
                        r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
                        break
                else:
                    raise ValueError(str("No Data received"))
##                if (r[0] & 0xf0) >> 4 == 1:
##                    r2 = self.SP.read(13)   #read the remaining 13 bytes to get 14 bytes
##                    break
            frame = r + r2
            #check bytes
            for i in range(14):
                number = fb = (frame[i] & 0xf0) >> 4
                if number != i+1:
                    #find device index
                    raise ValueError(str("Data corruption"))
            if len(frame) == 14:
                #extract data from frame in to a list containing the hex string values of the data
                data = []
                for i in range(14):
                    data.append(hex((frame[i] & 0x0f))[2:])
                #The four LCD digits are BC + DE + FG + HI   
                digits = [data[1]+data[2],data[3]+data[4],data[5]+data[6],data[7]+data[8]]
                #find sign 
                sign = ""   # +
                if (int(digits[0],16) & 0x80) >> 7:
                    sign = "-"
                #find location of decimal point
                for i in range(4):
                    if (int(digits[i],16) & 0x80) >> 7:
                        dec = i
                        digits[i] = hex(int(digits[i],16) & 0x7f)[2:]  #remove decimal point
                        if len(digits[i]) < 2:
                            digits[i] = "0" + digits[i]
                #find value from table
                table = {"00":" ","68":"L","7d":"0","05":"1","5b":"2","1f":"3",
                         "27":"4","3e":"5","7e":"6","15":"7","7f":"8","3f":"9"} 
                val = ""
                #some erros found in values: "38","5d",0A,etc
                for i in range(4):
                    if digits[i] in table:
                        val += table[digits[i]]
                    else:
                        raise ValueError(str("Data corruption"))
                number = ".".join((val[:dec],val[dec:]))  #add the decimal point
                #find symbols
                tablesymbols = [
                                ["AC","","",""],    #["AC","","Auto","RS232"]
                                ["u","n","k","diode"],
                                ["m","%","M","Beep"],
                                ["F","Ohm","Relative","Hold"],
                                ["A","V","Hz","Low Batt"]
                                ]
                masks = [0x08,0x04,0x02,0x01]
                nbytes = [0,9,10,11,12]
                symbols = ""
                for p in range(5):
                    for i in range(4):
                        if (int(data[nbytes[p]],16) & masks[i]):
                            symbols += " " + tablesymbols[p][i]
                return (sign + number), symbols
            else:
                raise ValueError(str("Needed 14 bytes but only received %i"%(len(frame))))
        except ValueError:
            #self.closeport()
            error  = QApplication.translate("Error Message","Value Error:",None) + " ser.HHM28multimeter()"
            timez = str(QDateTime.currentDateTime().toString(u("hh:mm:ss.zzz")))    #zzz = miliseconds
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror(timez + " " + error,exc_tb.tb_lineno)
            #find device index
            if aw.qmc.device == 23:
                if len(aw.qmc.temp1):
                    return str(aw.qmc.temp1[-1]),str(aw.qmc.temp2[-1])
                else:
                    return "0","0"
            else:
                index = aw.qmc.extradevices.index(23)
                if len(aw.qmc.extratemp1[i]):
                    return str(aw.qmc.extratemp1[index][-1]),str(aw.qmc.temp2[index][-1])
                else:
                    return "0","0"
        except Exception as ex:
            #self.closeport()
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.HHM28multimeter() {0}").format(str(ex)),exc_tb.tb_lineno)
            return "0"""
        finally:
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("HHM28multimeter: " + settings + " || Tx = " + "No command" + " || Rx = " + str(frame))

    #sends a command to the ET/BT device. (used by eventaction to send serial command to e.g. Arduino)
    def sendTXcommand(self,command):
        try:
            #### lock shared resources #####
            aw.qmc.samplingsemaphore.acquire(1)
            if not self.SP.isOpen():
                self.openport()
                libtime.sleep(1)
                #Reinitialize Arduino in case communication was interrupted
                if aw.qmc.device == 19:
                    self.ArduinoIsInitialized = 0
            if self.SP.isOpen():
                self.SP.reset_input_buffer() # self.SP.flushInput() # deprecated in v3
                self.SP.reset_output_buffer() # self.SP.flushOutput() # deprecated in v3
                if (aw.qmc.device == 19 and not command.endswith("\n")):
                    command += "\n"
                self.SP.write(str2cmd(command))
                #self.SP.flush()
        except Exception as ex:
            #self.closeport() # do not close the serial port as reopening might take too long
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " ser.sendTXcommand() {0}").format(str(ex)),exc_tb.tb_lineno)
        finally:
            if aw.qmc.samplingsemaphore.available() < 1:
                aw.qmc.samplingsemaphore.release(1)        
            #note: logged chars should not be binary
            if aw.seriallogflag:
                settings = str(self.comport) + "," + str(self.baudrate) + "," + str(self.bytesize)+ "," + str(self.parity) + "," + str(self.stopbits) + "," + str(self.timeout)
                aw.addserial("Serial Ccommand: " + settings + " || Tx = " + command + " || Rx = " + "No answer needed")


#########################################################################
#############  DESIGNER CONFIG DIALOG ###################################
#########################################################################

class designerconfigDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(designerconfigDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Designer Config",None))
        self.setModal(True)
        #landmarks
        charge = QLabel(QApplication.translate("Label", "CHARGE",None))
        charge.setAlignment(Qt.AlignRight)
        charge.setStyleSheet("background-color: #f07800")
        self.dryend = QCheckBox(QApplication.translate("CheckBox","DRY END",None))
        self.dryend.setStyleSheet("background-color: orange")
        self.fcs = QCheckBox(QApplication.translate("CheckBox","FC START",None))
        self.fcs.setStyleSheet("background-color: orange")
        self.fce = QCheckBox(QApplication.translate("CheckBox","FC END",None))
        self.fce.setStyleSheet("background-color: orange")
        self.scs = QCheckBox(QApplication.translate("CheckBox","SC START",None))
        self.scs.setStyleSheet("background-color: orange")
        self.sce = QCheckBox(QApplication.translate("CheckBox","SC END",None))
        self.sce.setStyleSheet("background-color: orange")
        drop = QLabel(QApplication.translate("Label", "DROP",None))
        drop.setAlignment(Qt.AlignRight)
        drop.setStyleSheet("background-color: #f07800")
        self.loadconfigflags()
        self.dryend.clicked.connect(self.changeflags)
        self.fcs.clicked.connect(self.changeflags)
        self.fce.clicked.connect(self.changeflags)
        self.scs.clicked.connect(self.changeflags)
        self.sce.clicked.connect(self.changeflags)
        if aw.qmc.timeindex[0] != -1:
            start = aw.qmc.timex[aw.qmc.timeindex[0]]
        else:
            start = 0
        markersettinglabel = QLabel(QApplication.translate("Label", "Marker",None))
        markersettinglabel.setAlignment(Qt.AlignCenter)
        timesettinglabel = QLabel(QApplication.translate("Label", "Time",None))
        timesettinglabel.setAlignment(Qt.AlignCenter)
        btsettinglabel = QLabel(QApplication.translate("Label", "BT",None))
        btsettinglabel.setAlignment(Qt.AlignCenter)
        etsettinglabel = QLabel(QApplication.translate("Label", "ET",None))
        etsettinglabel.setAlignment(Qt.AlignCenter)
        self.Edit0 = QLineEdit(aw.qmc.stringfromseconds(0))
        self.Edit0.setEnabled(False)
        self.Edit0bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit0et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit0.setAlignment(Qt.AlignRight)
        self.Edit0bt.setAlignment(Qt.AlignRight)
        self.Edit0et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[1]:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[1]] - start))
            self.Edit1bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
            self.Edit1et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        else:
            self.Edit1 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit1bt = QLineEdit("0.0")
            self.Edit1et = QLineEdit("0.0")
        self.Edit1.setAlignment(Qt.AlignRight)
        self.Edit1bt.setAlignment(Qt.AlignRight)
        self.Edit1et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[2]:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[2]] - start))
            self.Edit2bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
            self.Edit2et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        else:
            self.Edit2 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit2bt = QLineEdit("0.0")
            self.Edit2et = QLineEdit("0.0")
        self.Edit2.setAlignment(Qt.AlignRight)
        self.Edit2bt.setAlignment(Qt.AlignRight)
        self.Edit2et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[3]:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[3]] - start))
            self.Edit3bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
            self.Edit3et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        else:
            self.Edit3 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit3bt = QLineEdit("0.0")
            self.Edit3et = QLineEdit("0.0")
        self.Edit3.setAlignment(Qt.AlignRight)
        self.Edit3bt.setAlignment(Qt.AlignRight)
        self.Edit3et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[4]:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[4]] - start))
            self.Edit4bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
            self.Edit4et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        else:
            self.Edit4 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit4bt = QLineEdit("0.0")
            self.Edit4et = QLineEdit("0.0")
        self.Edit4.setAlignment(Qt.AlignRight)
        self.Edit4bt.setAlignment(Qt.AlignRight)
        self.Edit4et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[5]:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[5]] - start))
            self.Edit5bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
            self.Edit5et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        else:
            self.Edit5 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit5bt = QLineEdit("0.0")
            self.Edit5et = QLineEdit("0.0")
        self.Edit5.setAlignment(Qt.AlignRight)
        self.Edit5bt.setAlignment(Qt.AlignRight)
        self.Edit5et.setAlignment(Qt.AlignRight)
        if aw.qmc.timeindex[6]:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(aw.qmc.timex[aw.qmc.timeindex[6]] - start))
            self.Edit6bt = QLineEdit("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
            self.Edit6et = QLineEdit("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        else:
            self.Edit6 = QLineEdit(aw.qmc.stringfromseconds(0))
            self.Edit6bt = QLineEdit("0.0")
            self.Edit6et = QLineEdit("0.0")
        self.Edit6.setAlignment(Qt.AlignRight)
        self.Edit6bt.setAlignment(Qt.AlignRight)
        self.Edit6et.setAlignment(Qt.AlignRight)
        maxwidth = 70
        self.Edit0.setMaximumWidth(maxwidth)
        self.Edit1.setMaximumWidth(maxwidth)
        self.Edit2.setMaximumWidth(maxwidth)
        self.Edit3.setMaximumWidth(maxwidth)
        self.Edit4.setMaximumWidth(maxwidth)
        self.Edit5.setMaximumWidth(maxwidth)
        self.Edit6.setMaximumWidth(maxwidth)
        self.Edit0bt.setMaximumWidth(maxwidth)
        self.Edit1bt.setMaximumWidth(maxwidth)
        self.Edit2bt.setMaximumWidth(maxwidth)
        self.Edit3bt.setMaximumWidth(maxwidth)
        self.Edit4bt.setMaximumWidth(maxwidth)
        self.Edit5bt.setMaximumWidth(maxwidth)
        self.Edit6bt.setMaximumWidth(maxwidth)
        self.Edit0et.setMaximumWidth(maxwidth)
        self.Edit1et.setMaximumWidth(maxwidth)
        self.Edit2et.setMaximumWidth(maxwidth)
        self.Edit3et.setMaximumWidth(maxwidth)
        self.Edit4et.setMaximumWidth(maxwidth)
        self.Edit5et.setMaximumWidth(maxwidth)
        self.Edit6et.setMaximumWidth(maxwidth)
        self.Edit1copy = self.Edit1.text()
        self.Edit2copy = self.Edit2.text()
        self.Edit3copy = self.Edit3.text()
        self.Edit4copy = self.Edit4.text()
        self.Edit5copy = self.Edit5.text()
        self.Edit6copy = self.Edit6.text()
        self.Edit0btcopy = self.Edit0bt.text()
        self.Edit1btcopy = self.Edit1bt.text()
        self.Edit2btcopy = self.Edit2bt.text()
        self.Edit3btcopy = self.Edit3bt.text()
        self.Edit4btcopy = self.Edit4bt.text()
        self.Edit5btcopy = self.Edit5bt.text()
        self.Edit6btcopy = self.Edit6bt.text()
        self.Edit0etcopy = self.Edit0et.text()
        self.Edit1etcopy = self.Edit1et.text()
        self.Edit2etcopy = self.Edit2et.text()
        self.Edit3etcopy = self.Edit3et.text()
        self.Edit4etcopy = self.Edit4et.text()
        self.Edit5etcopy = self.Edit5et.text()
        self.Edit6etcopy = self.Edit6et.text()
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.Edit0.setValidator(QRegExpValidator(regextime,self))
        self.Edit1.setValidator(QRegExpValidator(regextime,self))
        self.Edit2.setValidator(QRegExpValidator(regextime,self))
        self.Edit3.setValidator(QRegExpValidator(regextime,self))
        self.Edit4.setValidator(QRegExpValidator(regextime,self))
        self.Edit5.setValidator(QRegExpValidator(regextime,self))
        self.Edit6.setValidator(QRegExpValidator(regextime,self))
        regextemp = QRegExp(r"^-?[0-9]?[0-9]?[0-9]?\.?[0-9]?$")
        self.Edit0bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit1bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit2bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit3bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit4bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit5bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit6bt.setValidator(QRegExpValidator(regextemp,self))
        self.Edit0et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit1et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit2et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit3et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit4et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit5et.setValidator(QRegExpValidator(regextemp,self))
        self.Edit6et.setValidator(QRegExpValidator(regextemp,self))
        curvinesslabel = QLabel(QApplication.translate("Label", "Curviness",None))
        etcurviness = QLabel(QApplication.translate("Label", "ET",None))
        btcurviness = QLabel(QApplication.translate("Label", "BT",None))
        etcurviness.setAlignment(Qt.AlignRight)
        btcurviness.setAlignment(Qt.AlignRight)
        self.ETsplineComboBox = QComboBox()
        self.ETsplineComboBox.addItems(["1","2","3","4","5"])
        self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree - 1)
        self.ETsplineComboBox.currentIndexChanged.connect(self.redrawcurviness)
        self.BTsplineComboBox = QComboBox()
        self.BTsplineComboBox.addItems(["1","2","3","4","5"])
        self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree - 1)
        self.BTsplineComboBox.currentIndexChanged.connect(self.redrawcurviness)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Ok))
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        
        self.dialogbuttons.addButton(QDialogButtonBox.Close)
        self.dialogbuttons.addButton(QDialogButtonBox.Apply)
        self.dialogbuttons.addButton(QDialogButtonBox.RestoreDefaults)
        if aw.locale not in aw.qtbase_locales:
            self.dialogbuttons.button(QDialogButtonBox.RestoreDefaults).setText(QApplication.translate("Button","Reset", None))
        
        self.dialogbuttons.rejected.connect(self.accept)
        self.dialogbuttons.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.reset)
        self.dialogbuttons.button(QDialogButtonBox.Apply).clicked.connect(self.settimes)
        
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        marksLayout = QGridLayout()
        marksLayout.addWidget(markersettinglabel,0,0)
        marksLayout.addWidget(timesettinglabel,0,1)
        marksLayout.addWidget(btsettinglabel,0,2)
        marksLayout.addWidget(etsettinglabel,0,3)
        marksLayout.addWidget(charge,1,0)
        marksLayout.addWidget(self.Edit0,1,1)
        marksLayout.addWidget(self.Edit0bt,1,2)
        marksLayout.addWidget(self.Edit0et,1,3)
        marksLayout.addWidget(self.dryend,2,0)
        marksLayout.addWidget(self.Edit1,2,1)
        marksLayout.addWidget(self.Edit1bt,2,2)
        marksLayout.addWidget(self.Edit1et,2,3)
        marksLayout.addWidget(self.fcs,3,0)
        marksLayout.addWidget(self.Edit2,3,1)
        marksLayout.addWidget(self.Edit2bt,3,2)
        marksLayout.addWidget(self.Edit2et,3,3)
        marksLayout.addWidget(self.fce,4,0)
        marksLayout.addWidget(self.Edit3,4,1)
        marksLayout.addWidget(self.Edit3bt,4,2)
        marksLayout.addWidget(self.Edit3et,4,3)
        marksLayout.addWidget(self.scs,5,0)
        marksLayout.addWidget(self.Edit4,5,1)
        marksLayout.addWidget(self.Edit4bt,5,2)
        marksLayout.addWidget(self.Edit4et,5,3)
        marksLayout.addWidget(self.sce,6,0)
        marksLayout.addWidget(self.Edit5,6,1)
        marksLayout.addWidget(self.Edit5bt,6,2)
        marksLayout.addWidget(self.Edit5et,6,3)
        marksLayout.addWidget(drop,7,0)
        marksLayout.addWidget(self.Edit6,7,1)
        marksLayout.addWidget(self.Edit6bt,7,2)
        marksLayout.addWidget(self.Edit6et,7,3)
        settingsLayout = QVBoxLayout()
        settingsLayout.addLayout(marksLayout)
        curvinessLayout = QHBoxLayout()
        curvinessLayout.addWidget(curvinesslabel)
        curvinessLayout.addWidget(etcurviness)
        curvinessLayout.addWidget(self.ETsplineComboBox)
        curvinessLayout.addWidget(btcurviness)
        curvinessLayout.addWidget(self.BTsplineComboBox)
        modLayout = QVBoxLayout()
        modLayout.addLayout(curvinessLayout)
        marksGroupLayout = QGroupBox(QApplication.translate("GroupBox","Initial Settings",None))
        marksGroupLayout.setLayout(settingsLayout)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(marksGroupLayout)
        mainLayout.addLayout(modLayout)
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Close).setFocus()

    @pyqtSlot(int)
    def redrawcurviness(self,_):
        ETcurviness = int(str(self.ETsplineComboBox.currentText()))
        BTcurviness = int(str(self.BTsplineComboBox.currentText()))
        timepoints = len(aw.qmc.timex)
        if (timepoints - ETcurviness) >= 1:
            aw.qmc.ETsplinedegree = ETcurviness
        else:
            aw.qmc.ETsplinedegree = len(aw.qmc.timex)-1
            self.ETsplineComboBox.setCurrentIndex(aw.qmc.ETsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an ET curviness of {0}. Set curviness to {1}",None).format(ETcurviness,aw.qmc.ETsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None),ms)
        if (timepoints - BTcurviness) >= 1:
            aw.qmc.BTsplinedegree = BTcurviness
        else:
            aw.qmc.BTsplinedegree = len(aw.qmc.timex)-1
            self.BTsplineComboBox.setCurrentIndex(aw.qmc.BTsplinedegree-1)
            ms = QApplication.translate("Message","Not enough time points for an BT curviness of {0}. Set curviness to {1}",None).format(BTcurviness,aw.qmc.BTsplinedegree)
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None),ms)
        aw.qmc.redrawdesigner()

    @pyqtSlot(bool)
    def settimes(self,_):
        #check input
        strings = [QApplication.translate("Message","CHARGE",None),
                   QApplication.translate("Message","DRY END",None),
                   QApplication.translate("Message","FC START",None),
                   QApplication.translate("Message","FC END",None),
                   QApplication.translate("Message","SC START",None),
                   QApplication.translate("Message","SC END",None),
                   QApplication.translate("Message","DROP",None)]
        timecheck = self.validatetime()
        if timecheck != 1000:
            st = QApplication.translate("Message","Incorrect time format. Please recheck {0} time",None).format(strings[timecheck])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None),st)
            return 1
        checkvalue = self.validatetimeorder()
        if checkvalue != 1000:
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck {0} time",None).format(strings[checkvalue+1])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None),st)
            return 1
        if self.Edit0bt.text() != self.Edit0btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[0]] = float(str(self.Edit0bt.text()))
            self.Edit0btcopy = self.Edit0bt.text()
        if self.Edit0et.text() != self.Edit0etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[0]] = float(str(self.Edit0et.text()))
            self.Edit0etcopy = self.Edit0et.text()
        if self.dryend.isChecked():
            if self.Edit1.text() != self.Edit1copy:
                if aw.qmc.stringtoseconds(str(self.Edit1.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit1.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[1]] = timez
                    self.Edit1copy = self.Edit1.text()
            if self.Edit1bt.text() != self.Edit1btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[1]] = float(str(self.Edit1bt.text()))
                self.Edit1btcopy = self.Edit1bt.text()
            if self.Edit1et.text() != self.Edit1etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[1]] = float(str(self.Edit1et.text()))
                self.Edit1etcopy = self.Edit1et.text()
        if self.fcs.isChecked():
            if self.Edit2.text() != self.Edit2copy:
                if aw.qmc.stringtoseconds(str(self.Edit2.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit2.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[2]] = timez
                    self.Edit2copy = self.Edit2.text()
            if self.Edit2bt.text() != self.Edit2btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[2]] = float(str(self.Edit2bt.text()))
                self.Edit2btcopy = self.Edit2bt.text()
            if self.Edit2et.text() != self.Edit2etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[2]] = float(str(self.Edit2et.text()))
                self.Edit2etcopy = self.Edit2et.text()
        if self.fce.isChecked():
            if self.Edit3.text() != self.Edit3copy:
                if aw.qmc.stringtoseconds(str(self.Edit3.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit3.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[3]] = timez
                    self.Edit3copy = self.Edit3.text()
            if self.Edit3bt.text() != self.Edit3btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[3]] = float(str(self.Edit3bt.text()))
                self.Edit3btcopy = self.Edit3bt.text()
            if self.Edit3et.text() != self.Edit3etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[3]] = float(str(self.Edit3et.text()))
                self.Edit3etcopy = self.Edit3et.text()
        if self.scs.isChecked():
            if self.Edit4.text() != self.Edit4copy:
                if aw.qmc.stringtoseconds(str(self.Edit4.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit4.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[4]] = timez
                    self.Edit4copy = self.Edit4.text()
            if self.Edit4bt.text() != self.Edit4btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[4]] = float(str(self.Edit4bt.text()))
                self.Edit4btcopy = self.Edit4bt.text()
            if self.Edit4et.text() != self.Edit4etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[4]] = float(str(self.Edit4et.text()))
                self.Edit4etcopy = self.Edit4et.text()
        if self.sce.isChecked():
            if self.Edit5.text() != self.Edit5copy:
                if aw.qmc.stringtoseconds(str(self.Edit5.text())):
                    timez = aw.qmc.stringtoseconds(str(self.Edit5.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                    aw.qmc.timex[aw.qmc.timeindex[5]] = timez
                    self.Edit5copy = self.Edit5.text()
            if self.Edit5bt.text() != self.Edit5btcopy:
                aw.qmc.temp2[aw.qmc.timeindex[5]] = float(str(self.Edit5bt.text()))
                self.Edit5btcopy = self.Edit5bt.text()
            if self.Edit5et.text() != self.Edit5etcopy:
                aw.qmc.temp1[aw.qmc.timeindex[5]] = float(str(self.Edit5et.text()))
                self.Edit5etcopy = self.Edit5et.text()
        if self.Edit6.text() != self.Edit6copy:
            if aw.qmc.stringtoseconds(str(self.Edit6.text())):
                timez = aw.qmc.stringtoseconds(str(self.Edit6.text()))+ aw.qmc.timex[aw.qmc.timeindex[0]]
                aw.qmc.timex[aw.qmc.timeindex[6]] = timez
                self.Edit6copy = self.Edit6.text()
        if self.Edit6bt.text() != self.Edit6btcopy:
            aw.qmc.temp2[aw.qmc.timeindex[6]] = float(str(self.Edit6bt.text()))
            self.Edit6btcopy = self.Edit6bt.text()
        if self.Edit6et.text() != self.Edit6etcopy:
            aw.qmc.temp1[aw.qmc.timeindex[6]] = float(str(self.Edit6et.text()))
            self.Edit6etcopy = self.Edit6et.text()
        for i in range(1,6): #1-5
            aw.qmc.designertimeinit[i] = aw.qmc.timex[aw.qmc.timeindex[i]]
        aw.qmc.xaxistosm(redraw=False)
        aw.qmc.redrawdesigner()
        return 0

    #supporting function for settimes()
    def validatetimeorder(self):
        time = []
        checks = self.readchecks()
        time.append(aw.qmc.stringtoseconds(str(self.Edit0.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        time.append(aw.qmc.stringtoseconds(str(self.Edit6.text())) + aw.qmc.timex[aw.qmc.timeindex[0]])
        for i in range(len(time)-1):
            if time[i+1] <= time[i] and checks[i+1] != 0:
                return i
        return 1000

    def validatetime(self):
        strings = []
        strings.append(self.Edit0.text())
        strings.append(self.Edit1.text())
        strings.append(self.Edit2.text())
        strings.append(self.Edit3.text())
        strings.append(self.Edit4.text())
        strings.append(self.Edit5.text())
        strings.append(self.Edit6.text())
        for i in range(len(strings)):
            if len(str(strings[i])) < 5:
                return i
        else:
            return 1000

    #supporting function for settimes()
    @pyqtSlot(bool)
    def readchecks(self,_=False):
        checks = [0,0,0,0,0,0,0]
        if self.dryend.isChecked(): 
            checks[1] = 1
        if self.fcs.isChecked():
            checks[2] = 1
        if self.fce.isChecked():
            checks[3] = 1
        if self.scs.isChecked():
            checks[4] = 1
        if self.sce.isChecked():
            checks[5] = 1
        return checks

    def create(self):
        self.close()
        aw.qmc.convert_designer()

    #reset
    @pyqtSlot(bool)
    def reset(self,_):
        self.dryend.setChecked(True)
        self.fcs.setChecked(True)
        self.fce.setChecked(True)
        self.scs.setChecked(True)
        self.sce.setChecked(True)
        #reset designer
        aw.qmc.reset_designer()
        #update editboxes
        self.Edit0.setText(aw.qmc.stringfromseconds(0))
        self.Edit1.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[1]))
        self.Edit2.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[2]))
        self.Edit3.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[3]))
        self.Edit4.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[4]))
        self.Edit5.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[5]))
        self.Edit6.setText(aw.qmc.stringfromseconds(aw.qmc.designertimeinit[6]))
        self.Edit0bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[0]])
        self.Edit1bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[1]])
        self.Edit2bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[2]])
        self.Edit3bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[3]])
        self.Edit4bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[4]])
        self.Edit5bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[5]])
        self.Edit6bt.setText("%.1f"%aw.qmc.temp2[aw.qmc.timeindex[6]])
        self.Edit0et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[0]])
        self.Edit1et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[1]])
        self.Edit2et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[2]])
        self.Edit3et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[3]])
        self.Edit4et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[4]])
        self.Edit5et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[5]])
        self.Edit6et.setText("%.1f"%aw.qmc.temp1[aw.qmc.timeindex[6]])
        aw.sendmessage(QApplication.translate("Message","Designer has been reset",None))

    def loadconfigflags(self):
        self.dryend.setChecked(aw.qmc.timeindex[1])
        self.fcs.setChecked(aw.qmc.timeindex[2])
        self.fce.setChecked(aw.qmc.timeindex[3])
        self.scs.setChecked(aw.qmc.timeindex[4])
        self.sce.setChecked(aw.qmc.timeindex[5])

    #adds deletes landmarks
    @pyqtSlot(bool)
    def changeflags(self,_):
        sender = self.sender()
        if sender == self.dryend:
            idi = 1
        elif sender == self.fcs:
            idi = 2
        elif sender == self.fce:
            idi = 3
        elif sender == self.scs:
            idi = 4
        elif sender == self.sce:
            idi = 5
        else:
            return
        if self.validatetimeorder() != 1000:
            if idi == 1:
                if self.dryend.isChecked():
                    self.dryend.setChecked(False)
            elif idi == 2:
                if self.fcs.isChecked():
                    self.fcs.setChecked(False)
            elif idi == 3:
                if self.fce.isChecked():
                    self.fce.setChecked(False)
            elif idi == 4:
                if self.scs.isChecked():
                    self.scs.setChecked(False)
            elif idi == 5:
                if self.sce.isChecked():
                    self.sce.setChecked(False)
            #ERROR time from edit boxes is not in ascending order
            strings = [QApplication.translate("Message","CHARGE",None),
                       QApplication.translate("Message","DRY END",None),
                       QApplication.translate("Message","FC START",None),
                       QApplication.translate("Message","FC END",None),
                       QApplication.translate("Message","SC START",None),
                       QApplication.translate("Message","SC END",None),
                       QApplication.translate("Message","DROP",None)]
            st = QApplication.translate("Message","Times need to be in ascending order. Please recheck {0} time",None).format(strings[idi])
            QMessageBox.information(self,QApplication.translate("Message","Designer Config",None),st)
            return
        #idi = id index
        if aw.qmc.timeindex[idi]:
            #ERASE mark point
            aw.qmc.currentx = aw.qmc.timex[aw.qmc.timeindex[idi]]
            aw.qmc.currenty = aw.qmc.temp2[aw.qmc.timeindex[idi]]
            aw.qmc.removepoint()
        else:
            #ADD mark point
            if idi == 1:
                timez = aw.qmc.stringtoseconds(str(self.Edit1.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit1bt.text()))
                et = float(str(self.Edit1et.text()))
            if idi == 2:
                timez = aw.qmc.stringtoseconds(str(self.Edit2.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit2bt.text()))
                et = float(str(self.Edit2et.text()))
            if idi == 3:
                timez = aw.qmc.stringtoseconds(str(self.Edit3.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit3bt.text()))
                et = float(str(self.Edit3et.text()))
            if idi == 4:
                timez = aw.qmc.stringtoseconds(str(self.Edit4.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit4bt.text()))
                et = float(str(self.Edit4et.text()))
            if idi == 5:
                timez = aw.qmc.stringtoseconds(str(self.Edit5.text())) + aw.qmc.timex[aw.qmc.timeindex[0]]
                bt = float(str(self.Edit5bt.text()))
                et = float(str(self.Edit5et.text()))
            aw.qmc.currentx = timez 
            aw.qmc.currenty = bt
            newindex = aw.qmc.addpoint(manual=False)
            aw.qmc.timeindex[idi] = newindex
            aw.qmc.temp2[aw.qmc.timeindex[idi]] = bt
            aw.qmc.temp1[aw.qmc.timeindex[idi]] = et
            aw.qmc.xaxistosm(redraw=False)
            aw.qmc.redrawdesigner()

class pointDlg(ArtisanDialog):
    def __init__(self,parent = None, values = [0,0]):
        super(pointDlg,self).__init__(parent)
        self.values = values
        self.setWindowTitle(QApplication.translate("Form Caption","Add Point",None))
        self.tempEdit = QLineEdit(str(int(round(self.values[1]))))
        self.tempEdit.setValidator(QIntValidator(0, 999, self.tempEdit))
        self.tempEdit.setFocus()
        self.tempEdit.setAlignment(Qt.AlignRight)
        templabel = QLabel(QApplication.translate("Label", "temp",None))
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        self.timeEdit = QLineEdit(aw.qmc.stringfromseconds(self.values[0],leadingzero=False))
        self.timeEdit.setAlignment(Qt.AlignRight)
        self.timeEdit.setValidator(QRegExpValidator(regextime,self))
        timelabel = QLabel(QApplication.translate("Label", "time",None))

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.return_values)
        self.dialogbuttons.rejected.connect(self.reject)
        
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        grid = QGridLayout()
        grid.addWidget(timelabel,0,0)
        grid.addWidget(self.timeEdit,0,1)
        grid.addWidget(templabel,1,0)
        grid.addWidget(self.tempEdit,1,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(grid)
        mainLayout.addStretch()  
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
    
    @pyqtSlot()
    def return_values(self):
        self.values[0] = aw.qmc.stringtoseconds(str(self.timeEdit.text()))
        self.values[1] = float(self.tempEdit.text())
        self.accept()

#########################################################################
#############  CUSTOM EVENT DIALOG ######################################
#########################################################################

class customEventDlg(ArtisanDialog):
    def __init__(self, parent = None,time_idx=0,description="",event_type=4,value=0):
        super(customEventDlg,self).__init__(parent)
        if time_idx != 0:
            event_time = aw.qmc.timex[time_idx]
            if aw.qmc.timeindex[0] > -1:
                event_time -= aw.qmc.timex[aw.qmc.timeindex[0]]
            event_time_str = " @ " + aw.eventtime2string(event_time)
        else:
            event_time_str = ""
        self.setWindowTitle(QApplication.translate("Form Caption","Event",None) + event_time_str)
        self.description = description
        self.type = event_type
        self.value = aw.qmc.eventsvalues(value)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.rejected.connect(self.reject)
        
        descriptionLabel = QLabel(QApplication.translate("Table", "Description", None))
        self.descriptionEdit = QLineEdit(self.description)
        typeLabel = QLabel(QApplication.translate("Table", "Type", None))
        etypes = aw.qmc.getetypes()
        self.typeCombo = MyQComboBox()
        self.typeCombo.setSizeAdjustPolicy(QComboBox.AdjustToContents)
        self.typeCombo.addItems(etypes)
        self.typeCombo.setCurrentIndex(self.type)
        valueLabel = QLabel(QApplication.translate("Table", "Value", None))
        self.valueEdit = QLineEdit(str(self.value))
        
        grid = QGridLayout()
        grid.addWidget(descriptionLabel,0,0)
        grid.addWidget(self.descriptionEdit,0,1)
        grid.addWidget(typeLabel,1,0)
        grid.addWidget(self.typeCombo,1,1)
        grid.addWidget(valueLabel,2,0)
        grid.addWidget(self.valueEdit,2,1)

        buttonsLayout = QHBoxLayout()
        buttonsLayout.addStretch()
        buttonsLayout.addWidget(self.dialogbuttons)
        
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(grid)
        mainLayout.addStretch()
        mainLayout.addLayout(buttonsLayout)
        self.setLayout(mainLayout)
        
    def accept(self):
        self.description = self.descriptionEdit.text()
        evalue = self.valueEdit.text()
        self.value = aw.qmc.str2eventsvalue(str(evalue))
        self.type = self.typeCombo.currentIndex()
        super(customEventDlg,self).accept()

#########################################################################
#############  NONE DEVICE DIALOG #######################################
#########################################################################

#inputs temperature
class nonedevDlg(QDialog,object):
    __slots__ = ['etEdit','btEdit','ETbox','okButton','cancelButton'] # save some memory by using slots
    def __init__(self, parent = None):
        super(nonedevDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Manual Temperature Logger",None))
        if len(aw.qmc.timex):
            if aw.qmc.manuallogETflag:
                etval = str(int(aw.qmc.temp1[-1]))
            else:
                etval = "0"
            btval = str(int(aw.qmc.temp2[-1])) 
        else:
            etval = "0"
            btval = "0"
        self.etEdit = QLineEdit(etval)
        btlabel = QLabel(QApplication.translate("Label", "BT",None))
        self.btEdit = QLineEdit(btval)
        self.etEdit.setValidator(QIntValidator(0, 1000, self.etEdit))
        self.btEdit.setValidator(QIntValidator(0, 1000, self.btEdit))
        self.btEdit.setFocus()
        self.ETbox = QCheckBox(QApplication.translate("CheckBox","ET",None))
        if aw.qmc.manuallogETflag == True:
            self.ETbox.setChecked(True)
        else:
            self.ETbox.setChecked(False)
            self.etEdit.setVisible(False)
        self.ETbox.stateChanged.connect(self.changemanuallogETflag)
        self.okButton = QPushButton(QApplication.translate("Button","OK",None))
        self.cancelButton = QPushButton(QApplication.translate("Button","Cancel",None))
        self.cancelButton.setFocusPolicy(Qt.NoFocus)
        self.okButton.clicked.connect(self.accept)
        self.cancelButton.clicked.connect(self.reject)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.cancelButton)
        buttonLayout.addWidget(self.okButton)
        grid = QGridLayout()
        grid.addWidget(self.ETbox,0,0)
        grid.addWidget(self.etEdit,0,1)
        grid.addWidget(btlabel,1,0)
        grid.addWidget(self.btEdit,1,1)
        mainLayout = QVBoxLayout()
        mainLayout.addLayout(grid)
        mainLayout.addStretch()  
        mainLayout.addLayout(buttonLayout)
        self.setLayout(mainLayout)

    @pyqtSlot(int)
    def changemanuallogETflag(self,_):
        if self.ETbox.isChecked():
            aw.qmc.manuallogETflag = 1
            self.etEdit.setVisible(True)
            self.etEdit.setFocus()
        else:
            aw.qmc.manuallogETflag = 0
            self.etEdit.setVisible(False)
            self.btEdit.setFocus()

#########################################################################
#############  SERIAL PORT CONFIGURATION DIALOG #########################
#########################################################################


class PortComboBox(QComboBox):
    __slots__ = ['selection','ports','edited'] # save some memory by using slots
    def __init__(self, parent = None, selection = None):
        super(PortComboBox, self).__init__(parent)
        self.installEventFilter(self)
        self.selection = u(selection) # just the port name (first element of one of the triples in self.ports)
        # a list of triples as returned by serial.tools.list_ports
        self.ports = []
        self.updateMenu()
        self.edited = None
        self.editTextChanged.connect(self.textEdited)
        self.setEditable(True)

    @pyqtSlot("QString")
    def textEdited(self,txt):
        self.edited = txt

    def getSelection(self):
        return self.edited or self.selection

    def setSelection(self,i):
        if i >= 0:
            try:
                self.selection = u(self.ports[i][0])
                self.edited = None # reset the user text editing
            except Exception:
                pass

    def eventFilter(self, obj, event):
# the next prevents correct setSelection on Windows
#        if event.type() == QEvent.FocusIn:
#            self.setSelection(self.currentIndex())
        if event.type() == QEvent.MouseButtonPress:
            self.updateMenu()
            return True
        return super(PortComboBox, self).eventFilter(obj, event)

    def updateMenu(self):
        self.blockSignals(True)
        try:
            import serial.tools.list_ports
            comports = [(cp if isinstance(cp, (list, tuple)) else [cp.device, cp.product, None]) for cp in serial.tools.list_ports.comports()]
            if platf == 'Darwin':
                self.ports = list([p for p in comports if not(p[0] in ['/dev/cu.Bluetooth-PDA-Sync',
                    '/dev/cu.Bluetooth-Modem','/dev/tty.Bluetooth-PDA-Sync','/dev/tty.Bluetooth-Modem',"/dev/cu.Bluetooth-Incoming-Port","/dev/tty.Bluetooth-Incoming-Port"])])
            else:
                self.ports = list(comports)
            if self.selection not in [p[0] for p in self.ports]:
                self.ports.append([self.selection,"",""])
            self.ports = sorted(self.ports,key=lambda p: p[0])
            self.clear()
            self.addItems([(p[1] if (p[1] and p[1]!="n/a") else p[0]) for p in self.ports])
            try:
                pos = [p[0] for p in self.ports].index(self.selection)
                self.setCurrentIndex(pos)
            except Exception:
                pass
        except Exception:
            pass
        self.blockSignals(False)

class comportDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(comportDlg,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose, False) # overwrite the ArtisanDialog class default here!!
        self.setWindowTitle(QApplication.translate("Form Caption","Ports Configuration",None))
        self.setModal(True)
        self.helpdialog = None
        ##########################    TAB 1 WIDGETS
        comportlabel =QLabel(QApplication.translate("Label", "Comm Port", None))
        self.comportEdit = PortComboBox(selection = aw.ser.comport)
        self.comportEdit.activated.connect(self.portComboBoxIndexChanged)
        comportlabel.setBuddy(self.comportEdit)
        baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None))
        self.baudrateComboBox = QComboBox()
        baudratelabel.setBuddy(self.baudrateComboBox)
        self.bauds = ["1200", "2400","4800","9600","19200","38400","57600","115200"]
        self.baudrateComboBox.addItems(self.bauds)
        self.baudrateComboBox.setCurrentIndex(self.bauds.index(str(aw.ser.baudrate)))
        bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None))
        self.bytesizeComboBox = QComboBox()
        bytesizelabel.setBuddy(self.bytesizeComboBox)
        self.bytesizes = ["7","8"]
        self.bytesizeComboBox.addItems(self.bytesizes)
        self.bytesizeComboBox.setCurrentIndex(self.bytesizes.index(str(aw.ser.bytesize)))
        paritylabel = QLabel(QApplication.translate("Label", "Parity",None))
        self.parityComboBox = QComboBox()
        paritylabel.setBuddy(self.parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.parity = ["O","E","N"]
        self.parityComboBox.addItems(self.parity)
        self.parityComboBox.setCurrentIndex(self.parity.index(aw.ser.parity))
        stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None))
        self.stopbitsComboBox = QComboBox()
        stopbitslabel.setBuddy(self.stopbitsComboBox)
        self.stopbits = ["1","2"]
        self.stopbitsComboBox.addItems(self.stopbits)
        self.stopbitsComboBox.setCurrentIndex(aw.ser.stopbits-1)
        timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None))
        self.timeoutEdit = QLineEdit(str(aw.ser.timeout))
        self.timeoutEdit.setValidator(aw.createCLocaleDoubleValidator(0,5,1,self.timeoutEdit))
        etbt_help_label = QLabel(QApplication.translate("Label", "Settings for non-Modbus devices",None) + "<br>")
        ##########################    TAB 2  WIDGETS   EXTRA DEVICES
        self.serialtable = QTableWidget()
        self.serialtable.setTabKeyNavigation(True)
        self.createserialTable()
        ##########################    TAB 3 WIDGETS   MODBUS
        modbus_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None))
        self.modbus_comportEdit = PortComboBox(selection = aw.modbus.comport)
        self.modbus_comportEdit.setFixedWidth(150)
        self.modbus_comportEdit.activated.connect(self.portComboBoxIndexChanged)
        modbus_comportlabel.setBuddy(self.modbus_comportEdit)
        modbus_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None))
        self.modbus_baudrateComboBox = QComboBox()
        modbus_baudratelabel.setBuddy(self.modbus_baudrateComboBox)
        self.modbus_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.modbus_baudrateComboBox.addItems(self.modbus_bauds)
        self.modbus_baudrateComboBox.setCurrentIndex(self.modbus_bauds.index(str(aw.modbus.baudrate)))
        modbus_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None))
        self.modbus_bytesizeComboBox = QComboBox()
        modbus_bytesizelabel.setBuddy(self.modbus_bytesizeComboBox)
        self.modbus_bytesizes = ["7","8"]
        self.modbus_bytesizeComboBox.addItems(self.modbus_bytesizes)
        self.modbus_bytesizeComboBox.setCurrentIndex(self.modbus_bytesizes.index(str(aw.modbus.bytesize)))
        modbus_paritylabel = QLabel(QApplication.translate("Label", "Parity",None))
        self.modbus_parityComboBox = QComboBox()
        modbus_paritylabel.setBuddy(self.modbus_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.modbus_parity = ["O","E","N"]
        self.modbus_parityComboBox.addItems(self.modbus_parity)
        self.modbus_parityComboBox.setCurrentIndex(self.modbus_parity.index(aw.modbus.parity))
        modbus_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None))
        self.modbus_stopbitsComboBox = QComboBox()
        modbus_stopbitslabel.setBuddy(self.modbus_stopbitsComboBox)
        self.modbus_stopbits = ["1","2"]
        self.modbus_stopbitsComboBox.addItems(self.stopbits)
        self.modbus_stopbitsComboBox.setCurrentIndex(aw.modbus.stopbits - 1)
        modbus_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None))
        self.modbus_timeoutEdit = QLineEdit(str(aw.modbus.timeout))
        self.modbus_timeoutEdit.setValidator(aw.createCLocaleDoubleValidator(0,5,1,self.modbus_timeoutEdit))

        modbus_function_codes = ["1","2","3","4"]
        modbus_modes = ["", "C","F"]
        modbus_divs = ["", "1/10","1/100"]
        modbus_decode = ["", "Float","BCD"]
        
        modbus_input1slavelabel = QLabel(QApplication.translate("Label", "Slave",None))
        modbus_input1registerlabel = QLabel(QApplication.translate("Label", "Register",None))
        modbus_input1floatlabel = QLabel(QApplication.translate("Label", "Decode",None))
        modbus_input1codelabel = QLabel(QApplication.translate("Label", "Function",None))
        modbus_input1divlabel = QLabel(QApplication.translate("Label", "Divider",None))
        modbus_input1modelabel = QLabel(QApplication.translate("Label", "Mode",None))
        
        self.modbus_inputSlaveEdits = [None]*aw.modbus.channels
        self.modbus_inputRegisterEdits = [None]*aw.modbus.channels
        self.modbus_inputCodes = [None]*aw.modbus.channels
        self.modbus_inputDivs = [None]*aw.modbus.channels
        self.modbus_inputModes = [None]*aw.modbus.channels
        self.modbus_inputDecodes = [None]*aw.modbus.channels
        
        for i in range(aw.modbus.channels):
            self.modbus_inputSlaveEdits[i] = QLineEdit(str(aw.modbus.inputSlaves[i]))
            self.modbus_inputSlaveEdits[i].setValidator(QIntValidator(0,247,self.modbus_inputSlaveEdits[i]))
            self.modbus_inputSlaveEdits[i].setFixedWidth(65)
            self.modbus_inputSlaveEdits[i].setAlignment(Qt.AlignRight)
            #
            self.modbus_inputRegisterEdits[i] = QLineEdit(str(aw.modbus.inputRegisters[i]))
            self.modbus_inputRegisterEdits[i].setValidator(QIntValidator(0,65536,self.modbus_inputRegisterEdits[i]))
            self.modbus_inputRegisterEdits[i].setFixedWidth(65)
            self.modbus_inputRegisterEdits[i].setAlignment(Qt.AlignRight)
            #
            self.modbus_inputCodes[i] = QComboBox()
            self.modbus_inputCodes[i].setFocusPolicy(Qt.NoFocus)
            self.modbus_inputCodes[i].addItems(modbus_function_codes)
            self.modbus_inputCodes[i].setCurrentIndex(modbus_function_codes.index(str(aw.modbus.inputCodes[i])))
            self.modbus_inputCodes[i].setFixedWidth(70)
            #
            self.modbus_inputDivs[i] = QComboBox()
            self.modbus_inputDivs[i].setFocusPolicy(Qt.NoFocus)
            self.modbus_inputDivs[i].addItems(modbus_divs)
            self.modbus_inputDivs[i].setCurrentIndex(aw.modbus.inputDivs[i])
            self.modbus_inputDivs[i].setFixedWidth(70)
            #
            self.modbus_inputModes[i] = QComboBox()
            self.modbus_inputModes[i].setFocusPolicy(Qt.NoFocus)
            self.modbus_inputModes[i].addItems(modbus_modes)
            self.modbus_inputModes[i].setCurrentIndex(modbus_modes.index(str(aw.modbus.inputModes[i])))
            self.modbus_inputModes[i].setFixedWidth(70)
            #
            self.modbus_inputDecodes[i] = QComboBox()
            self.modbus_inputDecodes[i].setFocusPolicy(Qt.NoFocus)
            self.modbus_inputDecodes[i].addItems(modbus_decode)
            if aw.modbus.inputFloats[i]:
                self.modbus_inputDecodes[i].setCurrentIndex(1)
            elif aw.modbus.inputBCDs[i]:
                self.modbus_inputDecodes[i].setCurrentIndex(2)
            self.modbus_inputDecodes[i].setFixedWidth(70)

        modbus_endianlabel = QLabel(QApplication.translate("Label", "little-endian",None))
        
        self.modbus_littleEndianBytes = QCheckBox(QApplication.translate("ComboBox","bytes",None))
        self.modbus_littleEndianBytes.setChecked(aw.modbus.byteorderLittle)
        self.modbus_littleEndianBytes.setFocusPolicy(Qt.NoFocus)

        self.modbus_littleEndianWords = QCheckBox(QApplication.translate("ComboBox","words",None))
        self.modbus_littleEndianWords.setChecked(aw.modbus.wordorderLittle)
        self.modbus_littleEndianWords.setFocusPolicy(Qt.NoFocus)

        # type
        self.modbus_type = QComboBox()
        modbus_typelabel = QLabel(QApplication.translate("Label", "Type",None))
        modbus_typelabel.setBuddy(self.modbus_type)
        self.modbus_type.setFocusPolicy(Qt.NoFocus)
        self.modbus_type.addItems(["Serial RTU", "Serial ASCII", "Serial Binary", "TCP", "UDP"])
        self.modbus_type.setCurrentIndex(aw.modbus.type)
        
        # host (IP or hostname)
        modbus_hostlabel = QLabel(QApplication.translate("Label", "Host",None))
        self.modbus_hostEdit = QLineEdit(str(aw.modbus.host))
        self.modbus_hostEdit.setFixedWidth(120)
        self.modbus_hostEdit.setAlignment(Qt.AlignRight)
        # port (default 502)
        modbus_portlabel = QLabel(QApplication.translate("Label", "Port",None))
        self.modbus_portEdit = QLineEdit(str(aw.modbus.port))
        self.modbus_portEdit.setValidator(QIntValidator(1,65535,self.modbus_portEdit))
        self.modbus_portEdit.setFixedWidth(60)
        self.modbus_portEdit.setAlignment(Qt.AlignRight)
        
        # modbus external PID conf
        modbus_PIDslave_label = QLabel(QApplication.translate("Label", "Slave",None))
        self.modbus_PIDslave_Edit = QLineEdit(str(aw.modbus.PID_slave_ID))
        self.modbus_PIDslave_Edit.setValidator(QIntValidator(0,65536,self.modbus_PIDslave_Edit))
        self.modbus_PIDslave_Edit.setFixedWidth(50)
        self.modbus_PIDslave_Edit.setAlignment(Qt.AlignRight)       
        modbus_SVregister_label = QLabel(QApplication.translate("Label", "SV",None))
        self.modbus_SVregister_Edit = QLineEdit(str(aw.modbus.PID_SV_register))
        self.modbus_SVregister_Edit.setValidator(QIntValidator(0,65536,self.modbus_SVregister_Edit))
        self.modbus_SVregister_Edit.setFixedWidth(50)
        self.modbus_SVregister_Edit.setAlignment(Qt.AlignRight)
        
        modbus_multis = ["", "10","100"]
        
        modbus_SVmultiplier_label = QLabel(QApplication.translate("Label", "SV Multiplier",None))
        self.modbus_SVmultiplier = QComboBox()
        self.modbus_SVmultiplier.setFocusPolicy(Qt.NoFocus)
        self.modbus_SVmultiplier.addItems(modbus_multis)
        self.modbus_SVmultiplier.setCurrentIndex(aw.modbus.SVmultiplier)
        self.modbus_SVmultiplier.setFixedWidth(70)
        
        modbus_PIDmultiplier_label = QLabel(QApplication.translate("Label", "p-i-d Multiplier",None))
        self.modbus_PIDmultiplier = QComboBox()
        self.modbus_PIDmultiplier.setFocusPolicy(Qt.NoFocus)
        self.modbus_PIDmultiplier.addItems(modbus_multis)
        self.modbus_PIDmultiplier.setCurrentIndex(aw.modbus.PIDmultiplier)
        self.modbus_PIDmultiplier.setFixedWidth(70)
                
        modbus_Pregister_label = QLabel(QApplication.translate("Label", "P",None))
        self.modbus_Pregister_Edit = QLineEdit(str(aw.modbus.PID_p_register))
        self.modbus_Pregister_Edit.setValidator(QIntValidator(0,65536,self.modbus_Pregister_Edit))
        self.modbus_Pregister_Edit.setFixedWidth(50)
        self.modbus_Pregister_Edit.setAlignment(Qt.AlignRight)
                
        modbus_Iregister_label = QLabel(QApplication.translate("Label", "I",None))
        self.modbus_Iregister_Edit = QLineEdit(str(aw.modbus.PID_i_register))
        self.modbus_Iregister_Edit.setValidator(QIntValidator(0,65536,self.modbus_Iregister_Edit))
        self.modbus_Iregister_Edit.setFixedWidth(50)
        self.modbus_Iregister_Edit.setAlignment(Qt.AlignRight)
                
        modbus_Dregister_label = QLabel(QApplication.translate("Label", "D",None))
        self.modbus_Dregister_Edit = QLineEdit(str(aw.modbus.PID_d_register))
        self.modbus_Dregister_Edit.setValidator(QIntValidator(0,65536,self.modbus_Dregister_Edit))
        self.modbus_Dregister_Edit.setFixedWidth(50)
        self.modbus_Dregister_Edit.setAlignment(Qt.AlignRight)
        
        modbus_pid_registers = QHBoxLayout()
        modbus_pid_registers.addWidget(modbus_SVregister_label)
        modbus_pid_registers.addWidget(self.modbus_SVregister_Edit)
        modbus_pid_registers.addSpacing(35)
        modbus_pid_registers.addWidget(modbus_Pregister_label)
        modbus_pid_registers.addWidget(self.modbus_Pregister_Edit)
        modbus_pid_registers.addSpacing(15)
        modbus_pid_registers.addWidget(modbus_Iregister_label)
        modbus_pid_registers.addWidget(self.modbus_Iregister_Edit)
        modbus_pid_registers.addSpacing(15)
        modbus_pid_registers.addWidget(modbus_Dregister_label)
        modbus_pid_registers.addWidget(self.modbus_Dregister_Edit)
        
        modbus_pid_multipliers = QHBoxLayout()
        modbus_pid_multipliers.addWidget(self.modbus_SVmultiplier)
        modbus_pid_multipliers.addWidget(modbus_SVmultiplier_label)
        modbus_pid_multipliers.addStretch()
        modbus_pid_multipliers.addWidget(modbus_PIDmultiplier_label)
        modbus_pid_multipliers.addWidget(self.modbus_PIDmultiplier)
        
        modbus_pid_regmulti = QVBoxLayout()
        modbus_pid_regmulti.addLayout(modbus_pid_registers)
        modbus_pid_regmulti.addLayout(modbus_pid_multipliers)
        
        modbus_pid_registers_box = QGroupBox(QApplication.translate("GroupBox","Registers",None))
        modbus_pid_registers_box.setLayout(modbus_pid_regmulti)
        modbus_pid_regmulti.setContentsMargins(2,2,20,2)
        
        modbus_pid_off_label = QLabel(QApplication.translate("Label", "OFF", None))
        self.modbus_pid_off = QLineEdit(aw.modbus.PID_OFF_action)
        self.modbus_pid_off.setToolTip(QApplication.translate("Tooltip", "OFF Action String", None))
        modbus_pid_on_label = QLabel(QApplication.translate("Label", "ON", None))
        self.modbus_pid_on = QLineEdit(aw.modbus.PID_ON_action)
        self.modbus_pid_on.setToolTip(QApplication.translate("Tooltip", "ON Action String", None))

        modbus_pid_commands = QGridLayout()
        modbus_pid_commands.addWidget(modbus_pid_on_label,0,0)
        modbus_pid_commands.addWidget(self.modbus_pid_on,0,1)
        modbus_pid_commands.addWidget(modbus_pid_off_label,1,0)
        modbus_pid_commands.addWidget(self.modbus_pid_off,1,1)
        
        modbus_pid_commands_box = QGroupBox(QApplication.translate("GroupBox","Commands",None))
        modbus_pid_commands_box.setLayout(modbus_pid_commands)
        modbus_pid_commands.setContentsMargins(2,2,20,2)
        
        modbus_pid = QHBoxLayout()
        modbus_pid.addStretch()
        modbus_pid.addWidget(modbus_PIDslave_label)
        modbus_pid.addWidget(self.modbus_PIDslave_Edit)
        modbus_pid.addWidget(modbus_pid_registers_box)
        modbus_pid.addWidget(modbus_pid_commands_box)
        modbus_pid.addStretch()

        modbus_pidgroup = QGroupBox(QApplication.translate("GroupBox", "PID",None))
        modbus_pidgroup.setLayout(modbus_pid)
        modbus_pid.setContentsMargins(0,10,0,0)
        modbus_pidgroup.setContentsMargins(0,20,0,3)
        
        scanButton = QPushButton(QApplication.translate("Button","Scan",None))
        scanButton.setToolTip(QApplication.translate("Tooltip","Scan MODBUS",None))
        scanButton.setFocusPolicy(Qt.NoFocus)
        scanButton.clicked.connect(self.scanModbus)

        ##########################    TAB 4 WIDGETS   SCALE
        scale_devicelabel = QLabel(QApplication.translate("Label", "Device", None))
        self.scale_deviceEdit = QComboBox()
        supported_scales = list(aw.scale.devicefunctionlist.keys())
        self.scale_deviceEdit.addItems(supported_scales)
        try:
            self.scale_deviceEdit.setCurrentIndex(supported_scales.index(aw.scale.device))
        except Exception:
            self.scale_deviceEdit.setCurrentIndex(0)
        self.scale_deviceEdit.setEditable(False)
        scale_devicelabel.setBuddy(self.scale_deviceEdit)
        scale_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None))
        self.scale_comportEdit = PortComboBox(selection = aw.scale.comport)
        self.scale_comportEdit.activated.connect(self.portComboBoxIndexChanged)
        scale_comportlabel.setBuddy(self.scale_comportEdit)
        scale_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None))
        self.scale_baudrateComboBox = QComboBox()
        scale_baudratelabel.setBuddy(self.scale_baudrateComboBox)
        self.scale_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.scale_baudrateComboBox.addItems(self.scale_bauds)
        self.scale_baudrateComboBox.setCurrentIndex(self.scale_bauds.index(str(aw.scale.baudrate)))
        scale_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None))
        self.scale_bytesizeComboBox = QComboBox()
        scale_bytesizelabel.setBuddy(self.scale_bytesizeComboBox)
        self.scale_bytesizes = ["7","8"]
        self.scale_bytesizeComboBox.addItems(self.scale_bytesizes)
        self.scale_bytesizeComboBox.setCurrentIndex(self.scale_bytesizes.index(str(aw.scale.bytesize)))
        scale_paritylabel = QLabel(QApplication.translate("Label", "Parity",None))
        self.scale_parityComboBox = QComboBox()
        scale_paritylabel.setBuddy(self.scale_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.scale_parity = ["O","E","N"]
        self.scale_parityComboBox.addItems(self.scale_parity)
        self.scale_parityComboBox.setCurrentIndex(self.scale_parity.index(aw.scale.parity))
        scale_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None))
        self.scale_stopbitsComboBox = QComboBox()
        scale_stopbitslabel.setBuddy(self.scale_stopbitsComboBox)
        self.scale_stopbits = ["1","2"]
        self.scale_stopbitsComboBox.addItems(self.stopbits)
        self.scale_stopbitsComboBox.setCurrentIndex(aw.scale.stopbits - 1)
        scale_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None))
        self.scale_timeoutEdit = QLineEdit(str(aw.float2float(aw.scale.timeout)))
        self.scale_timeoutEdit.setValidator(aw.createCLocaleDoubleValidator(0,5,1,self.scale_timeoutEdit))
        ##########################    TAB 5 WIDGETS   COLOR
        color_devicelabel = QLabel(QApplication.translate("Label", "Device", None))
        self.color_deviceEdit = QComboBox()
        supported_color_meters = list(aw.color.devicefunctionlist.keys())
        self.color_deviceEdit.addItems(supported_color_meters)
        try:
            self.color_deviceEdit.setCurrentIndex(supported_color_meters.index(aw.color.device))
        except Exception:
            self.color_deviceEdit.setCurrentIndex(0)
        self.color_deviceEdit.setEditable(False)
        self.color_deviceEdit.activated.connect(self.colorDeviceIndexChanged)
        color_devicelabel.setBuddy(self.color_deviceEdit)
        color_comportlabel = QLabel(QApplication.translate("Label", "Comm Port", None))
        self.color_comportEdit = PortComboBox(selection = aw.color.comport)
        self.color_comportEdit.activated.connect(self.portComboBoxIndexChanged)
        color_comportlabel.setBuddy(self.color_comportEdit)
        color_baudratelabel = QLabel(QApplication.translate("Label", "Baud Rate", None))
        self.color_baudrateComboBox = QComboBox()
        color_baudratelabel.setBuddy(self.color_baudrateComboBox)
        self.color_bauds = ["1200","2400","4800","9600","19200","38400","57600","115200"]
        self.color_baudrateComboBox.addItems(self.color_bauds)
        self.color_baudrateComboBox.setCurrentIndex(self.color_bauds.index(str(aw.color.baudrate)))
        color_bytesizelabel = QLabel(QApplication.translate("Label", "Byte Size",None))
        self.color_bytesizeComboBox = QComboBox()
        color_bytesizelabel.setBuddy(self.color_bytesizeComboBox)
        self.color_bytesizes = ["7","8"]
        self.color_bytesizeComboBox.addItems(self.color_bytesizes)
        self.color_bytesizeComboBox.setCurrentIndex(self.color_bytesizes.index(str(aw.color.bytesize)))
        color_paritylabel = QLabel(QApplication.translate("Label", "Parity",None))
        self.color_parityComboBox = QComboBox()
        color_paritylabel.setBuddy(self.color_parityComboBox)
        #0 = Odd, E = Even, N = None. NOTE: These strings cannot be translated as they are arguments to the lib pyserial.
        self.color_parity = ["O","E","N"]
        self.color_parityComboBox.addItems(self.color_parity)
        self.color_parityComboBox.setCurrentIndex(self.color_parity.index(aw.color.parity))
        color_stopbitslabel = QLabel(QApplication.translate("Label", "Stopbits",None))
        self.color_stopbitsComboBox = QComboBox()
        color_stopbitslabel.setBuddy(self.color_stopbitsComboBox)
        self.color_stopbits = ["1","2"]
        self.color_stopbitsComboBox.addItems(self.stopbits)
        self.color_stopbitsComboBox.setCurrentIndex(aw.color.stopbits - 1)
        color_timeoutlabel = QLabel(QApplication.translate("Label", "Timeout",None))
        self.color_timeoutEdit = QLineEdit(str(aw.color.timeout))
        self.color_timeoutEdit.setValidator(aw.createCLocaleDoubleValidator(0,5,1,self.color_timeoutEdit))
        #### dialog buttons
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.rejected.connect(self.close)
        
        helpButton = self.dialogbuttons.addButton(QDialogButtonBox.Help)
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None))
        if aw.locale not in aw.qtbase_locales:
            helpButton.setText(QApplication.translate("Button","Help", None))
        helpButton.clicked.connect(self.showModbusbuttonhelp)
        
        #button layout
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(self.dialogbuttons)
        #LAYOUT TAB 1
        tab1Layout = QVBoxLayout()
        tab1Layout.addWidget(etbt_help_label)
        devid = aw.qmc.device
        if not(devid in aw.qmc.nonSerialDevices) and not(devid == 0 and aw.ser.useModbusPort): # hide serial confs for MODBUS, Phidget and Yocto devices
            grid = QGridLayout()
            grid.addWidget(comportlabel,0,0,Qt.AlignRight)
            grid.addWidget(self.comportEdit,0,1)
            grid.addWidget(baudratelabel,1,0,Qt.AlignRight)
            grid.addWidget(self.baudrateComboBox,1,1)
            grid.addWidget(bytesizelabel,2,0,Qt.AlignRight)
            grid.addWidget(self.bytesizeComboBox,2,1)
            grid.addWidget(paritylabel,3,0,Qt.AlignRight)
            grid.addWidget(self.parityComboBox,3,1)
            grid.addWidget(stopbitslabel,4,0,Qt.AlignRight)
            grid.addWidget(self.stopbitsComboBox,4,1)
            grid.addWidget(timeoutlabel,5,0,Qt.AlignRight)
            grid.addWidget(self.timeoutEdit,5,1)
            gridBoxLayout = QHBoxLayout()
            gridBoxLayout.addLayout(grid)
            gridBoxLayout.addStretch()
            tab1Layout.addLayout(gridBoxLayout)
        tab1Layout.addStretch()
        #LAYOUT TAB 2
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.serialtable)
        #LAYOUT TAB 3
        modbus_grid = QGridLayout()
        modbus_grid.addWidget(modbus_comportlabel,0,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_comportEdit,0,1)
        modbus_grid.addWidget(modbus_baudratelabel,1,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_baudrateComboBox,1,1)
        modbus_grid.addWidget(modbus_bytesizelabel,2,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_bytesizeComboBox,2,1)
        modbus_grid.addWidget(modbus_paritylabel,3,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_parityComboBox,3,1)
        modbus_grid.addWidget(modbus_stopbitslabel,4,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_stopbitsComboBox,4,1)
        modbus_grid.addWidget(modbus_timeoutlabel,5,0,Qt.AlignRight)
        modbus_grid.addWidget(self.modbus_timeoutEdit,5,1)
        modbus_grid.setContentsMargins(5,5,5,5)
        modbus_grid.setSpacing(7)
        modbus_gridV = QVBoxLayout()
        modbus_gridV.addStretch()
        modbus_gridV.addLayout(modbus_grid)
        modbus_gridV.addStretch()
        
        modbus_input_grid = QGridLayout()
        
        modbus_input_grid.addWidget(modbus_input1slavelabel,1,0,Qt.AlignRight)
        modbus_input_grid.addWidget(modbus_input1registerlabel,2,0,Qt.AlignRight)
        modbus_input_grid.addWidget(modbus_input1codelabel,3,0,Qt.AlignRight)
        modbus_input_grid.addWidget(modbus_input1divlabel,4,0,Qt.AlignRight)
        modbus_input_grid.addWidget(modbus_input1modelabel,5,0,Qt.AlignRight)
        modbus_input_grid.addWidget(modbus_input1floatlabel,6,0,Qt.AlignRight)
        
        for i in range(aw.modbus.channels):
            modbus_input_grid.addWidget(QLabel(QApplication.translate("GroupBox", "Input",None) + " " + str(i+1)),0,i+1,Qt.AlignCenter)
            modbus_input_grid.addWidget(self.modbus_inputSlaveEdits[i],1,i+1)
            modbus_input_grid.addWidget(self.modbus_inputRegisterEdits[i],2,i+1)
            modbus_input_grid.addWidget(self.modbus_inputCodes[i],3,i+1)
            modbus_input_grid.addWidget(self.modbus_inputDivs[i],4,i+1)
            modbus_input_grid.addWidget(self.modbus_inputModes[i],5,i+1)
            modbus_input_grid.addWidget(self.modbus_inputDecodes[i],6,i+1,Qt.AlignCenter)
        
        modbus_gridVLayout = QHBoxLayout()
        modbus_gridVLayout.addLayout(modbus_gridV)
        modbus_gridVLayout.addStretch()
        modbus_gridVLayout.addLayout(modbus_input_grid)
        modbus_gridVLayout.addStretch()
        modbus_setup = QHBoxLayout()
        modbus_setup.addWidget(scanButton)
        modbus_setup.addStretch()
        modbus_setup.addSpacing(7)
        modbus_setup.addWidget(modbus_endianlabel)
        modbus_setup.addSpacing(5)
        modbus_setup.addWidget(self.modbus_littleEndianBytes)
        modbus_setup.addSpacing(5)
        modbus_setup.addWidget(self.modbus_littleEndianWords)
        modbus_setup.addSpacing(7)
        modbus_setup.addStretch()
        modbus_setup.addWidget(modbus_typelabel)
        modbus_setup.addWidget(self.modbus_type)
        modbus_setup.addStretch()
        modbus_setup.addWidget(modbus_hostlabel)
        modbus_setup.addWidget(self.modbus_hostEdit)
        modbus_setup.addSpacing(7)
        modbus_setup.addWidget(modbus_portlabel)
        modbus_setup.addWidget(self.modbus_portEdit)
        tab3Layout = QVBoxLayout()
        tab3Layout.addLayout(modbus_gridVLayout)
        tab3Layout.addWidget(modbus_pidgroup)
        tab3Layout.addLayout(modbus_setup)
        tab3Layout.addStretch()
        tab3Layout.setContentsMargins(0,0,0,0)
        tab3Layout.setSpacing(5)
        
        #LAYOUT TAB 4
        # host (IP or hostname)
        s7_hostlabel = QLabel(QApplication.translate("Label", "Host",None))
        self.s7_hostEdit = QLineEdit(str(aw.s7.host))
        self.s7_hostEdit.setFixedWidth(120)
        self.s7_hostEdit.setAlignment(Qt.AlignRight)
        # port (default 102)
        s7_portlabel = QLabel(QApplication.translate("Label", "Port",None))
        self.s7_portEdit = QLineEdit(str(aw.s7.port))
        self.s7_portEdit.setValidator(QIntValidator(1,65535,self.s7_portEdit))
        self.s7_portEdit.setFixedWidth(60)
        self.s7_portEdit.setAlignment(Qt.AlignRight)
        # rack (default 0)
        s7_racklabel = QLabel(QApplication.translate("Label", "Rack",None))
        self.s7_rackEdit = QLineEdit(str(aw.s7.rack))
        self.s7_rackEdit.setValidator(QIntValidator(0,7,self.s7_rackEdit))
        self.s7_rackEdit.setFixedWidth(60)
        self.s7_rackEdit.setAlignment(Qt.AlignRight)
        # slot (default 0)
        s7_slotlabel = QLabel(QApplication.translate("Label", "Slot",None))
        self.s7_slotEdit = QLineEdit(str(aw.s7.slot))
        self.s7_slotEdit.setValidator(QIntValidator(0,31,self.s7_slotEdit))
        self.s7_slotEdit.setFixedWidth(60)
        self.s7_slotEdit.setAlignment(Qt.AlignRight)

        s7_areaLabel = QLabel(QApplication.translate("Label", "Area",None))
        s7_dbLabel = QLabel(QApplication.translate("Label", "DB#",None))
        s7_startLabel = QLabel(QApplication.translate("Label", "Start",None))
        s7_typeLabel = QLabel(QApplication.translate("Label", "Type",None))
        s7_modeLabel = QLabel(QApplication.translate("Label", "Mode",None))
        s7_divLabel = QLabel(QApplication.translate("Label", "Factor",None))
        
        self.s7_channelLabels = []
        self.s7_areaCombos = []
        self.s7_dbEdits = []
        self.s7_startEdits = []
        self.s7_typeCombos = []
        self.s7_modeCombos = []
        self.s7_divCombos = []
        
        s7_areas = [" ","PE","PA","MK","CT","TM","DB"]
        s7_types = ["Int", "Float"]
        
        s7_grid = QGridLayout()
        
        s7_grid.addWidget(s7_areaLabel,1,0,Qt.AlignRight)
        s7_grid.addWidget(s7_dbLabel,2,0,Qt.AlignRight)
        s7_grid.addWidget(s7_startLabel,3,0,Qt.AlignRight)
        s7_grid.addWidget(s7_typeLabel,4,0,Qt.AlignRight)
        s7_grid.addWidget(s7_divLabel,5,0,Qt.AlignRight)
        s7_grid.addWidget(s7_modeLabel,6,0,Qt.AlignRight)
        
        for i in range(aw.s7.channels):
            # channel label
            label = QLabel(QApplication.translate("Label", "Input",None) + " " + str(i+1))
            self.s7_channelLabels.append(label)
            s7_grid.addWidget(label,0,i+1,Qt.AlignRight)
            # area combo
            area = QComboBox()
            area.setFocusPolicy(Qt.NoFocus)
            area.addItems(s7_areas)
            area.setCurrentIndex(aw.s7.area[i])
            area.setFixedWidth(70)
            self.s7_areaCombos.append(area) 
            s7_grid.addWidget(area,1,i+1,Qt.AlignRight)
            # db edit: 1-16000
            dbEdit = QLineEdit(str(aw.s7.db_nr[i]))
            dbEdit.setFixedWidth(65)
            dbEdit.setAlignment(Qt.AlignRight)
            self.s7_dbEdits.append(dbEdit)
            dbEdit.setValidator(QIntValidator(1,16000,self.s7_dbEdits[i]))
            s7_grid.addWidget(dbEdit,2,i+1,Qt.AlignRight)
            # start edit:
            startEdit = QLineEdit(str(aw.s7.start[i]))
            startEdit.setFixedWidth(65)
            startEdit.setAlignment(Qt.AlignRight)
            self.s7_startEdits.append(startEdit)
            startEdit.setValidator(QIntValidator(0,65536,self.s7_startEdits[i]))
            s7_grid.addWidget(startEdit,3,i+1,Qt.AlignRight)
            # type combo: Int, Float
            tp = QComboBox()
            tp.setFocusPolicy(Qt.NoFocus)
            tp.addItems(s7_types)
            tp.setCurrentIndex(aw.s7.type[i])
            tp.setFixedWidth(70)
            self.s7_typeCombos.append(tp)
            s7_grid.addWidget(tp,4,i+1,Qt.AlignRight)
            # div combo: -,1/10,1/100
            div = QComboBox()
            div.setFocusPolicy(Qt.NoFocus)
            div.addItems(modbus_divs)
            div.setCurrentIndex(aw.s7.div[i])
            div.setFixedWidth(70)
            self.s7_divCombos.append(div)
            s7_grid.addWidget(div,5,i+1,Qt.AlignRight)
            # mode combo: -,C,F
            mode = QComboBox()
            mode.setFocusPolicy(Qt.NoFocus)
            mode.addItems(modbus_modes)
            mode.setCurrentIndex(aw.s7.mode[i])
            mode.setFixedWidth(70) 
            self.s7_modeCombos.append(mode)
            s7_grid.addWidget(mode,6,i+1,Qt.AlignRight)
          
        # s7 external PID conf
        
        s7_PIDareaLabel = QLabel(QApplication.translate("Label", "Area",None))
        self.s7_PIDarea = QComboBox()
        self.s7_PIDarea.setFocusPolicy(Qt.NoFocus)
        self.s7_PIDarea.addItems(s7_areas)
        self.s7_PIDarea.setCurrentIndex(aw.s7.PID_area)
        self.s7_PIDarea.setFixedWidth(70)                    
        s7_PIDdb_nr_label = QLabel(QApplication.translate("Label", "DB#",None))
        self.s7_PIDdb_nr_Edit = QLineEdit(str(aw.s7.PID_db_nr))
        self.s7_PIDdb_nr_Edit.setValidator(QIntValidator(0,65536,self.s7_PIDdb_nr_Edit))
        self.s7_PIDdb_nr_Edit.setFixedWidth(50)
        self.s7_PIDdb_nr_Edit.setAlignment(Qt.AlignRight)       
        s7_SVregister_label = QLabel(QApplication.translate("Label", "SV",None))
        self.s7_SVregister_Edit = QLineEdit(str(aw.s7.PID_SV_register))
        self.s7_SVregister_Edit.setValidator(QIntValidator(0,65536,self.s7_SVregister_Edit))
        self.s7_SVregister_Edit.setFixedWidth(50)
        self.s7_SVregister_Edit.setAlignment(Qt.AlignRight)
        
        s7_multis = ["", "10","100"]
        
        s7_SVmultiplier_label = QLabel(QApplication.translate("Label", "SV Multiplier",None))
        self.s7_SVmultiplier = QComboBox()
        self.s7_SVmultiplier.setFocusPolicy(Qt.NoFocus)
        self.s7_SVmultiplier.addItems(s7_multis)
        self.s7_SVmultiplier.setCurrentIndex(aw.s7.SVmultiplier)
        self.s7_SVmultiplier.setFixedWidth(70)
        
        s7_PIDmultiplier_label = QLabel(QApplication.translate("Label", "p-i-d Multiplier",None))
        self.s7_PIDmultiplier = QComboBox()
        self.s7_PIDmultiplier.setFocusPolicy(Qt.NoFocus)
        self.s7_PIDmultiplier.addItems(s7_multis)
        self.s7_PIDmultiplier.setCurrentIndex(aw.s7.PIDmultiplier)
        self.s7_PIDmultiplier.setFixedWidth(70)
                
        s7_Pregister_label = QLabel(QApplication.translate("Label", "P",None))
        self.s7_Pregister_Edit = QLineEdit(str(aw.s7.PID_p_register))
        self.s7_Pregister_Edit.setValidator(QIntValidator(0,65536,self.s7_Pregister_Edit))
        self.s7_Pregister_Edit.setFixedWidth(50)
        self.s7_Pregister_Edit.setAlignment(Qt.AlignRight)
                
        s7_Iregister_label = QLabel(QApplication.translate("Label", "I",None))
        self.s7_Iregister_Edit = QLineEdit(str(aw.s7.PID_i_register))
        self.s7_Iregister_Edit.setValidator(QIntValidator(0,65536,self.s7_Iregister_Edit))
        self.s7_Iregister_Edit.setFixedWidth(50)
        self.s7_Iregister_Edit.setAlignment(Qt.AlignRight)
                
        s7_Dregister_label = QLabel(QApplication.translate("Label", "D",None))
        self.s7_Dregister_Edit = QLineEdit(str(aw.s7.PID_d_register))
        self.s7_Dregister_Edit.setValidator(QIntValidator(0,65536,self.s7_Dregister_Edit))
        self.s7_Dregister_Edit.setFixedWidth(50)
        self.s7_Dregister_Edit.setAlignment(Qt.AlignRight)
        
        s7_pid_registers = QHBoxLayout()
        s7_pid_registers.addWidget(s7_SVregister_label)
        s7_pid_registers.addWidget(self.s7_SVregister_Edit)
        s7_pid_registers.addSpacing(35)
        s7_pid_registers.addWidget(s7_Pregister_label)
        s7_pid_registers.addWidget(self.s7_Pregister_Edit)
        s7_pid_registers.addSpacing(15)
        s7_pid_registers.addWidget(s7_Iregister_label)
        s7_pid_registers.addWidget(self.s7_Iregister_Edit)
        s7_pid_registers.addSpacing(15)
        s7_pid_registers.addWidget(s7_Dregister_label)
        s7_pid_registers.addWidget(self.s7_Dregister_Edit)
        
        s7_pid_multipliers = QHBoxLayout()
        s7_pid_multipliers.addWidget(self.s7_SVmultiplier)
        s7_pid_multipliers.addWidget(s7_SVmultiplier_label)
        s7_pid_multipliers.addStretch()
        s7_pid_multipliers.addWidget(s7_PIDmultiplier_label)
        s7_pid_multipliers.addWidget(self.s7_PIDmultiplier)
        
        s7_pid_regmulti = QVBoxLayout()
        s7_pid_regmulti.addLayout(s7_pid_registers)
        s7_pid_regmulti.addLayout(s7_pid_multipliers)
        
        s7_pid_registers_box = QGroupBox(QApplication.translate("GroupBox","Registers",None))
        s7_pid_registers_box.setLayout(s7_pid_regmulti)
        s7_pid_regmulti.setContentsMargins(2,2,20,2)
        
        s7_pid_off_label = QLabel(QApplication.translate("Label", "OFF", None))
        self.s7_pid_off = QLineEdit(aw.s7.PID_OFF_action)
        self.s7_pid_off.setToolTip(QApplication.translate("Tooltip", "OFF Action String", None))
        s7_pid_on_label = QLabel(QApplication.translate("Label", "ON", None))
        self.s7_pid_on = QLineEdit(aw.s7.PID_ON_action)
        self.s7_pid_on.setToolTip(QApplication.translate("Tooltip", "ON Action String", None))
                  
        s7_pid_commands = QGridLayout()
        s7_pid_commands.addWidget(s7_pid_on_label,0,0)
        s7_pid_commands.addWidget(self.s7_pid_on,0,1)
        s7_pid_commands.addWidget(s7_pid_off_label,1,0)
        s7_pid_commands.addWidget(self.s7_pid_off,1,1)
        
        s7_pid_commands_box = QGroupBox(QApplication.translate("GroupBox","Commands",None))
        s7_pid_commands_box.setLayout(s7_pid_commands)
        s7_pid_commands.setContentsMargins(2,2,20,2)
        
        s7_pid_area = QHBoxLayout()
        s7_pid_area.addWidget(s7_PIDareaLabel)
        s7_pid_area.addWidget(self.s7_PIDarea)
        
        s7_pid_dbnr = QHBoxLayout()
        s7_pid_dbnr.addWidget(s7_PIDdb_nr_label)
        s7_pid_dbnr.addWidget(self.s7_PIDdb_nr_Edit)
        
        s7_pid_base = QVBoxLayout()
        s7_pid_base.addLayout(s7_pid_area)
        s7_pid_base.addLayout(s7_pid_dbnr)
        
        s7_pid = QHBoxLayout()
        s7_pid.addStretch()
        s7_pid.addLayout(s7_pid_base)
        s7_pid.addWidget(s7_pid_registers_box)
        s7_pid.addWidget(s7_pid_commands_box)
        s7_pid.addStretch()
                                    
        s7_pidgroup = QGroupBox(QApplication.translate("GroupBox", "PID",None))
        s7_pidgroup.setLayout(s7_pid)
        s7_pid.setContentsMargins(0,10,0,0)
        s7_pidgroup.setContentsMargins(0,20,0,3)
        
        s7_gridHLayout = QHBoxLayout()
        s7_gridHLayout.addStretch()
        s7_gridHLayout.addLayout(s7_grid)
        s7_gridHLayout.addStretch()
        
        s7_setup = QHBoxLayout()
        s7_setup.addStretch()
        s7_setup.addWidget(s7_hostlabel)
        s7_setup.addWidget(self.s7_hostEdit)
        s7_setup.addSpacing(7)
        s7_setup.addWidget(s7_portlabel)
        s7_setup.addWidget(self.s7_portEdit)
        s7_setup.addStretch()
        s7_setup.addWidget(s7_racklabel)
        s7_setup.addWidget(self.s7_rackEdit)
        s7_setup.addSpacing(7)
        s7_setup.addWidget(s7_slotlabel)
        s7_setup.addWidget(self.s7_slotEdit)
        s7_setup.addStretch()
        
        tab4Layout = QVBoxLayout()
        tab4Layout.addStretch()
        tab4Layout.addLayout(s7_gridHLayout)
        tab4Layout.addWidget(s7_pidgroup)
        tab4Layout.addStretch()
        tab4Layout.addLayout(s7_setup)
        tab4Layout.addStretch()
        tab4Layout.setContentsMargins(0,0,0,0)
        tab4Layout.setSpacing(5)
        
        #LAYOUT TAB 5
        scale_grid = QGridLayout()
        scale_grid.addWidget(scale_devicelabel,0,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_deviceEdit,0,1)
        scale_grid.addWidget(scale_comportlabel,1,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_comportEdit,1,1)
        scale_grid.addWidget(scale_baudratelabel,2,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_baudrateComboBox,2,1)
        scale_grid.addWidget(scale_bytesizelabel,3,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_bytesizeComboBox,3,1)
        scale_grid.addWidget(scale_paritylabel,4,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_parityComboBox,4,1)
        scale_grid.addWidget(scale_stopbitslabel,5,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_stopbitsComboBox,5,1)
        scale_grid.addWidget(scale_timeoutlabel,6,0,Qt.AlignRight)
        scale_grid.addWidget(self.scale_timeoutEdit,6,1)
        scaleH = QHBoxLayout()
        scaleH.addLayout(scale_grid)
        scaleH.addStretch()
        tab5Layout = QVBoxLayout()
        tab5Layout.addLayout(scaleH)
        tab5Layout.addStretch()
        
        #LAYOUT TAB 6
        color_grid = QGridLayout()
        color_grid.addWidget(color_devicelabel,0,0,Qt.AlignRight)
        color_grid.addWidget(self.color_deviceEdit,0,1)
        color_grid.addWidget(color_comportlabel,1,0,Qt.AlignRight)
        color_grid.addWidget(self.color_comportEdit,1,1)
        color_grid.addWidget(color_baudratelabel,2,0,Qt.AlignRight)
        color_grid.addWidget(self.color_baudrateComboBox,2,1)
        color_grid.addWidget(color_bytesizelabel,3,0,Qt.AlignRight)
        color_grid.addWidget(self.color_bytesizeComboBox,3,1)
        color_grid.addWidget(color_paritylabel,4,0,Qt.AlignRight)
        color_grid.addWidget(self.color_parityComboBox,4,1)
        color_grid.addWidget(color_stopbitslabel,5,0,Qt.AlignRight)
        color_grid.addWidget(self.color_stopbitsComboBox,5,1)
        color_grid.addWidget(color_timeoutlabel,6,0,Qt.AlignRight)
        color_grid.addWidget(self.color_timeoutEdit,6,1)
        colorH = QHBoxLayout()
        colorH.addLayout(color_grid)
        colorH.addStretch()
        tab6Layout = QVBoxLayout()
        tab6Layout.addLayout(colorH)
        tab6Layout.addStretch()
        #tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Modbus",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","S7",None))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Scale",None))
        C6Widget = QWidget()
        C6Widget.setLayout(tab6Layout)
        TabWidget.addTab(C6Widget,QApplication.translate("Tab","Color",None))
        TabWidget.currentChanged.connect(self.tabSwitched)
        
        if devid == 29 or (devid == 0 and aw.ser.useModbusPort) : # switch to MODBUS tab if MODBUS device was selected as main device
            # or if PID and "Use ModbusPort" was selected
            TabWidget.setCurrentIndex(2)
        elif devid == 79: # switch to S7 tab if S7 device was selected as main device
            TabWidget.setCurrentIndex(3)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        Mlayout.setContentsMargins(5,15,5,5)
        Mlayout.setSpacing(5)
        self.setLayout(Mlayout)
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
    
    @pyqtSlot(int)
    def colorDeviceIndexChanged(self,i):
        try:
            if i==2: # Classic Tonino
                aw.color.baudrate = 115200
            elif i==1: # Tiny Tonino
                aw.color.baudrate = 57600
            self.color_baudrateComboBox.setCurrentIndex(self.color_bauds.index(str(aw.color.baudrate)))
        except:
            pass
    
    @pyqtSlot(bool)
    def scanModbus(self,_):
        scan_mobuds_dlg = scanModbusDlg(self)
        scan_mobuds_dlg.port = str(self.modbus_comportEdit.getSelection())
        scan_mobuds_dlg.baudrate = int(str(self.modbus_baudrateComboBox.currentText()))
        scan_mobuds_dlg.bytesize = int(str(self.modbus_bytesizeComboBox.currentText()))
        scan_mobuds_dlg.stopbits = int(str(self.modbus_stopbitsComboBox.currentText()))
        scan_mobuds_dlg.parity = str(self.modbus_parityComboBox.currentText())
        scan_mobuds_dlg.timeout = aw.float2float(toFloat(aw.comma2dot(str(self.modbus_timeoutEdit.text()))))
        scan_mobuds_dlg.mtype = int(self.modbus_type.currentIndex())
        scan_mobuds_dlg.mhost = str(self.modbus_hostEdit.text())
        scan_mobuds_dlg.mport = int(str(self.modbus_portEdit.text()))
        scan_mobuds_dlg.show()
            
    @pyqtSlot(int)
    def portComboBoxIndexChanged(self,i):
        self.sender().setSelection(i)

    def createserialTable(self):
        try:
            self.serialtable.clear()
            nssdevices = min(len(aw.extracomport),len(aw.qmc.extradevices))
            if nssdevices:
                self.serialtable.setRowCount(nssdevices)
                self.serialtable.setColumnCount(7)
                self.serialtable.setHorizontalHeaderLabels([QApplication.translate("Table","Device",None),
                                                            QApplication.translate("Table","Comm Port",None),
                                                            QApplication.translate("Table","Baud Rate",None),
                                                            QApplication.translate("Table","Byte Size",None),
                                                            QApplication.translate("Table","Parity",None),
                                                            QApplication.translate("Table","Stopbits",None),
                                                            QApplication.translate("Table","Timeout",None)])
                self.serialtable.setAlternatingRowColors(True)
                self.serialtable.setEditTriggers(QTableWidget.NoEditTriggers)
                self.serialtable.setSelectionBehavior(QTableWidget.SelectRows)
                self.serialtable.setSelectionMode(QTableWidget.SingleSelection)
                self.serialtable.setShowGrid(True)
                self.serialtable.verticalHeader().setSectionResizeMode(2)
                for i in range(nssdevices):
                    if len(aw.qmc.extradevices) > i:
                        devid = aw.qmc.extradevices[i]
                        devicename = aw.qmc.devices[max(0,devid-1)]
                        if devicename[0] == "+":
                            devname = devicename[1:]
                        else:
                            devname = devicename
                        device = QTableWidgetItem(devname)    #type identification of the device. Non editable
                        self.serialtable.setItem(i,0,device)
                        if not (devid in aw.qmc.nonSerialDevices) and devid != 29 and devicename[0] != "+": # hide serial confs for MODBUS, Phidgets and "+X" extra devices
                            comportComboBox = PortComboBox(selection = aw.extracomport[i])
                            comportComboBox.activated.connect(self.portComboBoxIndexChanged)
                            comportComboBox.setFixedWidth(200)
                            baudComboBox =  QComboBox()
                            baudComboBox.addItems(self.bauds)
                            if str(aw.extrabaudrate[i]) in self.bauds:
                                baudComboBox.setCurrentIndex(self.bauds.index(str(aw.extrabaudrate[i])))
                            byteComboBox =  QComboBox()
                            byteComboBox.addItems(self.bytesizes)
                            if str(aw.extrabytesize[i]) in self.bytesizes:
                                byteComboBox.setCurrentIndex(self.bytesizes.index(str(aw.extrabytesize[i])))
                            parityComboBox =  QComboBox()
                            parityComboBox.addItems(self.parity)
                            if aw.extraparity[i] in self.parity:
                                parityComboBox.setCurrentIndex(self.parity.index(aw.extraparity[i]))
                            stopbitsComboBox = QComboBox()
                            stopbitsComboBox.addItems(self.stopbits)
                            if str(aw.extrastopbits[i]) in self.stopbits:
                                stopbitsComboBox.setCurrentIndex(self.stopbits.index(str(aw.extrastopbits[i])))
                            timeoutEdit = QLineEdit(str(aw.extratimeout[i]))
                            timeoutEdit.setValidator(QIntValidator(1,5,timeoutEdit))
                            timeoutEdit.setFixedWidth(65)
                            timeoutEdit.setAlignment(Qt.AlignRight)
                            #add widgets to the table
                            self.serialtable.setCellWidget(i,1,comportComboBox)
                            self.serialtable.setCellWidget(i,2,baudComboBox)
                            self.serialtable.setCellWidget(i,3,byteComboBox)
                            self.serialtable.setCellWidget(i,4,parityComboBox)
                            self.serialtable.setCellWidget(i,5,stopbitsComboBox)
                            self.serialtable.setCellWidget(i,6,timeoutEdit)
                self.serialtable.resizeColumnsToContents()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " createserialTable(): {0}").format(str(e)),exc_tb.tb_lineno)

    def saveserialtable(self):
        try:
            #aw.extracomport,aw.extrabaudrate,aw.extrabytesize,aw.extraparity,aw.extrastopbits,aw.extratimeout = [],[],[],[],[],[]
            ser_ports = min(len(aw.extracomport),len(aw.qmc.extradevices))
            self.closeserialports()
            for i in range(ser_ports):
                if len(aw.qmc.extradevices) > i:
                    devid = aw.qmc.extradevices[i]
                    devicename = aw.qmc.devices[devid-1]    #type identification of the device. Non editable
                    if devid != 29 and devid != 33 and devicename[0] != "+": # hide serial confs for MODBUS and "+XX" extra devices
                        comportComboBox =  self.serialtable.cellWidget(i,1)
                        if comportComboBox:
                            aw.extracomport[i] = str(comportComboBox.getSelection())
                        baudComboBox =  self.serialtable.cellWidget(i,2)
                        if baudComboBox:
                            aw.extrabaudrate[i] = int(str(baudComboBox.currentText()))
                        byteComboBox =  self.serialtable.cellWidget(i,3)
                        if byteComboBox:
                            aw.extrabytesize[i] = int(str(byteComboBox.currentText()))
                        parityComboBox =  self.serialtable.cellWidget(i,4)
                        if parityComboBox:
                            aw.extraparity[i] = str(parityComboBox.currentText())
                        stopbitsComboBox =  self.serialtable.cellWidget(i,5)
                        if stopbitsComboBox:
                            aw.extrastopbits[i] = int(str(stopbitsComboBox.currentText()))
                        timeoutEdit = self.serialtable.cellWidget(i,6)
                        if timeoutEdit:
                            aw.extratimeout[i] = int(str(timeoutEdit.text()))
            #create serial ports for each extra device
            aw.extraser = [None]*ser_ports
            #load the settings for the extra serial ports found
            for i in range(ser_ports):
                aw.extraser[i] = serialport()
                aw.extraser[i].comport = str(aw.extracomport[i])
                aw.extraser[i].baudrate = aw.extrabaudrate[i]
                aw.extraser[i].bytesize = aw.extrabytesize[i]
                aw.extraser[i].parity = str(aw.extraparity[i])
                aw.extraser[i].stopbits = aw.extrastopbits[i]
                aw.extraser[i].timeout = aw.extratimeout[i]
        except Exception as e:
            _, _, exc_tb = sys.exc_info() 
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " saveserialtable(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def showModbusbuttonhelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = modbusHelpDlg(self)
        except:
            self.helpdialog = modbusHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

    @pyqtSlot(int)
    def tabSwitched(self,_):
        self.closeHelp()

    def closeEvent(self,_):
        self.closeHelp()

    @pyqtSlot()
    def accept(self):
        self.closeHelp()
        #validate serial parameter against input errors
        class comportError(Exception): pass
        class timeoutError(Exception): pass
        comport = str(self.comportEdit.getSelection())
        baudrate = str(self.baudrateComboBox.currentText())
        bytesize = str(self.bytesizeComboBox.currentText())
        parity = str(self.parityComboBox.currentText())
        stopbits = str(self.stopbitsComboBox.currentText())
        timeout = aw.comma2dot(str(self.timeoutEdit.text()))
        #save extra serial ports by reading the serial extra table
        self.saveserialtable()
        if not(aw.qmc.device in aw.qmc.nonSerialDevices) and not(aw.qmc.device == 0 and aw.ser.useModbusPort): # only if serial conf is not hidden
            try:
                #check here comport errors
                if not comport:
                    raise comportError
                if not timeout:
                    raise timeoutError
                #add more checks here
                aw.sendmessage(QApplication.translate("Message","Serial Port Settings: {0}, {1}, {2}, {3}, {4}, {5}", None).format(comport,baudrate,bytesize,parity,stopbits,timeout))
            except comportError:
                aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: invalid comm port", None))
                self.comportEdit.selectAll()
                self.comportEdit.setFocus()
                return
            except timeoutError:
                aw.qmc.adderror(QApplication.translate("Error Message","Serial Exception: timeout", None))
                self.timeoutEdit.selectAll()
                self.timeoutEdit.setFocus()
                return
        QDialog.accept(self)

    def closeserialports(self):
        aw.closeserialports()

########################################################################################
#####################  MODBUS HELP DLG #################################################
########################################################################################
class modbusHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(modbusHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Modbus Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("modbusHelpGeometry"):
            self.restoreGeometry(settings.value("modbusHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','MODBUS',None)) + "</b>"
        tbl_Modbustop = prettytable.PrettyTable()
        tbl_Modbustop.header = False
        tbl_Modbustop.add_row([u(QApplication.translate('HelpDlg','The MODBUS device corresponds to input channels1 and 2.. The MODBUS_34 extra device adds input channels 3 and 4.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Inputs with slave id set to 0 are turned off.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Modbus function 3 "read holding register" is the standard. Modbus function 4 triggers the use of "read input register". Input registers (fct 4) usually are from 30000-39999.',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Most devices hold data in 2 byte integer registers. A temperature of 145.2C is often sent as 1452. In that case you have to set the divider to "x/10".',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Few devices hold data as 4 byte floats in two registers. Tick the Float flag in this case.',None))])
        helpstr += tbl_Modbustop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("modbusHelpGeometry",self.saveGeometry())


#################################################################################
##################   MODBUS Scan DIALOG for testing registers    ################
#################################################################################

class scanModbusDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(scanModbusDlg,self).__init__(parent)
        self.setModal(True)
        # current setup selected in the MODBUS tab
        self.port = ""
        self.baudrate = 19200
        self.bytesize = 8
        self.stopbits = 1
        self.parity = "N"
        self.timeout = 1
        self.mtype = 1
        self.mhost = "127.0.0.1"
        self.mport = 502
        # save current MODBUS serial, type, host, port settings
        self.port_aw = aw.modbus.comport
        self.baudrate_aw = aw.modbus.baudrate
        self.bytesize_aw = aw.modbus.bytesize
        self.parity_aw = aw.modbus.parity
        self.stopbits_aw = aw.modbus.stopbits
        self.timeout_aw = aw.modbus.timeout
        self.mtype_aw = aw.modbus.type
        self.mhost_aw = aw.modbus.host
        self.mport_aw = aw.modbus.port
        self.stop = False # if True stop the processing
        self.setWindowTitle(QApplication.translate("Form Caption","Scan Modbus", None))
        self.slave = 1
        self.slaveLabel = QLabel(QApplication.translate("Label", "Slave",None))
        self.slaveEdit = QLineEdit(str(self.slave))
        self.slaveEdit.setValidator(QIntValidator(1,247,self.slaveEdit))
        self.slaveEdit.setFixedWidth(65)
        self.slaveEdit.setAlignment(Qt.AlignRight)
        self.min_register = 0
        self.registerLabel = QLabel(QApplication.translate("Label", "Register",None))
        self.toLabel = QLabel(u(uchr(8212)))
        self.minRegisterEdit = QLineEdit(str(self.min_register))
        self.minRegisterEdit.setValidator(QIntValidator(0,65536,self.minRegisterEdit))
        self.minRegisterEdit.setFixedWidth(65)
        self.minRegisterEdit.setAlignment(Qt.AlignRight)
        self.max_register = 65536
        self.maxRegisterEdit = QLineEdit(str(self.max_register))
        self.maxRegisterEdit.setValidator(QIntValidator(0,65536,self.maxRegisterEdit))
        self.maxRegisterEdit.setFixedWidth(65)
        self.maxRegisterEdit.setAlignment(Qt.AlignRight)
        self.code3 = True
        self.code4 = False
        self.checkbox3 = QCheckBox(QApplication.translate("CheckBox","Fct. 3", None))
        self.checkbox3.setChecked(self.code3)
        self.checkbox3.stateChanged.connect(self.checkbox3Changed)
        self.checkbox4 = QCheckBox(QApplication.translate("CheckBox","Fct. 4", None))
        self.checkbox4.setChecked(self.code4)
        self.checkbox4.stateChanged.connect(self.checkbox4Changed)
        self.modbusEdit = QTextEdit()
        self.modbusEdit.setReadOnly(True)
        startButton = QPushButton(QApplication.translate("Button","Start", None))
        startButton.setMaximumWidth(150)
        startButton.clicked.connect(self.start_pressed)
        labellayout = QHBoxLayout()
        labellayout.addWidget(self.slaveLabel)
        labellayout.addStretch()
        labellayout.addWidget(self.registerLabel)
        labellayout.addStretch()
        srlayout = QHBoxLayout()
        srlayout.addWidget(self.slaveEdit)
        srlayout.addStretch()
        srlayout.addWidget(self.minRegisterEdit)
        srlayout.addWidget(self.toLabel)
        srlayout.addWidget(self.maxRegisterEdit)
        cblayout= QHBoxLayout()
        cblayout.addStretch()
        cblayout.addWidget(self.checkbox3)
        cblayout.addStretch()
        cblayout.addWidget(self.checkbox4)
        cblayout.addStretch()
        hlayout = QHBoxLayout()
        hlayout.addStretch()
        hlayout.addWidget(startButton)
        hlayout.addStretch()
        layout = QVBoxLayout()
        layout.addLayout(labellayout)
        layout.addLayout(srlayout)
        layout.addLayout(cblayout)
        layout.addWidget(self.modbusEdit)
        layout.addLayout(hlayout)
        self.setLayout(layout)
        
    def keyPressEvent(self,event):
        key = int(event.key())
        if key != 0:
            self.stop = True

    @pyqtSlot(bool)
    def start_pressed(self):
        try:
            # set MODBUS serial, type, host, port settings from dialog
            aw.modbus.comport = self.port
            aw.modbus.baudrate = self.baudrate
            aw.modbus.bytesize = self.bytesize
            aw.modbus.stopbits = self.stopbits
            aw.modbus.parity = self.parity
            aw.modbus.timeout = self.timeout
            aw.modbus.type = self.mtype
            aw.modbus.host = self.mhost
            aw.modbus.port = self.mport
            self.stop = False
            
            # update slave and register limits
            self.slave = int(self.slaveEdit.text())
            self.min_register = int(self.minRegisterEdit.text())
            self.max_register = int(self.maxRegisterEdit.text())
            
            # scan and report
            result = "Register,Value<br>"
            result += "--------------<br>"
            for register in range(min(self.min_register,self.max_register),max(self.min_register,self.max_register)+1):
                QApplication.processEvents()
                if self.stop:
                    result += "<br>stopped<br>"
                    self.modbusEdit.setHtml(result)
                    break
                if self.code4:
                    aw.modbus.sleepBetween()
                    aw.modbus.sleepBetween()
                    aw.modbus.connect()
                    res = aw.modbus.peekSingleRegister(self.slave,int(register),code=4)
                    if res is not None:
                        result += str(register) + "(4)," + str(res) + "<br>"
                        self.modbusEdit.setHtml(result)
                if self.code3:
                    aw.modbus.sleepBetween()
                    aw.modbus.sleepBetween()
                    aw.modbus.connect()
                    res = aw.modbus.peekSingleRegister(self.slave,int(register),code=3)
                    if res is not None:
                        result += str(register) + "(3)," + str(res) + "<br>"
                        self.modbusEdit.setHtml(result)
        except:
            pass
        # reconstruct MODBUS setup
        aw.modbus.comport = self.port_aw
        aw.modbus.baudrate = self.baudrate_aw
        aw.modbus.bytesize = self.bytesize_aw
        aw.modbus.stopbits = self.stopbits_aw
        aw.modbus.parity = self.parity_aw
        aw.modbus.timeout = self.timeout_aw
        aw.modbus.type = self.mtype_aw
        aw.modbus.host = self.mhost_aw
        aw.modbus.port = self.mport_aw  
            
    def update(self):
        if aw.seriallogflag:
            self.modbusEdit.setText(self.getstring())

    @pyqtSlot(int)
    def checkbox3Changed(self,_):
        if self.checkbox3.isChecked():
            self.code3 = True
        else:
            self.code3 = False

    @pyqtSlot(int)
    def checkbox4Changed(self,_):
        if self.checkbox4.isChecked():
            self.code4 = True
        else:
            self.code4 = False
            
    def closeEvent(self,_):
        self.accept()


#################################################################################
##################   Device assignments DIALOG for reading temperature   ########
#################################################################################

class DeviceAssignmentDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(DeviceAssignmentDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Device Assignment", None))
        self.setModal(True)

        self.helpdialog = None
                    
        ################ TAB 1   WIDGETS
        #ETcurve
        self.ETcurve = QCheckBox(QApplication.translate("CheckBox", "ET",None))
        self.ETcurve.setChecked(aw.qmc.ETcurve)
        #BTcurve
        self.BTcurve = QCheckBox(QApplication.translate("CheckBox", "BT",None))
        self.BTcurve.setChecked(aw.qmc.BTcurve)
        #ETlcd
        self.ETlcd = QCheckBox(QApplication.translate("CheckBox", "ET",None))
        self.ETlcd.setChecked(aw.qmc.ETlcd)
        #BTlcd
        self.BTlcd = QCheckBox(QApplication.translate("CheckBox", "BT",None))
        self.BTlcd.setChecked(aw.qmc.BTlcd)
        #swaplcd
        self.swaplcds = QCheckBox(QApplication.translate("CheckBox", "Swap",None))
        self.swaplcds.setChecked(aw.qmc.swaplcds)
        self.curveHBox = QHBoxLayout()
        self.curveHBox.setContentsMargins(10,5,10,5)
        self.curveHBox.setSpacing(5)
        self.curveHBox.addWidget(self.ETcurve)
        self.curveHBox.addSpacing(10)
        self.curveHBox.addWidget(self.BTcurve)
        self.curveHBox.addStretch()
        self.curves = QGroupBox(QApplication.translate("GroupBox","Curves",None))
        self.curves.setLayout(self.curveHBox)
        self.lcdHBox = QHBoxLayout()
        self.lcdHBox.setContentsMargins(0,5,0,5)
        self.lcdHBox.setSpacing(5)
        self.lcdHBox.addWidget(self.ETlcd)
        self.lcdHBox.addSpacing(10)
        self.lcdHBox.addWidget(self.BTlcd)
        self.lcdHBox.addSpacing(15)
        self.lcdHBox.addWidget(self.swaplcds)
        self.lcds = QGroupBox(QApplication.translate("GroupBox","LCDs",None))
        self.lcds.setLayout(self.lcdHBox)
        
        self.controlButtonFlag = QCheckBox(QApplication.translate("Label", "Control", None))
        self.controlButtonFlag.setChecked(aw.qmc.Controlbuttonflag)
        self.controlButtonFlag.stateChanged.connect(self.showControlbuttonToggle)
        
        self.nonpidButton = QRadioButton(QApplication.translate("Radio Button","Meter", None))
        self.pidButton = QRadioButton(QApplication.translate("Radio Button","PID", None))
        self.arduinoButton = QRadioButton(QApplication.translate("Radio Button","TC4", None))
        self.programButton = QRadioButton(QApplication.translate("Radio Button","Prog", None))
        #As a main device, don't show the devices that start with a "+"
        # devices with a first letter "+" are extra devices an depend on another device
        # each device provides 2 curves
        #don't show devices with a "-". Devices with a - at front are either a pid, arduino, or an external program
        dev = aw.qmc.devices[:]             #deep copy
        limit = len(dev)
        for _ in range(limit):
            for i in range(len(dev)):
                if dev[i][0] == "+" or dev[i][0] == "-":
                    dev.pop(i)              #note: pop() makes the list smaller that's why there are 2 FOR statements
                    break 
        self.sorted_devices = sorted(dev)
        self.devicetypeComboBox = MyQComboBox()
        
#        self.devicetypeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToContents)
#        self.devicetypeComboBox.view().setTextElideMode(Qt.ElideNone)
        # HACK: only needed for the macintosh UI on Qt 5.12 onwords; without long items get cutted in the popup
        #  note the -7 as the width of the popup is too large if given the correct maximum characters
#        self.devicetypeComboBox.setMinimumContentsLength(max(22,len(max(dev, key=len)) - 7)) # expects # characters, but is to wide
        self.devicetypeComboBox.setSizePolicy(QSizePolicy.Expanding,self.devicetypeComboBox.sizePolicy().verticalPolicy())

        self.devicetypeComboBox.addItems(self.sorted_devices)
        self.programedit = QLineEdit(aw.ser.externalprogram)
        self.outprogramedit = QLineEdit(aw.ser.externaloutprogram)
        self.outprogramFlag = QCheckBox(QApplication.translate("CheckBox", "Output",None))
        self.outprogramFlag.setChecked(aw.ser.externaloutprogramFlag)
        self.outprogramFlag.stateChanged.connect(self.changeOutprogramFlag)         #toggle
        selectprogrambutton =  QPushButton(QApplication.translate("Button","Select",None))
        selectprogrambutton.setFocusPolicy(Qt.NoFocus)
        selectprogrambutton.clicked.connect(self.loadprogramname)
        helpprogrambutton =  QPushButton(QApplication.translate("Button","Help",None))
        helpprogrambutton.setFocusPolicy(Qt.NoFocus)
        helpprogrambutton.clicked.connect(self.showhelpprogram)
        selectoutprogrambutton =  QPushButton(QApplication.translate("Button","Select",None))
        selectoutprogrambutton.setFocusPolicy(Qt.NoFocus)
        selectoutprogrambutton.clicked.connect(self.loadoutprogramname)
        ###################################################
        # PID
        controllabel =QLabel(QApplication.translate("Label", "Control ET",None))
        self.controlpidtypeComboBox = QComboBox()
        self.controlpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","Delta DTA","Fuji PXF"])
        cp = aw.ser.controlETpid[0]
        if cp < 3:
            self.controlpidtypeComboBox.setCurrentIndex(cp)  #pid type is index 0
        else:
            self.controlpidtypeComboBox.setCurrentIndex(cp-1)  #pid type is index 0 PXF has an index offset of 1 as index 3 is not used
        btlabel =QLabel(QApplication.translate("Label", "Read BT",None))
        self.btpidtypeComboBox = QComboBox()
        self.btpidtypeComboBox.addItems(["Fuji PXG","Fuji PXR","None","Delta DTA","Fuji PXF"])
        self.btpidtypeComboBox.setCurrentIndex(aw.ser.readBTpid[0]) #pid type is index 0
        label1 = QLabel(QApplication.translate("Label", "Type",None))
        label2 = QLabel(QApplication.translate("Label", "RS485 Unit ID",None))
        #rs485 possible unit IDs (1-32); unit 0 is master (computer)
        unitids = list(map(str,list(range(1,33))))
        self.controlpidunitidComboBox = QComboBox()
        self.controlpidunitidComboBox.addItems(unitids)
        self.btpidunitidComboBox = QComboBox()
        self.btpidunitidComboBox.addItems(unitids)
        # index 1 = unitID of the rs485 network
        self.controlpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.controlETpid[1])))
        self.btpidunitidComboBox.setCurrentIndex(unitids.index(str(aw.ser.readBTpid[1])))
        #Show Fuji PID SV/% LCDs
        self.showFujiLCDs = QCheckBox(QApplication.translate("CheckBox", "PID Duty/Power LCDs",None))
        self.showFujiLCDs.setChecked(aw.ser.showFujiLCDs)
        #Reuse Modbus port
        self.useModbusPort = QCheckBox(QApplication.translate("CheckBox", "Modbus Port",None))
        self.useModbusPort.setChecked(aw.ser.useModbusPort)
        ####################################################
        #Arduino TC4 channel config
        arduinoChannels = ["None","1","2","3","4"]
        arduinoETLabel =QLabel(QApplication.translate("Label", "ET Channel",None))
        self.arduinoETComboBox = QComboBox()
        self.arduinoETComboBox.addItems(arduinoChannels)
        arduinoBTLabel =QLabel(QApplication.translate("Label", "BT Channel",None))
        self.arduinoBTComboBox = QComboBox()
        self.arduinoBTComboBox.addItems(arduinoChannels)
        #check previous settings for radio button
        if aw.qmc.device == 0 or aw.qmc.device == 26:   #if Fuji pid or Delta DTA pid
            self.pidButton.setChecked(True)
        elif aw.qmc.device == 19:                       #if arduino
            self.arduinoButton.setChecked(True)
        elif aw.qmc.device == 27:                       #if program
            self.programButton.setChecked(True)
        else:
            self.nonpidButton.setChecked(True)          #else
            selected_device_index = 0
            try:
                selected_device_index = self.sorted_devices.index(aw.qmc.devices[aw.qmc.device - 1])
            except Exception:
                pass
            self.devicetypeComboBox.setCurrentIndex(selected_device_index)
        self.arduinoETComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoETChannel))
        self.arduinoBTComboBox.setCurrentIndex(arduinoChannels.index(aw.ser.arduinoBTChannel))
        arduinoATLabel =QLabel(QApplication.translate("Label", "AT Channel",None))
        
        arduinoTemperatures = ["None","T1","T2","T3","T4","T5","T6"]
        self.arduinoATComboBox = QComboBox()        
        self.arduinoATComboBox.addItems(arduinoTemperatures)
        self.arduinoATComboBox.setCurrentIndex(arduinoTemperatures.index(aw.ser.arduinoATChannel))
        self.showControlButton = QCheckBox(QApplication.translate("CheckBox", "PID Firmware",None))
        self.showControlButton.setChecked(aw.qmc.PIDbuttonflag)
        self.showControlButton.stateChanged.connect(self.PIDfirmwareToggle)
        FILTLabel =QLabel(QApplication.translate("Label", "Filter",None))
        self.FILTspinBoxes = []
        for i in range(4):
            spinBox = QSpinBox()
            spinBox.setAlignment(Qt.AlignRight)
            spinBox.setRange(0,99)
            spinBox.setSingleStep(5)
            spinBox.setSuffix(" %")
            spinBox.setValue(aw.ser.ArduinoFILT[i])
            self.FILTspinBoxes.append(spinBox)
        ####################################################
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.okEvent)
        self.dialogbuttons.rejected.connect(self.cancelEvent)
        
        labelETadvanced = QLabel(QApplication.translate("Label", "ET Y(x)",None))
        labelBTadvanced = QLabel(QApplication.translate("Label", "BT Y(x)",None))
        self.ETfunctionedit = QLineEdit(str(aw.qmc.ETfunction))
        self.BTfunctionedit = QLineEdit(str(aw.qmc.BTfunction))
        symbolicHelpButton = QPushButton(QApplication.translate("Button","Help",None))
        symbolicHelpButton.setMaximumSize(symbolicHelpButton.sizeHint())
        symbolicHelpButton.setMinimumSize(symbolicHelpButton.minimumSizeHint())
        symbolicHelpButton.setFocusPolicy(Qt.NoFocus)
        symbolicHelpButton.clicked.connect(self.showSymbolicHelp)
        ##########################    TAB 2  WIDGETS   "EXTRA DEVICES"
        #table for showing data
        self.devicetable = QTableWidget()
        self.devicetable.setTabKeyNavigation(True)
        self.createDeviceTable()
        self.copydeviceTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copydeviceTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copydeviceTableButton.setFocusPolicy(Qt.NoFocus)
        self.copydeviceTableButton.clicked.connect(self.copyDeviceTabletoClipboard)
        self.addButton = QPushButton(QApplication.translate("Button","Add",None))
        self.addButton.setFocusPolicy(Qt.NoFocus)
        self.addButton.setMinimumWidth(100)
        #self.addButton.setMaximumWidth(100)
        self.addButton.clicked.connect(self.adddevice)
        resetButton = QPushButton(QApplication.translate("Button","Reset",None))
        resetButton.setFocusPolicy(Qt.NoFocus)
        resetButton.setMinimumWidth(100)
        resetButton.clicked.connect(self.resetextradevices)
        self.delButton = QPushButton(QApplication.translate("Button","Delete",None))
        self.delButton.setFocusPolicy(Qt.NoFocus)
        self.delButton.setMinimumWidth(100)
        #self.delButton.setMaximumWidth(100)
        self.delButton.clicked.connect(self.deldevice)
        self.recalcButton = QPushButton(QApplication.translate("Button","Update Profile",None))
        self.recalcButton.setFocusPolicy(Qt.NoFocus)
        self.recalcButton.setMinimumWidth(100)
        self.recalcButton.setToolTip(QApplication.translate("Tooltip","Recaclulates all Virtual Devices and updates their values in the profile",None))
        self.recalcButton.clicked.connect(self.updateVirtualdevicesinprofile)
        self.enableDisableAddDeleteButtons()
        ##########     LAYOUTS
        # create Phidget box
        phidgetProbeTypeItems = ["K", "J", "E", "T"]
        phidgetBox1048 = QGridLayout()
        self.asyncCheckBoxes1048 = []
        self.ratioCheckBoxes1048 = []
        self.changeTriggerCombos1048 = []
        self.probeTypeCombos = []
        for i in range(1,5):
            changeTriggersCombo = QComboBox()
            changeTriggersCombo.setFocusPolicy(Qt.NoFocus)
            model = changeTriggersCombo.model()
            changeTriggerItems = self.createItems(aw.qmc.phidget1048_changeTriggersStrings)
            for item in changeTriggerItems:
                model.appendRow(item)
            try:
                changeTriggersCombo.setCurrentIndex(aw.qmc.phidget1048_changeTriggersValues.index(aw.qmc.phidget1048_changeTriggers[i-1]))
            except Exception:
                pass
            
            changeTriggersCombo.setMinimumContentsLength(3)
            changeTriggersCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            
            self.changeTriggerCombos1048.append(changeTriggersCombo)
            phidgetBox1048.addWidget(changeTriggersCombo,3,i)
            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            asyncFlag.stateChanged.connect(self.asyncFlagStateChanged1048)
            asyncFlag.setChecked(aw.qmc.phidget1048_async[i-1])
            self.asyncCheckBoxes1048.append(asyncFlag)
            phidgetBox1048.addWidget(asyncFlag,2,i)
            probeTypeCombo = QComboBox()
            probeTypeCombo.setFocusPolicy(Qt.NoFocus)
            model = probeTypeCombo.model()
            probeTypeItems = self.createItems(phidgetProbeTypeItems)
            for item in probeTypeItems:
                model.appendRow(item)
            try:
                probeTypeCombo.setCurrentIndex(aw.qmc.phidget1048_types[i-1]-1)
            except Exception:
                pass
                
            probeTypeCombo.setMinimumContentsLength(0)
            probeTypeCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
#            width = probeTypeCombo.minimumSizeHint().width()
#            probeTypeCombo.setMinimumWidth(width)
#            if platf == 'Darwin':
#                probeTypeCombo.setMaximumWidth(width)
            
            self.probeTypeCombos.append(probeTypeCombo)
            phidgetBox1048.addWidget(probeTypeCombo,1,i)
            rowLabel = QLabel(str(i-1))
            phidgetBox1048.addWidget(rowLabel,0,i)
     
        self.dataRateCombo1048 = QComboBox()             
        self.dataRateCombo1048.setFocusPolicy(Qt.NoFocus)
        model = self.dataRateCombo1048.model()
        dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
        for item in dataRateItems:
            model.appendRow(item)
        try:
            self.dataRateCombo1048.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1048_dataRate))
        except Exception:
            pass
        self.dataRateCombo1048.setMinimumContentsLength(5)
        self.dataRateCombo1048.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        width = self.dataRateCombo1048.minimumSizeHint().width()
        self.dataRateCombo1048.setMinimumWidth(width)
        if platf == 'Darwin':
            self.dataRateCombo1048.setMaximumWidth(width)
        
        phidgetBox1048.addWidget(self.dataRateCombo1048,4,1,1,2)
        phidgetBox1048.setSpacing(1)
            
        typeLabel = QLabel(QApplication.translate("Label","Type", None))
        asyncLabel = QLabel(QApplication.translate("Label","Async", None))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None))
        rateLabel = QLabel(QApplication.translate("Label","Rate", None))
        phidgetBox1048.addWidget(typeLabel,1,0,Qt.AlignRight)
        phidgetBox1048.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1048.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidgetBox1048.addWidget(rateLabel,4,0,Qt.AlignRight)
        phidget1048HBox = QHBoxLayout()
        phidget1048HBox.addStretch()
        phidget1048HBox.addLayout(phidgetBox1048)
        phidget1048HBox.addStretch()
        phidget1048VBox = QVBoxLayout()
        phidget1048VBox.addLayout(phidget1048HBox)
        phidget1048VBox.addStretch()
        phidget1048GroupBox = QGroupBox("1048/1051/TMP1100/TMP1101 TC")
        phidget1048GroupBox.setLayout(phidget1048VBox)
        phidget1048GroupBox.setContentsMargins(0,0,0,0)
        phidget1048HBox.setContentsMargins(0,0,0,0)
        phidget1048VBox.setContentsMargins(0,0,0,0)
        
        # Phidget IR
        phidgetBox1045 = QGridLayout()
        phidgetBox1045.setSpacing(1)
        self.changeTriggerCombos1045 = QComboBox()
        self.changeTriggerCombos1045.setFocusPolicy(Qt.NoFocus)
        model = self.changeTriggerCombos1045.model()
        changeTriggerItems = self.createItems(aw.qmc.phidget1045_changeTriggersStrings)
        for item in changeTriggerItems:
            model.appendRow(item)
        try:
            self.changeTriggerCombos1045.setCurrentIndex(aw.qmc.phidget1045_changeTriggersValues.index(aw.qmc.phidget1045_changeTrigger))
        except Exception:
            pass
            
        #self.changeTriggerCombos1045.setMaximumSize(65,100)
        self.changeTriggerCombos1045.setMinimumContentsLength(4)
        self.changeTriggerCombos1045.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength) 
        
        phidgetBox1045.addWidget(self.changeTriggerCombos1045,3,1)
        self.asyncCheckBoxe1045 = QCheckBox()
        self.asyncCheckBoxe1045.setFocusPolicy(Qt.NoFocus)
        self.asyncCheckBoxe1045.setChecked(True)
        self.asyncCheckBoxe1045.stateChanged.connect(self.asyncFlagStateChanged1045)
        self.asyncCheckBoxe1045.setChecked(aw.qmc.phidget1045_async)
        phidgetBox1045.addWidget(self.asyncCheckBoxe1045,2,1)
        asyncLabel = QLabel(QApplication.translate("Label","Async", None))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None))
        rateLabel = QLabel(QApplication.translate("Label","Rate", None)) 
                
        self.dataRateCombo1045 = QComboBox()             
        self.dataRateCombo1045.setFocusPolicy(Qt.NoFocus)
        model = self.dataRateCombo1045.model()
        dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
        for item in dataRateItems:
            model.appendRow(item)
        try:
            self.dataRateCombo1045.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1045_dataRate))
        except Exception:
            pass
        self.dataRateCombo1045.setMinimumContentsLength(5)
        self.dataRateCombo1045.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        width = self.dataRateCombo1045.minimumSizeHint().width()
        self.dataRateCombo1045.setMinimumWidth(width)
        if platf == 'Darwin':
            self.dataRateCombo1045.setMaximumWidth(width)
        
        EmissivityLabel = QLabel(QApplication.translate("Label","Emissivity", None))
        self.emissivitySpinBox = QDoubleSpinBox()
        self.emissivitySpinBox.setAlignment(Qt.AlignRight)
        self.emissivitySpinBox.setRange(0.,1.)
        self.emissivitySpinBox.setSingleStep(.1) 
        self.emissivitySpinBox.setValue(aw.qmc.phidget1045_emissivity) 

        phidgetBox1045.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1045.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidgetBox1045.addWidget(rateLabel,4,0,Qt.AlignRight) 
        phidgetBox1045.addWidget(self.dataRateCombo1045,4,1)
        phidgetBox1045.addWidget(EmissivityLabel,5,0,Qt.AlignRight)
        phidgetBox1045.addWidget(self.emissivitySpinBox,5,1)
        phidget1045VBox = QVBoxLayout()
        phidget1045VBox.addStretch()
        phidget1045VBox.addLayout(phidgetBox1045)
        phidget1045VBox.addStretch()
        phidget1045VBox.addStretch()
        phidget1045GroupBox = QGroupBox("1045 IR")
        phidget1045GroupBox.setLayout(phidget1045VBox)
        phidget1045VBox.setContentsMargins(0,0,0,0) 


        # 1046 RTD
        phidgetBox1046 = QGridLayout()
        phidgetBox1046.setSpacing(1)
        self.gainCombos1046 = []
        self.formulaCombos1046 = []
        self.asyncCheckBoxes1046 = []
        for i in range(1,5):
            gainCombo = QComboBox()
            gainCombo.setFocusPolicy(Qt.NoFocus)
            
            model = gainCombo.model()
            gainItems = self.createItems(aw.qmc.phidget1046_gainValues)
            for item in gainItems:
                model.appendRow(item)
            try:
                gainCombo.setCurrentIndex(aw.qmc.phidget1046_gain[i-1] - 1)
            except Exception:
                pass
          
            gainCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            gainCombo.setMinimumContentsLength(2)
            width = gainCombo.minimumSizeHint().width()
            gainCombo.setMinimumWidth(width)
#            gainCombo.setMaximumWidth(width)
            
            self.gainCombos1046.append(gainCombo)
            phidgetBox1046.addWidget(gainCombo,1,i)
            
            formulaCombo = QComboBox()
            formulaCombo.setFocusPolicy(Qt.NoFocus)
            model = formulaCombo.model()
            formulaItems = self.createItems(aw.qmc.phidget1046_formulaValues)
            for item in formulaItems:
                model.appendRow(item)
            try:
                formulaCombo.setCurrentIndex(aw.qmc.phidget1046_formula[i-1])
            except Exception:
                pass

            formulaCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            formulaCombo.setMinimumContentsLength(3)
            width = formulaCombo.minimumSizeHint().width()
            formulaCombo.setMinimumWidth(width)
            if platf == 'Darwin':
                formulaCombo.setMaximumWidth(width)

            self.formulaCombos1046.append(formulaCombo)
            phidgetBox1046.addWidget(formulaCombo,2,i)

            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            asyncFlag.setChecked(aw.qmc.phidget1046_async[i-1])
            self.asyncCheckBoxes1046.append(asyncFlag)
            phidgetBox1046.addWidget(asyncFlag,3,i)
            rowLabel = QLabel(str(i-1))
            phidgetBox1046.addWidget(rowLabel,0,i)
            
        self.dataRateCombo1046 = QComboBox()
        self.dataRateCombo1046.setFocusPolicy(Qt.NoFocus)
        model = self.dataRateCombo1046.model()
        dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
        for item in dataRateItems:
            model.appendRow(item)
        try:
            self.dataRateCombo1046.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1046_dataRate))
        except Exception:
            pass                
        self.dataRateCombo1046.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        self.dataRateCombo1046.setMinimumContentsLength(5)
        width = self.dataRateCombo1046.minimumSizeHint().width()
        self.dataRateCombo1046.setMinimumWidth(width)
        if platf == 'Darwin':
            self.dataRateCombo1046.setMaximumWidth(width)
            
        phidgetBox1046.addWidget(self.dataRateCombo1046,4,1,1,2)
        phidgetBox1046.setSpacing(5)
     
        gainLabel = QLabel(QApplication.translate("Label","Gain", None))
        formulaLabel = QLabel(QApplication.translate("Label","Wiring", None))
        asyncLabel = QLabel(QApplication.translate("Label","Async", None))
        rateLabel = QLabel(QApplication.translate("Label","Rate", None))
        phidgetBox1046.addWidget(gainLabel,1,0,Qt.AlignRight)
        phidgetBox1046.addWidget(formulaLabel,2,0,Qt.AlignRight)
        phidgetBox1046.addWidget(asyncLabel,3,0,Qt.AlignRight)
        phidgetBox1046.addWidget(rateLabel,4,0,Qt.AlignRight)
        phidget1046HBox = QHBoxLayout()
        phidget1046HBox.addStretch()
        phidget1046HBox.addLayout(phidgetBox1046)
        phidget1046HBox.addStretch()
        phidget1046VBox = QVBoxLayout()
        phidget1046VBox.addLayout(phidget1046HBox)
        phidget1046VBox.addStretch()
        phidget1046GroupBox = QGroupBox("1046 RTD")
        phidget1046GroupBox.setLayout(phidget1046VBox)
        phidget1046GroupBox.setContentsMargins(0,10,0,0)
        phidget1046HBox.setContentsMargins(0,0,0,0)
        phidget1046VBox.setContentsMargins(0,0,0,0)
        
        
        # TMP1200 RTD
        phidgetBox1200 = QGridLayout()
        phidgetBox1200.setSpacing(1)

        self.formulaCombo1200 = QComboBox()
        self.formulaCombo1200.setFocusPolicy(Qt.NoFocus)
        model = self.formulaCombo1200.model()
        wireItems = self.createItems(aw.qmc.phidget1200_formulaValues)
        for item in wireItems:
            model.appendRow(item)
        try:
            self.formulaCombo1200.setCurrentIndex(aw.qmc.phidget1200_formula)
        except Exception:
            pass
        self.formulaCombo1200.setMinimumContentsLength(5)
        width = self.formulaCombo1200.minimumSizeHint().width()
        self.formulaCombo1200.setMinimumWidth(width)
#        self.formulaCombo1200.setMaximumWidth(width)
        
        self.wireCombo1200 = QComboBox()
        self.wireCombo1200.setFocusPolicy(Qt.NoFocus)
        model = self.wireCombo1200.model()
        wireItems = self.createItems(aw.qmc.phidget1200_wireValues)
        for item in wireItems:
            model.appendRow(item)
        try:
            self.wireCombo1200.setCurrentIndex(aw.qmc.phidget1200_wire)
        except Exception:
            pass
        self.wireCombo1200.setMinimumContentsLength(5)
        width = self.wireCombo1200.minimumSizeHint().width()
        self.wireCombo1200.setMinimumWidth(width)
#        self.wireCombo1200.setMaximumWidth(width)

        self.asyncCheckBoxe1200 = QCheckBox()
        self.asyncCheckBoxe1200.setFocusPolicy(Qt.NoFocus)
        self.asyncCheckBoxe1200.setChecked(aw.qmc.phidget1200_async)
        self.asyncCheckBoxe1200.stateChanged.connect(self.asyncFlagStateChanged1200)
            
        self.changeTriggerCombo1200 = QComboBox()
        self.changeTriggerCombo1200.setFocusPolicy(Qt.NoFocus)
        model = self.changeTriggerCombo1200.model()
        changeTriggerItems = self.createItems(aw.qmc.phidget1200_changeTriggersStrings)
        for item in changeTriggerItems:
            model.appendRow(item)
        try:
            self.changeTriggerCombo1200.setCurrentIndex(aw.qmc.phidget1200_changeTriggersValues.index(aw.qmc.phidget1200_changeTrigger))
        except Exception:
            pass
        self.changeTriggerCombo1200.setMinimumContentsLength(4)
        width = self.changeTriggerCombo1200.minimumSizeHint().width()
        self.changeTriggerCombo1200.setMinimumWidth(width)
#        self.changeTriggerCombo1200.setMaximumWidth(width) 
        self.changeTriggerCombo1200.setEnabled(aw.qmc.phidget1200_async)
        
        self.rateCombo1200 = QComboBox()
        self.rateCombo1200.setFocusPolicy(Qt.NoFocus)
        model = self.rateCombo1200.model()
        dataRateItems = self.createItems(aw.qmc.phidget1200_dataRatesStrings)
        for item in dataRateItems:
            model.appendRow(item)
        try:
            self.rateCombo1200.setCurrentIndex(aw.qmc.phidget1200_dataRatesValues.index(aw.qmc.phidget1200_dataRate))
        except Exception:
            pass
        self.rateCombo1200.setMinimumContentsLength(3)
        width = self.rateCombo1200.minimumSizeHint().width()
        self.rateCombo1200.setMinimumWidth(width)
#        self.rateCombo1200.setMaximumWidth(width)
        
        typeLabel = QLabel(QApplication.translate("Label","Type", None))
        wireLabel = QLabel(QApplication.translate("Label","Wiring", None))
        asyncLabel = QLabel(QApplication.translate("Label","Async", None))
        changeLabel = QLabel(QApplication.translate("Label","Change", None))
        rateLabel = QLabel(QApplication.translate("Label","Rate", None))
        
        phidgetBox1200.addWidget(typeLabel,1,0,Qt.AlignRight)
        phidgetBox1200.addWidget(self.formulaCombo1200,1,1)
        phidgetBox1200.addWidget(wireLabel,2,0,Qt.AlignRight)
        phidgetBox1200.addWidget(self.wireCombo1200,2,1)
        phidgetBox1200.addWidget(asyncLabel,3,0,Qt.AlignRight)
        phidgetBox1200.addWidget(self.asyncCheckBoxe1200,3,1)
        phidgetBox1200.addWidget(changeLabel,4,0,Qt.AlignRight)
        phidgetBox1200.addWidget(self.changeTriggerCombo1200,4,1)
        phidgetBox1200.addWidget(rateLabel,5,0,Qt.AlignRight)
        phidgetBox1200.addWidget(self.rateCombo1200,5,1)

        phidget1200HBox = QHBoxLayout()
        phidget1200HBox.addStretch()
        phidget1200HBox.addLayout(phidgetBox1200)
        phidget1200HBox.addStretch()
        phidget1200VBox = QVBoxLayout()
        phidget1200VBox.addLayout(phidget1200HBox)
        phidget1200VBox.addStretch()
        
        phidget1200GroupBox = QGroupBox("TMP1200 RTD")
        phidget1200VBox.setContentsMargins(0,0,0,0)
        phidget1200HBox.setContentsMargins(0,0,0,0)
        phidget1200GroupBox.setLayout(phidget1200VBox)
        phidget1200GroupBox.setContentsMargins(0,10,0,0)
        
        # DAQ1400 VI
        powerLabel = QLabel(QApplication.translate("Label","Power", None))
        modeLabel = QLabel(QApplication.translate("Label","Mode", None))

        self.powerCombo1400 = QComboBox()
        self.powerCombo1400.setFocusPolicy(Qt.NoFocus)
        self.powerCombo1400.addItems(aw.qmc.phidgetDAQ1400_powerSupplyStrings)
        self.powerCombo1400.setCurrentIndex(aw.qmc.phidgetDAQ1400_powerSupply)
        self.powerCombo1400.setMinimumContentsLength(3)
        width = self.powerCombo1400.minimumSizeHint().width()
        self.powerCombo1400.setMinimumWidth(width)

        self.modeCombo1400 = QComboBox()
        self.modeCombo1400.setFocusPolicy(Qt.NoFocus)
        self.modeCombo1400.addItems(aw.qmc.phidgetDAQ1400_inputModeStrings)
        self.modeCombo1400.setCurrentIndex(aw.qmc.phidgetDAQ1400_inputMode)
        self.modeCombo1400.setMinimumContentsLength(3)
        width = self.modeCombo1400.minimumSizeHint().width()
        self.modeCombo1400.setMinimumWidth(width)

        phidgetBox1400 = QGridLayout()
        phidgetBox1400.setSpacing(1)
        phidgetBox1400.addWidget(powerLabel,0,0,Qt.AlignRight)
        phidgetBox1400.addWidget(self.powerCombo1400,0,1)
        phidgetBox1400.addWidget(modeLabel,1,0,Qt.AlignRight)
        phidgetBox1400.addWidget(self.modeCombo1400,1,1)

        phidget1400HBox = QHBoxLayout()
        phidget1400HBox.addLayout(phidgetBox1400)
        phidget1400VBox = QVBoxLayout()
        phidget1400VBox.addLayout(phidget1400HBox)
        phidget1400VBox.addStretch()
        
        phidget1400GroupBox = QGroupBox("DAQ1400 VI")
        phidget1400GroupBox.setLayout(phidget1400VBox)
        phidget1400GroupBox.setContentsMargins(0,0,0,0)
        phidget1400VBox.setContentsMargins(0,0,0,0)
        phidget1400HBox.setContentsMargins(0,0,0,0)

        phdget10481045GroupBoxHBox = QHBoxLayout()
        phdget10481045GroupBoxHBox.addWidget(phidget1048GroupBox)
        phdget10481045GroupBoxHBox.addStretch()
        phdget10481045GroupBoxHBox.addWidget(phidget1200GroupBox)
        phdget10481045GroupBoxHBox.addStretch()
        phdget10481045GroupBoxHBox.addWidget(phidget1400GroupBox)
        phdget10481045GroupBoxHBox.addStretch()
        phdget10481045GroupBoxHBox.addWidget(phidget1046GroupBox)
        phdget10481045GroupBoxHBox.setContentsMargins(2,0,2,0)
        phdget10481045GroupBoxHBox.setSpacing(1)


        # Phidget IO 1018
        # per each of the 8-channels: raw flag / data rate popup / change trigger popup
        phidgetBox1018 = QGridLayout()
        phidgetBox1018.setSpacing(1)
        self.asyncCheckBoxes = []
        self.ratioCheckBoxes = []
        self.dataRateCombos = []
        self.changeTriggerCombos = []
        for i in range(1,9):
            dataRatesCombo = QComboBox()
            dataRatesCombo.setFocusPolicy(Qt.NoFocus)
            model = dataRatesCombo.model()
            dataRateItems = self.createItems(aw.qmc.phidget_dataRatesStrings)
            for item in dataRateItems:
                model.appendRow(item)
            try:
                dataRatesCombo.setCurrentIndex(aw.qmc.phidget_dataRatesValues.index(aw.qmc.phidget1018_dataRates[i-1]))
            except Exception:
                pass

            dataRatesCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            dataRatesCombo.setMinimumContentsLength(5)
            width = dataRatesCombo.minimumSizeHint().width()
            dataRatesCombo.setMinimumWidth(width)
            if platf == 'Darwin':
                dataRatesCombo.setMaximumWidth(width)
            
            self.dataRateCombos.append(dataRatesCombo)
            
            phidgetBox1018.addWidget(dataRatesCombo,4,i)
            
            changeTriggersCombo = QComboBox()
            changeTriggersCombo.setFocusPolicy(Qt.NoFocus)
            model = changeTriggersCombo.model()
            changeTriggerItems = self.createItems(aw.qmc.phidget1018_changeTriggersStrings)
            for item in changeTriggerItems:
                model.appendRow(item)
            try:
                changeTriggersCombo.setCurrentIndex((aw.qmc.phidget1018_changeTriggersValues.index(aw.qmc.phidget1018_changeTriggers[i-1])))
            except Exception:
                pass

            changeTriggersCombo.setMinimumContentsLength(5)
            changeTriggersCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
            width = changeTriggersCombo.minimumSizeHint().width()
            changeTriggersCombo.setMinimumWidth(width)
            if platf == 'Darwin':
                changeTriggersCombo.setMaximumWidth(width)
            
            self.changeTriggerCombos.append(changeTriggersCombo)
            phidgetBox1018.addWidget(changeTriggersCombo,3,i)
                        
            asyncFlag = QCheckBox()
            asyncFlag.setFocusPolicy(Qt.NoFocus)
            asyncFlag.setChecked(True)
            asyncFlag.stateChanged.connect(self.asyncFlagStateChanged)
            asyncFlag.setChecked(aw.qmc.phidget1018_async[i-1])
            self.asyncCheckBoxes.append(asyncFlag)
            phidgetBox1018.addWidget(asyncFlag,2,i)

            ratioFlag = QCheckBox()
            ratioFlag.setFocusPolicy(Qt.NoFocus)
            ratioFlag.setChecked(False)
            ratioFlag.setChecked(aw.qmc.phidget1018_ratio[i-1])
            self.ratioCheckBoxes.append(ratioFlag)
            phidgetBox1018.addWidget(ratioFlag,5,i)

            rowLabel = QLabel(str(i-1))
            phidgetBox1018.addWidget(rowLabel,0,i)
           
        asyncLabel = QLabel(QApplication.translate("Label","Async", None))
        dataRateLabel = QLabel(QApplication.translate("Label","Rate", None))
        changeTriggerLabel = QLabel(QApplication.translate("Label","Change", None))
        ratioLabel = QLabel(QApplication.translate("Label","Ratio", None))
        phidgetBox1018.addWidget(asyncLabel,2,0,Qt.AlignRight)
        phidgetBox1018.addWidget(changeTriggerLabel,3,0,Qt.AlignRight)
        phidgetBox1018.addWidget(dataRateLabel,4,0,Qt.AlignRight)
        phidgetBox1018.addWidget(ratioLabel,5,0,Qt.AlignRight)
        phidget1018HBox = QVBoxLayout()
        phidget1018HBox.addLayout(phidgetBox1018)
        phidget1018GroupBox = QGroupBox("1010/1011/1013/1018/1019/HUB0000/SBC IO")
        phidget1018GroupBox.setLayout(phidget1018HBox)
        phidget1018HBox.setContentsMargins(0,0,0,0)
        self.phidgetBoxRemoteFlag = QCheckBox()
        self.phidgetBoxRemoteFlag.setFocusPolicy(Qt.NoFocus)
        self.phidgetBoxRemoteFlag.setChecked(aw.qmc.phidgetRemoteFlag)
        phidgetServerIdLabel = QLabel(QApplication.translate("Label","Host", None))
        self.phidgetServerId = QLineEdit(aw.qmc.phidgetServerID)
        self.phidgetServerId.setMinimumWidth(200)
        phidgetPasswordLabel = QLabel(QApplication.translate("Label","Password", None))
        self.phidgetPassword = QLineEdit(aw.qmc.phidgetPassword)
        self.phidgetPassword.setEchoMode(3)
        self.phidgetPassword.setMinimumWidth(100)
        phidgetPortLabel = QLabel(QApplication.translate("Label","Port", None))
        self.phidgetPort = QLineEdit(str(aw.qmc.phidgetPort))
        self.phidgetPort.setMaximumWidth(70)
        self.phidgetBoxRemoteOnlyFlag = QCheckBox(QApplication.translate("Label","Remote Only", None))
        self.phidgetBoxRemoteOnlyFlag.setFocusPolicy(Qt.NoFocus)
        self.phidgetBoxRemoteOnlyFlag.setChecked(aw.qmc.phidgetRemoteOnlyFlag)
        phidgetServerBox = QHBoxLayout()
        phidgetServerBox.addWidget(phidgetServerIdLabel)
        phidgetServerBox.addWidget(self.phidgetServerId)
        phidgetServerBox.setContentsMargins(0,0,0,0)
        phidgetServerBox.setSpacing(3)
        phidgetPasswordBox = QHBoxLayout()
        phidgetPasswordBox.addWidget(phidgetPasswordLabel)
        phidgetPasswordBox.addWidget(self.phidgetPassword)
        phidgetPasswordBox.setContentsMargins(0,0,0,0)
        phidgetPasswordBox.setSpacing(3)
        phidgetPortBox = QHBoxLayout()
        phidgetPortBox.addWidget(phidgetPortLabel)
        phidgetPortBox.addWidget(self.phidgetPort)
        phidgetPortBox.setContentsMargins(0,0,0,0)
        phidgetPortBox.setSpacing(3)
        phidgetNetworkGrid = QHBoxLayout()
        phidgetNetworkGrid.addWidget(self.phidgetBoxRemoteFlag)
        phidgetNetworkGrid.addStretch()
        phidgetNetworkGrid.addLayout(phidgetServerBox)
        phidgetNetworkGrid.addLayout(phidgetPortBox)
        phidgetNetworkGrid.addStretch()
        phidgetNetworkGrid.addLayout(phidgetPasswordBox)
        phidgetNetworkGrid.addStretch()
        phidgetNetworkGrid.addWidget(self.phidgetBoxRemoteOnlyFlag)
        phidgetNetworkGrid.setContentsMargins(0,0,0,0)
        phidgetNetworkGrid.setSpacing(20)
        phidgetNetworkGroupBox = QGroupBox(QApplication.translate("GroupBox","Network",None))
        phidgetNetworkGroupBox.setLayout(phidgetNetworkGrid)
        phidget10451018HBox = QHBoxLayout()
        phidget10451018HBox.addWidget(phidget1045GroupBox)
        phidget10451018HBox.addStretch()
        phidget10451018HBox.addWidget(phidget1018GroupBox)
        phidget10451018HBox.setSpacing(1)
        phidgetVBox = QVBoxLayout()
        phidgetVBox.addLayout(phdget10481045GroupBoxHBox)
        phidgetVBox.addLayout(phidget10451018HBox)
        phidgetVBox.addWidget(phidgetNetworkGroupBox)
        phidgetVBox.addStretch()
        phidgetVBox.setSpacing(5)
        # yoctopuce widgets
        self.yoctoBoxRemoteFlag = QCheckBox()
        self.yoctoBoxRemoteFlag.setFocusPolicy(Qt.NoFocus)
        self.yoctoBoxRemoteFlag.setChecked(aw.qmc.yoctoRemoteFlag)
        yoctoServerIdLabel = QLabel(QApplication.translate("Label","VirtualHub", None))
        self.yoctoServerId = QLineEdit(aw.qmc.yoctoServerID)
        YoctoEmissivityLabel = QLabel(QApplication.translate("Label","Emissivity", None))
        self.yoctoEmissivitySpinBox = QDoubleSpinBox()
        self.yoctoEmissivitySpinBox.setAlignment(Qt.AlignRight)
        self.yoctoEmissivitySpinBox.setRange(0.,1.)
        self.yoctoEmissivitySpinBox.setSingleStep(.1) 
        self.yoctoEmissivitySpinBox.setValue(aw.qmc.YOCTO_emissivity) 
        yoctoServerBox = QHBoxLayout()
        yoctoServerBox.addWidget(yoctoServerIdLabel)
        yoctoServerBox.addSpacing(10)
        yoctoServerBox.addWidget(self.yoctoServerId)
        yoctoServerBox.setContentsMargins(0,0,0,0)
        yoctoServerBox.setSpacing(10)
        yoctoNetworkGrid = QGridLayout()
        yoctoNetworkGrid.addWidget(self.yoctoBoxRemoteFlag,0,0)
        yoctoNetworkGrid.addLayout(yoctoServerBox,0,1)
#        yoctoNetworkGrid.setContentsMargins(10,10,10,10)
        yoctoNetworkGrid.setSpacing(20)
        yoctoNetworkGroupBox = QGroupBox(QApplication.translate("GroupBox","Network",None))
        yoctoNetworkGroupBox.setLayout(yoctoNetworkGrid)
        yoctoIRGrid = QGridLayout()
        yoctoIRGrid.addWidget(YoctoEmissivityLabel,0,0)
        yoctoIRGrid.addWidget(self.yoctoEmissivitySpinBox,0,1)
        yoctoIRHorizontalLayout = QHBoxLayout()
        yoctoIRHorizontalLayout.addLayout(yoctoIRGrid)
        yoctoIRHorizontalLayout.addStretch()
        self.yoctoDataRateCombo = QComboBox()
        self.yoctoDataRateCombo.setFocusPolicy(Qt.NoFocus)
        model = self.yoctoDataRateCombo.model()
        dataRateItems = self.createItems(aw.qmc.YOCTO_dataRatesStrings)
        for item in dataRateItems:
                model.appendRow(item)
        try:
            self.yoctoDataRateCombo.setCurrentIndex(aw.qmc.YOCTO_dataRatesValues.index(aw.qmc.YOCTO_dataRate))
        except Exception:
            pass
        self.yoctoDataRateCombo.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        self.yoctoDataRateCombo.setMinimumContentsLength(5)
        width = self.yoctoDataRateCombo.minimumSizeHint().width()
        self.yoctoDataRateCombo.setMinimumWidth(width)
        self.yoctoAyncChanFlag = QCheckBox()
        self.yoctoAyncChanFlag.setFocusPolicy(Qt.NoFocus)
        self.yoctoAyncChanFlag.setChecked(aw.qmc.YOCTO_async[0]) # only one flag for both channels, as running on async and the other sync will disturbe the readings
        yoctoAsyncGrid = QGridLayout()
        yoctoAsyncGrid.addWidget(self.yoctoAyncChanFlag,0,0)
        yoctoAsyncGrid.addWidget(self.yoctoDataRateCombo,0,1)
        yoctoAsyncHorizontalLayout = QHBoxLayout()
        yoctoAsyncHorizontalLayout.addLayout(yoctoAsyncGrid)
        yoctoAsyncHorizontalLayout.addStretch()
        yoctoAsyncGroupBox = QGroupBox(QApplication.translate("GroupBox","Async",None))
        yoctoAsyncGroupBox.setLayout(yoctoAsyncHorizontalLayout)
        yoctoIRGroupBox = QGroupBox(QApplication.translate("GroupBox","IR",None))
        yoctoIRGroupBox.setLayout(yoctoIRHorizontalLayout)
        yoctoVBox = QVBoxLayout()
        yoctoVBox.addWidget(yoctoNetworkGroupBox)
        yoctoVBox.addWidget(yoctoIRGroupBox)
        yoctoVBox.addWidget(yoctoAsyncGroupBox)
        yoctoVBox.addStretch()
        yoctoVBox.setSpacing(5)
        yoctoVBox.setContentsMargins(0,0,0,0)  
        # Ambient Widgets and Layouts
        self.temperatureDeviceCombo = QComboBox()
        self.temperatureDeviceCombo.setFocusPolicy(Qt.NoFocus)
        self.temperatureDeviceCombo.addItems(aw.qmc.temperaturedevicefunctionlist)

        # HACK: only needed for the macintosh UI on Qt 5.12 onwords; withou long items get cutted in the popup
        #  note the -7 as the width of the popup is too large if given the correct maximum characters
#        self.temperatureDeviceCombo.setMinimumContentsLength(max(22,len(max(aw.qmc.temperaturedevicefunctionlist, key=len)) - 7)) # expects # characters, but is to wide

        try:
            self.temperatureDeviceCombo.setCurrentIndex(aw.qmc.ambient_temperature_device)
        except:
            pass
        self.humidityDeviceCombo = QComboBox()
        self.humidityDeviceCombo.setFocusPolicy(Qt.NoFocus)
        self.humidityDeviceCombo.addItems(aw.qmc.humiditydevicefunctionlist)
        try:
            self.humidityDeviceCombo.setCurrentIndex(aw.qmc.ambient_humidity_device)
        except:
            pass
        self.pressureDeviceCombo = QComboBox()
        self.pressureDeviceCombo.setFocusPolicy(Qt.NoFocus)
        self.pressureDeviceCombo.addItems(aw.qmc.pressuredevicefunctionlist)
        try:
            self.pressureDeviceCombo.setCurrentIndex(aw.qmc.ambient_pressure_device)
        except:
            pass
        self.elevationSpinBox = QSpinBox()
        self.elevationSpinBox.setAlignment(Qt.AlignRight)
        self.elevationSpinBox.setRange(0,3000)
        self.elevationSpinBox.setSingleStep(1)
        self.elevationSpinBox.setValue(aw.qmc.elevation)
        self.elevationSpinBox.setSuffix(" " + QApplication.translate("Label","MASL"))
        temperatureDeviceLabel = QLabel(QApplication.translate("Label","Temperature",None))
        humidityDeviceLabel = QLabel(QApplication.translate("Label","Humidity",None))
        pressureDeviceLabel = QLabel(QApplication.translate("Label","Pressure",None))
        elevationLabel = QLabel(QApplication.translate("Label","Elevation",None))
        ambientGrid = QGridLayout()
        ambientGrid.addWidget(temperatureDeviceLabel,0,0)
        ambientGrid.addWidget(self.temperatureDeviceCombo,0,1)
        ambientGrid.addWidget(humidityDeviceLabel,1,0)
        ambientGrid.addWidget(self.humidityDeviceCombo,1,1)
        ambientGrid.addWidget(pressureDeviceLabel,2,0)
        ambientGrid.addWidget(self.pressureDeviceCombo,2,1)
        ambientGrid.addWidget(elevationLabel,3,0)
        ambientGrid.addWidget(self.elevationSpinBox,3,1)
        ambientHBox = QHBoxLayout()
        ambientHBox.addStretch()
        ambientHBox.addLayout(ambientGrid)
        ambientHBox.addStretch()
        ambientVBox = QVBoxLayout()
        ambientVBox.addStretch()
        ambientVBox.addLayout(ambientHBox)
        ambientVBox.addStretch()
        ambientVBox.setContentsMargins(0,0,0,0)
        # create pid box
        PIDgrid = QGridLayout()
        PIDgrid.addWidget(label1,0,1)
        PIDgrid.addWidget(label2,0,2)
        PIDgrid.addWidget(controllabel,1,0)
        PIDgrid.addWidget(self.controlpidtypeComboBox,1,1)
        PIDgrid.addWidget(self.controlpidunitidComboBox,1,2)
        PIDgrid.addWidget(self.showFujiLCDs,1,3)
        PIDgrid.addWidget(btlabel,2,0,Qt.AlignRight)
        PIDgrid.addWidget(self.btpidtypeComboBox,2,1)
        PIDgrid.addWidget(self.btpidunitidComboBox,2,2)
        PIDgrid.addWidget(self.useModbusPort,2,3)
        PIDBox = QHBoxLayout()
        PIDBox.addLayout(PIDgrid)
        PIDBox.addStretch()
        PIDBox.setContentsMargins(5,0,5,5)
        PIDGroupBox = QGroupBox(QApplication.translate("GroupBox","PID",None))
        PIDGroupBox.setLayout(PIDBox)
        # create arduino box
        filtgrid = QGridLayout()
        for i in range(4):
            filtgrid.addWidget(self.FILTspinBoxes[i],1,i+2)
        filtgridBox = QHBoxLayout()
        filtgridBox.addLayout(filtgrid)
        filtgridBox.addStretch()
        filtgridBox.setContentsMargins(5,5,5,5)
        arduinogrid = QGridLayout()
        arduinogrid.addWidget(arduinoETLabel,1,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoETComboBox,1,1)
        arduinogrid.addWidget(arduinoBTLabel,2,0,Qt.AlignRight)
        arduinogrid.addWidget(self.arduinoBTComboBox,2,1)
        arduinogrid.addWidget(self.arduinoATComboBox,2,3)
        arduinogrid.addWidget(arduinoATLabel,2,4)
        arduinogrid.addWidget(self.showControlButton,2,5)
        arduinogrid.addWidget(FILTLabel,1,3,Qt.AlignRight)
        arduinogrid.addLayout(filtgridBox,1,4,1,2)
        arduinogridBox = QHBoxLayout()
        arduinogridBox.addLayout(arduinogrid)
        arduinogridBox.addStretch()
        arduinogridBox.setContentsMargins(5,5,5,5)
        arduinoBox = QVBoxLayout()
        arduinoBox.addLayout(arduinogridBox)
        arduinoBox.setContentsMargins(5,5,5,5)
        arduinoGroupBox = QGroupBox(QApplication.translate("GroupBox","Arduino TC4",None))
        arduinoGroupBox.setLayout(arduinoBox)
        arduinoBox.setContentsMargins(0,0,0,0)
        arduinoGroupBox.setContentsMargins(0,12,0,0)
        #create program Box
        programlayout = QGridLayout()
        programlayout.addWidget(helpprogrambutton,0,0)
        programlayout.addWidget(selectprogrambutton,0,1)
        programlayout.addWidget(self.programedit,0,2)
        programlayout.addWidget(self.outprogramFlag,1,0)
        programlayout.addWidget(selectoutprogrambutton,1,1)
        programlayout.addWidget(self.outprogramedit,1,2)
        programGroupBox = QGroupBox(QApplication.translate("GroupBox","External Program",None))
        programGroupBox.setLayout(programlayout)
        programlayout.setContentsMargins(5,10,5,5)
        programGroupBox.setContentsMargins(0,12,0,0)
        #ET BT symbolic adjustments/assignments Box
        adjustmentHelp = QHBoxLayout()
        adjustmentHelp.addStretch()
        adjustmentHelp.addWidget(symbolicHelpButton)
        adjustmentGroupBox = QGroupBox(QApplication.translate("GroupBox","Symbolic Assignments",None))
        adjustmentsLayout = QVBoxLayout()
        adjustmentsLayout.addWidget(labelETadvanced)
        adjustmentsLayout.addWidget(self.ETfunctionedit)
        adjustmentsLayout.addWidget(labelBTadvanced)
        adjustmentsLayout.addWidget(self.BTfunctionedit)
        adjustmentsLayout.addStretch()
        adjustmentsLayout.addLayout(adjustmentHelp)
        adjustmentGroupBox.setLayout(adjustmentsLayout)
        #LAYOUT TAB 1
        deviceSubSelector = QHBoxLayout()
        deviceSubSelector.addWidget(self.controlButtonFlag)
        deviceSubSelector.addSpacing(35)
        deviceSubSelector.addWidget(self.curves)
        deviceSubSelector.addSpacing(15)
        deviceSubSelector.addWidget(self.lcds)
        
        deviceSelector = QHBoxLayout()
        deviceSelector.addWidget(self.devicetypeComboBox)
        deviceSelector.addStretch()
        deviceSelector.addLayout(deviceSubSelector)

        grid = QGridLayout()
        grid.addWidget(self.nonpidButton,2,0)
        grid.addLayout(deviceSelector,2,1)
        grid.addWidget(self.pidButton,3,0)
        grid.addWidget(PIDGroupBox,3,1)
        grid.addWidget(self.arduinoButton,4,0)
        grid.addWidget(arduinoGroupBox,4,1)
        grid.addWidget(self.programButton,5,0)
        grid.addWidget(programGroupBox,5,1)
        grid.setSpacing(3)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        buttonLayout.setSpacing(10)
        tab1Layout = QVBoxLayout()
        tab1Layout.addLayout(grid)
        tab1Layout.setContentsMargins(5,5,5,5)
        tab1Layout.addStretch()
        bLayout = QHBoxLayout()
        bLayout.addWidget(self.addButton)
        bLayout.addWidget(self.delButton)
        bLayout.addWidget(self.copydeviceTableButton)
        bLayout.addStretch()
        bLayout.addSpacing(10)
        bLayout.addWidget(self.recalcButton)
        bLayout.addStretch()
        bLayout.addSpacing(10)
        bLayout.addWidget(resetButton)
        #LAYOUT TAB 2 (Extra Devices)
        tab2Layout = QVBoxLayout()
        tab2Layout.addWidget(self.devicetable)
        tab2Layout.setSpacing(5)
        tab2Layout.setContentsMargins(0,10,0,5)
        tab2Layout.addLayout(bLayout)
        #LAYOUT TAB 3 (Symb ET/BT)
        tab3Layout = QVBoxLayout()
        tab3Layout.addWidget(adjustmentGroupBox)
        tab3Layout.setContentsMargins(2,10,2,5)
        #LAYOUT TAB 4 (Phidgets)
        tab4Layout = QVBoxLayout()
        tab4Layout.addLayout(phidgetVBox)
        tab4Layout.setContentsMargins(2,10,2,5)
        tab4Layout.setSpacing(3)
        #LAYOUT TAB 5 (Yoctopuce)
        tab5Layout = QVBoxLayout()
        tab5Layout.addLayout(yoctoVBox)
        tab5Layout.setContentsMargins(2,10,2,5)
        #LAYOUT TAB 6 (Ambient)
        tab6Layout = QVBoxLayout()
        tab6Layout.addLayout(ambientVBox)
        tab6Layout.setContentsMargins(2,10,2,5)
        #main tab widget
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","ET/BT",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","Extra Devices",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3Layout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","Symb ET/BT",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4Layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Phidgets",None))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Yoctopuce",None))
        C6Widget = QWidget()
        C6Widget.setLayout(tab6Layout)
        TabWidget.addTab(C6Widget,QApplication.translate("Tab","Ambient",None))
        TabWidget.currentChanged.connect(self.tabSwitched)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(TabWidget)
        Mlayout.addLayout(buttonLayout)
        Mlayout.setSpacing(0)
        Mlayout.setContentsMargins(5,10,5,5)
        self.setLayout(Mlayout)
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
        settings = QSettings()
        if settings.contains("DeviceAssignmentGeometry"):
            self.restoreGeometry(settings.value("DeviceAssignmentGeometry"))

    @pyqtSlot(int)
    def changeOutprogramFlag(self,_):
        aw.ser.externaloutprogramFlag = not aw.ser.externaloutprogramFlag

    @pyqtSlot(int)
    def asyncFlagStateChanged1048(self,x):
        try:
            i = self.asyncCheckBoxes1048.index(self.sender())
            if x == 0:
                # disable ChangeTrigger selection
                self.changeTriggerCombos1048[i].setEnabled(False)
            else:
                # enable ChangeTrigger selection
                self.changeTriggerCombos1048[i].setEnabled(True)
        except:
            pass

    @pyqtSlot(int)
    def asyncFlagStateChanged1045(self,x):
        if x == 0:
            # disable ChangeTrigger selection
            self.changeTriggerCombos1045.setEnabled(False)
        else:
            # enable ChangeTrigger selection
            self.changeTriggerCombos1045.setEnabled(True)
            
    @pyqtSlot(int)
    def asyncFlagStateChanged1200(self,x):
        if x == 0:
            # disable ChangeTrigger selection
            self.changeTriggerCombo1200.setEnabled(False)
        else:
            # enable ChangeTrigger selection
            self.changeTriggerCombo1200.setEnabled(True)
    
    @pyqtSlot(int)
    def asyncFlagStateChanged(self,x):
        try:
            i = self.asyncCheckBoxes.index(self.sender())
            if x == 0:
                # disable DataRate selection
                self.changeTriggerCombos[i].setEnabled(False)
            else:
                # enable ChangeTrigger and if that is 0 also DataRate selection
                self.changeTriggerCombos[i].setEnabled(True)
        except:
            pass

    def createItems(self,strs):
        items = []
        for i in range(len(strs)):
            item = QStandardItem(strs[i])
            items.append(item)
        return items

    @pyqtSlot(int)
    def PIDfirmwareToggle(self,i):
        if i:
            aw.qmc.PIDbuttonflag = True
        else:
            aw.qmc.PIDbuttonflag = False
        aw.showControlButton()
    
    @pyqtSlot(int)
    def showControlbuttonToggle(self,i):
        if i:
            aw.qmc.Controlbuttonflag = True
        else:
            aw.qmc.Controlbuttonflag = False
        aw.showControlButton()
            
    def createDeviceTable(self):
        try:
            nddevices = len(aw.qmc.extradevices)
            #self.devicetable.clear() # this crashes Ubuntu 16.04
#            if nddevices != 0:
#                self.devicetable.clearContents() # this crashes Ubuntu 16.04 if device table is empty
            self.devicetable.clearSelection()
            self.devicetable.setRowCount(nddevices)
            self.devicetable.setColumnCount(15)
            self.devicetable.setHorizontalHeaderLabels([QApplication.translate("Table", "Device",None),
                                                        QApplication.translate("Table", "Color 1",None),
                                                        QApplication.translate("Table", "Color 2",None),
                                                        QApplication.translate("Table", "Label 1",None),
                                                        QApplication.translate("Table", "Label 2",None),
                                                        QApplication.translate("Table", "y1(x)",None),
                                                        QApplication.translate("Table", "y2(x)",None),
                                                        QApplication.translate("Table", "LCD 1",None),
                                                        QApplication.translate("Table", "LCD 2",None),
                                                        QApplication.translate("Table", "Curve 1",None),
                                                        QApplication.translate("Table", "Curve 2",None),
                                                        deltaLabelUTF8 + " " + QApplication.translate("GroupBox","Axis",None) + " 1",
                                                        deltaLabelUTF8 + " " + QApplication.translate("GroupBox","Axis",None) + " 2",
                                                        QApplication.translate("Table", "Fill 1",None),
                                                        QApplication.translate("Table", "Fill 2",None)])
            self.devicetable.setAlternatingRowColors(True)
            self.devicetable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.devicetable.setSelectionBehavior(QTableWidget.SelectRows)
            self.devicetable.setSelectionMode(QTableWidget.SingleSelection)
            self.devicetable.setShowGrid(True)
            self.devicetable.verticalHeader().setSectionResizeMode(2)
            if nddevices:
                dev = aw.qmc.devices[:]             #deep copy
                limit = len(dev)
                for _ in range(limit):
                    for i in range(len(dev)):
                        if dev[i][0] == "-" or dev[i] == "NONE": # non manual device or deactivated device in extra device list
                            dev.pop(i)              #note: pop() makes the list smaller 
                            break 
                devices = sorted(map(lambda x:(x[1:] if x.startswith("+") else x),dev), key=lambda x: (x[1:] if x.startswith("+") else x))
                for i in range(nddevices):
                    try:
                        typeComboBox =  MyQComboBox()
                        typeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
                        typeComboBox.addItems(devices[:])
                        try:
                            dev_name = aw.qmc.devices[max(0,aw.qmc.extradevices[i]-1)]
                            if dev_name[0] == "+":
                                dev_name = dev_name[1:]
                            typeComboBox.setCurrentIndex(devices.index(dev_name))
                        except Exception:
                            pass
                        color1Button = QPushButton(u(aw.qmc.extradevicecolor1[i]))
                        color1Button.setFocusPolicy(Qt.NoFocus)
                        color1Button.clicked.connect(self.setextracolor1)
                        textcolor = aw.labelBorW(aw.qmc.extradevicecolor1[i])
                        color1Button.setStyleSheet("background-color: %s; color: %s"%(aw.qmc.extradevicecolor1[i], textcolor))
                        color2Button = QPushButton(u(aw.qmc.extradevicecolor2[i]))
                        color2Button.setFocusPolicy(Qt.NoFocus)
                        color2Button.clicked.connect(self.setextracolor2)
                        textcolor = aw.labelBorW(aw.qmc.extradevicecolor2[i])
                        color2Button.setStyleSheet("background-color: %s; color: %s"%(aw.qmc.extradevicecolor2[i], textcolor))
                        name1edit = QLineEdit(u(aw.qmc.extraname1[i]))
                        name2edit = QLineEdit(u(aw.qmc.extraname2[i]))
                        mexpr1edit = QLineEdit(u(aw.qmc.extramathexpression1[i]))
                        mexpr2edit = QLineEdit(u(aw.qmc.extramathexpression2[i]))
                        mexpr1edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + 2*x",None))
                        mexpr2edit.setToolTip(QApplication.translate("Tooltip","Example: 100 + x",None))
                        LCD1visibilityComboBox =  QCheckBox()
                        if aw.extraLCDvisibility1[i]:
                            LCD1visibilityComboBox.setCheckState(Qt.Checked)
                        else:
                            LCD1visibilityComboBox.setCheckState(Qt.Unchecked)
                        LCD1visibilityComboBox.stateChanged.connect(self.updateLCDvisibility1)
                        LCD2visibilityComboBox =  QCheckBox()
                        if aw.extraLCDvisibility2[i]:
                            LCD2visibilityComboBox.setCheckState(Qt.Checked)
                        else:
                            LCD2visibilityComboBox.setCheckState(Qt.Unchecked)
                        LCD2visibilityComboBox.stateChanged.connect(self.updateLCDvisibility2)
                        Curve1visibilityComboBox =  QCheckBox()
                        if aw.extraCurveVisibility1[i]:
                            Curve1visibilityComboBox.setCheckState(Qt.Checked)
                        else:
                            Curve1visibilityComboBox.setCheckState(Qt.Unchecked)
                        Curve1visibilityComboBox.stateChanged.connect(self.updateCurveVisibility1)
                        Curve2visibilityComboBox =  QCheckBox()
                        if aw.extraCurveVisibility2[i]:
                            Curve2visibilityComboBox.setCheckState(Qt.Checked)
                        else:
                            Curve2visibilityComboBox.setCheckState(Qt.Unchecked)
                        Curve2visibilityComboBox.stateChanged.connect(self.updateCurveVisibility2)
                        Delta1ComboBox =  QCheckBox()
                        if aw.extraDelta1[i]:
                            Delta1ComboBox.setCheckState(Qt.Checked)
                        else:
                            Delta1ComboBox.setCheckState(Qt.Unchecked)
                        Delta1ComboBox.stateChanged.connect(self.updateDelta1)
                        Delta2ComboBox =  QCheckBox()
                        if aw.extraDelta2[i]:
                            Delta2ComboBox.setCheckState(Qt.Checked)
                        else:
                            Delta2ComboBox.setCheckState(Qt.Unchecked)
                        Delta2ComboBox.stateChanged.connect(self.updateDelta2)
                        Fill1SpinBox =  QSpinBox()
                        Fill1SpinBox.setSingleStep(1)
                        Fill1SpinBox.setRange(0,100)
                        Fill1SpinBox.setAlignment(Qt.AlignRight)
                        Fill1SpinBox.setValue(aw.extraFill1[i])
                        Fill1SpinBox.editingFinished.connect(self.updateFill1)
                        Fill2SpinBox =  QSpinBox()
                        Fill2SpinBox.setSingleStep(1)
                        Fill2SpinBox.setRange(0,100)
                        Fill2SpinBox.setAlignment(Qt.AlignRight)
                        Fill2SpinBox.setValue(aw.extraFill2[i])
                        Fill2SpinBox.editingFinished.connect(self.updateFill2)
                        #add widgets to the table
                        self.devicetable.setCellWidget(i,0,typeComboBox)
                        self.devicetable.setCellWidget(i,1,color1Button)
                        self.devicetable.setCellWidget(i,2,color2Button)
                        self.devicetable.setCellWidget(i,3,name1edit)
                        self.devicetable.setCellWidget(i,4,name2edit)
                        self.devicetable.setCellWidget(i,5,mexpr1edit)
                        self.devicetable.setCellWidget(i,6,mexpr2edit)
                        self.devicetable.setCellWidget(i,7,LCD1visibilityComboBox)
                        self.devicetable.setCellWidget(i,8,LCD2visibilityComboBox)
                        self.devicetable.setCellWidget(i,9,Curve1visibilityComboBox)
                        self.devicetable.setCellWidget(i,10,Curve2visibilityComboBox)
                        self.devicetable.setCellWidget(i,11,Delta1ComboBox)
                        self.devicetable.setCellWidget(i,12,Delta2ComboBox)
                        self.devicetable.setCellWidget(i,13,Fill1SpinBox)
                        self.devicetable.setCellWidget(i,14,Fill2SpinBox)
                    except Exception as e:
#                        import traceback
#                        traceback.print_exc(file=sys.stdout)
                        pass
                self.devicetable.resizeColumnsToContents()
                self.devicetable.setColumnWidth(0,150)
                # remember the columnwidth
                for i in range(len(aw.qmc.devicetablecolumnwidths)):
                    try:
                        self.devicetable.setColumnWidth(i,aw.qmc.devicetablecolumnwidths[i])
                    except:
                        pass
                header = self.devicetable.horizontalHeader()
                header.setStretchLastSection(True)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " createDeviceTable(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def copyDeviceTabletoClipboard(self,_=False):
        nrows = self.devicetable.rowCount() 
        ncols = self.devicetable.columnCount()
        clipboard = ""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            tbl = prettytable.PrettyTable()
            fields = []
            re_strip = re.compile(u'[\u2009]')  #thin space is not read properly by prettytable
            for c in range(ncols):
                fields.append(re_strip.sub('',u(self.devicetable.horizontalHeaderItem(c).text())))
            tbl.field_names = fields
            for r in range(nrows):
                rows = []
                rows.append(u(self.devicetable.cellWidget(r,0).currentText()))
                rows.append(u(self.devicetable.cellWidget(r,1).palette().button().color().name()))
                rows.append(u(self.devicetable.cellWidget(r,2).palette().button().color().name()))
                rows.append(u(self.devicetable.cellWidget(r,3).text()))
                rows.append(u(self.devicetable.cellWidget(r,4).text()))
                rows.append(u(self.devicetable.cellWidget(r,5).text()))
                rows.append(u(self.devicetable.cellWidget(r,6).text()))
                rows.append(u(self.devicetable.cellWidget(r,7).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,8).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,9).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,10).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,11).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,12).isChecked()))
                rows.append(u(self.devicetable.cellWidget(r,13).value()))
                rows.append(u(self.devicetable.cellWidget(r,14).value()))
                tbl.add_row(rows)
            clipboard = tbl.get_string()
        else:
            for c in range(ncols):
                clipboard += u(self.devicetable.horizontalHeaderItem(c).text())
                if c != (ncols-1):
                    clipboard += '\t'
            clipboard += '\n'
            for r in range(nrows):
                clipboard += u(self.devicetable.cellWidget(r,0).currentText()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,1).palette().button().color().name()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,2).palette().button().color().name()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,3).text()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,4).text()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,5).text()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,6).text()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,7).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,8).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,9).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,10).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,11).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,12).isChecked()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,13).value()) + '\t'
                clipboard += u(self.devicetable.cellWidget(r,14).value()) + '\n'
        # copy to the system clipboard
        sys_clip = QApplication.clipboard()
        sys_clip.setText(clipboard)
        aw.sendmessage(QApplication.translate("Message","Device table copied to clipboard",None))

    @pyqtSlot(bool)
    def loadprogramname(self,_):
        fileName = aw.ArtisanOpenFileDialog()
        if fileName:
            if ' ' in fileName:
                self.programedit.setText('"' + fileName + '"')
            else:
                self.programedit.setText(fileName)
    
    @pyqtSlot(bool)
    def loadoutprogramname(self,_):
        fileName = aw.ArtisanOpenFileDialog()
        if fileName:
            self.outprogramedit.setText(fileName)
            aw.ser.externaloutprogram = u(self.outprogramedit.text())

    def enableDisableAddDeleteButtons(self):
        if len(aw.qmc.extradevices) >= aw.nLCDS:
            self.addButton.setEnabled(False)
        else:
            self.addButton.setEnabled(True)
        if len(aw.qmc.extradevices) > 0:
            self.delButton.setEnabled(True)
        else:
            self.delButton.setEnabled(False)
        if len(aw.qmc.timex) > 0:
            self.recalcButton.setEnabled(True)
        else:
            self.recalcButton.setEnabled(False)

    #adds extra device
    @pyqtSlot(bool)
    def adddevice(self,_):
        try:
            self.savedevicetable()
            #addDevice() is located in aw so that the same function can be used in init after dynamically loading settings
            aw.addDevice()
            self.createDeviceTable()
            self.enableDisableAddDeleteButtons()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " adddevice(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def deldevice(self,_):
        try:
            self.savedevicetable()
            bindex = len(aw.qmc.extradevices)-1
            selected = self.devicetable.selectedRanges()
            if len(selected) > 0:
                bindex = selected[0].topRow()
            if bindex >= 0 and bindex < len(aw.qmc.extradevices):
                self.delextradevice(bindex)
            aw.updateExtraLCDvisibility()
            aw.qmc.resetlinecountcaches()
            self.enableDisableAddDeleteButtons()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " deldevice(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def resetextradevices(self,_):
        try:
            aw.resetExtraDevices()
            #update table
            self.createDeviceTable()
            #enable/disable buttons
            self.enableDisableAddDeleteButtons()
            #redraw
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " resetextradevices(): {0}").format(str(e)),exc_tb.tb_lineno)

    def delextradevice(self,x):
        try:
            aw.qmc.extradevices.pop(x)
            aw.qmc.extradevicecolor1.pop(x)
            aw.qmc.extradevicecolor2.pop(x)
            aw.qmc.extratimex.pop(x)
            aw.qmc.extratemp1.pop(x)
            aw.qmc.extratemp2.pop(x)
            aw.qmc.extrastemp1.pop(x)
            aw.qmc.extrastemp2.pop(x)
            aw.qmc.extractimex1.pop(x)
            aw.qmc.extractimex2.pop(x)
            aw.qmc.extractemp1.pop(x)
            aw.qmc.extractemp2.pop(x)
            aw.qmc.extralinestyles1.pop(x)
            aw.qmc.extralinestyles2.pop(x)
            aw.qmc.extradrawstyles1.pop(x)
            aw.qmc.extradrawstyles2.pop(x)
            aw.qmc.extralinewidths1.pop(x)
            aw.qmc.extralinewidths2.pop(x)
            aw.qmc.extramarkers1.pop(x)
            aw.qmc.extramarkers2.pop(x)
            aw.qmc.extramarkersizes1.pop(x)
            aw.qmc.extramarkersizes2.pop(x)
            
            # visible curves before this one
            before1 = before2 = 0
            for j in range(x):
                if aw.extraCurveVisibility1[j]:
                    before1 = before1 + 1
                if aw.extraCurveVisibility2[j]:
                    before2 = before2 + 1
            if aw.extraCurveVisibility1[x]:
                aw.qmc.extratemp1lines.pop(before1)
            if aw.extraCurveVisibility2[x]:
                aw.qmc.extratemp2lines.pop(before2)
            
            aw.extraLCDvisibility1.pop(x)
            aw.extraLCDvisibility1.append(True) # keep length constant (aw.nLCDS)
            aw.extraLCDvisibility2.pop(x)
            aw.extraLCDvisibility2.append(True) # keep length constant (aw.nLCDS)
            aw.extraCurveVisibility1.pop(x)
            aw.extraCurveVisibility1.append(True) # keep length constant (aw.nLCDS)
            aw.extraCurveVisibility2.pop(x)
            aw.extraCurveVisibility2.append(True) # keep length constant (aw.nLCDS)
            aw.extraDelta1.pop(x)
            aw.extraDelta1.append(False) # keep length constant (aw.nLCDS)
            aw.extraDelta2.pop(x)
            aw.extraDelta2.append(False) # keep length constant (aw.nLCDS)
            aw.extraFill1.pop(x)
            aw.extraFill1.append(0) # keep length constant (aw.nLCDS)
            aw.extraFill2.pop(x)
            aw.extraFill2.append(0) # keep length constant (aw.nLCDS)

            aw.qmc.extraname1.pop(x)
            aw.qmc.extraname2.pop(x)
            aw.qmc.extramathexpression1.pop(x)
            aw.qmc.extramathexpression2.pop(x)
            aw.updateExtraLCDvisibility()
            #pop serial port settings
            if len(aw.extracomport) > x:
                aw.extracomport.pop(x)
            if len(aw.extrabaudrate) > x:
                aw.extrabaudrate.pop(x)
            if len(aw.extrabytesize) > x:
                aw.extrabytesize.pop(x)
            if len(aw.extraparity) > x:
                aw.extraparity.pop(x)
            if len(aw.extrastopbits) > x:
                aw.extrastopbits.pop(x)
            if len(aw.extratimeout) > x:
                aw.extratimeout.pop(x)
            if len(aw.extraser) > x:
                if aw.extraser[x].SP.isOpen():
                    aw.extraser[x].SP.close()
                    libtime.sleep(0.7) # on OS X opening a serial port too fast after closing the port get's disabled
                aw.extraser.pop(x)
            self.createDeviceTable()
            aw.qmc.resetlinecountcaches()
            aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "delextradevice(): {0}").format(str(ex)),exc_tb.tb_lineno)

    def savedevicetable(self,redraw=True):
        try:
            for i in range(len(aw.qmc.extradevices)):
                typecombobox = self.devicetable.cellWidget(i,0)
                #cellWidget(i,1) and cellWidget(i,2) are saved automatically when there is a change. No need to save here.
                name1edit = self.devicetable.cellWidget(i,3)
                name2edit = self.devicetable.cellWidget(i,4)
                mexpr1edit = self.devicetable.cellWidget(i,5)
                mexpr2edit = self.devicetable.cellWidget(i,6)
                try:
                    aw.qmc.extradevices[i] = aw.qmc.devices.index(str(typecombobox.currentText())) + 1
                except Exception:
                    try: # might be a +device
                        aw.qmc.extradevices[i] = aw.qmc.devices.index("+" + str(typecombobox.currentText())) + 1
                    except Exception:
                        aw.qmc.extradevices[i] = 0
                if name1edit:
                    aw.qmc.extraname1[i] = u(name1edit.text())
                else:
                    aw.qmc.extraname1[i] = ""
                if name2edit:
                    aw.qmc.extraname2[i] = u(name2edit.text())
                else:
                    aw.qmc.extraname2[i] = ""
                    
                l1 = "<b>" + aw.qmc.extraname1[i] + "</b>"
                try:
                    aw.extraLCDlabel1[i].setText(l1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel1[i].setText(l1)
                l2 = "<b>" + aw.qmc.extraname2[i] + "</b>"
                try:
                    aw.extraLCDlabel2[i].setText(l2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3]))
                except:
                    aw.extraLCDlabel2[i].setText(l2)
                if mexpr2edit:
                    aw.qmc.extramathexpression1[i] = u(mexpr1edit.text())
                else:
                    aw.qmc.extramathexpression1[i] = ""
                if mexpr2edit:
                    aw.qmc.extramathexpression2[i] = u(mexpr2edit.text())
                else:
                    aw.qmc.extramathexpression2[i] = ""
            #update legend with new curves
            if redraw:
                aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "savedevicetable(): {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def updateVirtualdevicesinprofile(self,_):
        try:
            self.savedevicetable(redraw=False)
            if aw.calcVirtualdevices(update=True):
                aw.qmc.redraw(recomputeAllDeltas=False)
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + "updateVirtualdevicesinprofile(): {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot(int)
    def updateLCDvisibility1(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),7)
        if r is not None:
            aw.extraLCDvisibility1[r] = bool(x)
            aw.extraLCDframe1[r].setVisible(bool(x))

    @pyqtSlot(int)
    def updateLCDvisibility2(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),8)
        if r is not None:
            aw.extraLCDvisibility2[r] = bool(x)
            aw.extraLCDframe2[r].setVisible(bool(x))

    @pyqtSlot(int)
    def updateCurveVisibility1(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),9)
        if r is not None:
            aw.extraCurveVisibility1[r] = bool(x)
            aw.qmc.resetlinecountcaches()

    @pyqtSlot(int)
    def updateCurveVisibility2(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),10)
        if r is not None:
            aw.extraCurveVisibility2[r] = bool(x)
            aw.qmc.resetlinecountcaches()

    @pyqtSlot(int)
    def updateDelta1(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),11)
        if r is not None:
            aw.extraDelta1[r] = bool(x)

    @pyqtSlot(int)
    def updateDelta2(self,x):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),12)
        if r is not None:
            aw.extraDelta2[r] = bool(x)
    
    @pyqtSlot()
    def updateFill1(self):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),13)
        if r is not None:
            aw.extraFill1[r] = self.sender().value()
    
    @pyqtSlot()
    def updateFill2(self):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),14)
        if r is not None:
            aw.extraFill2[r] = self.sender().value()

    @pyqtSlot(bool)
    def setextracolor1(self,_):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),1)
        if r is not None:
            self.setextracolor(1,r)

    @pyqtSlot(bool)
    def setextracolor2(self,_):
        r = aw.findWidgetsRow(self.devicetable,self.sender(),2)
        if r is not None:
            self.setextracolor(2,r)

    def setextracolor(self,l,i):
        try:
            #line 1
            if l == 1:
                # use native no buttons dialog on Mac OS X, blocks otherwise
                colorf = aw.colordialog(QColor(aw.qmc.extradevicecolor1[i]),True,self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor1[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel1[i],QColor(colorname))                    
                    self.devicetable.cellWidget(i,1).setStyleSheet("background-color: %s; color: %s"%(aw.qmc.extradevicecolor1[i], aw.labelBorW(aw.qmc.extradevicecolor1[i])))
                    self.devicetable.cellWidget(i,1).setText(u(colorname))
                    aw.checkColors([(aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate("Label","Background",None), aw.qmc.palette['background'])])
                    aw.checkColors([(aw.qmc.extraname1[i], aw.qmc.extradevicecolor1[i], QApplication.translate("Label","Legend bkgnd",None), aw.qmc.palette['background'])])
            #line 2
            elif l == 2:
                # use native no buttons dialog on Mac OS X, blocks otherwise
                colorf = aw.colordialog(QColor(aw.qmc.extradevicecolor2[i]),True,self)
                if colorf.isValid():
                    colorname = str(colorf.name())
                    aw.qmc.extradevicecolor2[i] = colorname
                    # set LCD label color
                    aw.setLabelColor(aw.extraLCDlabel2[i],QColor(colorname))
                    self.devicetable.cellWidget(i,2).setStyleSheet("background-color: %s; color: %s"%(aw.qmc.extradevicecolor2[i], aw.labelBorW(aw.qmc.extradevicecolor2[i])))
                    self.devicetable.cellWidget(i,2).setText(u(colorname))
                    aw.checkColors([(aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate("Label","Background",None), aw.qmc.palette['background'])])
                    aw.checkColors([(aw.qmc.extraname2[i], aw.qmc.extradevicecolor2[i], QApplication.translate("Label","Legend bkgnd",None),aw.qmc.palette['background'])])
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setextracolor(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot()
    def cancelEvent(self):
        self.closeHelp()
        self.reject()

    @pyqtSlot()
    def okEvent(self):
        try:
            self.closeHelp()
            settings = QSettings()
            #save window geometry
            settings.setValue("DeviceAssignmentGeometry",self.saveGeometry()) 
        
            #save any extra devices here
            self.savedevicetable(redraw=False)
            aw.qmc.devicetablecolumnwidths = [self.devicetable.columnWidth(c) for c in range(self.devicetable.columnCount())]
            
            message = QApplication.translate("Message","Device not set", None)
            # by default switch PID buttons/LCDs off
            aw.button_10.setVisible(False)
            aw.LCD6frame.setVisible(False)
            aw.LCD7frame.setVisible(False)
            aw.qmc.resetlinecountcaches()
            aw.ser.arduinoETChannel = str(self.arduinoETComboBox.currentText())
            aw.ser.arduinoBTChannel = str(self.arduinoBTComboBox.currentText())
            aw.ser.arduinoATChannel = str(self.arduinoATComboBox.currentText())
            aw.ser.ArduinoFILT = [sb.value() for sb in self.FILTspinBoxes]
            
            aw.ser.externalprogram = u(self.programedit.text())
            aw.ser.externaloutprogram = u(self.outprogramedit.text())
            
            if self.pidButton.isChecked():
                #type index[0]: 0 = PXG, 1 = PXR, 2 = DTA
                if str(self.controlpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.controlETpid[0] = 0
                    str1 = "Fuji PXG"
                elif str(self.controlpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.controlETpid[0] = 1
                    str1 = "Fuji PXR"
                elif str(self.controlpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.controlETpid[0] = 2
                    str1 = "Delta DTA"
                elif str(self.controlpidtypeComboBox.currentText()) == "Fuji PXF":
                    aw.ser.controlETpid[0] = 4
                    str1 = "Fuji PXF"
                aw.ser.controlETpid[1] =  int(str(self.controlpidunitidComboBox.currentText()))
                if str(self.btpidtypeComboBox.currentText()) == "Fuji PXG":
                    aw.ser.readBTpid[0] = 0
                    str2 = "Fuji PXG"
                elif str(self.btpidtypeComboBox.currentText()) == "Fuji PXR":
                    aw.ser.readBTpid[0] = 1
                    str2 = "Fuji PXR"
                elif str(self.btpidtypeComboBox.currentText()) == "None":
                    aw.ser.readBTpid[0] = 2
                    str2 = "None"
                elif str(self.btpidtypeComboBox.currentText()) == "Delta DTA":
                    aw.ser.readBTpid[0] = 3
                    str2 = "Delta DTA"
                elif str(self.btpidtypeComboBox.currentText()) == "Fuji PXF":
                    aw.ser.readBTpid[0] = 4
                    str2 = "Fuji PXF"
                aw.ser.readBTpid[1] =  int(str(self.btpidunitidComboBox.currentText()))
                if self.showFujiLCDs.isChecked():
                    aw.ser.showFujiLCDs = True
                else:
                    aw.ser.showFujiLCDs = False
                if self.useModbusPort.isChecked():
                    aw.ser.useModbusPort = True
                else:
                    aw.ser.useModbusPort = False
                #If fuji pid
                if str1 != "Delta DTA":
                    aw.qmc.device = 0
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'O'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                #else if DTA pid
                else:
                    aw.qmc.device = 26
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                message = QApplication.translate("Message","PID to control ET set to {0} {1}" + \
                                                 " ; PID to read BT set to {2} {3}", None).format(str1,str(aw.ser.controlETpid[1]),str2,str(aw.ser.readBTpid[1]))
            elif self.arduinoButton.isChecked():
                meter = "Arduino (TC4)"
                aw.qmc.device = 19
                aw.ser.baudrate = 115200
                aw.ser.bytesize = 8
                aw.ser.parity= 'N'
                aw.ser.stopbits = 1
                aw.ser.timeout = 1.0
                aw.ser.ArduinoIsInitialized = 0 # ensure the Arduino gets reinitalized if settings changed
                message = QApplication.translate("Message","Device set to {0}. Now, check Serial Port settings", None).format(meter)
            elif self.programButton.isChecked():
                meter = u(self.programedit.text())
                aw.ser.externalprogram = meter
                aw.qmc.device = 27
                message = QApplication.translate("Message","Device set to {0}. Now, check Serial Port settings", None).format(meter)
            elif self.nonpidButton.isChecked():
                meter = str(self.devicetypeComboBox.currentText())
                if meter == "Omega HH806AU":
                    aw.qmc.device = 1
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                elif meter == "Omega HH506RA":
                    aw.qmc.device = 2
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    aw.ser.HH506RAid = "X" # ensure the HH506RA gets reinitalized if settings changed
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 309":
                    aw.qmc.device = 3
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 306":
                    aw.qmc.device = 4
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 305":
                    aw.qmc.device = 5
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to CENTER 305, which is equivalent to CENTER 306. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 304":
                    aw.qmc.device = 6
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 309. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 303":
                    aw.qmc.device = 7
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 302":
                    aw.qmc.device = 8
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 303. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 301":
                    aw.qmc.device = 9
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 303. Now, chose serial port", None).format(meter)
                elif meter == "CENTER 300":
                    aw.qmc.device = 10
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 303. Now, chose serial port", None).format(meter)
                elif meter == "VOLTCRAFT K204":
                    aw.qmc.device = 11
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 309. Now, chose serial port", None).format(meter)
                elif meter == "VOLTCRAFT K202":
                    aw.qmc.device = 12
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 306. Now, chose serial port", None).format(meter)
                elif meter == "VOLTCRAFT 300K":
                    aw.qmc.device = 13
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 0.5
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 303. Now, chose serial port", None).format(meter)
                elif meter == "VOLTCRAFT 302KJ":
                    aw.qmc.device = 14
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 303. Now, chose serial port", None).format(meter)
                elif meter == "EXTECH 421509":
                    aw.qmc.device = 15
                    #aw.ser.comport = "/dev/tty.usbserial-A2001Epn"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 7
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to Omega HH506RA. Now, chose serial port", None).format(meter)
                elif meter == "Omega HH802U":
                    aw.qmc.device = 16
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to Omega HH806AU. Now, chose serial port", None).format(meter)
                elif meter == "Omega HH309":
                    aw.qmc.device = 17
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                #special device manual mode. No serial settings.
                elif meter == "NONE":
                    aw.qmc.device = 18
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                    st = ""
                    if aw.qmc.delay != aw.qmc.min_delay:
                        aw.qmc.delay = aw.qmc.min_delay
                        st += ". Sampling rate changed to 1 second"
                    # ensure that events button is shown
                    aw.eventsbuttonflag = 1
                    aw.button_11.setVisible(True)
                    message = QApplication.translate("Message","Device set to {0}{1}", None).format(meter,st)
                ##########################
                ####  DEVICE 19 is the Arduino/TC4
                ##########################
                elif meter == "TE VA18B":
                    aw.qmc.device = 20
                    #aw.ser.comport = "COM7"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, check Serial Port settings", None).format(meter)
                ##########################
                ####  DEVICE 21 is +309_34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 22 is +PID DUTY% but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HHM28[6]":
                    aw.qmc.device = 23
                    #aw.ser.comport = "COM1"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, check Serial Port settings", None).format(meter)
# +DEVICEs cannot be set as main device
                ##########################
                ####  DEVICE 24 is +VOLTCRAFT 204_34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 25 is +Virtual but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 26 is DTA pid
                ##########################
                ##########################
                ####  DEVICE 27 is an external program
                ##########################
                ##########################
                ####  DEVICE 28 is +ArduinoTC4 34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "MODBUS":
                    aw.qmc.device = 29
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 115200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose Modbus serial port or IP address", None).format(meter)
                elif meter == "VOLTCRAFT K201":
                    aw.qmc.device = 30
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to CENTER 302. Now, chose serial port", None).format(meter)
                elif meter == "Amprobe TMD-56":
                    aw.qmc.device = 31
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 19200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}, which is equivalent to Omega HH806AU. Now, chose serial port", None).format(meter)
                ##########################
                ####  DEVICE 32 is +ArduinoTC4 56 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 33 is +MODBUS 34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Phidget 1048 4xTC 01":
                    aw.qmc.device = 34
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 35 is +Phidget 1048 4xTC 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 36 is +Phidget 1048 4xTC AT but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Phidget 1046 4xRTD 01":
                    aw.qmc.device = 37
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 38 is +Phidget 1046 4xRTD 23 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Mastech MS6514":
                    aw.qmc.device = 39
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                elif meter == "Phidget IO 01":
                    aw.qmc.device = 40
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 41 is +Phidget IO 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 42 is +Phidget IO 45 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 43 is +Phidget IO 67 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 44 is +ARDUINOTC4_78 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Yocto Thermocouple":
                    aw.qmc.device = 45
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                elif meter == "Yocto PT100":
                    aw.qmc.device = 46
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                elif meter == "Phidget 1045 IR":
                    aw.qmc.device = 47
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 48 is an external program 34
                ##########################
                ##########################
                ####  DEVICE 49 is an external program 56
                ##########################
                elif meter == "DUMMY": # including a dummy serial device (can be used for serial commands)
                    aw.qmc.device = 50
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                ##########################
                ####  DEVICE 51 is +304_34 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Phidget 1051 1xTC 01":
                    aw.qmc.device = 52
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                elif meter == "Hottop BT/ET":
                    aw.qmc.device = 53
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 115200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ####  DEVICE 54 is +Hottop HF but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Omega HH806W":
                    aw.qmc.device = 55
                    #aw.ser.comport = "COM11"
                    aw.ser.baudrate = 38400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'E'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ####  DEVICE 55 is +MODBUS_56 but +DEVICE cannot be set as main device
                ##########################
                elif meter == "Apollo DT301":
                    aw.qmc.device = 56
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                elif meter == "EXTECH 755":
                    aw.qmc.device = 57
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                elif meter == "Phidget TMP1101 4xTC 01":
                    aw.qmc.device = 58
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 59 is +Phidget TMP1101 4xTC 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 60 is +Phidget TMP1101 4xTC AT but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "Phidget TMP1100 1xTC":
                    aw.qmc.device = 61
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Phidget 1011 IO 01":
                    aw.qmc.device = 62
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Phidget HUB IO 01":
                    aw.qmc.device = 63
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ##########################
                ####  DEVICE 64 is +Phidget HUB IO 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 65 is +Phidget HUB IO 45 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 66 is -HH806W but -DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "VOLTCRAFT PL-125-T2":
                    aw.qmc.device = 67
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ##########################
                elif meter == "Phidget TMP1200 1xRTD":
                    aw.qmc.device = 68
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Phidget IO Digital 01":
                    aw.qmc.device = 69
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 70 is +Phidget IO Digital 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 71 is +Phidget IO Digital 45 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 72 is +Phidget IO Digital 67 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "Phidget 1011 IO Digital 01":
                    aw.qmc.device = 73
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Phidget HUB IO Digital 01":
                    aw.qmc.device = 74
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ##########################
                ####  DEVICE 75 is +Phidget HUB IO Digital 23 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 76 is +Phidget HUB IO Digital 45 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "VOLTCRAFT PL-125-T4":
                    aw.qmc.device = 77
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 9600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ##########################
                ####  DEVICE 78 is +VOLTCRAFT PL-125-T4 34 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                elif meter == "S7":
                    aw.qmc.device = 79
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 115200
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 80 is +S7 34 but no serial setup
                ##########################
                ##########################
                ####  DEVICE 81 is +S7 56 but no serial setup
                ##########################
                ##########################
                ####  DEVICE 82 is +S7 78 but no serial setup
                ##########################
                ##########################
                ####  DEVICE 83-87 are Aillio R1 and have no serial setup
                ##########################
                elif meter == "Aillio Bullet R1 BT/DT":
                    aw.qmc.device = 83
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 88 and 89 are an external program 78 and 910
                ##########################
                ##########################
                ####  DEVICE 90 and 91 are an slider 01 and slider 23
                ##########################
                ##########################
                ####  DEVICE 92-94 are an Probat Middleware and have no serial setup
                ##########################
                elif meter == "Probat Middleware":
                    aw.qmc.device = 92
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 95 is Phidget DAQ1400 Current
                ##########################
                elif meter == "Phidget DAQ1400 Current":
                    aw.qmc.device = 95
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 96 is Phidget DAQ1400 Frequency
                ##########################
                elif meter == "Phidget DAQ1400 Frequency":
                    aw.qmc.device = 96
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 97 is Phidget DAQ1400 Digital
                ##########################
                elif meter == "Phidget DAQ1400 Digital":
                    aw.qmc.device = 97
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 98 is Phidget DAQ1400 Voltage
                ##########################
                elif meter == "Phidget DAQ1400 Voltage":
                    aw.qmc.device = 98
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 99 is Aillio Bullet R1 IBTS/DT
                ##########################
                elif meter == "Aillio Bullet R1 IBTS/DT":
                    aw.qmc.device = 99
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 100 are Yocto IR
                ##########################
                elif meter == "Yocto IR":
                    aw.qmc.device = 100
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                elif meter == "Behmor BT/CT":
                    aw.qmc.device = 101
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 57600
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ####  DEVICE 102 Behmor 34 channel 3 and 4
                ##########################
                elif meter == "VICTOR 86B":
                    aw.qmc.device = 103
                    #aw.ser.comport = "COM4"
                    aw.ser.baudrate = 2400
                    aw.ser.bytesize = 8
                    aw.ser.parity= 'N'
                    aw.ser.stopbits = 1
                    aw.ser.timeout = 1.0
                    message = QApplication.translate("Message","Device set to {0}. Now, chose serial port", None).format(meter)
                ##########################
                ####  DEVICE 104 Behmor 56 channel 5 and 6
                ##########################
                ##########################
                ####  DEVICE 105 Behmor 78 channel 7 and 8
                ##########################
                ##########################
                elif meter == "Phidget HUB IO 0":
                    aw.qmc.device = 106
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Phidget HUB IO Digital 0":
                    aw.qmc.device = 107
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                elif meter == "Yocto 4-20ma Rx":
                    aw.qmc.device = 108
                    message = QApplication.translate("Message","Device set to {0}", None).format(meter)
                ##########################
                ####  DEVICE 109 is +MODBUS_78 but +DEVICE cannot be set as main device
                ##########################
                ##########################
                ####  DEVICE 110 is +S7_010 but +DEVICE cannot be set as main device
                ##########################

                # ADD DEVICE:

                # ensure that by selecting a real device, the initial sampling rate is set to 3s
                if meter != "NONE":
                    aw.qmc.delay = max(aw.qmc.delay,aw.qmc.min_delay)
            # update Control button visibility
            aw.showControlButton()
            
    # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
    # - add an elif entry above to specify the default serial settings
            #extra devices serial config
            #set of different serial settings modes options
            ssettings = [[9600,8,'O',1,1],[19200,8,'E',1,1],[2400,7,'E',1,1],[9600,8,'N',1,1],
                         [19200,8,'N',1,1],[2400,8,'N',1,1],[9600,8,'E',1,1],[38400,8,'E',1,1],[115200,8,'N',1,1],[57600,8,'N',1,1]]
            #map device index to a setting mode (chose the one that matches the device)
    # ADD DEVICE: to add a device you have to modify several places. Search for the tag "ADD DEVICE:"in the code
    # - add an entry to devsettings below (and potentially to ssettings above)
            devssettings = [
                0, # 0
                1, # 1
                2, # 2
                3, # 3
                3, # 4
                3, # 5
                3, # 6
                3, # 7
                3, # 8
                3, # 9
                3, # 10
                3, # 11
                3, # 12
                3, # 13
                3, # 14
                2, # 15
                1, # 16
                3, # 17
                0, # 18
                4, # 19
                5, # 20
                3, # 21
                6, # 22
                5, # 23
                3, # 24
                3, # 25
                6, # 26
                3, # 27
                4, # 28
                8, # 29
                3, # 30
                1, # 31
                4, # 32
                7, # 33
                1, # 34
                1, # 35
                1, # 36
                1, # 37
                1, # 38
                3, # 39
                1, # 40
                1, # 41
                1, # 42
                1, # 43
                4, # 44
                1, # 45
                1, # 46
                1, # 47
                3, # 48
                3, # 49
                3, # 50
                3, # 51
                1, # 52
                8, # 53
                8, # 54
                7, # 55
                3, # 56
                3, # 57
                1, # 58
                1, # 59
                1, # 60
                1, # 61
                1, # 62
                1, # 63
                1, # 64
                1, # 65
                8, # 66
                3, # 67
                1, # 68
                1, # 69
                1, # 70
                1, # 71
                1, # 72
                1, # 73
                1, # 74
                1, # 75
                1, # 76
                3, # 77
                3, # 78
                1, # 79
                1, # 80
                1, # 81
                1, # 82
                1, # 83
                1, # 84
                1, # 85
                1, # 86
                1, # 87
                1, # 88
                1, # 89
                1, # 90
                1, # 91
                1, # 92
                1, # 93
                1, # 94
                1, # 99
                1, # 100
                9, # 101
                9, # 102
                5, # 103
                9, # 104
                9, # 105
                1, # 106
                1, # 107
                1, # 108
                7, # 109
                1, # 110
                ] 
            #init serial settings of extra devices
            for i in range(len(aw.qmc.extradevices)):
                if aw.qmc.extradevices[i] < len(devssettings) and devssettings[aw.qmc.extradevices[i]] < len(ssettings):
                    dsettings = ssettings[devssettings[aw.qmc.extradevices[i]]]
                    if i < len(aw.extrabaudrate):
                        aw.extrabaudrate[i] = dsettings[0]
                    else:
                        aw.extrabaudrate.append(dsettings[0])
                    if i < len(aw.extrabytesize):
                        aw.extrabytesize[i] = dsettings[1]
                    else:
                        aw.extrabytesize.append(dsettings[1])
                    if i < len(aw.extraparity): 
                        aw.extraparity[i] = dsettings[2]
                    else:
                        aw.extraparity.append(dsettings[2])
                    if i < len(aw.extrastopbits):
                        aw.extrastopbits[i] = dsettings[3]
                    else:
                        aw.extrastopbits.append(dsettings[3])
                    if i < len(aw.extratimeout):
                        aw.extratimeout[i] = dsettings[4]
                    else:
                        aw.extratimeout.append(dsettings[4])
            if self.nonpidButton.isChecked():
                aw.button_12.setVisible(False)
                aw.button_13.setVisible(False)
                aw.button_14.setVisible(False)
                aw.button_15.setVisible(False)
                aw.button_16.setVisible(False)
                aw.button_17.setVisible(False)
                aw.LCD6frame.setVisible(False)
                aw.LCD7frame.setVisible(False)
            aw.qmc.ETfunction = str(self.ETfunctionedit.text())
            aw.qmc.BTfunction = str(self.BTfunctionedit.text())
            aw.qmc.ETcurve = self.ETcurve.isChecked()
            aw.qmc.BTcurve = self.BTcurve.isChecked()
            aw.qmc.ETlcd = self.ETlcd.isChecked()
            aw.qmc.BTlcd = self.BTlcd.isChecked()
            
            swap = self.swaplcds.isChecked()
            # swap BT/ET lcds on leaving the dialog
            if aw.qmc.swaplcds != swap:
                tmp = QWidget()
                tmp.setLayout(aw.LCD2frame.layout())
                aw.LCD2frame.setLayout(aw.LCD3frame.layout())
                aw.LCD3frame.setLayout(tmp.layout())
                if aw.largeLCDs_dialog is not None:
                    aw.qmc.swaplcds = swap
                    aw.largeLCDs_dialog.reLayout()
            aw.qmc.swaplcds = swap
            
            # close all ports to force a reopen
            aw.qmc.disconnectProbes()
            
            # Yotopuce configurations
            aw.qmc.yoctoRemoteFlag = self.yoctoBoxRemoteFlag.isChecked()
            aw.qmc.yoctoServerID = u(self.yoctoServerId.text())
            aw.qmc.YOCTO_emissivity = self.yoctoEmissivitySpinBox.value()
            aw.qmc.YOCTO_async[0] = self.yoctoAyncChanFlag.isChecked()
            aw.qmc.YOCTO_async[1] = self.yoctoAyncChanFlag.isChecked() # flag for channel 1 is ignored and only that of channel 0 is respected for both channels
            aw.qmc.YOCTO_dataRate = aw.qmc.YOCTO_dataRatesValues[self.yoctoDataRateCombo.currentIndex()]
            
            # Ambient confifgurations
            aw.qmc.ambient_temperature_device = self.temperatureDeviceCombo.currentIndex()
            aw.qmc.ambient_humidity_device = self.humidityDeviceCombo.currentIndex()
            aw.qmc.ambient_pressure_device = self.pressureDeviceCombo.currentIndex()
            try:
                aw.qmc.elevation = int(self.elevationSpinBox.value())
            except:
                pass
            
            # Phidget configurations
            for i in range(4):
                aw.qmc.phidget1048_types[i] = self.probeTypeCombos[i].currentIndex()+1
                aw.qmc.phidget1048_async[i] = self.asyncCheckBoxes1048[i].isChecked()
                aw.qmc.phidget1048_changeTriggers[i] = aw.qmc.phidget1048_changeTriggersValues[self.changeTriggerCombos1048[i].currentIndex()]
                aw.qmc.phidget1046_gain[i] = self.gainCombos1046[i].currentIndex()+1
                aw.qmc.phidget1046_formula[i] = self.formulaCombos1046[i].currentIndex()
                aw.qmc.phidget1046_async[i] = self.asyncCheckBoxes1046[i].isChecked()
            aw.qmc.phidget1048_dataRate = aw.qmc.phidget_dataRatesValues[self.dataRateCombo1048.currentIndex()]
            aw.qmc.phidget1046_dataRate = aw.qmc.phidget_dataRatesValues[self.dataRateCombo1046.currentIndex()]
            aw.qmc.phidget1045_async = self.asyncCheckBoxe1045.isChecked()
            aw.qmc.phidget1045_changeTrigger = aw.qmc.phidget1045_changeTriggersValues[self.changeTriggerCombos1045.currentIndex()]
            aw.qmc.phidget1045_emissivity = self.emissivitySpinBox.value() 
            aw.qmc.phidget1045_dataRate = aw.qmc.phidget_dataRatesValues[self.dataRateCombo1045.currentIndex()] 
            
            aw.qmc.phidget1200_formula = self.formulaCombo1200.currentIndex()
            aw.qmc.phidget1200_wire = self.wireCombo1200.currentIndex()
            aw.qmc.phidget1200_async = self.asyncCheckBoxe1200.isChecked()
            aw.qmc.phidget1200_changeTrigger = aw.qmc.phidget1200_changeTriggersValues[self.changeTriggerCombo1200.currentIndex()]
            aw.qmc.phidget1200_dataRate = aw.qmc.phidget1200_dataRatesValues[self.rateCombo1200.currentIndex()]
            
            aw.qmc.phidgetDAQ1400_powerSupply = self.powerCombo1400.currentIndex()
            aw.qmc.phidgetDAQ1400_inputMode = self.modeCombo1400.currentIndex()
                      
            aw.qmc.phidgetRemoteFlag = self.phidgetBoxRemoteFlag.isChecked()
            aw.qmc.phidgetServerID = u(self.phidgetServerId.text())
            aw.qmc.phidgetPassword = u(self.phidgetPassword.text())
            aw.qmc.phidgetRemoteOnlyFlag = self.phidgetBoxRemoteOnlyFlag.isChecked()
            try:
                aw.qmc.phidgetPort = int(self.phidgetPort.text())
            except:
                pass
            for i in range(8):
                aw.qmc.phidget1018_async[i] = self.asyncCheckBoxes[i].isChecked()
                aw.qmc.phidget1018_ratio[i] = self.ratioCheckBoxes[i].isChecked()
                aw.qmc.phidget1018_dataRates[i] = aw.qmc.phidget_dataRatesValues[self.dataRateCombos[i].currentIndex()]
                aw.qmc.phidget1018_changeTriggers[i] = aw.qmc.phidget1018_changeTriggersValues[self.changeTriggerCombos[i].currentIndex()]

            # LCD visibility
            aw.LCD2frame.setVisible((aw.qmc.BTlcd if aw.qmc.swaplcds else aw.qmc.ETlcd))
            aw.LCD3frame.setVisible((aw.qmc.ETlcd if aw.qmc.swaplcds else aw.qmc.BTlcd))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateVisiblitiesETBT()
            if aw.largePIDLCDs_dialog:
                aw.largePIDLCDs_dialog.updateVisiblitiesPID()
            if aw.largeExtraLCDs_dialog:
                aw.largeExtraLCDs_dialog.reLayout() # names, styles and visibilties might have changed
            
            # restart PhidgetManager
            try:
                aw.qmc.restartPhidgetManager()
            except:
                pass
            
            aw.qmc.redraw(recomputeAllDeltas=False)
            aw.sendmessage(message)
            #open serial conf Dialog
            self.accept()
            #if device is not None or not external-program (don't need serial settings config)
            if not(aw.qmc.device in aw.qmc.nonSerialDevices):
                aw.setcommport()
            #self.close()
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " device accept(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def showSymbolicHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = symbolicformulasHelpDlg(self)
        except:
            self.helpdialog = symbolicformulasHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    @pyqtSlot(bool)
    def showhelpprogram(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = programHelpDlg(self)
        except:
            self.helpdialog = programHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

    @pyqtSlot(int)
    def tabSwitched(self,_):
        self.closeHelp()

########################################################################################
#####################  PROGRAM HELP DLG ################################################
########################################################################################
class programHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(programHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Symbolic Formulas Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("programHelpGeometry"):
            self.restoreGeometry(settings.value("programHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','EXTERNAL PROGRAMS',None)) + "</b>"
        tbl_Programstop = prettytable.PrettyTable()
        tbl_Programstop.header = False
        tbl_Programstop.add_row([u(QApplication.translate('HelpDlg','Allows to link to external programs that print temperature when called',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','The output of the program must be to Stdout (like when using print statements)',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','this allo ws to connect meters that use any programming language',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Example of output needed from program for single temperature (BT)',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','"100.4" (note: "" not needed)',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','Example of output needed from program for double temperature (ET,BT)',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','"200.4,100.4" (note: temperatures are separated by a comma "ET,BT")',None))])
        helpstr += tbl_Programstop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Programsbottom = prettytable.PrettyTable()
        tbl_Programsbottom.header = False
        tbl_Programsbottom.add_row([u(QApplication.translate('HelpDlg','Example of a file written in python language called test.py:',None))+newline+u(QApplication.translate('HelpDlg','#comment: print a string with two numbers separated by a comma',None))+newline+u(QApplication.translate('HelpDlg','',None))+newline+u(QApplication.translate('HelpDlg','#!/usr/bin/env python',None))+newline+u(QApplication.translate('HelpDlg','print ("237.1,100.4")',None))])
        helpstr += tbl_Programsbottom.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("programHelpGeometry",self.saveGeometry())


############################################################
#######################  CUSTOM COLOR DIALOG  ##############
############################################################

class graphColorDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(graphColorDlg,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose, False) # overwrite the ArtisanDialog class default here!!
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Colors", None))
        titlefont = QFont()
        titlefont.setBold(True)
        titlefont.setWeight(75)
        self.commonstyle = "border-style: solid; border-width: 1px; border-radius: 4px; border-color: black; padding: 4px;"
        
        #TAB0
        profilecolorlabel = QLabel(QApplication.translate("Label","Profile Colors",None))
        profilecolorlabel.setFont(titlefont)
        bgcolorlabel = QLabel(QApplication.translate("Label","Background Profile Colors",None))
        bgcolorlabel.setFont(titlefont)
        profilecolorlabel.setMaximumSize(180,20)
        bgcolorlabel.setMaximumSize(180,20)
        profilecolorlabel.setMinimumSize(150,20)
        bgcolorlabel.setMinimumSize(150,20)
        
        self.metLabel = QLabel(QApplication.translate("Button","ET", None))
        self.metLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.metButton = QPushButton()
        self.metButton.setFocusPolicy(Qt.NoFocus)
        self.metButton.clicked.connect(self.setColorSlot)
        self.btLabel = QLabel(QApplication.translate("Button","BT", None))
        self.btLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.btButton = QPushButton()
        self.btButton.setFocusPolicy(Qt.NoFocus)
        self.btButton.clicked.connect(self.setColorSlot)
        self.deltametLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Button","ET", None))
        self.deltametLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.deltametButton = QPushButton()
        self.deltametButton.setFocusPolicy(Qt.NoFocus)
        self.deltametButton.clicked.connect(self.setColorSlot)
        self.deltabtLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Button","BT", None))
        self.deltabtLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.deltabtButton = QPushButton()
        self.deltabtButton.setFocusPolicy(Qt.NoFocus)
        self.deltabtButton.clicked.connect(self.setColorSlot)

        self.bgmetLabel = QLabel(QApplication.translate("Button","ET", None))
        self.bgmetLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgmetButton = QPushButton()
        self.bgmetButton.setFocusPolicy(Qt.NoFocus)
        self.bgmetButton.clicked.connect(self.setbgColorSlot)
        self.bgbtLabel = QLabel(QApplication.translate("Button","BT", None))
        self.bgbtLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgbtButton = QPushButton()
        self.bgbtButton.setFocusPolicy(Qt.NoFocus)
        self.bgbtButton.clicked.connect(self.setbgColorSlot)
        self.bgdeltametLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Button","ET", None))
        self.bgdeltametLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgdeltametButton = QPushButton()
        self.bgdeltametButton.setFocusPolicy(Qt.NoFocus)
        self.bgdeltametButton.clicked.connect(self.setbgColorSlot)
        self.bgdeltabtLabel = QLabel(deltaLabelUTF8 + QApplication.translate("Button","BT", None))
        self.bgdeltabtLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgdeltabtButton = QPushButton()
        self.bgdeltabtButton.setFocusPolicy(Qt.NoFocus)
        self.bgdeltabtButton.clicked.connect(self.setbgColorSlot)

        self.bgextraLabel = QLabel(QApplication.translate("Button","Extra", None))
        self.bgextraLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgextraButton = QPushButton()
        self.bgextraButton.setFocusPolicy(Qt.NoFocus)
        self.bgextraButton.clicked.connect(self.setbgColorSlot)
            
        opaqbgLabel = QLabel(QApplication.translate("Label", "Opaqueness",None))
        opaqbgLabel.setAlignment(Qt.AlignRight)
        self.opaqbgSpinBox = QSpinBox()
        self.opaqbgSpinBox.setAlignment(Qt.AlignRight)
        self.opaqbgSpinBox.setRange(1,10)
        self.opaqbgSpinBox.setSingleStep(1)
        self.opaqbgSpinBox.setValue(aw.qmc.backgroundalpha * 10)
        self.opaqbgSpinBox.valueChanged.connect(self.adjustintensity)
        self.opaqbgSpinBox.setFocusPolicy(Qt.NoFocus)
        self.opaqbgLayout = QHBoxLayout()
        self.opaqbgLayout.addWidget(opaqbgLabel)
        self.opaqbgLayout.addWidget(self.opaqbgSpinBox)
            
        #TAB1
        self.backgroundLabel = QLabel(QApplication.translate("Button","Background", None))
        self.backgroundLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.backgroundButton = QPushButton()
        self.backgroundButton = self.colorButton(aw.qmc.palette["background"])
        self.backgroundButton.setFocusPolicy(Qt.NoFocus)
        self.backgroundButton.clicked.connect(self.setColorSlot)
        self.gridLabel = QLabel(QApplication.translate("Button","Grid", None))
        self.gridLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.gridButton = QPushButton()
        self.gridButton = self.colorButton(aw.qmc.palette["grid"])
        self.gridButton.setFocusPolicy(Qt.NoFocus)
        self.gridButton.clicked.connect(self.setColorSlot)
        self.titleLabel = QLabel(QApplication.translate("Button","Title", None))
        self.titleLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.titleButton = QPushButton()
        self.titleButton = self.colorButton(aw.qmc.palette["title"])
        self.titleButton.setFocusPolicy(Qt.NoFocus)
        self.titleButton.clicked.connect(self.setColorSlot)
        self.yLabel = QLabel(QApplication.translate("Button","Y Label", None))
        self.yLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.yButton = QPushButton()
        self.yButton = self.colorButton(aw.qmc.palette["ylabel"])
        self.yButton.setFocusPolicy(Qt.NoFocus)
        self.yButton.clicked.connect(self.setColorSlot)
        self.xLabel = QLabel(QApplication.translate("Button","X Label", None))
        self.xLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.xButton = self.colorButton(aw.qmc.palette["xlabel"])
        self.xButton.setFocusPolicy(Qt.NoFocus)
        self.xButton.clicked.connect(self.setColorSlot)
        self.rect1Label = QLabel(QApplication.translate("Button","Drying Phase", None))
        self.rect1Label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.rect1Button = QPushButton()
        self.rect1Button = self.colorButton(aw.qmc.palette["rect1"])
        self.rect1Button.setFocusPolicy(Qt.NoFocus)
        self.rect1Button.clicked.connect(self.setColorSlot)
        self.rect2Label = QLabel(QApplication.translate("Button","Maillard Phase", None))
        self.rect2Label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.rect2Button = QPushButton()
        self.rect2Button = self.colorButton(aw.qmc.palette["rect2"])
        self.rect2Button.setFocusPolicy(Qt.NoFocus)
        self.rect2Button.clicked.connect(self.setColorSlot)
        self.rect3Label = QLabel(QApplication.translate("Button","Finishing Phase", None))
        self.rect3Label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.rect3Button = QPushButton()
        self.rect3Button = self.colorButton(aw.qmc.palette["rect3"])
        self.rect3Button.setFocusPolicy(Qt.NoFocus)
        self.rect3Button.clicked.connect(self.setColorSlot)
        self.rect4Label = QLabel(QApplication.translate("Button","Cooling Phase", None))
        self.rect4Label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.rect4Button = QPushButton()
        self.rect4Button = self.colorButton(aw.qmc.palette["rect4"])
        self.rect4Button.setFocusPolicy(Qt.NoFocus)
        self.rect4Button.clicked.connect(self.setColorSlot)
        self.rect5Label = QLabel(QApplication.translate("Button","Bars Bkgnd", None))
        self.rect5Label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.rect5Button = QPushButton()
        self.rect5Button = self.colorButton(aw.qmc.palette["rect5"])
        self.rect5Button.setFocusPolicy(Qt.NoFocus)
        self.rect5Button.clicked.connect(self.setColorSlot)
        self.markersLabel = QLabel(QApplication.translate("Button","Markers", None))
        self.markersLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.markersButton = QPushButton()
        self.markersButton = self.colorButton(aw.qmc.palette["markers"])
        self.markersButton.setFocusPolicy(Qt.NoFocus)
        self.markersButton.clicked.connect(self.setColorSlot)
        self.textLabel = QLabel(QApplication.translate("Button","Text", None))
        self.textLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.textButton = QPushButton()
        self.textButton = self.colorButton(aw.qmc.palette["text"])
        self.textButton.setFocusPolicy(Qt.NoFocus)
        self.textButton.clicked.connect(self.setColorSlot)
        self.watermarksLabel = QLabel(QApplication.translate("Button","Watermarks", None))
        self.watermarksLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.watermarksButton = QPushButton()
        self.watermarksButton = self.colorButton(aw.qmc.palette["watermarks"])
        self.watermarksButton.setFocusPolicy(Qt.NoFocus)
        self.watermarksButton.clicked.connect(self.setColorSlot)
        self.timeguideLabel = QLabel(QApplication.translate("Button","Time Guide", None))
        self.timeguideLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.timeguideButton = QPushButton()
        self.timeguideButton = self.colorButton(aw.qmc.palette["timeguide"])
        self.timeguideButton.setFocusPolicy(Qt.NoFocus)
        self.timeguideButton.clicked.connect(self.setColorSlot)
        self.aucguideLabel = QLabel(QApplication.translate("Button","AUC Guide", None))
        self.aucguideLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.aucguideButton = QPushButton()
        self.aucguideButton = self.colorButton(aw.qmc.palette["aucguide"])
        self.aucguideButton.setFocusPolicy(Qt.NoFocus)
        self.aucguideButton.clicked.connect(self.setColorSlot)
        self.aucareaLabel = QLabel(QApplication.translate("Button","AUC Area", None))
        self.aucareaLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.aucareaButton = QPushButton()
        self.aucareaButton = self.colorButton(aw.qmc.palette["aucarea"])
        self.aucareaButton.setFocusPolicy(Qt.NoFocus)
        self.aucareaButton.clicked.connect(self.setColorSlot)
        self.legendbgLabel = QLabel(QApplication.translate("Button","Legend bkgnd", None))
        self.legendbgLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.legendbgButton = QPushButton()
        self.legendbgButton = self.colorButton(aw.qmc.palette["legendbg"])
        self.legendbgButton.setFocusPolicy(Qt.NoFocus)
        self.legendbgButton.clicked.connect(self.setColorSlot)
        self.legendbgSpinBox = QSpinBox()
        self.legendbgSpinBox.setAlignment(Qt.AlignRight)
        self.legendbgSpinBox.setRange(1,10)
        self.legendbgSpinBox.setSingleStep(1)
        self.legendbgSpinBox.setValue(aw.qmc.alpha["legendbg"] * 10)
        self.legendbgSpinBox.valueChanged.connect(self.adjustOpaqenesssSlot)
        self.legendbgSpinBox.setFocusPolicy(Qt.StrongFocus)
        self.legendbgButton.setSizePolicy(QSizePolicy.Expanding,self.legendbgButton.sizePolicy().verticalPolicy())
        self.legendbgLayout = QHBoxLayout()
        self.legendbgLayout.addWidget(self.legendbgButton)
        self.legendbgLayout.addWidget(self.legendbgSpinBox)
        self.legendborderLabel = QLabel(QApplication.translate("Button","Legend border", None))
        self.legendborderLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.legendborderButton = QPushButton()
        self.legendborderButton = self.colorButton(aw.qmc.palette["legendborder"])
        self.legendborderButton.setFocusPolicy(Qt.StrongFocus)
        self.legendborderButton.clicked.connect(self.setColorSlot)

        self.canvasLabel = QLabel(QApplication.translate("Button","Canvas", None))
        self.canvasLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.canvasButton = QPushButton()
        self.canvasButton = self.colorButton(aw.qmc.palette["canvas"])
        if str(aw.qmc.palette["canvas"]) == 'None':
            self.canvasButton.setPalette(QPalette(QColor("#f0f0f0")))
        else:
            self.canvasButton.setPalette(QPalette(QColor(aw.qmc.palette["canvas"])))
        self.canvasButton.setFocusPolicy(Qt.NoFocus)
        self.canvasButton.clicked.connect(self.setColorSlot)

        self.specialeventboxLabel = QLabel(QApplication.translate("Button","SpecialEvent Marker", None))
        self.specialeventboxLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.specialeventboxButton = QPushButton()
        self.specialeventboxButton = self.colorButton(aw.qmc.palette["specialeventbox"])
        self.specialeventboxButton.setFocusPolicy(Qt.NoFocus)
        self.specialeventboxButton.clicked.connect(self.setColorSlot)
        self.specialeventtextLabel = QLabel(QApplication.translate("Button","SpecialEvent Text", None))
        self.specialeventtextLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.specialeventtextButton = QPushButton()
        self.specialeventtextButton = self.colorButton(aw.qmc.palette["specialeventtext"])
        self.specialeventtextButton.setFocusPolicy(Qt.NoFocus)
        self.specialeventtextButton.clicked.connect(self.setColorSlot)
        self.bgeventmarkerLabel = QLabel(QApplication.translate("Button","Bkgd Event Marker", None))
        self.bgeventmarkerLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgeventmarkerButton = QPushButton()
        self.bgeventmarkerButton = self.colorButton(aw.qmc.palette["bgeventmarker"])
        self.bgeventmarkerButton.setFocusPolicy(Qt.NoFocus)
        self.bgeventmarkerButton.clicked.connect(self.setColorSlot)
        self.bgeventtextLabel = QLabel(QApplication.translate("Button","Bkgd Event Text", None))
        self.bgeventtextLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.bgeventtextButton = QPushButton()
        self.bgeventtextButton = self.colorButton(aw.qmc.palette["bgeventtext"])
        self.bgeventtextButton.setFocusPolicy(Qt.NoFocus)
        self.bgeventtextButton.clicked.connect(self.setColorSlot)
        self.mettextLabel = QLabel(QApplication.translate("Button","MET Text", None))
        self.mettextLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.mettextButton = QPushButton()
        self.mettextButton = self.colorButton(aw.qmc.palette["mettext"])
        self.mettextButton.setFocusPolicy(Qt.NoFocus)
        self.mettextButton.clicked.connect(self.setColorSlot)
        self.metboxLabel = QLabel(QApplication.translate("Button","MET Box", None))
        self.metboxLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.metboxButton = QPushButton()
        self.metboxButton = self.colorButton(aw.qmc.palette["metbox"])
        self.metboxButton.setFocusPolicy(Qt.NoFocus)
        self.metboxButton.clicked.connect(self.setColorSlot)
        self.analysismaskLabel = QLabel(QApplication.translate("Button","Analysis Mask", None))
        self.analysismaskLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.analysismaskButton = QPushButton()
        self.analysismaskButton = self.colorButton(aw.qmc.palette["analysismask"])
        self.analysismaskButton.setFocusPolicy(Qt.StrongFocus)
        self.analysismaskButton.clicked.connect(self.setColorSlot)
        self.analysismaskSpinBox = QSpinBox()
        self.analysismaskSpinBox.setAlignment(Qt.AlignRight)
        self.analysismaskSpinBox.setRange(1,10)
        self.analysismaskSpinBox.setSingleStep(1)
        self.analysismaskSpinBox.setValue(aw.qmc.alpha["analysismask"] * 10)
        self.analysismaskSpinBox.valueChanged.connect(self.adjustOpaqenesssSlot)
        self.analysismaskLayout = QHBoxLayout()
        self.analysismaskButton.setSizePolicy(QSizePolicy.Expanding,self.analysismaskButton.sizePolicy().verticalPolicy())
        self.analysismaskLayout.addWidget(self.analysismaskButton)
        self.analysismaskLayout.addWidget(self.analysismaskSpinBox)
        self.statsanalysisbkgndLabel = QLabel(QApplication.translate("Button","Stats&Analysis Bkgnd", None))
        self.statsanalysisbkgndLabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.statsanalysisbkgndButton = QPushButton()
        self.statsanalysisbkgndButton = self.colorButton(aw.qmc.palette["statsanalysisbkgnd"])
        self.statsanalysisbkgndButton.setFocusPolicy(Qt.StrongFocus)
        self.statsanalysisbkgndButton.clicked.connect(self.setColorSlot)
        self.statsanalysisbkgndSpinBox = QSpinBox()
        self.statsanalysisbkgndSpinBox.setAlignment(Qt.AlignRight)
        self.statsanalysisbkgndSpinBox.setRange(1,10)
        self.statsanalysisbkgndSpinBox.setSingleStep(1)
        self.statsanalysisbkgndSpinBox.setValue(aw.qmc.alpha["statsanalysisbkgnd"] * 10)
        self.statsanalysisbkgndSpinBox.valueChanged.connect(self.adjustOpaqenesssSlot)
        self.statsanalysisbkgndSpinBox.setFocusPolicy(Qt.StrongFocus)
        self.statsanalysisbkgndLayout = QHBoxLayout()
        self.statsanalysisbkgndButton.setSizePolicy(QSizePolicy.Expanding,self.statsanalysisbkgndButton.sizePolicy().verticalPolicy())
        self.statsanalysisbkgndLayout.addWidget(self.statsanalysisbkgndButton)
        self.statsanalysisbkgndLayout.addWidget(self.statsanalysisbkgndSpinBox)

        #TAB2
        self.lcd1LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd1LEDButton.clicked.connect(self.paintlcdsSlot)
        self.lcd2LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd2LEDButton.clicked.connect(self.paintlcdsSlot)
        self.lcd3LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd3LEDButton.clicked.connect(self.paintlcdsSlot)
        self.lcd4LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd4LEDButton.clicked.connect(self.paintlcdsSlot)
        self.lcd5LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd5LEDButton.clicked.connect(self.paintlcdsSlot)
        self.lcd6LEDButton = QPushButton(QApplication.translate("Button","Digits",None))
        self.lcd6LEDButton.clicked.connect(self.paintlcdsSlot)
        
        self.lcd1backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd1backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd2backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd2backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd3backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd3backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd4backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd4backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd5backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd5backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd6backButton = QPushButton(QApplication.translate("Button","Background",None))
        self.lcd6backButton.clicked.connect(self.paintlcdsSlot)
        self.lcd1LEDButton.setMinimumWidth(80)
        self.lcd2LEDButton.setMinimumWidth(80)
        self.lcd3LEDButton.setMinimumWidth(80)
        self.lcd4LEDButton.setMinimumWidth(80)
        self.lcd5LEDButton.setMinimumWidth(80)
        self.lcd6LEDButton.setMinimumWidth(80)

        LCDdefaultButton = QPushButton(QApplication.translate("Button","B/W",None))
        LCDdefaultButton.clicked.connect(self.setLCD_bw)
            
        #LAYOUTS
        #tab0 layout
        lines = QGridLayout()
        lines.setAlignment(Qt.AlignCenter)
        lines.setVerticalSpacing(1)
        lines.setColumnMinimumWidth(0,0)   #0,80
#        lines.setColumnMaximumWidth(0,30)
        lines.setColumnMinimumWidth(1,150)   #1,180
        lines.setColumnMinimumWidth(2,50)   #2,80
        lines.setColumnMinimumWidth(3,150)   #3,180

        lines.addWidget(profilecolorlabel,0,1)
        lines.addWidget(self.metButton,1,1)
        lines.addWidget(self.metLabel,1,0)
        lines.addWidget(self.btButton,2,1)
        lines.addWidget(self.btLabel,2,0)
        lines.addWidget(self.deltametButton,3,1)
        lines.addWidget(self.deltametLabel,3,0)
        lines.addWidget(self.deltabtButton,4,1)
        lines.addWidget(self.deltabtLabel,4,0)

        lines.addWidget(bgcolorlabel,0,3)
        lines.addWidget(self.bgmetButton,1,3)
        lines.addWidget(self.bgmetLabel,1,2)
        lines.addWidget(self.bgbtButton,2,3)
        lines.addWidget(self.bgbtLabel,2,2)
        lines.addWidget(self.bgdeltametButton,3,3)
        lines.addWidget(self.bgdeltametLabel,3,2)
        lines.addWidget(self.bgdeltabtButton,4,3)
        lines.addWidget(self.bgdeltabtLabel,4,2)
        lines.addWidget(self.bgextraButton,5,3)
        lines.addWidget(self.bgextraLabel,5,2)
#        lines.addWidget(opaqbgLabel,6,2)
        lines.addLayout(self.opaqbgLayout,6,3)

        graphlinesLayout = QVBoxLayout()
        graphlinesLayout.addLayout(lines)
        
        #tab1 layout
        grid = QGridLayout()
        grid.setAlignment(Qt.AlignCenter)
#        grid.setColumnStretch(1,12)
#        grid.setColumnStretch(3,12)
        grid.setVerticalSpacing(1)
        grid.setColumnMinimumWidth(0,80)
        grid.setColumnMinimumWidth(2,80)
        grid.setColumnMinimumWidth(1,110)  #1,80
        grid.setColumnMinimumWidth(3,110)  #3,80
        grid.addWidget(self.canvasButton,0,1)
        grid.addWidget(self.canvasLabel,0,0)
        grid.addWidget(self.backgroundButton,1,1)
        grid.addWidget(self.backgroundLabel,1,0)
        grid.addWidget(self.titleButton,2,1)
        grid.addWidget(self.titleLabel,2,0)
        grid.addWidget(self.gridButton,3,1)
        grid.addWidget(self.gridLabel,3,0)
        grid.addWidget(self.yButton,4,1)
        grid.addWidget(self.yLabel,4,0)
        grid.addWidget(self.xButton,5,1)
        grid.addWidget(self.xLabel,5,0)
        grid.addWidget(self.markersButton,6,1)
        grid.addWidget(self.markersLabel,6,0)
        grid.addWidget(self.textButton,7,1)
        grid.addWidget(self.textLabel,7,0)
        grid.addLayout(self.legendbgLayout,8,1) 
        grid.addWidget(self.legendbgLabel,8,0) 
        grid.addWidget(self.legendborderButton,9,1)
        grid.addWidget(self.legendborderLabel,9,0) 
        grid.addWidget(self.watermarksButton,10,1)
        grid.addWidget(self.watermarksLabel,10,0)
        grid.addWidget(self.aucguideButton,11,1)
        grid.addWidget(self.aucguideLabel,11,0)
        grid.addWidget(self.aucareaButton,12,1)
        grid.addWidget(self.aucareaLabel,12,0)
        grid.addWidget(self.rect1Button,0,3)
        grid.addWidget(self.rect1Label,0,2)
        grid.addWidget(self.rect2Button,1,3)
        grid.addWidget(self.rect2Label,1,2)
        grid.addWidget(self.rect3Button,2,3)
        grid.addWidget(self.rect3Label,2,2)
        grid.addWidget(self.rect4Button,3,3)
        grid.addWidget(self.rect4Label,3,2)
        grid.addWidget(self.rect5Button,4,3)
        grid.addWidget(self.rect5Label,4,2)
        grid.addWidget(self.specialeventboxButton,5,3) 
        grid.addWidget(self.specialeventboxLabel,5,2) 
        grid.addWidget(self.specialeventtextButton,6,3) 
        grid.addWidget(self.specialeventtextLabel,6,2) 
        grid.addWidget(self.bgeventmarkerButton,7,3) 
        grid.addWidget(self.bgeventmarkerLabel,7,2) 
        grid.addWidget(self.bgeventtextButton,8,3) 
        grid.addWidget(self.bgeventtextLabel,8,2) 
        grid.addWidget(self.metboxButton,9,3) 
        grid.addWidget(self.metboxLabel,9,2) 
        grid.addWidget(self.mettextButton,10,3) 
        grid.addWidget(self.mettextLabel,10,2) 
        grid.addWidget(self.timeguideButton,11,3)
        grid.addWidget(self.timeguideLabel,11,2)
        grid.addLayout(self.analysismaskLayout,12,3)
        grid.addWidget(self.analysismaskLabel,12,2)
        grid.addLayout(self.statsanalysisbkgndLayout,13,3)
        grid.addWidget(self.statsanalysisbkgndLabel,13,2)
        graphLayout = QVBoxLayout()
        graphLayout.addLayout(grid)

        #tab 2 layout
        lcd1layout = QHBoxLayout()
        lcd1layout.addWidget(self.lcd1LEDButton,0)
        lcd1layout.addWidget(self.lcd1backButton,1)
        lcd2layout = QHBoxLayout()
        lcd2layout.addWidget(self.lcd2LEDButton,0)
        lcd2layout.addWidget(self.lcd2backButton,1)
        lcd3layout = QHBoxLayout()
        lcd3layout.addWidget(self.lcd3LEDButton,0)
        lcd3layout.addWidget(self.lcd3backButton,1)
        lcd4layout = QHBoxLayout()
        lcd4layout.addWidget(self.lcd4LEDButton,0)
        lcd4layout.addWidget(self.lcd4backButton,1)
        lcd5layout = QHBoxLayout()
        lcd5layout.addWidget(self.lcd5LEDButton,0)
        lcd5layout.addWidget(self.lcd5backButton,1)
        lcd6layout = QHBoxLayout()
        lcd6layout.addWidget(self.lcd6LEDButton,0)
        lcd6layout.addWidget(self.lcd6backButton,1)
        LCD1GroupLayout = QGroupBox(QApplication.translate("GroupBox","Timer LCD",None))
        LCD1GroupLayout.setLayout(lcd1layout)
        lcd1layout.setContentsMargins(0,0,0,0)
        LCD2GroupLayout = QGroupBox(QApplication.translate("GroupBox","ET LCD",None))
        LCD2GroupLayout.setLayout(lcd2layout)
        lcd2layout.setContentsMargins(0,0,0,0)
        LCD3GroupLayout = QGroupBox(QApplication.translate("GroupBox","BT LCD",None))
        LCD3GroupLayout.setLayout(lcd3layout)
        lcd3layout.setContentsMargins(0,0,0,0)
        LCD4GroupLayout = QGroupBox(deltaLabelUTF8 + QApplication.translate("GroupBox","ET LCD",None))
        LCD4GroupLayout.setLayout(lcd4layout)
        lcd4layout.setContentsMargins(0,0,0,0)
        LCD5GroupLayout = QGroupBox(deltaLabelUTF8 + QApplication.translate("GroupBox","BT LCD",None))
        LCD5GroupLayout.setLayout(lcd5layout)
        lcd5layout.setContentsMargins(0,0,0,0)
        LCD6GroupLayout = QGroupBox(QApplication.translate("GroupBox","Extra Devices / PID SV LCD",None))
        LCD6GroupLayout.setLayout(lcd6layout)
        lcd6layout.setContentsMargins(0,0,0,0)
        buttonlayout = QHBoxLayout()
        buttonlayout.addStretch()
        buttonlayout.addWidget(LCDdefaultButton)
        buttonlayout.setContentsMargins(0,0,0,0)
        buttonlayout.setSpacing(0)
        
        lcdlayout1 = QVBoxLayout()
        lcdlayout1.addWidget(LCD2GroupLayout)
        lcdlayout1.addWidget(LCD3GroupLayout)
        lcdlayout1.addWidget(LCD1GroupLayout)
        lcdlayout2 = QVBoxLayout()
        lcdlayout2.addWidget(LCD4GroupLayout)
        lcdlayout2.addWidget(LCD5GroupLayout)
        lcdlayout2.addWidget(LCD6GroupLayout)
        lcdlayout = QHBoxLayout()
        lcdlayout.addLayout(lcdlayout1)
        lcdlayout.addLayout(lcdlayout2)
        lllayout = QVBoxLayout()
        lllayout.addLayout(lcdlayout)
        lllayout.addLayout(buttonlayout)
        lllayout.setContentsMargins(0,0,0,0)
        lllayout.setSpacing(5)

        ###################################
        self.TabWidget = QTabWidget()
        C0Widget = QWidget()
        C0Widget.setLayout(graphlinesLayout)
        self.TabWidget.addTab(C0Widget,QApplication.translate("Tab","Curves",None))
        C1Widget = QWidget()
        C1Widget.setLayout(graphLayout)
        self.TabWidget.addTab(C1Widget,QApplication.translate("Tab","Graph",None))
        C2Widget = QWidget()
        C2Widget.setLayout(lllayout)
        self.TabWidget.addTab(C2Widget,QApplication.translate("Tab","LCDs",None))

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.accept)
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.addButton(QDialogButtonBox.RestoreDefaults)
        self.dialogbuttons.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.recolor1)
        if aw.locale not in aw.qtbase_locales:
            self.dialogbuttons.button(QDialogButtonBox.RestoreDefaults).setText(QApplication.translate("Button","Defaults", None))
        
        greyButton = QPushButton(QApplication.translate("Button","Grey", None))
        greyButton.setFocusPolicy(Qt.NoFocus)
        greyButton.clicked.connect(self.recolor2)
        
        self.dialogbuttons.addButton(greyButton, QDialogButtonBox.ActionRole)

        okLayout = QHBoxLayout()
        okLayout.addStretch()
        okLayout.addWidget(self.dialogbuttons)
        okLayout.setContentsMargins(10, 10, 10, 10)
        self.TabWidget.setContentsMargins(0, 0, 0, 0)
        C0Widget.setContentsMargins(5, 10, 5, 10)
        C1Widget.setContentsMargins(5, 10, 5, 10)
        C2Widget.setContentsMargins(5, 10, 5, 10)
        graphLayout.setContentsMargins(5,0,5,0)
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(self.TabWidget)
        Mlayout.addLayout(okLayout)
        Mlayout.setContentsMargins(5,10,5,0)
        Mlayout.setSpacing(0)
        self.setLayout(Mlayout)
        self.setColorButtons()
        if platf == 'Windows':
            self.dialogbuttons.button(QDialogButtonBox.Ok)
        else:
            self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
        self.layout().setSizeConstraint(QLayout.SetFixedSize) # don't allow resizing

    @pyqtSlot(bool)
    def setLCD_bw(self,_):
        aw.setLCDsBW()
        self.setColorButtons()
        
    def setLED(self,hue,lcd):
        if lcd == 1:
            color = QColor(aw.lcdpaletteF["timer"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["timer"] = str(color.name())
            aw.lcd1.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        elif lcd == 2:
            color = QColor(aw.lcdpaletteF["et"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["et"] = str(color.name())
            aw.lcd2.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        elif lcd == 3:
            color = QColor(aw.lcdpaletteF["bt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["bt"] = str(color.name())
            aw.lcd3.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        elif lcd == 4:
            color = QColor(aw.lcdpaletteF["deltaet"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltaet"] = str(color.name())
            aw.lcd4.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
            if aw.largeDeltaLCDs_dialog:
                aw.largeDeltaLCDs_dialog.updateStyles()
        elif lcd == 5:
            color = QColor(aw.lcdpaletteF["deltabt"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["deltabt"] = str(color.name())
            aw.lcd5.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
            if aw.largeDeltaLCDs_dialog:
                aw.largeDeltaLCDs_dialog.updateStyles()
        elif lcd == 6:
            color = QColor(aw.lcdpaletteF["sv"])
            color.setHsv(hue,255,255,255)
            aw.lcdpaletteF["sv"] = str(color.name())
            aw.lcd6.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            for i in range(len(aw.qmc.extradevices)):
                aw.extraLCD1[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
                aw.extraLCD2[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            if aw.largePIDLCDs_dialog:
                aw.largePIDLCDs_dialog.updateStyles()
            if aw.largeExtraLCDs_dialog:
                aw.largeExtraLCDs_dialog.updateStyles()

    @pyqtSlot(bool)
    def paintlcdsSlot(self,_):
        lcdButton = self.sender()
        if lcdButton in [self.lcd1LEDButton,self.lcd1backButton]:
            if lcdButton == self.lcd1backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"timer")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"timer")
            aw.lcd1.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        if lcdButton in [self.lcd2LEDButton,self.lcd2backButton]:
            if lcdButton == self.lcd2backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"et")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"et")
            aw.lcd2.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["et"],aw.lcdpaletteB["et"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        if lcdButton in [self.lcd3LEDButton,self.lcd3backButton]:
            if lcdButton == self.lcd3backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"bt")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"bt")
            aw.lcd3.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["bt"],aw.lcdpaletteB["bt"]))
            if aw.largeLCDs_dialog:
                aw.largeLCDs_dialog.updateStyles()
        if lcdButton in [self.lcd4LEDButton,self.lcd4backButton]:
            if lcdButton == self.lcd4backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"deltaet")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"deltaet")
            aw.lcd4.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltaet"],aw.lcdpaletteB["deltaet"]))
            if aw.largeDeltaLCDs_dialog:
                aw.largeDeltaLCDs_dialog.updateStyles()
        if lcdButton in [self.lcd5LEDButton,self.lcd5backButton]:
            if lcdButton == self.lcd5backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"deltabt")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"deltabt")
            aw.lcd5.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["deltabt"],aw.lcdpaletteB["deltabt"]))
            if aw.largeDeltaLCDs_dialog:
                aw.largeDeltaLCDs_dialog.updateStyles()
        if lcdButton in [self.lcd6LEDButton,self.lcd6backButton]:
            if lcdButton == self.lcd6backButton:
                self.setlcdColor(aw.lcdpaletteB,aw.lcdpaletteF,"sv")
            else:
                self.setlcdColor(aw.lcdpaletteF,aw.lcdpaletteB,"sv")
            aw.lcd6.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            aw.lcd7.setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            for i in range(len(aw.qmc.extradevices)):
                aw.extraLCD1[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
                aw.extraLCD2[i].setStyleSheet("QLCDNumber { border-radius: 4; color: %s; background-color: %s;}"%(aw.lcdpaletteF["sv"],aw.lcdpaletteB["sv"]))
            if aw.largePIDLCDs_dialog:
                aw.largePIDLCDs_dialog.updateStyles()
            if aw.largeExtraLCDs_dialog:
                aw.largeExtraLCDs_dialog.updateStyles()
        self.setColorButtons()

    def setColorButtons(self):
        for l,t in [
                # Curves (background curves handled separately)
                (self.metButton,"et"),
                (self.btButton,"bt"),
                (self.deltametButton,"deltaet"),
                (self.deltabtButton,"deltabt"),
                # Graph
                (self.canvasButton,"canvas"),
                (self.backgroundButton,"background"),
                (self.titleButton,"title"),
                (self.gridButton,"grid"),
                (self.yButton,"ylabel"),
                (self.xButton,"xlabel"),
                (self.timeguideButton,"timeguide"),
                (self.aucguideButton,"aucguide"),
                (self.aucareaButton,"aucarea"),
                (self.watermarksButton,"watermarks"),
                (self.rect1Button,"rect1"),
                (self.rect2Button,"rect2"),
                (self.rect3Button,"rect3"),
                (self.rect4Button,"rect4"),
                (self.rect5Button,"rect5"),
                (self.markersButton,"markers"),
                (self.textButton,"text"),
                (self.legendbgButton,"legendbg"),
                (self.legendborderButton,"legendborder"),
                (self.specialeventboxButton,"specialeventbox"),
                (self.specialeventtextButton,"specialeventtext"),
                (self.bgeventmarkerButton,"bgeventmarker"),
                (self.bgeventtextButton,"bgeventtext"),
                (self.mettextButton,"mettext"),
                (self.metboxButton,"metbox"),
                (self.analysismaskButton,"analysismask"),
                (self.statsanalysisbkgndButton,"statsanalysisbkgnd"),
                ]:
            self.setColorButton(l,t)
            
        # Curves, set background colors and alpha
        self.bgmetButton.setText(aw.qmc.backgroundmetcolor)
        self.bgbtButton.setText(aw.qmc.backgroundbtcolor)
        self.bgdeltametButton.setText(aw.qmc.backgrounddeltaetcolor)
        self.bgdeltabtButton.setText(aw.qmc.backgrounddeltabtcolor)
        self.bgextraButton.setText(aw.qmc.backgroundxtcolor)
        self.bgmetButton.setStyleSheet("QPushButton { background-color: " + aw.qmc.backgroundmetcolor + "; color: " + aw.labelBorW(aw.qmc.backgroundmetcolor) + ";" + self.commonstyle + "}")
        self.bgbtButton.setStyleSheet("QPushButton { background-color: " + aw.qmc.backgroundbtcolor + "; color: " + aw.labelBorW(aw.qmc.backgroundbtcolor) + ";" + self.commonstyle + "}")
        self.bgdeltametButton.setStyleSheet("QPushButton { background-color: " + aw.qmc.backgrounddeltaetcolor + "; color: " + aw.labelBorW(aw.qmc.backgrounddeltaetcolor) + ";" + self.commonstyle + "}")
        self.bgdeltabtButton.setStyleSheet("QPushButton { background-color: " + aw.qmc.backgrounddeltabtcolor + "; color: " + aw.labelBorW(aw.qmc.backgrounddeltabtcolor) + ";" + self.commonstyle + "}")
        self.bgextraButton.setStyleSheet("QPushButton { background-color: " + aw.qmc.backgroundxtcolor + "; color: " + aw.labelBorW(aw.qmc.backgroundxtcolor) + ";" + self.commonstyle + "}")
        self.opaqbgSpinBox.setValue(aw.qmc.backgroundalpha * 10)

        # LEDs
        self.lcd1backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['timer'] + "; color: " + aw.lcdpaletteF['timer'] + ";" + self.commonstyle)
        self.lcd1LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['timer'] + "; color: " + aw.lcdpaletteF['timer'] + ";" + self.commonstyle)
        self.lcd2backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['et'] + "; color: " + aw.lcdpaletteF['et'] + ";" + self.commonstyle)
        self.lcd2LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['et'] + "; color: " + aw.lcdpaletteF['et'] + ";" + self.commonstyle)
        self.lcd3backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['bt'] + "; color: " + aw.lcdpaletteF['bt'] + ";" + self.commonstyle)
        self.lcd3LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['bt'] + "; color: " + aw.lcdpaletteF['bt'] + ";" + self.commonstyle)
        self.lcd4backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['deltaet'] + "; color: " + aw.lcdpaletteF['deltaet'] + ";" + self.commonstyle)
        self.lcd4LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['deltaet'] + "; color: " + aw.lcdpaletteF['deltaet'] + ";" + self.commonstyle)
        self.lcd5backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['deltabt'] + "; color: " + aw.lcdpaletteF['deltabt'] + ";" + self.commonstyle)
        self.lcd5LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['deltabt'] + "; color: " + aw.lcdpaletteF['deltabt'] + ";" + self.commonstyle)
        self.lcd6backButton.setStyleSheet("background-color: " + aw.lcdpaletteB['sv'] + "; color: " + aw.lcdpaletteF['sv'] + ";" + self.commonstyle)
        self.lcd6LEDButton.setStyleSheet("background-color: " + aw.lcdpaletteB['sv'] + "; color: " + aw.lcdpaletteF['sv'] + ";" + self.commonstyle)
            
        if str(aw.qmc.palette["canvas"]) == 'None':
#            self.canvasLabel.setStyleSheet("QLabel { background-color: #f0f0f0 }")
            self.canvasLabel.setStyleSheet("QPushButton {background-color: #f0f0f0 ;" + self.commonstyle + "}")
            
    def setColorButton(self,button,tag):
        c = aw.qmc.palette[tag]
        button.setText(c)
        tc = aw.labelBorW(c)
        button.setStyleSheet("QPushButton {background: " + c + "; color: " + tc + ";" + self.commonstyle + "}")

    # adds a new event to the Dlg
    @pyqtSlot(bool)
    def recolor1(self,_):
        aw.qmc.changeGColor(1)
        self.setColorButtons()
    
    @pyqtSlot(bool)
    def recolor2(self,_):
        aw.qmc.changeGColor(2)
        self.setColorButtons()

    def adjustOpaqenesss(self,spinbox,coloralpha):
        #block button
        spinbox.setDisabled(True)
        aw.qmc.alpha[coloralpha] = spinbox.value()/10.
#        coloralpha = spinbox.value()/10.
        aw.qmc.redraw(recomputeAllDeltas=False)
        #reactivate button
        spinbox.setDisabled(False)

    @pyqtSlot(int)
    def adjustOpaqenesssSlot(self,_):
        widget = self.sender()
#        if widget == self.opaqbgSpinBox:
#            self.adjustOpaqenesss(self.opaqbgSpinBox,aw.qmc.backgroundalpha)
        if widget == self.legendbgSpinBox:
            self.adjustOpaqenesss(self.legendbgSpinBox,"legendbg")
        if widget == self.analysismaskSpinBox:
            self.adjustOpaqenesss(self.analysismaskSpinBox,"analysismask")
        if widget == self.statsanalysisbkgndSpinBox:
            self.adjustOpaqenesss(self.statsanalysisbkgndSpinBox,"statsanalysisbkgnd")

    @pyqtSlot(bool)
    def setbgColorSlot(self,_):
        widget = self.sender()
        if widget == self.bgmetButton:
            self.setbgColor("ET",self.bgmetButton,aw.qmc.backgroundmetcolor)
        elif widget == self.bgbtButton:
            self.setbgColor("BT",self.bgbtButton,aw.qmc.backgroundbtcolor)
        elif widget == self.bgdeltametButton:
            self.setbgColor("DeltaET",self.bgdeltametButton,aw.qmc.backgrounddeltaetcolor)
        elif widget == self.bgdeltabtButton:
            self.setbgColor("DeltaBT",self.bgdeltabtButton,aw.qmc.backgrounddeltabtcolor)
        elif widget == self.bgextraButton:
            self.setbgColor("Extra",self.bgextraButton,aw.qmc.backgroundxtcolor)

    def setbgColor(self,title,var,color):
        labelcolor = QColor(color)
        colorf = aw.colordialog(labelcolor)
        if colorf.isValid():
            color = str(colorf.name())
            aw.updateCanvasColors()
            tc = aw.labelBorW(color)
            var.setText(colorf.name())
            var.setStyleSheet("QPushButton { background-color: " + color + "; color: " + tc + ";" + self.commonstyle + "}");
#  is this needed?            var.setPalette(QPalette(colorf))
            aw.qmc.fig.canvas.redraw(recomputeAllDeltas=False)
            if title == "ET":
                aw.qmc.backgroundmetcolor = color
            elif title == "BT":
                aw.qmc.backgroundbtcolor = color
            elif title == "DeltaET":
                aw.qmc.backgrounddeltaetcolor = color
            elif title == "DeltaBT":
                aw.qmc.backgrounddeltabtcolor = color
            elif title == "Extra":
                aw.qmc.backgroundxtcolor = color
            aw.sendmessage(QApplication.translate("Message","Color of {0} set to {1}", None).format(title,str(color)))

    def setlcdColor(self,palette,disj_palette,select):
        res = aw.colordialog(QColor(palette[select]))
        if QColor.isValid(res):
            nc = str(res.name())
            if nc != disj_palette[select]:
                palette[select] = nc
            else:
                QMessageBox.question(aw,QApplication.translate("Message", "Config LCD colors",None),
                    "Digits color and Background color cannot be the same.", QMessageBox.Ok)
    
    @pyqtSlot(bool)
    def setColorSlot(self,_):
        widget = self.sender()
        if widget == self.metButton:
            self.setColor("ET",self.metButton,"et")
        elif widget == self.btButton:
            self.setColor("BT",self.btButton,"bt")
        elif widget == self.deltametButton:
            self.setColor("DeltaET",self.deltametButton,"deltaet")
        elif widget == self.deltabtButton:
            self.setColor("DeltaBT",self.deltabtButton,"deltabt")
        elif widget == self.backgroundButton:
            self.setColor("Background",self.backgroundButton,"background")
        elif widget == self.gridButton:
            self.setColor("Grid",self.gridButton,"grid")
        elif widget == self.titleButton:
            self.setColor("Title",self.titleButton,"title")
        elif widget ==self.yButton:
            self.setColor("Y Button",self.yButton,"ylabel")
        elif widget == self.xButton:
            self.setColor("X Button",self.xButton,"xlabel")
        elif widget == self.rect1Button:
            self.setColor("Drying Phase",self.rect1Button,"rect1")
        elif widget == self.rect2Button:
            self.setColor("Maillard Phase",self.rect2Button,"rect2")
        elif widget == self.rect3Button:
            self.setColor("Finishing Phase",self.rect3Button,"rect3")
        elif widget == self.rect4Button:
            self.setColor("Cooling Phase",self.rect4Button,"rect4")
        elif widget == self.rect5Button:
            self.setColor("Bars Bkgnd",self.rect5Button,"rect5")
        elif widget == self.markersButton:
            self.setColor("Markers",self.markersButton,"markers")
        elif widget == self.textButton:
            self.setColor("Text",self.textButton,"text")
        elif widget == self.watermarksButton:
            self.setColor("Watermarks",self.watermarksButton,"watermarks")
        elif widget == self.timeguideButton:
            self.setColor("Time Guide",self.timeguideButton,"timeguide")
        elif widget == self.aucguideButton:
            self.setColor("AUC Guide",self.aucguideButton,"aucguide")
        elif widget == self.aucareaButton:
            self.setColor("AUC Area",self.aucareaButton,"aucarea")
        elif widget == self.legendbgButton:
            self.setColor("legendbg",self.legendbgButton,"legendbg")
        elif widget == self.legendborderButton:
            self.setColor("legendborder",self.legendborderButton,"legendborder")
        elif widget == self.canvasButton:
            self.setColor("canvas",self.canvasButton,"canvas")
        elif widget == self.specialeventboxButton:
            self.setColor("specialeventbox",self.specialeventboxButton,"specialeventbox")
        elif widget == self.specialeventtextButton:
            self.setColor("specialeventtext",self.specialeventtextButton,"specialeventtext")
        elif widget == self.bgeventmarkerButton:
            self.setColor("bgeventmarker",self.bgeventmarkerButton,"bgeventmarker")
        elif widget == self.bgeventtextButton:
            self.setColor("bgeventtext",self.bgeventtextButton,"bgeventtext")
        elif widget == self.mettextButton:
            self.setColor("mettext",self.mettextButton,"mettext")
        elif widget == self.metboxButton:
            self.setColor("metbox",self.metboxButton,"metbox")
        elif widget == self.analysismaskButton:
            self.setColor("Analysis Mask",self.analysismaskButton,"analysismask")
        elif widget == self.statsanalysisbkgndButton:
            self.setColor("Analysis Result",self.statsanalysisbkgndButton,"statsanalysisbkgnd")
            
    def colorButton(self,s):
        button = QPushButton(s)
        button.setPalette(QPalette(QColor(s)))
        button.setStyleSheet("QPushButton {background-color:" + s + ";" + self.commonstyle + "}")
        return button

    def setColor(self,title,var,color):
        labelcolor = QColor(aw.qmc.palette[color])
        colorf = aw.colordialog(labelcolor)
        if colorf.isValid():
            aw.qmc.palette[color] = str(colorf.name())
            aw.updateCanvasColors()
            aw.applyStandardButtonVisibility()
            aw.update_extraeventbuttons_visibility()
            var.setText(colorf.name())
            tc = aw.labelBorW(aw.qmc.palette[color])
            var.setStyleSheet("QPushButton { background: " + aw.qmc.palette[color] + "; color: " + tc + ";" + self.commonstyle + "}")
#            var.setPalette(QPalette(colorf))
            aw.qmc.fig.canvas.redraw(recomputeAllDeltas=False)
            if title == "ET":
                aw.setLabelColor(aw.label2,QColor(aw.qmc.palette[color]))
            elif title == "BT":
                aw.setLabelColor(aw.label3,QColor(aw.qmc.palette[color]))
            elif title == "DeltaET":
                aw.setLabelColor(aw.label4,QColor(aw.qmc.palette[color]))
            elif title == "DeltaBT":
                aw.setLabelColor(aw.label5,QColor(aw.qmc.palette[color]))
            aw.sendmessage(QApplication.translate("Message","Color of {0} set to {1}", None).format(title,str(aw.qmc.palette[color])))

    @pyqtSlot(int)
    def adjustintensity(self,_):
        #block button
        self.opaqbgSpinBox.setDisabled(True)
        aw.qmc.backgroundalpha = self.opaqbgSpinBox.value()/10.
        aw.qmc.redraw(recomputeAllDeltas=False)
        #reactivate button
        self.opaqbgSpinBox.setDisabled(False)

############################################################
#######################  LARGE LCDs DIALOG  ################
############################################################

class LargeLCDs(ArtisanDialog):
    def __init__(self, parent = None):
        super(LargeLCDs,self).__init__(parent)
        # it is assumed that both lists of lcds (lcd1 & lcd2) have the same length
        # the same is assumed for the other lists below:
        self.lcds1 = []
        self.lcds2 = []
        self.lcds1styles = []
        self.lcds2styles = []
        self.lcds1labelsUpper = []
        self.lcds1labelsLower = []
        self.lcds2labelsUpper = []
        self.lcds2labelsLower = []
        self.lcds1frames = []
        self.lcds2frames = []
        self.tight = False
        self.layoutNr = -1 # 0: landscape, 1: portrait
        self.swaplcds = False
        windowFlags = self.windowFlags()
        windowFlags |= Qt.Tool
        self.setWindowFlags(windowFlags)
    
    def resizeEvent(self, event):
        super(LargeLCDs, self).resizeEvent(event)
        w = event.size().width()
        h = event.size().height()
        self.chooseLayout(w,h)

    def landscapeLayout(self):
        self.tight = False
        self.makeLCDs()
        landscapelayout = QHBoxLayout()
        for i in range(min(len(self.lcds1frames),len(self.lcds2frames))):
            self.lcds1labelsLower
            if self.swaplcds:
                landscapelayout.addWidget(self.lcds2frames[i])
                landscapelayout.addWidget(self.lcds1frames[i])
            else:
                landscapelayout.addWidget(self.lcds1frames[i])
                landscapelayout.addWidget(self.lcds2frames[i])
        landscapelayout.setSpacing(0)
        landscapelayout.setContentsMargins(0, 0, 0, 0)
        return landscapelayout

    def portraitLayout(self):
        self.tight = True
        self.makeLCDs()
        portraitlayout = QVBoxLayout()
        for i in range(min(len(self.lcds1frames),len(self.lcds2frames))):
            if self.swaplcds:
                portraitlayout.addWidget(self.lcds2frames[i],1)
                portraitlayout.addWidget(self.lcds1frames[i],1)
            else:
                portraitlayout.addWidget(self.lcds1frames[i],1)
                portraitlayout.addWidget(self.lcds2frames[i],1)
        portraitlayout.setSpacing(0)
        portraitlayout.setContentsMargins(0, 0, 0, 0)
        return portraitlayout

    def hideAllEmptyLabels(self):
        if all(l is not None and l.text().strip() == "" for l in (self.lcds1labelsLower + self.lcds2labelsLower)):
            # all lower labels empty, hide them to gain space
            self.lowerLabelssvisibility(False)
        else:
            self.lowerLabelssvisibility(True)
        if all(l is not None and l.text().strip() == "" for l in (self.lcds1labelsUpper + self.lcds2labelsUpper)):
            # all lower labels empty, hide them to gain space
            self.upperLabelssvisibility(False)
        else:
            self.upperLabelssvisibility(True)
    
    def hideOuterEmptyLabels(self):
        all_frames = [val for pair in zip(self.lcds1frames, self.lcds2frames) for val in pair]
        visible_frames = list(filter(lambda f: not f.isHidden(), all_frames))
        if visible_frames:
            all_upper_labels = [val for pair in zip(self.lcds1labelsUpper, self.lcds2labelsUpper) for val in pair]
            for i,l in enumerate(all_upper_labels):
                if (all_frames[i] == visible_frames[0] and l.text().strip() == ""):
                    # hide first visible upper label if empty
                    l.setVisible(False)
                else:
                    l.setVisible(True)
            all_lower_labels = [val for pair in zip(self.lcds1labelsLower, self.lcds2labelsLower) for val in pair]
            for i,l in enumerate(all_lower_labels):
                if (all_frames[i] == visible_frames[-1] and l.text().strip() == ""):
                    # hide last visible label if empty
                    l.setVisible(False)
                else:
                    l.setVisible(True)
    
    def lowerLabelssvisibility(self,b):
        for l in self.lcds1labelsLower + self.lcds2labelsLower:
            l.setVisible(b)
    
    def upperLabelssvisibility(self,b):
        for l in self.lcds1labelsUpper + self.lcds2labelsUpper:
            l.setVisible(b)

    # n the number of layout to be set (0: landscape, 1: portrait)
    # calling reLayout() without arg will force a relayout using the current layout
    def reLayout(self,n=None):
        if self.layoutNr != n:
            if n is None:
                newLayoutNr = self.layoutNr
            else:
                newLayoutNr = n
            if newLayoutNr < 0:
                newLayoutNr = 0
            # release old layout
            if self.layout():
                QWidget().setLayout(self.layout())
            # install the new layout
            if newLayoutNr == 0:
                # in horizontal mode we hide rows of empty labels to save space
                self.setLayout(self.landscapeLayout())
                self.hideAllEmptyLabels()
            elif newLayoutNr == 1:
                self.setLayout(self.portraitLayout())
                # in vertical mode we hide the top and bottom labels if empty
                self.hideOuterEmptyLabels()
            self.raise_()
            self.activateWindow()
            self.layoutNr = newLayoutNr
    
    def chooseLayout(self,w,h):
        if w > h:
            self.reLayout(0)
        else:
            self.reLayout(1)
    
    def makeLCD(self,s):
        lcd = QLCDNumber()
        lcd.setSegmentStyle(2)
        lcd.setFrameStyle(QFrame.Plain)
        lcd.setSmallDecimalPoint(False)
        lcd.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
        return lcd
    
    def makeLabel(self,name):
        label = myQLabel(name)
        label.setTextFormat(Qt.RichText)
        label.setAlignment(Qt.AlignVCenter | Qt.AlignRight)
        return label
    
    def makeLCDframe(self,lcdUpper,lcd,lcdLower):
        lcdlayout = QVBoxLayout()
        lcdlayout.addWidget(lcdUpper,1)
        lcdlayout.addWidget(lcd,5)
        lcdlayout.addWidget(lcdLower,1)
        lcdlayout.setSpacing(0)
        lcdlayout.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        frame.setContentsMargins(0, 0, 0, 0)
        frame.setLayout(lcdlayout)
        return frame
        
    # to be implemented in subclasses
    def makeLCDs(self):
        pass

    def updateVisibilities(self,l1,l2):
        for i in range(len(l1)):
            try:
                self.lcds1frames[i].setVisible(l1[i])
            except:
                pass
        for i in range(len(l2)):
            try:
                self.lcds2frames[i].setVisible(l2[i])
            except:
                pass
    
    def updateStyles(self):
        for i,s in enumerate(self.lcds1styles):
            try:
                self.lcds1labelsUpper[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
            try:
                self.lcds1[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
            try:
                self.lcds1labelsLower[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
        for i,s in enumerate(self.lcds2styles):
            try:
                self.lcds2labelsUpper[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
            try:
                self.lcds2[i].setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
            try:
                self.lcds2labelsLower[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.lcdpaletteF[s],aw.lcdpaletteB[s]))
            except:
                pass
    
    # in horizontal layouts we add one more digit per LCD than needed as spacer for separation
    # in vertical layouts we add only the exact number of digits that are needed to fully display the number to save space (tight mode)
    def updateDecimals(self):
        for lcd in self.lcds1 + self.lcds2:
            if aw.qmc.LCDdecimalplaces:
                if self.tight:
                    lcd.setDigitCount(5)
                    if not aw.qmc.flagon:
                        lcd.display("  -.-")
                else:
                    lcd.setDigitCount(6)
                    if not aw.qmc.flagon:
                        lcd.display("   -.-")
            else:
                if self.tight:
                    lcd.setDigitCount(3)
                    if not aw.qmc.flagon:
                        lcd.display(" --")
                else:
                    lcd.setDigitCount(4)
                    if not aw.qmc.flagon:
                        lcd.display("  --")

    # note that values1 and values2 can contain None values indicating that those lcds are not updated in this round
    def updateValues(self,values1,values2, *args, **kwargs):
        del args, kwargs
        for i,v1 in enumerate(values1):
            try:
                if v1 is not None:
                    self.lcds1[i].display(v1)
            except:
                pass
        for i,v2 in enumerate(values2):
            try:
                if v2 is not None:
                    self.lcds2[i].display(v2)
            except:
                pass
    
    # note that all given values can contain None indicating that those labels are not updated in this round
    def updateLabels(self,lowerlabels1,lowerlabels2,upperlabels1,upperlabels2, *args, **kwargs):
        del args, kwargs
        if lowerlabels1 is not None:
            for i,v1 in enumerate(lowerlabels1):
                try:
                    if v1 is not None:
                        self.lcds1labelsLower[i].setText(v1)
                        self.lcds1labelsLower[i].repaint()
                except:
                    pass
        if lowerlabels2 is not None:
            for i,v2 in enumerate(lowerlabels2):
                try:
                    if v2 is not None:
                        self.lcds2labelsLower[i].setText(v2)
                        self.lcds2labelsLower[i].repaint()
                except:
                    pass
        if upperlabels1 is not None:
            for i,v1 in enumerate(upperlabels1):
                try:
                    if v1 is not None:
                        self.lcds1labelsUpper[i].setText(v1)
                        self.lcds1labelsUpper[i].repaint()
                except:
                    pass
        if upperlabels2 is not None:
            for i,v2 in enumerate(upperlabels2):
                try:
                    if v2 is not None:
                        self.lcds2labelsUpper[i].setText(v2)
                        self.lcds2labelsUpper[i].repaint()
                except:
                    pass
        if self.layoutNr == 1:
            # show all labels in portrait mode
            self.hideOuterEmptyLabels()
        elif self.layoutNr == 0:
            # hide all empty upperlabels in landscape mode
            self.hideAllEmptyLabels()

class LargeMainLCDs(LargeLCDs):
    def __init__(self, parent = None):
        self.lcd0 = None # Timer
        # we add the ET lcd to the lcd1 list and the BT lcds to the lcd2 list (same for styles, labels and frames
        super(LargeMainLCDs,self).__init__(parent)
        settings = QSettings()
        if settings.contains("LCDGeometry"):
            self.restoreGeometry(settings.value("LCDGeometry"))
        else:
            self.resize(200,100)
        self.chooseLayout(self.width(),self.height())
        self.setWindowTitle(UIconst.TOOLKIT_MENU_LCDS)
    
    def updateVisiblitiesETBT(self):
        self.updateVisibilities([aw.qmc.ETlcd],[aw.qmc.BTlcd])
    
    def updateStyles(self):
        self.lcd0.setStyleSheet("QLCDNumber { color: %s; background-color: %s;}"%(aw.lcdpaletteF["timer"],aw.lcdpaletteB["timer"]))
        super().updateStyles()

    def updateValues(self, values1, values2, time=None, *args, **kwargs):
        super().updateValues(values1,values2,*args, **kwargs)
        if time is not None:
            self.lcd0.display(time)
    
    # create LCDs, LCD labels and LCD frames
    def makeLCDs(self):
        # time LCD
        self.lcd0 = self.makeLCD("timer") # time
        self.lcd0.setDigitCount(5)
        self.lcd0.display("00:00")
        # ET
        ETlcd = self.makeLCD("et") # Environmental Temperature ET
        ETlabelUpper = self.makeLabel("<b>" + aw.ETname + "</b> ")
        ETlabelLower = self.makeLabel(" ")
        #
        self.lcds1 = [ETlcd]
        self.lcds1styles = ["et"]
        self.lcds1labelsUpper = [ETlabelUpper]
        self.lcds1labelsLower = [ETlabelLower]
        self.lcds1frames = [self.makeLCDframe(ETlabelUpper,ETlcd,ETlabelLower)]
        # BT
        BTlcd = self.makeLCD("bt") # Bean Temperature BT
        BTlabelUpper = self.makeLabel("<b>" + aw.BTname + "</b> ")
        BTlabelLower = self.makeLabel(" ")
        #
        self.lcds2 = [BTlcd]
        self.lcds2styles = ["bt"]
        self.lcds2labelsUpper = [BTlabelUpper]
        self.lcds2labelsLower = [BTlabelLower]
        self.lcds2frames = [self.makeLCDframe(BTlabelUpper,BTlcd,BTlabelLower)]
        ##
        self.updateVisiblitiesETBT()
        self.updateStyles()
        self.updateDecimals()
        
    def landscapeLayout(self):
        self.tight = False
        self.makeLCDs()
        templayout = QHBoxLayout()
        if aw.qmc.swaplcds:
            templayout.addWidget(self.lcds2frames[0])
            templayout.addWidget(self.lcds1frames[0])
        else:
            templayout.addWidget(self.lcds1frames[0])
            templayout.addWidget(self.lcds2frames[0])
        landscapelayout = QVBoxLayout()
        landscapelayout.addWidget(self.lcd0,1)
        landscapelayout.addLayout(templayout,1)
        landscapelayout.setSpacing(0)
        landscapelayout.setContentsMargins(0, 0, 0, 0)
        return landscapelayout
        
    def landscapeTightLayout(self):
        self.tight = False
        self.makeLCDs()
        landscapetightlayout = QHBoxLayout()
        landscapetightlayout.addWidget(self.lcd0,1)
        if aw.qmc.swaplcds:
            landscapetightlayout.addWidget(self.lcds2frames[0],1)
            landscapetightlayout.addWidget(self.lcds1frames[0],1)
        else:
            landscapetightlayout.addWidget(self.lcds1frames[0],1)
            landscapetightlayout.addWidget(self.lcds2frames[0],1)
        landscapetightlayout.setSpacing(0)
        landscapetightlayout.setContentsMargins(0, 0, 0, 0)
        return landscapetightlayout
        
    def portraitLayout(self):
        self.tight = True
        self.makeLCDs()
        portraitlayout = QVBoxLayout()
        portraitlayout.addWidget(self.lcd0,1)
        if aw.qmc.swaplcds:
            portraitlayout.addWidget(self.lcds2frames[0],1)
            portraitlayout.addWidget(self.lcds1frames[0],1)
        else:
            portraitlayout.addWidget(self.lcds1frames[0],1)
            portraitlayout.addWidget(self.lcds2frames[0],1)
        portraitlayout.setSpacing(0)
        portraitlayout.setContentsMargins(0, 0, 0, 0)
        return portraitlayout
                
    # n the number of layout to be set (0: landscape, 1: landscape tight, 2: portrait)
    # calling reLayout() without arg will force a relayout using the current layout
    def reLayout(self,n=None):
        if self.layoutNr != n:
            if n is None:
                newLayoutNr = self.layoutNr
            else:
                newLayoutNr = n
            if newLayoutNr < 0:
                newLayoutNr = 0
            # release old layout
            if self.layout():
                QWidget().setLayout(self.layout())
            # install the new layout
            if newLayoutNr == 0:
                self.setLayout(self.landscapeLayout())
                self.hideAllEmptyLabels()
            elif newLayoutNr == 1:
                self.setLayout(self.landscapeTightLayout())
                self.hideAllEmptyLabels()
            elif newLayoutNr == 2:
                self.setLayout(self.portraitLayout())
                self.hideOuterEmptyLabels()
            self.raise_()
            self.activateWindow()
            self.layoutNr = newLayoutNr
    
    def chooseLayout(self,w,h):
        if w > h:
            if w > 3*h:
                self.reLayout(1)
            else:
                self.reLayout(0)
        else:
            self.reLayout(2)
        
    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("LCDGeometry",self.saveGeometry())
        #free resources
        aw.largeLCDs_dialog = None
        aw.LargeLCDsFlag = False

class LargeDeltaLCDs(LargeLCDs):
    def __init__(self, parent = None):
        super(LargeDeltaLCDs,self).__init__(parent)
        settings = QSettings()
        if settings.contains("DeltaLCDGeometry"):
            self.restoreGeometry(settings.value("DeltaLCDGeometry"))
        else:
            self.resize(100,200)
        self.setWindowTitle(UIconst.TOOLKIT_MENU_DELTA_LCDS)
        self.chooseLayout(self.width(),self.height())
    
    def makeLCDs(self):
        self.lcds1styles = ["deltaet"]
        self.lcds1 = [self.makeLCD(self.lcds1styles[0])] # DeltaET
        label1Upper = self.makeLabel("<b>&Delta;" + aw.ETname + "</b> ")
        label1Lower = self.makeLabel(" ")
        self.lcds1labelsUpper = [label1Upper]
        self.lcds1labelsLower = [label1Lower]
        self.lcds1frames = [self.makeLCDframe(label1Upper,self.lcds1[0],label1Lower)]
        #
        self.lcds2styles = ["deltabt"]
        self.lcds2 = [self.makeLCD(self.lcds2styles[0])] # DeltaBT
        label2Upper = self.makeLabel("<b>&Delta;" + aw.BTname + "</b> ")
        label2Lower = self.makeLabel(" ")
        self.lcds2labelsUpper = [label2Upper]
        self.lcds2labelsLower = [label2Lower]
        self.lcds2frames = [self.makeLCDframe(label2Upper,self.lcds2[0],label2Lower)]
        ##
        self.updateVisiblitiesDeltaETBT()
        self.updateStyles()
        self.updateDecimals()
    
    def updateVisiblitiesDeltaETBT(self):
        self.updateVisibilities([aw.qmc.DeltaETlcdflag],[aw.qmc.DeltaBTlcdflag])
    
    def reLayout(self,n=None):
        self.swaplcds = aw.qmc.swapdeltalcds
        super().reLayout(n)
        
    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("DeltaLCDGeometry",self.saveGeometry())
        aw.largeDeltaLCDs_dialog = None
        aw.LargeDeltaLCDsFlag = False

class LargePIDLCDs(LargeLCDs):
    def __init__(self, parent = None):
        super(LargePIDLCDs,self).__init__(parent)
        settings = QSettings()
        if settings.contains("PIDLCDGeometry"):
            self.restoreGeometry(settings.value("PIDLCDGeometry"))
        else:
            self.resize(100,200)
        self.setWindowTitle(UIconst.TOOLKIT_MENU_PID_LCDS)
        self.chooseLayout(self.width(),self.height())
    
    def makeLCDs(self):
        self.lcds1styles = ["sv"]
        self.lcds1 = [self.makeLCD(self.lcds1styles[0])] # PID SV
        label1Upper = self.makeLabel("<b>" + u(QApplication.translate("Label", "PID SV",None)) + "</b> ")
        label1Lower = self.makeLabel(" ")
        self.lcds1labelsUpper = [label1Upper]
        self.lcds1labelsLower = [label1Lower]
        self.lcds1frames = [self.makeLCDframe(label1Upper,self.lcds1[0],label1Lower)]
        #
        self.lcds2styles = ["sv"]
        self.lcds2 = [self.makeLCD(self.lcds2styles[0])] # PID %
        label2Upper = self.makeLabel("<b>" + u(QApplication.translate("Label", "PID %",None)) + "</b> ")
        label2Lower = self.makeLabel(" ")
        self.lcds2labelsUpper = [label2Upper]
        self.lcds2labelsLower = [label2Lower]
        self.lcds2frames = [self.makeLCDframe(label2Upper,self.lcds2[0],label2Lower)]
        ##
        self.updateVisiblitiesPID()
        self.updateStyles()
        self.updateDecimals()
    
    def updateVisiblitiesPID(self):
        if aw.ser.showFujiLCDs and aw.qmc.device == 0 or aw.qmc.device == 26:
            self.updateVisibilities([True],[True])
        else:
            self.updateVisibilities([False],[False])
        
    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("PIDLCDGeometry",self.saveGeometry())
        aw.largePIDLCDs_dialog = None
        aw.LargePIDLCDsFlag = False

class LargeExtraLCDs(LargeLCDs):
    def __init__(self, parent = None):
        super(LargeExtraLCDs,self).__init__(parent)
        settings = QSettings()
        if settings.contains("ExtraLCDGeometry"):
            self.restoreGeometry(settings.value("ExtraLCDGeometry"))
        else:
            self.resize(100,200)
        self.chooseLayout(self.width(),self.height())
        self.setWindowTitle(UIconst.TOOLKIT_MENU_EXTRA_LCDS)
    
    def makeLCDs(self):
        self.lcds1 = []
        self.lcds2 = []
        self.lcds1styles = []
        self.lcds2styles = []
        self.lcds1labelsUpper = []
        self.lcds2labelsUpper = []
        self.lcds1labelsLower = []
        self.lcds2labelsLower = []
        self.lcds1frames = []
        self.lcds2frames = []
        for i in range(len(aw.qmc.extradevices)): #(aw.nLCDS):
            lcdstyle = "sv"
            #
            lcd1 = self.makeLCD(lcdstyle)
            self.lcds1.append(lcd1)
            self.lcds1styles.append(lcdstyle)
            l1 = "<b>" + aw.qmc.extraname1[i] + "</b> "
            try:
                l1 = l1.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
            except:
                pass
            label1Upper = self.makeLabel(l1)
            self.lcds1labelsUpper.append(label1Upper)
            label1Lower = self.makeLabel(" ")
            self.lcds1labelsLower.append(label1Lower)
            self.lcds1frames.append(self.makeLCDframe(label1Upper,lcd1,label1Lower))
            #
            lcd2 = self.makeLCD(lcdstyle)
            self.lcds2.append(lcd2)
            self.lcds2styles.append(lcdstyle)
            l2 = "<b>" + aw.qmc.extraname2[i] + "</b> "
            try:
                l2 = l2.format(aw.qmc.etypes[0],aw.qmc.etypes[1],aw.qmc.etypes[2],aw.qmc.etypes[3])
            except:
                pass
            label2Upper = self.makeLabel(l2)
            self.lcds2labelsUpper.append(label2Upper)
            label2Lower = self.makeLabel(" ")
            self.lcds2labelsLower.append(label2Lower)
            self.lcds2frames.append(self.makeLCDframe(label2Upper,lcd2,label2Lower))
        ##
        self.updateVisiblitiesExtra()
        self.updateStyles()
        self.updateDecimals()

    def updateVisiblitiesExtra(self):
        self.updateVisibilities(aw.extraLCDvisibility1,aw.extraLCDvisibility2)

    def updateStyles(self):
        super(LargeExtraLCDs,self).updateStyles()
        for i,s in enumerate(self.lcds1styles):
            try:
                self.lcds1labelsUpper[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.qmc.extradevicecolor1[i],aw.lcdpaletteB[s]))
            except:
                pass
        for i,s in enumerate(self.lcds2styles):
            try:
                self.lcds2labelsUpper[i].setStyleSheet("QLabel { color: %s; background-color: %s;}"%(aw.qmc.extradevicecolor2[i],aw.lcdpaletteB[s]))
            except:
                pass
    
    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("ExtraLCDGeometry",self.saveGeometry())
        aw.largeExtraLCDs_dialog = None
        aw.LargeExtraLCDsFlag = False

class LargePhasesLCDs(LargeLCDs):
    def __init__(self, parent = None):
        self.labels = [" ", " ", " ", self.formatLabel("AUC")] # formated labels
        self.values1 = [" "]*2
        self.values2 = [" "]*2
        super(LargePhasesLCDs,self).__init__(parent)
        settings = QSettings()
        if settings.contains("PhasesLCDGeometry"):
            self.restoreGeometry(settings.value("PhasesLCDGeometry"))
        else:
            self.resize(100,200)
        self.chooseLayout(self.width(),self.height())
        self.setWindowTitle(UIconst.TOOLKIT_MENU_PHASES_LCDS)
    
    def formatLabel(self,l):
        if l is None:
            return None
        else:
            label_fmt = "<b>{}</b>"
            return label_fmt.format(l)

    def makeLCDs(self):
        self.lcds1styles = ["sv","sv"]
        self.lcds1 = [
            self.makeLCD(self.lcds1styles[0]), # Phase 1
            self.makeLCD(self.lcds1styles[1])  # Phase 3
            ]
        label1Upper = self.makeLabel(self.labels[0])
        label1Lower = self.makeLabel(" ")
        label3Upper = self.makeLabel(self.labels[2])
        label3Lower = self.makeLabel(" ")
        self.lcds1labelsUpper = [label1Upper,label3Upper]
        self.lcds1labelsLower = [label1Lower,label3Lower]
        self.lcds1frames = [self.makeLCDframe(label1Upper,self.lcds1[0],label1Lower),self.makeLCDframe(label3Upper,self.lcds1[1],label3Lower)]
        for f in self.lcds1frames:
            f.setContextMenuPolicy(Qt.CustomContextMenu)
            f.customContextMenuRequested.connect(aw.PhaseslcdClicked)
        #
        self.lcds2styles = ["sv","sv"]
        self.lcds2 = [
            self.makeLCD(self.lcds2styles[0]), # Phase 2
            self.makeLCD(self.lcds2styles[1])  # AUC
            ]
        label2Upper = self.makeLabel(self.labels[1])
        label2Lower = self.makeLabel(" ")
        label4Upper = self.makeLabel(self.labels[3])
        label4Lower = self.makeLabel(" ")
        self.lcds2labelsUpper = [label2Upper,label4Upper]
        self.lcds2labelsLower = [label2Lower,label4Lower]
        self.lcds2frames = [self.makeLCDframe(label2Upper,self.lcds2[0],label2Lower),self.makeLCDframe(label4Upper,self.lcds2[1],label4Lower)]
        self.lcds2frames[0].setContextMenuPolicy(Qt.CustomContextMenu)
        self.lcds2frames[0].customContextMenuRequested.connect(aw.PhaseslcdClicked)
        self.lcds2frames[1].setContextMenuPolicy(Qt.CustomContextMenu)
        self.lcds2frames[1].customContextMenuRequested.connect(aw.AUClcdClicked)
        ##
        for i in range(len(self.values1)):
            self.lcds1[i].display(self.values1[i])
        for i in range(len(self.values2)):
            self.lcds2[i].display(self.values2[i])
        ##
        self.updateVisiblitiesPhases()
        self.updateStyles()
        self.updateDecimals()
    
    def updateValues(self,values1,values2):
        # don't update None values
        for i,v in enumerate(values1):
            if v is not None:
                self.values1[i] = v
        for i,v in enumerate(values2):
            if v is not None:
                self.values2[i] = v
        super(LargePhasesLCDs,self).updateValues(values1,values2)
    
    def updateVisiblitiesPhases(self):
        self.updateVisibilities([True,True],[True,aw.qmc.AUClcdFlag])
    
    def updateDecimals(self):
        for lcd in self.lcds1 + self.lcds2:
            lcd.setDigitCount(6)
    
    def updateLabels(self,labels):
        # don't update None values
        for i,l in enumerate(map(self.formatLabel,labels)):
            if l is not None:
                self.labels[i] = l
        super(LargePhasesLCDs,self).updateLabels([" "]*2,[" "]*2,[self.labels[0],self.labels[2]],[self.labels[1],self.labels[3]])
    
    def updateAUCstyle(self,style):
        self.lcds2[1].setStyleSheet(style)
    
    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("PhasesLCDGeometry",self.saveGeometry())
        aw.largePhasesLCDs_dialog = None
        aw.LargePhasesLCDsFlag = False

############################################################
#######################  WHEEL GRAPH CONFIG DIALOG  ########
############################################################

class WheelDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(WheelDlg,self).__init__(parent)
        self.setAttribute(Qt.WA_DeleteOnClose, False) # overwrite the ArtisanDialog class default here!!
        
        rcParams['path.effects'] = []
            
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Wheel Graph Editor",None))
        #table
        self.datatable = QTableWidget()
        self.createdatatable()
        #table for labels
        self.labeltable = QTableWidget()

        self.subdialogbuttons = QDialogButtonBox(QDialogButtonBox.Close | QDialogButtonBox.RestoreDefaults, Qt.Horizontal)
        if aw.locale not in aw.qtbase_locales:
            self.subdialogbuttons.button(QDialogButtonBox.RestoreDefaults).setText(QApplication.translate("Button","Reset Parents", None))
            self.subdialogbuttons.button(QDialogButtonBox.Close).setText(QApplication.translate("Button","Close",None))
        self.subdialogbuttons.rejected.connect(self.closelabels)
        self.subdialogbuttons.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.resetlabelparents)
        
        self.labelwheelx = 0   #index of wheel being edited on labeltable
        self.hierarchyButton = QPushButton(QApplication.translate("Button","Reverse Hierarchy",None))
        self.hierarchyButton.setToolTip(QApplication.translate("Tooltip","Sets graph hierarchy child->parent instead of parent->child",None))
        self.hierarchyButton.clicked.connect(aw.qmc.setWheelHierarchy)
        self.labeltable.setVisible(False)
        self.subdialogbuttons.setVisible(False)
        aspectlabel = QLabel(QApplication.translate("Label","Ratio",None))
        self.aspectSpinBox = QDoubleSpinBox()
        self.aspectSpinBox.setToolTip(QApplication.translate("Tooltip","Aspect Ratio",None))
        self.aspectSpinBox.setRange(0.,2.)
        self.aspectSpinBox.setSingleStep(.1)
        self.aspectSpinBox.setValue(aw.qmc.wheelaspect)
        self.aspectSpinBox.valueChanged.connect(self.setaspect)
        txtlabel = QLabel(QApplication.translate("Label","Text",None))
        txtButtonplus = QPushButton(QApplication.translate("Button","+",None))
        txtButtonplus.setToolTip(QApplication.translate("Tooltip","Increase size of text in all the graph",None))
        txtButtonplus.clicked.connect(self.changetext1)
        txtButtonminus = QPushButton(QApplication.translate("Button","-",None))
        txtButtonminus.setToolTip(QApplication.translate("Tooltip","Decrease size of text in all the graph",None))
        txtButtonminus.clicked.connect(self.changetext0)
        edgelabel = QLabel(QApplication.translate("Label","Edge",None))
        self.edgeSpinBox = QSpinBox()
        self.edgeSpinBox.setToolTip(QApplication.translate("Tooltip","Decorative edge beween wheels",None))
        self.edgeSpinBox.setRange(0,5)
        self.edgeSpinBox.setValue(int(aw.qmc.wheeledge*100))
        self.edgeSpinBox.valueChanged.connect(self.setedge)
        linewidthlabel = QLabel(QApplication.translate("Label","Line",None))
        self.linewidthSpinBox = QSpinBox()
        self.linewidthSpinBox.setToolTip(QApplication.translate("Tooltip","Line thickness",None))
        self.linewidthSpinBox.setRange(0,20)
        self.linewidthSpinBox.setValue(aw.qmc.wheellinewidth)
        self.linewidthSpinBox.valueChanged.connect(self.setlinewidth)
        linecolor = QPushButton(QApplication.translate("Button","Line Color",None))
        linecolor.setToolTip(QApplication.translate("Tooltip","Line color",None))
        linecolor.clicked.connect(self.setlinecolor)        
        textcolor = QPushButton(QApplication.translate("Button","Text Color",None))
        textcolor.setToolTip(QApplication.translate("Tooltip","Text color",None))
        textcolor.clicked.connect(self.settextcolor)        
        colorlabel = QLabel(QApplication.translate("Label","Color pattern",None))
        self.colorSpinBox = QSpinBox()
        self.colorSpinBox.setToolTip(QApplication.translate("Tooltip","Apply color pattern to whole graph",None))
        self.colorSpinBox.setRange(0,255)
        self.colorSpinBox.setValue(aw.qmc.wheelcolorpattern)
        self.colorSpinBox.setWrapping(True)
        self.colorSpinBox.valueChanged.connect(self.setcolorpattern)
        addButton = QPushButton(QApplication.translate("Button","Add",None))
        addButton.setToolTip(QApplication.translate("Tooltip","Add new wheel",None))
        addButton.clicked.connect(self.insertwheel)
        rotateLeftButton = QPushButton(QApplication.translate("Button","<",None))
        rotateLeftButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree counter clockwise",None))
        rotateLeftButton.clicked.connect(self.rotatewheels1)
        rotateRightButton = QPushButton(QApplication.translate("Button",">",None))
        rotateRightButton.setToolTip(QApplication.translate("Tooltip","Rotate graph 1 degree clockwise",None))
        rotateRightButton.clicked.connect(self.rotatewheels0)
        
        self.main_buttons = QDialogButtonBox()
        
        saveButton = QPushButton(QApplication.translate("Button","Save File",None))
        saveButton.clicked.connect(self.fileSave)
        saveButton.setToolTip(QApplication.translate("Tooltip","Save graph to a text file.wg",None))
        self.main_buttons.addButton(saveButton,QDialogButtonBox.ActionRole)
        
        saveImgButton = QPushButton(QApplication.translate("Button","Save Img",None))
        saveImgButton.setToolTip(QApplication.translate("Tooltip","Save image using current graph size to a png format",None))
        #saveImgButton.clicked.connect(aw.resizeImg_0_1) # save as PNG (raster)
        saveImgButton.clicked.connect(aw.saveVectorGraph_PDF) # save as PDF (vector)
        self.main_buttons.addButton(saveImgButton,QDialogButtonBox.ActionRole)
        
        openButton = self.main_buttons.addButton(QDialogButtonBox.Open)
        openButton.setToolTip(QApplication.translate("Tooltip","open wheel graph file",None))
        openButton.clicked.connect(self.loadWheel)
        
        viewModeButton = self.main_buttons.addButton(QDialogButtonBox.Close)
        viewModeButton.setToolTip(QApplication.translate("Tooltip","Sets Wheel graph to view mode",None))
        viewModeButton.clicked.connect(self.viewmode)
        
        if aw.locale not in aw.qtbase_locales:
            self.main_buttons.button(QDialogButtonBox.Close).setText(QApplication.translate("Button","Close", None))
            self.main_buttons.button(QDialogButtonBox.Open).setText(QApplication.translate("Button","Open",None))
        
        aw.qmc.drawWheel()
        label1layout = QVBoxLayout()
        label2layout = QHBoxLayout()
        label1layout.addWidget(self.labeltable)
        label2layout.addWidget(self.subdialogbuttons)
        label1layout.addLayout(label2layout)
        self.labelGroupLayout = QGroupBox(QApplication.translate("GroupBox","Label Properties",None))
        self.labelGroupLayout.setLayout(label1layout)
        self.labelGroupLayout.setVisible(False)
        buttonlayout = QHBoxLayout()
        buttonlayout.addWidget(self.main_buttons)
        configlayout =  QHBoxLayout()
        configlayout.addWidget(colorlabel)
        configlayout.addWidget(self.colorSpinBox)
        configlayout.addWidget(aspectlabel)
        configlayout.addWidget(self.aspectSpinBox)
        configlayout.addWidget(edgelabel)
        configlayout.addWidget(self.edgeSpinBox)
        configlayout.addWidget(linewidthlabel)
        configlayout.addWidget(self.linewidthSpinBox)
        configlayout.addWidget(linecolor)
        configlayout.addWidget(textcolor)
        configlayout.addWidget(txtlabel)
        configlayout.addWidget(txtButtonplus)
        configlayout.addWidget(txtButtonminus)
        controlLayout = QHBoxLayout()
        controlLayout.addWidget(addButton)
        controlLayout.addWidget(rotateLeftButton)
        controlLayout.addWidget(rotateRightButton)
        controlLayout.addWidget(self.hierarchyButton)
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.datatable)
        mainlayout.addWidget(self.labelGroupLayout)
        mainlayout.addLayout(controlLayout)
        mainlayout.addLayout(configlayout)
        mainlayout.addLayout(buttonlayout)
        self.setLayout(mainlayout)
        
    def close(self):
        self.accept()

    #creates config table for wheel with index x
    @pyqtSlot(bool)
    def createlabeltable(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),3)
        if x is not None:
            self.createlabeltablex(x)

    def createlabeltablex(self,x):
        self.labelwheelx = x                    #wheel being edited
        self.labelGroupLayout.setVisible(True)
        self.labeltable.setVisible(True)
        self.subdialogbuttons.setVisible(True)
        
        nlabels = len(aw.qmc.wheelnames[x])
        # self.labeltable.clear() # this crashes Ubuntu 16.04
        self.labeltable.clearSelection() # this seems to work also for Ubuntu 16.04
        
        if nlabels:
            self.labeltable.setRowCount(nlabels)
            self.labeltable.setColumnCount(5)
            self.labeltable.setHorizontalHeaderLabels([QApplication.translate("Table","Label",None),
                                                       QApplication.translate("Table","Parent",None),
                                                       QApplication.translate("Table","Width",None),
                                                       QApplication.translate("Table","Color",None),
                                                       QApplication.translate("Table","Opaqueness",None)])
            self.labeltable.setAlternatingRowColors(True)
            self.labeltable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.labeltable.setSelectionBehavior(QTableWidget.SelectRows)
            self.labeltable.setSelectionMode(QTableWidget.SingleSelection)
            self.labeltable.setShowGrid(True)
            self.labeltable.verticalHeader().setSectionResizeMode(2)
            #populate table
            for i in range(nlabels):
                label = QTableWidgetItem(aw.qmc.wheelnames[x][i])
                parentComboBox =  QComboBox()
                if x > 0:
                    items = aw.qmc.wheelnames[x-1][:]
                    items.insert(0,"")
                    parentComboBox.addItems(items)
                    if aw.qmc.wheellabelparent[x][i]:
                        parentComboBox.setCurrentIndex(aw.qmc.wheellabelparent[x][i])
                else:
                    parentComboBox.addItems([])
                parentComboBox.currentIndexChanged.connect(self.setwheelchild)
                labelwidthSpinBox = QDoubleSpinBox()
                labelwidthSpinBox.setRange(1.,100.)
                labelwidthSpinBox.setValue(aw.qmc.segmentlengths[x][i])
                labelwidthSpinBox.setSuffix("%")
                labelwidthSpinBox.valueChanged.connect(self.setlabelwidth)
                colorButton = QPushButton("Set Color")
                colorButton.clicked.connect(self.setsegmentcolor)
                alphaSpinBox = QSpinBox()
                alphaSpinBox.setRange(0,10)
                alphaSpinBox.setValue(int(aw.qmc.segmentsalpha[x][i]*10))
                alphaSpinBox.valueChanged.connect(self.setsegmentalpha)
                #add widgets to the table
                self.labeltable.setItem(i,0,label)
                self.labeltable.setCellWidget(i,1,parentComboBox)
                self.labeltable.setCellWidget(i,2,labelwidthSpinBox)
                self.labeltable.setCellWidget(i,3,colorButton)
                self.labeltable.setCellWidget(i,4,alphaSpinBox)

    @pyqtSlot(bool)
    def setsegmentcolor(self,_):
        i = aw.findWidgetsRow(self.labeltable,self.sender(),3)
        if i is not None:
            x = self.labelwheelx
            colorf = aw.colordialog(QColor(aw.qmc.wheelcolor[x][i]))
            if colorf.isValid():
                colorname = str(colorf.name())
                aw.qmc.wheelcolor[x][i] = colorname      #add new color to label
                self.createdatatable()                           #update main table with label names (label::color)
                aw.qmc.drawWheel()

    #sets a uniform color in wheel
    @pyqtSlot(bool)
    def setwheelcolor(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),8)
        if x is not None:
            colorf = aw.colordialog(QColor(aw.qmc.wheelcolor[x][0]))
            if colorf.isValid():
                colorname = str(colorf.name())
                for i in range(len(aw.qmc.wheelcolor[x])):
                    aw.qmc.wheelcolor[x][i] =  colorname
            self.createdatatable()
            aw.qmc.drawWheel()

    #sets color pattern (many colors) in wheel
    @pyqtSlot(int)
    def setwheelcolorpattern(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),9)
        if x is not None:
            wsb =  self.datatable.cellWidget(x,9)
            wpattern = wsb.value()
            wlen = len(aw.qmc.wheelcolor[x])
            for i in range(wlen):
                color = QColor()
                color.setHsv((360/wlen)*i*wpattern,255,255,255)
                aw.qmc.wheelcolor[x][i] = str(color.name())
            aw.qmc.drawWheel()

    #sets color pattern (many colors) for whole graph
    @pyqtSlot(int)
    def setcolorpattern(self,_):
        aw.qmc.wheelcolorpattern = self.colorSpinBox.value()
        if aw.qmc.wheelcolorpattern:
            for x in range(len(aw.qmc.wheelcolor)):
                wlen = len(aw.qmc.wheelcolor[x])
                for i in range(wlen):
                    color = QColor()
                    color.setHsv((360/wlen)*i*aw.qmc.wheelcolorpattern,255,255,255)
                    aw.qmc.wheelcolor[x][i] = str(color.name())
            aw.qmc.drawWheel()

    @pyqtSlot(int)
    def setsegmentalpha(self,z):
        u = aw.findWidgetsRow(self.labeltable,self.sender(),4)
        if u is not None:
            x = self.labelwheelx
            aw.qmc.segmentsalpha[x][u] = float(z/10.)
            aw.qmc.drawWheel()

    #rotate whole graph
    @pyqtSlot(bool)
    def rotatewheels1(self,_):
        for i in range(len(aw.qmc.startangle)):
            aw.qmc.startangle[i] += 1
        aw.qmc.drawWheel()
    
    @pyqtSlot(bool)
    def rotatewheels0(self,_):
        for i in range(len(aw.qmc.startangle)):
            aw.qmc.startangle[i] -= 1
        aw.qmc.drawWheel()

    #z= new width%, x= wheel number index, u = index of segment in the wheel
    @pyqtSlot(float)
    def setlabelwidth(self,z):
        u = aw.findWidgetsRow(self.labeltable,self.sender(),2)
        if u is not None:
            x = self.labelwheelx
            newwidth = z
            oldwidth = aw.qmc.segmentlengths[x][u]
            diff = newwidth - oldwidth
            l = len(aw.qmc.segmentlengths[x])
            for i in range(l):
                if i != u:
                    if diff > 0:
                        aw.qmc.segmentlengths[x][i] -= abs(float(diff))/(l-1)
                    else:
                        aw.qmc.segmentlengths[x][i] += abs(float(diff))/(l-1)
            aw.qmc.segmentlengths[x][u] = newwidth
            aw.qmc.drawWheel()

    #input: z = index of parent in previus wheel; x = wheel number; i = index of element in wheel
    @pyqtSlot(int)
    def setwheelchild(self,z):
        i = aw.findWidgetsRow(self.labeltable,self.sender(),1)
        if i is not None:
            aw.qmc.setwheelchild(z,self.labelwheelx,i)
            aw.qmc.drawWheel()
            self.createdatatable() #update data table

    #deletes parent-child relation in a wheel. It obtains the wheel index by self.labelwheelx
    @pyqtSlot(bool)
    def resetlabelparents(self,_):
        x = self.labelwheelx
        nsegments = len(aw.qmc.wheellabelparent[x])
        for i in range(nsegments):
            aw.qmc.wheellabelparent[x][i] = 0
            aw.qmc.segmentlengths[x][i] = 100./nsegments
        aw.qmc.drawWheel()
        self.createlabeltablex(x)

    @pyqtSlot(float)
    def setaspect(self,_):
        aw.qmc.wheelaspect = self.aspectSpinBox.value()
        aw.qmc.drawWheel()

    #adjust decorative edge between wheels
    @pyqtSlot(int)
    def setedge(self):
        aw.qmc.wheeledge = float(self.edgeSpinBox.value())/100.
        aw.qmc.drawWheel()

    #adjusts line thickness
    @pyqtSlot(int)
    def setlinewidth(self,_):
        aw.qmc.wheellinewidth = self.linewidthSpinBox.value()
        aw.qmc.drawWheel()

    #sets line color
    @pyqtSlot(bool)
    def setlinecolor(self,_):
        colorf = aw.colordialog(QColor(aw.qmc.wheellinecolor))
        if colorf.isValid():
            colorname = str(colorf.name())
            #aw.qmc.wheellinealpha = colorf.alphaF()
            aw.qmc.wheellinecolor = colorname      #add new color to label
            aw.qmc.drawWheel()
            
    #sets text color
    @pyqtSlot(bool)
    def settextcolor(self,_):
        colorf = aw.colordialog(QColor(aw.qmc.wheeltextcolor))
        if colorf.isValid():
            colorname = str(colorf.name())
            #aw.qmc.wheeltextalpha = colorf.alphaF()
            aw.qmc.wheeltextcolor = colorname      #add new color to label
            aw.qmc.drawWheel()

    #makes not visible the wheel config table
    @pyqtSlot()
    def closelabels(self):
        self.labelGroupLayout.setVisible(False)
        self.labeltable.setVisible(False)
#        self.labelCloseButton.setVisible(False)
#        self.labelResetButton.setVisible(False)
        self.subdialogbuttons.setVisible(False)

    #creates graph table
    def createdatatable(self):
        ndata = len(aw.qmc.wheelnames)
        
        # self.datatable.clear() # this crashes Ubuntu 16.04
#        if ndata != 0:
#            self.datatable.clearContents() # this crashes Ubuntu 16.04 if device table is empty and also sometimes else
        self.datatable.clearSelection() # this seems to work also for Ubuntu 16.04
        
        self.datatable.setRowCount(ndata)
        self.datatable.setColumnCount(10)
        self.datatable.setHorizontalHeaderLabels([QApplication.translate("Table","Delete Wheel",None),
                                                  QApplication.translate("Table","Edit Labels",None),
                                                  QApplication.translate("Table","Update Labels",None),
                                                  QApplication.translate("Table","Properties",None),
                                                  QApplication.translate("Table","Radius",None),
                                                  QApplication.translate("Table","Starting angle",None),
                                                  QApplication.translate("Table","Projection",None),
                                                  QApplication.translate("Table","Text Size",None),
                                                  QApplication.translate("Table","Color",None),
                                                  QApplication.translate("Table","Color Pattern",None)])
        self.datatable.setAlternatingRowColors(True)
        self.datatable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.datatable.setSelectionBehavior(QTableWidget.SelectRows)
        self.datatable.setSelectionMode(QTableWidget.SingleSelection)
        self.datatable.setShowGrid(True)
        self.datatable.verticalHeader().setSectionResizeMode(2)
        #populate table
        for i in range(ndata):
            delButton = QPushButton(QApplication.translate("Button","Delete",None))
            delButton.clicked.connect(self.popwheel)
            labelsedit = QLineEdit(str(",".join(aw.qmc.wheelnames[i])))
            updateButton = QPushButton(QApplication.translate("Button","Update",None))
            updateButton.clicked.connect(self.updatelabels)
            setButton = QPushButton(QApplication.translate("Button","Select",None))
            setButton.clicked.connect(self.createlabeltable)
            widthSpinBox = QDoubleSpinBox()
            widthSpinBox.setRange(1.,100.)
            widthSpinBox.setValue(aw.qmc.wradii[i])
            widthSpinBox.setSuffix("%")
            widthSpinBox.valueChanged.connect(self.setwidth)
            angleSpinBox = QSpinBox()
            angleSpinBox.setSuffix(QApplication.translate("Label"," dg",None))
            angleSpinBox.setRange(0,359)
            angleSpinBox.setWrapping(True)
            angleSpinBox.setValue(aw.qmc.startangle[i])
            angleSpinBox.valueChanged.connect(self.setangle)
            projectionComboBox =  QComboBox()
            projectionComboBox.addItems([QApplication.translate("ComboBox","Flat",None),
                                         QApplication.translate("ComboBox","Perpendicular",None),
                                         QApplication.translate("ComboBox","Radial",None)])
            projectionComboBox.setCurrentIndex(aw.qmc.projection[i])
            projectionComboBox.currentIndexChanged.connect(self.setprojection)
            txtSpinBox = QSpinBox()
            txtSpinBox.setRange(1,30)
            txtSpinBox.setValue(aw.qmc.wheeltextsize[i])
            txtSpinBox.valueChanged.connect(self.setTextsizeX)
            colorButton = QPushButton(QApplication.translate("Button","Set Color",None))
            colorButton.clicked.connect(self.setwheelcolor)
            colorSpinBox = QSpinBox()
            colorSpinBox.setRange(0,255)
            colorSpinBox.setWrapping(True)
            colorSpinBox.valueChanged.connect(self.setwheelcolorpattern)
            #add widgets to the table
            self.datatable.setCellWidget(i,0,delButton)
            self.datatable.setCellWidget(i,1,labelsedit)
            self.datatable.setCellWidget(i,2,updateButton)
            self.datatable.setCellWidget(i,3,setButton)
            self.datatable.setCellWidget(i,4,widthSpinBox)
            self.datatable.setCellWidget(i,5,angleSpinBox)
            self.datatable.setCellWidget(i,6,projectionComboBox)
            self.datatable.setCellWidget(i,7,txtSpinBox)
            self.datatable.setCellWidget(i,8,colorButton)
            self.datatable.setCellWidget(i,9,colorSpinBox)

    #reads label edit box for wheel with index x, and updates labels
    @pyqtSlot(bool)
    def updatelabels(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),2)
        if x is not None:
            labelsedit =  self.datatable.cellWidget(x,1)
            text  = str(labelsedit.text())
            if "\\n" in text:              #make multiple line text if "\n" found in label string
                parts = text.split("\\n")
                text = chr(10).join(parts)
            newwheellabels = text.strip().split(",")
            newnlabels = len(newwheellabels)
            oldnlabels = len(aw.qmc.wheelnames[x])
            #adjust segments len and alpha for each wheel if number of labels changed
            if oldnlabels != newnlabels:
                aw.qmc.segmentlengths[x] = [100./newnlabels]*newnlabels
                aw.qmc.segmentsalpha[x] = [.3]*newnlabels
                aw.qmc.wheellabelparent[x] = [0]*newnlabels
                aw.qmc.wheelcolor[x] = [aw.qmc.wheelcolor[x][0]]*newnlabels
            aw.qmc.wheelnames[x] = newwheellabels[:]
            aw.qmc.drawWheel()

    #sets radii for a wheel
    @pyqtSlot(float)
    def setwidth(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),4)
        if x is not None:
            widthSpinBox = self.datatable.cellWidget(x,4)
            newwidth = widthSpinBox.value()
            oldwidth = aw.qmc.wradii[x]
            diff = newwidth - oldwidth
            l = len(aw.qmc.wradii)
            for i in range(l):
                if i != x:
                    if diff > 0:
                        aw.qmc.wradii[i] -= abs(float(diff))/(l-1)
                    else:
                        aw.qmc.wradii[i] += abs(float(diff))/(l-1)
            aw.qmc.wradii[x] = newwidth
            #Need 100.0% coverage. Correct for numerical floating point rounding errors:
            count = 0.
            for i in range(len(aw.qmc.wradii)):
                count +=  aw.qmc.wradii[i]
            diff = 100. - count
            if diff  != 0.:
                if diff > 0.000:  #if count smaller
                    aw.qmc.wradii[x] += abs(diff)
                else:
                    aw.qmc.wradii[x] -= abs(diff)
            aw.qmc.drawWheel()

    #sets starting angle (rotation) for a wheel with index x
    @pyqtSlot(int)
    def setangle(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),5)
        if x is not None:
            angleSpinBox = self.datatable.cellWidget(x,5)
            aw.qmc.startangle[x] = angleSpinBox.value()
            aw.qmc.drawWheel()

    #sets text projection style for a wheel with index x
    @pyqtSlot(int)
    def setprojection(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),6)
        if x is not None:
            projectionComboBox = self.datatable.cellWidget(x,6)
            aw.qmc.projection[x] = projectionComboBox.currentIndex()
            aw.qmc.drawWheel()

    #chages text size in wheel with index x
    @pyqtSlot(int)
    def setTextsizeX(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),7)
        if x is not None:
            txtSpinBox = self.datatable.cellWidget(x,7)
            aw.qmc.wheeltextsize[x] = txtSpinBox.value()
            aw.qmc.drawWheel()

    #changes size of text in whole graph
    @pyqtSlot(bool)
    def changetext1(self,_):
        for i in range(len(aw.qmc.wheeltextsize)):
            aw.qmc.wheeltextsize[i] += 1
        aw.qmc.drawWheel()
    
    @pyqtSlot(bool)
    def changetext0(self,_):
        for i in range(len(aw.qmc.wheeltextsize)):
            aw.qmc.wheeltextsize[i] -= 1
        aw.qmc.drawWheel()

    #adds new top wheel
    @pyqtSlot(bool)
    def insertwheel(self,_):
        ndata = len(aw.qmc.wradii)
        if ndata:
            count = 0.
            for i in range(ndata):
                aw.qmc.wradii[i] = 100./(ndata+1)
                count += aw.qmc.wradii[i]
            aw.qmc.wradii.append(100.-count)
        else:
            aw.qmc.wradii.append(100.)
        #find number of labels of most outer wheel (last)
        if len(aw.qmc.wheelnames):
            nwheels = len(aw.qmc.wheelnames[-1])
        else:                                       #if no wheels
            nwheels = 3
        wn,sl,sa,wlp,co = [],[],[],[],[]
        for i in range(nwheels+1):
            wn.append("W%i %i"%(len(aw.qmc.wheelnames)+1,i+1))
            sl.append(100./(nwheels+1))
            sa.append(.3)
            wlp.append(0)
            color = QColor()
            color.setHsv((360/(nwheels+1))*i,255,255,255)
            co.append(str(color.name()))
        aw.qmc.wheelnames.append(wn)
        aw.qmc.segmentlengths.append(sl)
        aw.qmc.segmentsalpha.append(sa)
        aw.qmc.wheellabelparent.append(wlp)
        aw.qmc.startangle.append(0)
        aw.qmc.projection.append(2)
        aw.qmc.wheeltextsize.append(10)
        aw.qmc.wheelcolor.append(co)
        self.createdatatable()
        aw.qmc.drawWheel()

    #deletes wheel with index x
    @pyqtSlot(bool)
    def popwheel(self,_):
        x = aw.findWidgetsRow(self.datatable,self.sender(),0)
        if x is not None:
            #correct raius of other wheels (to use 100% coverage)
            width = aw.qmc.wradii[x]
            l = len(aw.qmc.wradii)
            for i in range(l):
                if i != x:
                    aw.qmc.wradii[i] += float(width)/(l-1)
            aw.qmc.wheelnames.pop(x)
            aw.qmc.wradii.pop(x)
            aw.qmc.startangle.pop(x)
            aw.qmc.projection.pop(x)
            aw.qmc.wheeltextsize.pop(x)
            aw.qmc.segmentlengths.pop(x)
            aw.qmc.segmentsalpha.pop(x)
            aw.qmc.wheellabelparent.pop(x)
            aw.qmc.wheelcolor.pop(x)
            self.createdatatable()
            aw.qmc.drawWheel()
    
    @pyqtSlot(bool)
    def fileSave(self,_):
        try:
            filename = aw.ArtisanSaveFileDialog(msg=QApplication.translate("Message","Save Wheel graph",None),ext="*.wg")
            if filename:
                #write
                aw.serialize(filename,aw.getWheelGraph())
                aw.sendmessage(QApplication.translate("Message","Wheel Graph saved",None))
        except IOError as e:
            aw.qmc.adderror((QApplication.translate("Error Message","IO Error:",None) + " Wheel graph filesave(): {0}").format(str(e)))
            return

    @pyqtSlot(bool)
    def loadWheel(self,_):
        filename = aw.ArtisanOpenFileDialog(msg=QApplication.translate("Message","Open Wheel Graph",None),path = aw.getDefaultPath(),ext="*.wg")
        if filename:
            aw.loadWheel(filename)
            aw.wheelpath = filename
            self.createdatatable()
            aw.qmc.drawWheel()

    def closeEvent(self, _):
        self.viewmode(False)

    @pyqtSlot(bool)
    def viewmode(self,_):
        self.close()
        aw.qmc.connectWheel()
        aw.qmc.drawWheel()

############################################################
#######################  ALARM DIALOG  #####################
############################################################

class MyQComboBox(QComboBox):
    def __init__(self, *args, **kwargs):
        super(MyQComboBox, self).__init__(*args, **kwargs)
        self.setFocusPolicy(Qt.StrongFocus)
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QComboBox.wheelEvent(self, *args, **kwargs)

class MyQDoubleSpinBox(QDoubleSpinBox):
    def __init__(self, *args, **kwargs):
        super(MyQDoubleSpinBox, self).__init__(*args, **kwargs)
        self.setFocusPolicy(Qt.StrongFocus)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QDoubleSpinBox.wheelEvent(self, *args, **kwargs)
            
    # we re-direct the mouse double-click event to the standard mouse press event and add
    # the (at least in PyQt 5.12.2/5.12.3) missing mouse release event
    # which had the effect that a double click an DoubleSpinBox arrow in the Cup Profile dialog
    # leads to a non-terminating sequence of setvalue() calls until the end of the spinner is reached.
    # Note: a triple click still has this effect
    def mouseDoubleClickEvent(self, event):
        super(MyQDoubleSpinBox, self).mouseReleaseEvent(event)
        super(MyQDoubleSpinBox, self).mouseDoubleClickEvent(event)
        super(MyQDoubleSpinBox, self).mouseReleaseEvent(event)

class MyTableWidgetItemQLineEdit(QTableWidgetItem):
    __slots__ = ['sortKey'] # save some memory by using slots
    def __init__(self, sortKey):
        #call custom constructor with UserType item type
        #QTableWidgetItem.__init__(self, "", QTableWidgetItem.UserType)
        super(QTableWidgetItem,self).__init__("", QTableWidgetItem.UserType)
        self.sortKey = sortKey

    #Qt uses a simple < check for sorting items, override this to use the sortKey
    def __lt__(self, other):
        a = self.sortKey.text()
        b = other.sortKey.text()
        if len(a) == 5 and len(b) == 5 and a[2] == ":" and b[2] == ":":
            # we compare times
            return aw.qmc.stringtoseconds(a) < aw.qmc.stringtoseconds(b)
        else:
            try:
                # if those are numbers
                return int(a) < int(b)
            except:
                # else we do a string compare
                return a < b
      
class MyTableWidgetItemInt(QTableWidgetItem):
    __slots__ = ['sortKey'] # save some memory by using slots
    def __init__(self, text, sortKey):
        super(QTableWidgetItem,self).__init__(text, QTableWidgetItem.UserType)
        self.sortKey = sortKey

    #Qt uses a simple < check for sorting items, override this to use the sortKey
    def __lt__(self, other):
        return self.sortKey < other.sortKey 
        
class MyTableWidgetItemQCheckBox(QTableWidgetItem):
    __slots__ = ['sortKey'] # save some memory by using slots
    def __init__(self, sortKey):
        #call custom constructor with UserType item type
        super(QTableWidgetItem,self).__init__("", QTableWidgetItem.UserType)
        self.sortKey = sortKey

    #Qt uses a simple < check for sorting items, override this to use the sortKey
    def __lt__(self, other):
        return self.sortKey.isChecked() < other.sortKey.isChecked()
        
class MyTableWidgetItemQComboBox(QTableWidgetItem):
    __slots__ = ['sortKey'] # save some memory by using slots
    def __init__(self, sortKey):
        #call custom constructor with UserType item type
        super(QTableWidgetItem,self).__init__("", QTableWidgetItem.UserType)
        self.sortKey = sortKey

    #Qt uses a simple < check for sorting items, override this to use the sortKey
    def __lt__(self, other):
        return str(self.sortKey.currentText()) < str(other.sortKey.currentText())

# QLabel that automatically resizes its text font
class myQLabel(QLabel):
    __slots__ = [] # save some memory by using slots
    def __init__(self, *args, **kargs):
        super(myQLabel, self).__init__(*args, **kargs)
        self.setSizePolicy(QSizePolicy(QSizePolicy.Ignored,QSizePolicy.Ignored))
        self.setMinSize(14)

    def setMinSize(self, minfs):
        f = self.font()
        f.setPixelSize(minfs)
        br = QFontMetrics(f).boundingRect(self.text())
        self.setMinimumSize(br.width(), br.height())

    def resizeEvent(self, event):
        super(myQLabel, self).resizeEvent(event)
        if not self.text():
            return
        #--- fetch current parameters ----
        f = self.font()
        cr = self.contentsRect()
        #--- iterate to find the font size that fits the contentsRect ---
        dw = event.size().width() - event.oldSize().width()   # width change
        dh = event.size().height() - event.oldSize().height() # height change
        fs = max(f.pixelSize(), 1)
        while True:
            f.setPixelSize(fs)
            br =  QFontMetrics(f).boundingRect(self.text())
            if dw >= 0 and dh >= 0: # label is expanding
                if br.height() <= cr.height() and br.width() <= cr.width():
                    fs += 1
                else:
                    f.setPixelSize(max(fs - 1, 1)) # backtrack
                    break
            else: # label is shrinking
                if br.height() > cr.height() or br.width() > cr.width():
                    fs -= 1
                else:
                    break
            if fs < 1: break
        #--- update font size --- 
        self.setFont(f)

class AlarmDlg(ArtisanResizeablDialog):
    def __init__(self, parent = None):
        super(AlarmDlg,self).__init__(parent)
        self.setModal(True)
        self.setWindowTitle(QApplication.translate("Form Caption","Alarms",None))
        self.helpdialog = None

        # restore window position
        settings = QSettings()
        if settings.contains("AlarmsGeometry"):
            self.restoreGeometry(settings.value("AlarmsGeometry"))
        
        #table for alarms
        self.alarmtable = QTableWidget()
        self.createalarmtable()
        self.alarmtable.itemSelectionChanged.connect(self.selectionChanged)
        allonButton = QPushButton(QApplication.translate("Button","All On",None))
        allonButton.clicked.connect(self.alarmsAllOn)
        allonButton.setFocusPolicy(Qt.NoFocus)
        alloffButton = QPushButton(QApplication.translate("Button","All Off",None))
        alloffButton.clicked.connect(self.alarmsAllOff)
        alloffButton.setFocusPolicy(Qt.NoFocus)
        addButton = QPushButton(QApplication.translate("Button","Add",None))
        addButton.clicked.connect(self.addalarm)
        addButton.setMinimumWidth(80)
        addButton.setFocusPolicy(Qt.NoFocus)   
        
        self.insertButton = QPushButton(QApplication.translate("Button","Insert",None))
        self.insertButton.clicked.connect(self.insertalarm)
        self.insertButton.setMinimumWidth(80)
        self.insertButton.setFocusPolicy(Qt.NoFocus)
        self.insertButton.setEnabled(False)
                     
        deleteButton = QPushButton(QApplication.translate("Button","Delete",None))
        deleteButton.clicked.connect(self.deletealarm)
        deleteButton.setMinimumWidth(80)
        deleteButton.setFocusPolicy(Qt.NoFocus)

        self.copyalarmTableButton = QPushButton(QApplication.translate("Button", "Copy Table",None))
        self.copyalarmTableButton.setToolTip(QApplication.translate("Tooltip","Copy table to clipboard, OPTION or ALT click for tabular text",None))
        self.copyalarmTableButton.setFocusPolicy(Qt.NoFocus)
        self.copyalarmTableButton.clicked.connect(self.copyAlarmTabletoClipboard)

        importButton = QPushButton(QApplication.translate("Button","Load",None))
        importButton.clicked.connect(self.importalarms)
        importButton.setMinimumWidth(80)
        importButton.setFocusPolicy(Qt.NoFocus)
        exportButton = QPushButton(QApplication.translate("Button","Save",None))
        exportButton.clicked.connect(self.exportalarms)
        exportButton.setMinimumWidth(80)
        exportButton.setFocusPolicy(Qt.NoFocus)
        
        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.accepted.connect(self.closealarms)
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        
        helpButton = QPushButton(QApplication.translate("Button","Help",None))
        helpButton.setToolTip(QApplication.translate("Tooltip","Show help",None))
        helpButton.setFocusPolicy(Qt.NoFocus)
        helpButton.setMinimumWidth(80)
        helpButton.clicked.connect(self.showAlarmbuttonhelp)
        clearButton = QPushButton(QApplication.translate("Button","Clear",None))
        clearButton.setToolTip(QApplication.translate("Tooltip","Clear alarms table",None))
        clearButton.setFocusPolicy(Qt.NoFocus)
        clearButton.setMinimumWidth(80)
        clearButton.clicked.connect(self.clearalarms)
        self.loadAlarmsFromProfile = QCheckBox(QApplication.translate("CheckBox", "Load from profile",None))
        self.loadAlarmsFromProfile.setChecked(aw.qmc.loadalarmsfromprofile)
        self.loadAlarmsFromBackground = QCheckBox(QApplication.translate("CheckBox", "Load from background",None))
        self.loadAlarmsFromBackground.setChecked(aw.qmc.loadalarmsfrombackground)
        
        self.popupTimoutSpinBox = QSpinBox()
        self.popupTimoutSpinBox.setSuffix("s")
        self.popupTimoutSpinBox.setSingleStep(1)
        self.popupTimoutSpinBox.setRange(0,120)
        self.popupTimoutSpinBox.setAlignment(Qt.AlignRight)
        self.popupTimoutSpinBox.setValue(aw.qmc.alarm_popup_timout)
        popupTimeoutLabel = QLabel(QApplication.translate("Label", "PopUp TimeOut",None))
        
        self.alarmsfile = QLabel(aw.qmc.alarmsfile)
        self.alarmsfile.setAlignment(Qt.AlignRight)
        self.alarmsfile.setMinimumWidth(300)
        self.alarmsfile.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Preferred)
        tablelayout = QVBoxLayout()
        buttonlayout = QHBoxLayout()
        okbuttonlayout = QHBoxLayout()
        mainlayout = QVBoxLayout()
        tablelayout.addWidget(self.alarmtable)
        buttonlayout.addWidget(addButton)
        buttonlayout.addWidget(self.insertButton)
        buttonlayout.addWidget(deleteButton)
        buttonlayout.addWidget(self.copyalarmTableButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(allonButton)
        buttonlayout.addWidget(alloffButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(10)
        buttonlayout.addWidget(importButton)
        buttonlayout.addWidget(exportButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(clearButton)
        buttonlayout.addStretch()
        buttonlayout.addSpacing(15)
        buttonlayout.addWidget(helpButton)
        okbuttonlayout.addWidget(self.loadAlarmsFromProfile)
        okbuttonlayout.addSpacing(10)
        okbuttonlayout.addWidget(self.loadAlarmsFromBackground)
        okbuttonlayout.addSpacing(15)
        okbuttonlayout.addWidget(popupTimeoutLabel)
        okbuttonlayout.addWidget(self.popupTimoutSpinBox)
        okbuttonlayout.addWidget(self.alarmsfile)
        okbuttonlayout.addSpacing(15)
        okbuttonlayout.addWidget(self.dialogbuttons)
        mainlayout.addLayout(tablelayout)
        mainlayout.addLayout(buttonlayout)
        mainlayout.addLayout(okbuttonlayout)
        self.setLayout(mainlayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()
    
    @pyqtSlot()
    def selectionChanged(self):
        selected = self.alarmtable.selectedRanges()
        if selected and len(selected) > 0:
            self.insertButton.setEnabled(True)	
        else:	
            self.insertButton.setEnabled(False)
            
    def deselectAll(self):
        selected = self.alarmtable.selectedRanges()
        if selected and len(selected) > 0:
            self.alarmtable.setRangeSelected(selected[0],False)

    @pyqtSlot(bool)
    def clearalarms(self):
        aw.qmc.alarmtablecolumnwidths = [self.alarmtable.columnWidth(c) for c in range(self.alarmtable.columnCount())]
        aw.qmc.alarmsfile = ""
        self.alarmsfile.setText(aw.qmc.alarmsfile)
        aw.qmc.alarmflag = []
        aw.qmc.alarmguard = []
        aw.qmc.alarmnegguard = []
        aw.qmc.alarmtime = []
        aw.qmc.alarmoffset = []
        aw.qmc.alarmcond = []
        aw.qmc.alarmstate = []
        aw.qmc.alarmsource = []
        aw.qmc.alarmtemperature = []
        aw.qmc.alarmaction = []
        aw.qmc.alarmbeep = []
        aw.qmc.alarmstrings = []
        self.alarmtable.setSortingEnabled(False)
        self.alarmtable.setRowCount(0)
        self.alarmtable.setSortingEnabled(True)

    @pyqtSlot(bool)
    def alarmsAllOn(self,_):
        self.alarmson(1)

    @pyqtSlot(bool)
    def alarmsAllOff(self,_):
        self.alarmson(0)
    
    def alarmson(self,flag):
        for i in range(len(aw.qmc.alarmflag)):
            if flag == 1:
                aw.qmc.alarmflag[i] = 1
            else:
                aw.qmc.alarmflag[i] = 0
        self.createalarmtable()

    @pyqtSlot(bool)
    def addalarm(self,_):
        alarm_flag = 1
        alarm_guard = -1
        alarm_negguard = -1
        alarm_time = -1
        alarm_offset = 0
        alarm_cond = 1
        alarm_state = 0
        alarm_source = 1
        alarm_temperature = 500.
        alarm_action = 0
        alarm_beep = 0
        alarm_string = QApplication.translate("Label","Enter description",None)
        selected = self.alarmtable.selectedRanges()
        if len(selected) > 0:
            selected_idx = selected[0].topRow()
            selected_idx = int(self.alarmtable.item(selected_idx,0).text()) -1 # we derref the rows number that might be different per sorting order
            try:
                alarm_flag = aw.qmc.alarmflag[selected_idx]
                alarm_guard = aw.qmc.alarmguard[selected_idx]
                alarm_negguard = aw.qmc.alarmnegguard[selected_idx]
                alarm_time = aw.qmc.alarmtime[selected_idx]
                alarm_offset = aw.qmc.alarmoffset[selected_idx]
                alarm_cond = aw.qmc.alarmcond[selected_idx]
                alarm_state = aw.qmc.alarmstate[selected_idx]
                alarm_source = aw.qmc.alarmsource[selected_idx]
                alarm_temperature = aw.qmc.alarmtemperature[selected_idx]
                alarm_action = aw.qmc.alarmaction[selected_idx]
                alarm_beep = aw.qmc.alarmbeep[selected_idx]
                alarm_string= aw.qmc.alarmstrings[selected_idx]
            except:
                pass
        aw.qmc.alarmflag.append(alarm_flag)
        aw.qmc.alarmguard.append(alarm_guard)
        aw.qmc.alarmnegguard.append(alarm_negguard)
        aw.qmc.alarmtime.append(alarm_time)
        aw.qmc.alarmoffset.append(alarm_offset)
        aw.qmc.alarmcond.append(alarm_cond)
        aw.qmc.alarmstate.append(alarm_state)
        aw.qmc.alarmsource.append(alarm_source)
        aw.qmc.alarmtemperature.append(alarm_temperature)
        aw.qmc.alarmaction.append(alarm_action)
        aw.qmc.alarmbeep.append(alarm_beep)
        aw.qmc.alarmstrings.append(alarm_string)
        self.alarmtable.setSortingEnabled(False)
        nalarms = self.alarmtable.rowCount()
        self.alarmtable.setRowCount(nalarms + 1)
        self.setalarmtablerow(nalarms)
        
        header = self.alarmtable.horizontalHeader()
        header.setStretchLastSection(True)
        
        if len(aw.qmc.alarmflag) == 1: # only for the first entry we apply some default column width
            # improve width of Qlineedit columns
            self.alarmtable.resizeColumnsToContents()
            self.alarmtable.setColumnWidth(1,50)
            self.alarmtable.setColumnWidth(2,50)
            self.alarmtable.setColumnWidth(3,50)
            self.alarmtable.setColumnWidth(4,90)
            self.alarmtable.setColumnWidth(5,50)
            self.alarmtable.setColumnWidth(6,70)
            self.alarmtable.setColumnWidth(7,90)
            self.alarmtable.setColumnWidth(8,50)
            self.alarmtable.setColumnWidth(9,90)
            # remember the columnwidth
            for i in range(len(aw.qmc.alarmtablecolumnwidths)):
                try:
                    self.alarmtable.setColumnWidth(i,aw.qmc.alarmtablecolumnwidths[i])
                except:
                    pass
            self.alarmtable.setSortingEnabled(True)
        else:
            self.deselectAll()
            # select newly added row i.e. the last one
            self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(nalarms,0,nalarms,self.alarmtable.columnCount()-1),True)
            header.setStretchLastSection(True)
            self.markNotEnabledAlarmRows()
            self.alarmtable.setSortingEnabled(True)

    @pyqtSlot(bool)
    def insertalarm(self,_):
        self.alarmtable.setSortingEnabled(False)
        nalarms = self.alarmtable.rowCount()
        if nalarms:
            alarm_flag = 1
            alarm_guard = -1
            alarm_negguard = -1
            alarm_time = -1
            alarm_offset = 0
            alarm_cond = 1
            alarm_state = 0
            alarm_source = 1
            alarm_temperature = 500.
            alarm_action = 0
            alarm_beep = 0
            alarm_string = QApplication.translate("Label","Enter description",None)
            # check for selection
            selected = self.alarmtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                selected_row = int(self.alarmtable.item(selected_row,0).text()) -1 # we derref the rows number that might be different per sorting order
                try:
                    alarm_flag = aw.qmc.alarmflag[selected_row]
                    alarm_guard = aw.qmc.alarmguard[selected_row]
                    alarm_negguard = aw.qmc.alarmnegguard[selected_row]
                    alarm_time = aw.qmc.alarmtime[selected_row]
                    alarm_offset = aw.qmc.alarmoffset[selected_row]
                    alarm_cond = aw.qmc.alarmcond[selected_row]
                    alarm_state = aw.qmc.alarmstate[selected_row]
                    alarm_source = aw.qmc.alarmsource[selected_row]
                    alarm_temperature = aw.qmc.alarmtemperature[selected_row]
                    alarm_action = aw.qmc.alarmaction[selected_row]
                    alarm_beep = aw.qmc.alarmbeep[selected_row]
                    alarm_string= aw.qmc.alarmstrings[selected_row]
                except:
                    pass  
                aw.qmc.alarmflag.insert(selected_row,alarm_flag)
                aw.qmc.alarmguard.insert(selected_row,alarm_guard)
                aw.qmc.alarmnegguard.insert(selected_row,alarm_negguard)
                aw.qmc.alarmtime.insert(selected_row,alarm_time)
                aw.qmc.alarmoffset.insert(selected_row,alarm_offset)
                aw.qmc.alarmcond.insert(selected_row,alarm_cond)
                aw.qmc.alarmstate.insert(selected_row,alarm_state)
                aw.qmc.alarmsource.insert(selected_row,alarm_source)
                aw.qmc.alarmtemperature.insert(selected_row,alarm_temperature)
                aw.qmc.alarmaction.insert(selected_row,alarm_action)
                aw.qmc.alarmbeep.insert(selected_row,alarm_beep)
                aw.qmc.alarmstrings.insert(selected_row,alarm_string)
                self.alarmtable.insertRow(selected_row)
                self.setalarmtablerow(selected_row)
#                self.alarmtable.resizeColumnsToContents()
#                #  improve width of Qlineedit columns
#                self.alarmtable.setColumnWidth(2,50)
#                self.alarmtable.setColumnWidth(3,50)
#                self.alarmtable.setColumnWidth(5,50)
#                self.alarmtable.setColumnWidth(6,80)
#                self.alarmtable.setColumnWidth(8,40)
                header = self.alarmtable.horizontalHeader()
                header.setStretchLastSection(False)
                self.deselectAll()
                # select newly inserted item
                self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(selected_row,0,selected_row,self.alarmtable.columnCount()-1),True)
                header.setStretchLastSection(True)
                self.markNotEnabledAlarmRows()
                self.alarmtable.sortItems(0, Qt.AscendingOrder) # we first have to sort the table according to the row numbers
                # we no re-number rows
                self.renumberRows()
                # we correct the IfAlarm and ButNot references to items after the inserted one
                for i in range(self.alarmtable.rowCount()):
                    guard = self.alarmtable.cellWidget(i,2)
                    try:
                        guard_value = int(str(guard.text())) - 1
                    except Exception:
                        guard_value = -1
                    if guard_value >= selected_row:
                        guard.setText(str(guard_value+2))
                    nguard = self.alarmtable.cellWidget(i,3)
                    try:
                        nguard_value = int(str(nguard.text())) - 1
                    except Exception:
                        nguard_value = -1
                    if nguard_value >= selected_row:
                        nguard.setText(str(nguard_value+2))
        self.alarmtable.setSortingEnabled(True)
        
    def renumberRows(self):
        for i in range(self.alarmtable.rowCount()):
            self.alarmtable.setItem(i, 0, MyTableWidgetItemInt(str(i+1),i))

    @pyqtSlot(bool)
    def deletealarm(self,_):
        aw.qmc.alarmtablecolumnwidths = [self.alarmtable.columnWidth(c) for c in range(self.alarmtable.columnCount())]
        self.alarmtable.setSortingEnabled(False)
        nalarms = self.alarmtable.rowCount()
        if nalarms:
            # check for selection
            selected = self.alarmtable.selectedRanges()
            if selected and len(selected) > 0:
                selected_row = selected[0].topRow()
                selected_row = int(self.alarmtable.item(selected_row,0).text()) -1 # we derref the rows number that might be different per sorting order
                self.alarmtable.removeRow(selected_row)
                aw.qmc.alarmflag = aw.qmc.alarmflag[0:selected_row] + aw.qmc.alarmflag[selected_row + 1:]
                aw.qmc.alarmguard = aw.qmc.alarmguard[0:selected_row] + aw.qmc.alarmguard[selected_row + 1:]
                aw.qmc.alarmnegguard = aw.qmc.alarmnegguard[0:selected_row] + aw.qmc.alarmnegguard[selected_row + 1:]
                aw.qmc.alarmtime = aw.qmc.alarmtime[0:selected_row] + aw.qmc.alarmtime[selected_row + 1:]
                aw.qmc.alarmoffset = aw.qmc.alarmoffset[0:selected_row] + aw.qmc.alarmoffset[selected_row + 1:]
                aw.qmc.alarmcond = aw.qmc.alarmcond[0:selected_row] + aw.qmc.alarmcond[selected_row + 1:]
                aw.qmc.alarmstate = aw.qmc.alarmstate[0:selected_row] + aw.qmc.alarmstate[selected_row + 1:]
                aw.qmc.alarmsource = aw.qmc.alarmsource[0:selected_row] + aw.qmc.alarmsource[selected_row + 1:]
                aw.qmc.alarmtemperature = aw.qmc.alarmtemperature[0:selected_row] + aw.qmc.alarmtemperature[selected_row + 1:]
                aw.qmc.alarmaction = aw.qmc.alarmaction[0:selected_row] + aw.qmc.alarmaction[selected_row + 1:]
                aw.qmc.alarmbeep = aw.qmc.alarmbeep[0:selected_row] + aw.qmc.alarmbeep[selected_row + 1:]
                aw.qmc.alarmstrings = aw.qmc.alarmstrings[0:selected_row] + aw.qmc.alarmstrings[selected_row + 1:]
                self.alarmtable.setRowCount(nalarms - 1)
                self.deselectAll()
                # select row number that was just deleted
                self.alarmtable.setRangeSelected(QTableWidgetSelectionRange(selected_row,0,selected_row,self.alarmtable.columnCount()-1),True)
                self.alarmtable.sortItems(0)
                self.alarmtable.sortItems(0, Qt.AscendingOrder) # we first have to sort the table according to the row numbers
                # renumber elements
                self.renumberRows()
                # we correct the IfAlarm and ButNot references to items after the deleted one
                for i in range(self.alarmtable.rowCount()):
                    guard = self.alarmtable.cellWidget(i,2)
                    try:
                        guard_value = int(str(guard.text())) - 1
                    except Exception:
                        guard_value = -1
                    if guard_value >= selected_row:
                        guard.setText(str(guard_value))
                    nguard = self.alarmtable.cellWidget(i,3)
                    try:
                        nguard_value = int(str(nguard.text())) - 1
                    except Exception:
                        nguard_value = -1
                    if nguard_value >= selected_row:
                        nguard.setText(str(nguard_value))
            else:
                self.alarmtable.removeRow(self.alarmtable.rowCount() - 1)
                # nothing selected, we pop the last element
                aw.qmc.alarmflag.pop()
                aw.qmc.alarmguard.pop()
                aw.qmc.alarmnegguard.pop()
                aw.qmc.alarmtime.pop()
                aw.qmc.alarmoffset.pop()
                aw.qmc.alarmcond.pop()
                aw.qmc.alarmstate.pop()
                aw.qmc.alarmsource.pop()
                aw.qmc.alarmtemperature.pop()
                aw.qmc.alarmaction.pop()
                aw.qmc.alarmbeep.pop()
                aw.qmc.alarmstrings.pop()
                self.alarmtable.setRowCount(nalarms - 1)
                self.deselectAll()
                self.alarmtable.sortItems(0)
            self.markNotEnabledAlarmRows()
        self.alarmtable.setSortingEnabled(True)

    @pyqtSlot(bool)
    def importalarms(self,_):
        aw.fileImport(QApplication.translate("Message", "Load Alarms",None),self.importalarmsJSON,ext="*.alrm *.alog")

    def importalarmsJSON(self,filename):
        try:
            _,ext = os.path.splitext(filename)
            if ext == ".alrm":
                import io
                infile = io.open(filename, 'r', encoding='utf-8')
                from json import load as json_load
                alarms = json_load(infile)
                infile.close()
                aw.qmc.alarmsfile = filename            
                self.alarmsfile.setText(aw.qmc.alarmsfile)
                aw.qmc.alarmflag = alarms["alarmflags"]
                aw.qmc.alarmguard = alarms["alarmguards"]
                if "alarmnegguards" in alarms:
                    aw.qmc.alarmnegguard = alarms["alarmnegguards"]
                else:
                    aw.qmc.alarmnegguard = [0]*len(aw.qmc.alarmflag)
                aw.qmc.alarmtime = alarms["alarmtimes"]
                aw.qmc.alarmoffset = alarms["alarmoffsets"]
                aw.qmc.alarmcond = alarms["alarmconds"]
                aw.qmc.alarmsource = alarms["alarmsources"]
                aw.qmc.alarmtemperature = alarms["alarmtemperatures"]
                aw.qmc.alarmaction = alarms["alarmactions"]
                if "alarmbeep" in alarms:
                    aw.qmc.alarmbeep = alarms["alarmbeep"]
                else:
                    aw.qmc.alarmbeep = [0]*len(aw.qmc.alarmflag)
                aw.qmc.alarmstrings = alarms["alarmstrings"]
            elif ext == ".alog":
                obj = aw.deserialize(filename)
                aw.loadAlarmsFromProfile(filename,obj)
                self.alarmsfile.setText(aw.qmc.alarmsfile) 
            aw.qmc.alarmstate = [-1]*len(aw.qmc.alarmflag) 
            aitems = self.buildAlarmSourceList()
            for i in range(len(aw.qmc.alarmsource)):
                if aw.qmc.alarmsource[i] + 3 >= len(aitems):
                    aw.qmc.alarmsource[i] = 1 # BT
            self.createalarmtable()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.sendmessage(QApplication.translate("Message","Error loading alarm file", None))
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importalarmsJSON() {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def exportalarms(self,_):
        aw.fileExport(QApplication.translate("Message", "Save Alarms",None),"*.alrm",self.exportalarmsJSON)

    def exportalarmsJSON(self,filename):
        try:
            self.savealarms()
            alarms = {}
            alarms["alarmflags"] = aw.qmc.alarmflag
            alarms["alarmguards"] = aw.qmc.alarmguard
            alarms["alarmnegguards"] = aw.qmc.alarmnegguard
            alarms["alarmtimes"] = aw.qmc.alarmtime
            alarms["alarmoffsets"] = aw.qmc.alarmoffset
            alarms["alarmconds"] = aw.qmc.alarmcond
            alarms["alarmsources"] = aw.qmc.alarmsource
            alarms["alarmtemperatures"] = aw.qmc.alarmtemperature
            alarms["alarmactions"] = aw.qmc.alarmaction
            alarms["alarmbeep"] = aw.qmc.alarmbeep
            alarms["alarmstrings"] = list(map(lambda s:u(s),aw.qmc.alarmstrings))
            outfile = open(filename, 'w')
            from json import dump as json_dump
            json_dump(alarms, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " exportalarmsJSON(): {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    @pyqtSlot()
    def closealarms(self):
        self.savealarms()
        # save column widths
        aw.qmc.alarmtablecolumnwidths = [self.alarmtable.columnWidth(c) for c in range(self.alarmtable.columnCount())]
        
        aw.qmc.alarm_popup_timout = int(self.popupTimoutSpinBox.value())
        self.closeHelp()
        settings = QSettings()
        #save window geometry
        settings.setValue("AlarmsGeometry",self.saveGeometry())  
        self.accept()
    
    def closeEvent(self, _):
        self.closealarms()

    def savealarms(self):
        try:
            self.alarmtable.sortItems(0)
            nalarms = self.alarmtable.rowCount()
            aw.qmc.loadalarmsfromprofile = self.loadAlarmsFromProfile.isChecked()
            aw.qmc.loadalarmsfrombackground = self.loadAlarmsFromBackground.isChecked()
            aw.qmc.alarmflag = [1]*nalarms
            aw.qmc.alarmguard = [-1]*nalarms
            aw.qmc.alarmnegguard = [-1]*nalarms
            aw.qmc.alarmtime = [-1]*nalarms
            aw.qmc.alarmoffset = [0]*nalarms
            aw.qmc.alarmcond = [1]*nalarms
            aw.qmc.alarmsource = [1]*nalarms
            aw.qmc.alarmtemperature = [500.]*nalarms
            aw.qmc.alarmaction = [0]*nalarms
            aw.qmc.alarmbeep = [0]*nalarms
            aw.qmc.alarmstrings = [""]*nalarms
            for i in range(nalarms):
                flag = self.alarmtable.cellWidget(i,1)
                aw.qmc.alarmflag[i] = int(flag.isChecked())
                guard = self.alarmtable.cellWidget(i,2)
                try:
                    guard_value = int(str(guard.text())) - 1
                except Exception:
                    guard_value = -1
                if guard_value > -1 and guard_value < nalarms:
                    aw.qmc.alarmguard[i] = guard_value
                else:
                    aw.qmc.alarmguard[i] = -1
                negguard = self.alarmtable.cellWidget(i,3)
                try:
                    negguard_value = int(str(negguard.text())) - 1
                except Exception:
                    negguard_value = -1
                if negguard_value > -1 and negguard_value < nalarms:
                    aw.qmc.alarmnegguard[i] = negguard_value
                else:
                    aw.qmc.alarmnegguard[i] = -1
                timez =  self.alarmtable.cellWidget(i,4)
                aw.qmc.alarmtime[i] = aw.qmc.menuidx2alarmtime[timez.currentIndex()]
                offset =  self.alarmtable.cellWidget(i,5)
                if offset and offset != "":
                    aw.qmc.alarmoffset[i] = max(0,aw.qmc.stringtoseconds(str(offset.text())))
                atype = self.alarmtable.cellWidget(i,6)
                aw.qmc.alarmsource[i] = int(str(atype.currentIndex())) - 3
                cond = self.alarmtable.cellWidget(i,7)
                aw.qmc.alarmcond[i] = int(str(cond.currentIndex())) 
                temp = self.alarmtable.cellWidget(i,8)
                try:
                    aw.qmc.alarmtemperature[i] = float(aw.comma2dot(str(temp.text())))
                except Exception:
                    aw.qmc.alarmtemperature[i] = 0.0
                action = self.alarmtable.cellWidget(i,9)
                aw.qmc.alarmaction[i] = int(str(action.currentIndex() - 1))
                beepWidget = self.alarmtable.cellWidget(i,10)
                beep = beepWidget.layout().itemAt(1).widget()
                if beep and beep is not None:
                    aw.qmc.alarmbeep[i] = int(beep.isChecked())
                description = self.alarmtable.cellWidget(i,11)
                aw.qmc.alarmstrings[i] = u(description.text())
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " savealarms(): {0}").format(str(ex)),exc_tb.tb_lineno)
            
    def buildAlarmSourceList(self):
        extra_names = []
        for i in range(len(aw.qmc.extradevices)):
            extra_names.append(str(i) + "xT1: " + aw.qmc.extraname1[i])
            extra_names.append(str(i) + "xT2: " + aw.qmc.extraname2[i])
        return ["",
             deltaLabelUTF8 + QApplication.translate("Label","ET",None),
             deltaLabelUTF8 + QApplication.translate("Label","BT",None),
             QApplication.translate("ComboBox","ET",None),
             QApplication.translate("ComboBox","BT",None)] + extra_names

    # creates Widget in row i of self.alarmtable and sets them to values from local dialog variables at position i
    def setalarmtablerow(self,i):
        #flag
        flagComboBox = QCheckBox()
        flagComboBox.setFocusPolicy(Qt.NoFocus)
        flagComboBox.setText(QApplication.translate("ComboBox","ON",None))
        if aw.qmc.alarmflag[i]:
            flagComboBox.setCheckState(Qt.Checked)
        else:
            flagComboBox.setCheckState(Qt.Unchecked)
        #guarded by alarm
        if aw.qmc.alarmguard[i] > -1:
            guardstr = str(aw.qmc.alarmguard[i] + 1)
        else:
            guardstr = "0"
        guardedit = QLineEdit(guardstr)
        guardedit.setValidator(QIntValidator(0, 999,guardedit))
        guardedit.setAlignment(Qt.AlignRight)
        #neg guarded by alarm
        if aw.qmc.alarmnegguard[i] > -1:
            negguardstr = str(aw.qmc.alarmnegguard[i] + 1)
        else:
            negguardstr = "0"
        negguardedit = QLineEdit(negguardstr)
        negguardedit.setValidator(QIntValidator(0, 999,negguardedit))
        negguardedit.setAlignment(Qt.AlignRight)
        #Effective time from
        timeComboBox = MyQComboBox()
        timeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        timeComboBox.addItems([QApplication.translate("ComboBox","ON",None), # qmc.alarmtime 9
                               QApplication.translate("ComboBox","START",None), # qmc.alarmtime -1
                               QApplication.translate("ComboBox","CHARGE",None), # qmc.alarmtime 0
                               QApplication.translate("ComboBox","TP",None), # qmc.alarmtime 8
                               QApplication.translate("ComboBox","DRY END",None), # qmc.alarmtime 1
                               QApplication.translate("ComboBox","FC START",None), # qmc.alarmtime 2
                               QApplication.translate("ComboBox","FC END",None), # qmc.alarmtime 3
                               QApplication.translate("ComboBox","SC START",None), # qmc.alarmtime 4
                               QApplication.translate("ComboBox","SC END",None), # qmc.alarmtime 5
                               QApplication.translate("ComboBox","DROP",None), # qmc.alarmtime 6
                               QApplication.translate("ComboBox","COOL",None), # qmc.alarmtime 7
                               QApplication.translate("ComboBox","If Alarm",None)]) # qmc.alarmtime 10
        timeComboBox.setCurrentIndex(aw.qmc.alarmtime2menuidx[aw.qmc.alarmtime[i]])
        #time after selected event
        timeoffsetedit = QLineEdit(aw.qmc.stringfromseconds(max(0,aw.qmc.alarmoffset[i])))
        timeoffsetedit.setAlignment(Qt.AlignRight)
        regextime = QRegExp(r"^[0-5][0-9]:[0-5][0-9]$")
        timeoffsetedit.setValidator(QRegExpValidator(regextime,self))
        #type/source
        typeComboBox = MyQComboBox()
        typeComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        aitems = self.buildAlarmSourceList()
        typeComboBox.addItems(aitems)
        if aw.qmc.alarmsource[i] + 3 < len(aitems):
            typeComboBox.setCurrentIndex(aw.qmc.alarmsource[i] + 3)
        else:
            typeComboBox.setCurrentIndex(3)
        #condition
        condComboBox = MyQComboBox()
        condComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        condComboBox.addItems([QApplication.translate("ComboBox","below",None),
                               QApplication.translate("ComboBox","above",None)])
        condComboBox.setCurrentIndex(aw.qmc.alarmcond[i])
        #temperature
        tempedit = QLineEdit(str(aw.float2float(aw.qmc.alarmtemperature[i])))
        tempedit.setAlignment(Qt.AlignRight)
        tempedit.setMaximumWidth(130)
#        tempedit.setValidator(QIntValidator(0, 999,tempedit))
        tempedit.setValidator(aw.createCLocaleDoubleValidator(-999.9, 999.9,1,tempedit))
        #action
        actionComboBox = MyQComboBox()
        actionComboBox.setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLength)
        actionComboBox.addItems(["",
                                 QApplication.translate("ComboBox","Pop Up",None),
                                 QApplication.translate("ComboBox","Call Program",None),
                                 QApplication.translate("ComboBox","Event Button",None),
                                 QApplication.translate("ComboBox","Slider",None) + " " + u(aw.qmc.etypesf(0)),
                                 QApplication.translate("ComboBox","Slider",None) + " " + u(aw.qmc.etypesf(1)),
                                 QApplication.translate("ComboBox","Slider",None) + " " + u(aw.qmc.etypesf(2)),
                                 QApplication.translate("ComboBox","Slider",None) + " " + u(aw.qmc.etypesf(3)),
                                 QApplication.translate("ComboBox","START",None),
                                 QApplication.translate("ComboBox","DRY",None),
                                 QApplication.translate("ComboBox","FCs",None),
                                 QApplication.translate("ComboBox","FCe",None),
                                 QApplication.translate("ComboBox","SCs",None),
                                 QApplication.translate("ComboBox","SCe",None),
                                 QApplication.translate("ComboBox","DROP",None),
                                 QApplication.translate("ComboBox","COOL END",None),
                                 QApplication.translate("ComboBox","OFF",None),
                                 QApplication.translate("ComboBox","CHARGE",None),
                                 QApplication.translate("ComboBox","RampSoak ON",None),
                                 QApplication.translate("ComboBox","RampSoak OFF",None),
                                 QApplication.translate("ComboBox","PID ON",None),
                                 QApplication.translate("ComboBox","PID OFF",None),
                                 QApplication.translate("ComboBox","SV",None),
                                 QApplication.translate("ComboBox","Playback ON",None),
                                 QApplication.translate("ComboBox","Playback OFF",None),
                                 QApplication.translate("ComboBox","Set Canvas Color",None),
                                 QApplication.translate("ComboBox","Reset Canvas Color",None)])
        actionComboBox.setCurrentIndex(aw.qmc.alarmaction[i] + 1)
        #beep
        beepWidget = QWidget()
        beepComboBox = QCheckBox()
        beepComboBox.setFocusPolicy(Qt.NoFocus)
        beepLayout = QHBoxLayout()
        beepLayout.addStretch()
        beepLayout.addWidget(beepComboBox)
        beepLayout.addSpacing(6);        
        beepLayout.addStretch()
        beepLayout.setContentsMargins(0,0,0,0)
        beepLayout.setSpacing(0)
        beepWidget.setLayout(beepLayout)
        if len(aw.qmc.alarmbeep) > i and aw.qmc.alarmbeep[i]:
            beepComboBox.setCheckState(Qt.Checked)
        else:
            beepComboBox.setCheckState(Qt.Unchecked)
        #text description
        descriptionedit = QLineEdit(u(aw.qmc.alarmstrings[i]))
        descriptionedit.setCursorPosition(0)
        self.alarmtable.setItem(i, 0, MyTableWidgetItemInt(str(i+1),i))
        self.alarmtable.setCellWidget(i,1,flagComboBox)
        self.alarmtable.setItem(i, 1, MyTableWidgetItemQCheckBox(flagComboBox))
        self.alarmtable.setCellWidget(i,2,guardedit)
        self.alarmtable.setItem(i, 2, MyTableWidgetItemQLineEdit(guardedit))
        self.alarmtable.setCellWidget(i,3,negguardedit)
        self.alarmtable.setItem(i, 3, MyTableWidgetItemQLineEdit(negguardedit))
        self.alarmtable.setCellWidget(i,4,timeComboBox)
        self.alarmtable.setItem(i, 4, MyTableWidgetItemQComboBox(timeComboBox))
        self.alarmtable.setCellWidget(i,5,timeoffsetedit)
        self.alarmtable.setItem(i, 5, MyTableWidgetItemQLineEdit(timeoffsetedit))
        self.alarmtable.setCellWidget(i,6,typeComboBox)
        self.alarmtable.setItem(i, 6, MyTableWidgetItemQComboBox(typeComboBox))
        self.alarmtable.setCellWidget(i,7,condComboBox)
        self.alarmtable.setItem(i, 7, MyTableWidgetItemQComboBox(condComboBox))
        self.alarmtable.setCellWidget(i,8,tempedit)
        self.alarmtable.setItem(i, 8, MyTableWidgetItemQLineEdit(tempedit))
        self.alarmtable.setCellWidget(i,9,actionComboBox)
        self.alarmtable.setItem(i, 9, MyTableWidgetItemQComboBox(actionComboBox))
        self.alarmtable.setCellWidget(i,10,beepWidget)
        self.alarmtable.setItem(i, 10, MyTableWidgetItemQCheckBox(beepWidget.layout().itemAt(1).widget()))
        self.alarmtable.setCellWidget(i,11,descriptionedit)
        self.alarmtable.setItem(i, 11, MyTableWidgetItemQLineEdit(descriptionedit))
        

    # puts a gray background on alarm rows that have already been fired
    def markNotEnabledAlarmRows(self):
        for i in range(self.alarmtable.rowCount()):
            for j in range(11):
                try:
                    if aw.qmc.alarmstate[i] != -1:
                        #self.alarmtable.setItem(i,j,QTableWidgetItem())
                        self.alarmtable.item(i,j).setBackground(QColor(191, 191, 191))
                except:
                    pass

    def createalarmtable(self):
        try:
            self.alarmtable.clear()
            self.alarmtable.setTabKeyNavigation(True)
            self.alarmtable.setColumnCount(12)
            self.alarmtable.setHorizontalHeaderLabels([QApplication.translate("Table","Nr",None),
                                                           QApplication.translate("Table","Status",None),
                                                           QApplication.translate("Table","If Alarm",None),
                                                           QApplication.translate("Table","But Not",None),
                                                           QApplication.translate("Table","From",None),
                                                           QApplication.translate("Table","Time",None),
                                                           QApplication.translate("Table","Source",None),
                                                           QApplication.translate("Table","Condition",None),
                                                           QApplication.translate("Table","Value",None),
                                                           QApplication.translate("Table","Action",None),
                                                           QApplication.translate("Table","Beep",None),
                                                           QApplication.translate("Table","Description",None)])
            self.alarmtable.setAlternatingRowColors(True)
            self.alarmtable.setEditTriggers(QTableWidget.NoEditTriggers)
            self.alarmtable.setSelectionBehavior(QTableWidget.SelectRows)
            self.alarmtable.setSelectionMode(QTableWidget.SingleSelection)
            self.alarmtable.setShowGrid(True)
            nalarms = len(aw.qmc.alarmtemperature)
            self.alarmtable.verticalHeader().setSectionResizeMode(2)
            self.alarmtable.verticalHeader().setVisible(False)
            self.alarmtable.setSortingEnabled(False)
            if nalarms:
                self.alarmtable.setRowCount(nalarms)
                #populate table
                for i in range(nalarms):
                    self.setalarmtablerow(i)
                header = self.alarmtable.horizontalHeader()
                header.setStretchLastSection(True)
                self.alarmtable.resizeColumnsToContents()
                # remember the columnwidth
                for i in range(len(aw.qmc.alarmtablecolumnwidths)):
                    try:
                        w = aw.qmc.alarmtablecolumnwidths[i]
                        if i == 6:
                            w = max(80,w)
                        self.alarmtable.setColumnWidth(i,w)
                    except:
                        pass
                self.markNotEnabledAlarmRows()
                self.alarmtable.setSortingEnabled(True)
            self.alarmtable.sortItems(0)
            
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " createalarmtable() {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def copyAlarmTabletoClipboard(self,_=False):
        nrows = self.alarmtable.rowCount() 
        ncols = self.alarmtable.columnCount()
        clipboard = ""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.AltModifier:  #alt click
            tbl = prettytable.PrettyTable()
            fields = []
            for c in range(ncols):
                fields.append(u(self.alarmtable.horizontalHeaderItem(c).text()))
            tbl.field_names = fields
            for r in range(nrows):
                rows = []
                rows.append(u(self.alarmtable.item(r,0).text()))
                rows.append(u(self.alarmtable.cellWidget(r,1).isChecked()))
                rows.append(u(self.alarmtable.cellWidget(r,2).text()))
                rows.append(u(self.alarmtable.cellWidget(r,3).text()))
                rows.append(u(self.alarmtable.cellWidget(r,4).currentText()))
                rows.append(u(self.alarmtable.cellWidget(r,5).text()))
                rows.append(u(self.alarmtable.cellWidget(r,6).currentText()))
                rows.append(u(self.alarmtable.cellWidget(r,7).currentText()))
                rows.append(u(self.alarmtable.cellWidget(r,8).text()))
                rows.append(u(self.alarmtable.cellWidget(r,9).currentText()))
                rows.append(u(self.alarmtable.cellWidget(r,10).layout().itemAt(1).widget().isChecked()))
                rows.append(u(self.alarmtable.cellWidget(r,11).text()))
                tbl.add_row(rows)
            clipboard = tbl.get_string()
        else:
            for c in range(ncols):
                clipboard += u(self.alarmtable.horizontalHeaderItem(c).text())
                if c != (ncols-1):
                    clipboard += '\t'
            clipboard += '\n'
            for r in range(nrows):
                clipboard += u(self.alarmtable.item(r,0).text()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,1).isChecked()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,2).text()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,3).text()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,4).currentText()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,5).text()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,6).currentText()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,7).currentText()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,8).text()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,9).currentText()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,10).layout().itemAt(1).widget().isChecked()) + '\t'
                clipboard += u(self.alarmtable.cellWidget(r,11).text()) + '\n'
        # copy to the system clipboard
        sys_clip = QApplication.clipboard()
        sys_clip.setText(clipboard)
        aw.sendmessage(QApplication.translate("Message","Alarm table copied to clipboard",None))

    @pyqtSlot(bool)
    def showAlarmbuttonhelp(self,_=False):
        try: # sip not supported on older PyQt versions (RPi!)
            if self.helpdialog is None or sip.isdeleted(self.helpdialog):
                self.helpdialog = alarmHelpDlg(self)
        except:
            self.helpdialog = alarmHelpDlg(self)
        self.helpdialog.show()
        self.helpdialog.activateWindow()

    def closeHelp(self):
        try: # sip not supported on older PyQt versions (RPi!)
            if not (self.helpdialog is None or sip.isdeleted(self.helpdialog)):
                self.helpdialog.close()
        except:
            self.helpdialog.close()

########################################################################################
#####################  ALARM HELP DLG  #################################################
########################################################################################
class alarmHelpDlg(ArtisanDialog):
    def __init__(self, parent = None):
        super(alarmHelpDlg,self).__init__(parent)
        self.setWindowTitle(QApplication.translate("Form Caption","Symbolic Formulas Help",None)) 
        self.setModal(False)
        
        settings = QSettings()
        if settings.contains("alarmHelpGeometry"):
            self.restoreGeometry(settings.value("alarmHelpGeometry"))

        # autogenerated help pasted below

        newline = "\n"  #@UnusedVariable
        helpstr = ""
        helpstr += "<head><style>"
        helpstr += "td, th {border: 1px solid #ddd;  padding: 6px;}"
        helpstr += "th {padding-top: 6px;padding-bottom: 6px;text-align: left;background-color: #0C6AA6; color: white;}"
        helpstr += "</style></head>"
        helpstr += "<body>"
        helpstr += "<b>" + u(QApplication.translate('HelpDlg','ALARMS',None)) + "</b>"
        tbl_Alarmstop = prettytable.PrettyTable()
        tbl_Alarmstop.header = False
        tbl_Alarmstop.add_row([u(QApplication.translate('HelpDlg','Each alarm is only triggered once.',None))])
        helpstr += tbl_Alarmstop.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        tbl_Alarms = prettytable.PrettyTable()
        tbl_Alarms.field_names = [u(QApplication.translate('HelpDlg','Field',None)),u(QApplication.translate('HelpDlg','Description',None))]
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Nr',None)),u(QApplication.translate('HelpDlg','Alarm number for reference',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Status',None)),u(QApplication.translate('HelpDlg','Activate or Deactivate the alarm',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','If Alarm',None)),u(QApplication.translate('HelpDlg','Alarm triggered only if the alarm with the given number was triggered before. Use 0 for no guard.',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','But Not',None)),u(QApplication.translate('HelpDlg','Alarm triggered only if the alarm with the given number was not triggered before. Use 0 for no guard.',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','From',None)),u(QApplication.translate('HelpDlg','Alarm only triggered after the given event',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Time',None)),u(QApplication.translate('HelpDlg','If not 00:00, alarm is triggered mm:ss after the event "From" happened',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Source',None)),u(QApplication.translate('HelpDlg','The observed temperature source',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Condition',None)),u(QApplication.translate('HelpDlg','Alarm is triggered if source rises above or below the specified temperature',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Temp',None)),u(QApplication.translate('HelpDlg','The specified temperature limit',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Action',None)),u(QApplication.translate('HelpDlg','The action to be triggered if all conditions are fulfilled',None))])
        tbl_Alarms.add_row([u(QApplication.translate('HelpDlg','Description',None)),u(QApplication.translate('HelpDlg','The text of the popup, the name of the program, the number of the event button, the new value of the slider or the program to call',None))])
        helpstr += tbl_Alarms.get_html_string(attributes={"width":"100%","border":"1","padding":"1","border-collapse":"collapse"})
        helpstr += "</body>"
        helpstr = re.sub(r"&amp;#160;", r"&#160;",helpstr)

        # autogenerated help pasted above

        phelp = QTextEdit()
        phelp.setHtml(helpstr)
        phelp.setReadOnly(True)

        # connect the ArtisanDialog standard OK/Cancel buttons
        self.dialogbuttons.removeButton(self.dialogbuttons.button(QDialogButtonBox.Cancel))
        self.dialogbuttons.accepted.connect(self.close)

        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(self.dialogbuttons)
        hLayout = QVBoxLayout()
        hLayout.addWidget(phelp)
        hLayout.addLayout(buttonLayout)
        self.setLayout(hLayout)
        self.dialogbuttons.button(QDialogButtonBox.Ok).setFocus()

    def closeEvent(self, _):
        settings = QSettings()
        #save window geometry
        settings.setValue("alarmHelpGeometry",self.saveGeometry())

############################################################################
######################## FUJI PX PID CONTROL DIALOG ########################
############################################################################

# common code for all Fuji PXxx subclasses
class PXpidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PXpidDlgControl,self).__init__(parent)

    @pyqtSlot(bool)
    def setpointET(self,_):
        self.setpoint("ET")
    
    @pyqtSlot(bool)
    def setpointBT(self,_):
        self.setpoint("BT")
    
    def setpoint(self,PID):
        if PID == "ET":
            slaveID = aw.ser.controlETpid[1]
            if aw.ser.controlETpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
            elif aw.ser.controlETpid[0] == 1:
                reg_dict = aw.fujipid.PXR
            else:
                reg_dict = aw.fujipid.PXF
        else: # "BT"
            slaveID = aw.ser.readBTpid[1]
            if aw.ser.readBTpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
            elif aw.ser.readBTpid[0] == 1:
                reg_dict = aw.fujipid.PXR
            else:
                reg_dict = aw.fujipid.PXF
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict["decimalposition"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,1)
                r = command
            else:
                command = aw.fujipid.message2send(slaveID,6,reg_dict["decimalposition"][1],1)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Decimal position successfully set to 1",None)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting decimal position",None),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setpoint(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def setthermocoupletypeET(self,_):
        self.setthermocoupletype("ET")

    @pyqtSlot(bool)
    def setthermocoupletypeBT(self,_):
        self.setthermocoupletype("BT")

    def setthermocoupletype(self,PID):
        if PID == "ET":
            slaveID = aw.ser.controlETpid[1]
            index = self.ETthermocombobox.currentIndex()
            if aw.ser.controlETpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
                conversiontoindex = aw.fujipid.PXGconversiontoindex
            elif aw.ser.controlETpid[0] == 1:
                reg_dict = aw.fujipid.PXR
                conversiontoindex = aw.fujipid.PXRconversiontoindex
            else:
                reg_dict = aw.fujipid.PXF
                conversiontoindex = aw.fujipid.PXFconversiontoindex
        else: # "BT"
            slaveID = aw.ser.readBTpid[1]
            index = self.BTthermocombobox.currentIndex()
            if aw.ser.readBTpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
                conversiontoindex = aw.fujipid.PXGconversiontoindex
            elif aw.ser.readBTpid[0] == 1:
                reg_dict = aw.fujipid.PXR
                conversiontoindex = aw.fujipid.PXRconversiontoindex
            else:
                reg_dict = aw.fujipid.PXF
                conversiontoindex = aw.fujipid.PXFconversiontoindex
        command = ""
        reg = None
        try:
            if aw.ser.useModbusPort:
                value = conversiontoindex[index]
                reg = aw.modbus.address2register(reg_dict["pvinputtype"][1],6)
                if reg:
                    aw.modbus.writeSingleRegister(slaveID,reg,value)
                r = command
            else:
                value = conversiontoindex[index]
                command = aw.fujipid.message2send(slaveID,6,reg_dict["pvinputtype"][1],value)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                reg_dict["pvinputtype"][0] = conversiontoindex[index]
                message = QApplication.translate("StatusBar","Thermocouple type successfully set",None)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting thermocouple type",None),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " setthermocoupletype(): {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def readthermocoupletypeET(self,_):
        self.readthermocoupletype("ET")

    @pyqtSlot(bool)
    def readthermocoupletypeBT(self,_):
        self.readthermocoupletype("BT")
    
    def readthermocoupletype(self,PID):
        if PID == "ET":
            unitID = aw.ser.controlETpid[1]
            if aw.ser.controlETpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
                conversiontoindex = aw.fujipid.PXGconversiontoindex
                thermotypes = aw.fujipid.PXGthermotypes
            elif aw.ser.controlETpid[0] == 1:
                reg_dict = aw.fujipid.PXR
                conversiontoindex = aw.fujipid.PXRconversiontoindex
                thermotypes = aw.fujipid.PXRthermotypes
            else:
                reg_dict = aw.fujipid.PXF
                conversiontoindex = aw.fujipid.PXFconversiontoindex
                thermotypes = aw.fujipid.PXFthermotypes
        else: # "BT"
            unitID = aw.ser.readBTpid[1]
            if aw.ser.readBTpid[0] == 0:
                reg_dict = aw.fujipid.PXG4
                conversiontoindex = aw.fujipid.PXGconversiontoindex
                thermotypes = aw.fujipid.PXGthermotypes
            elif aw.ser.readBTpid[0] == 1:
                reg_dict = aw.fujipid.PXR
                conversiontoindex = aw.fujipid.PXRconversiontoindex
                thermotypes = aw.fujipid.PXRthermotypes
            else:
                reg_dict = aw.fujipid.PXF
                conversiontoindex = aw.fujipid.PXFconversiontoindex
                thermotypes = aw.fujipid.PXFthermotypes
        command = ""
        message = "empty"
        reg = None
        Thtype = None
        try:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict["pvinputtype"][1],3)
                if reg:
                    Thtype = aw.modbus.readSingleRegister(unitID,reg,3)
            else:
                command = aw.fujipid.message2send(unitID,3,reg_dict["pvinputtype"][1],1)
                if command:
                    Thtype = aw.fujipid.readoneword(command)
            if Thtype is not None:
                if PID == "ET":
                    if Thtype in conversiontoindex:
                        reg_dict["pvinputtype"][0] = Thtype
                        self.ETthermocombobox.setCurrentIndex(conversiontoindex.index(Thtype))
                        message = "ET type %i: %s"%(Thtype,thermotypes[conversiontoindex.index(Thtype)])
                    else:
                        message = "ERR"
                elif PID == "BT":
                    if Thtype in conversiontoindex:
                        reg_dict["pvinputtype"][0] = Thtype
                        message = "BT type %i: %s"%(Thtype,thermotypes[conversiontoindex.index(Thtype)])
                        self.BTthermocombobox.setCurrentIndex(conversiontoindex.index(Thtype))
                self.status.showMessage(message,5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " readthermocoupletype(): {0}").format(str(e)),exc_tb.tb_lineno)



#########################################################################
######################## FUJI PXR CONTROL DIALOG  #######################
#########################################################################

class PXRpidDlgControl(PXpidDlgControl):
    def __init__(self, parent = None):
        super(PXRpidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXR PID Control",None))
        #create Ramp Soak control button colums
        self.labelrs1 = QLabel()
        self.labelrs1.setContentsMargins(5,5,5,5)
        self.labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<BR>(1-4)",None) + "</b></font>")
        self.labelrs2 = QLabel()
        self.labelrs2.setContentsMargins(5,5,5,5)
        self.labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        self.labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak HH:MM<BR>(5-8)",None) + "</b></font>")
        labelpattern = QLabel(QApplication.translate("Label", "Ramp/Soak Pattern",None))
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8"])
        self.patternComboBox.setCurrentIndex(aw.fujipid.PXR["rampsoakpattern"][0])
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None),5000)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.paintlabels()
        #update button and exit button
        button_getall = QPushButton(QApplication.translate("Button","Read Ra/So values",None))
        button_getall.setFocusPolicy(Qt.NoFocus)
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None))
        button_rson.setFocusPolicy(Qt.NoFocus)
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None))
        button_rsoff.setFocusPolicy(Qt.NoFocus)
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None))
        button_standbyON.setFocusPolicy(Qt.NoFocus)
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None))
        button_standbyOFF.setFocusPolicy(Qt.NoFocus)

        button_exit = QPushButton(QApplication.translate("Button","OK",None))
        button_exit.setFocus()

        self.patternComboBox.currentIndexChanged.connect(self.paintlabels)
        button_getall.clicked.connect(self.getallsegments)
        button_rson.clicked.connect(self.setONrampsoak)
        button_rsoff.clicked.connect(self.setOFFrampsoak)
        button_standbyON.clicked.connect(self.setONstandby)
        button_standbyOFF.clicked.connect(self.setOFFstandby)
        button_exit.clicked.connect(self.reject)
        #TAB 2
        tab2svbutton = QPushButton(QApplication.translate("Button","Write SV",None))
        tab2svbutton.setFocusPolicy(Qt.NoFocus)
        
        self.tab2easySVbuttonsFlag = QCheckBox(QApplication.translate("Label","SV Buttons",None))
        self.tab2easySVbuttonsFlag.setChecked(aw.pidcontrol.svButtons)
        self.tab2easySVbuttonsFlag.stateChanged.connect(self.setSVbuttons)
        self.tab2easySVsliderFlag = QCheckBox(QApplication.translate("Label","SV Slider",None))
        self.tab2easySVsliderFlag.setChecked(aw.pidcontrol.svSlider)
        self.tab2easySVsliderFlag.stateChanged.connect(self.setSVsliderSlot)
        
        
        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV",None))
        tab2getsvbutton.setFocusPolicy(Qt.NoFocus)
        self.readsvedit = QLineEdit()
        tab2svbutton.clicked.connect(self.setsv)
        tab2getsvbutton.clicked.connect(self.getsv)
        svwarning1 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None) + "</b><br>"
                            + QApplication.translate("Label", "Writing eeprom memory",None) + "<br>"
                            + QApplication.translate("Label", "<u>Max life</u> 10,000 writes",None) + "<br>"
                            + QApplication.translate("Label", "Infinite read life.",None) + "</CENTER>")
        svwarning2 = QLabel("<CENTER><b>" + QApplication.translate("Label", "WARNING",None) + "</b><br>"
                            + QApplication.translate("Label", "After <u>writing</u> an adjustment,<br>never power down the pid<br>for the next 5 seconds <br>or the pid may never recover.",None) + "<br>"
                            + QApplication.translate("Label", "Read operations manual",None) + "</CENTER>")
        self.svedit = QLineEdit()
        self.svedit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.svedit))
        #TAB 3
        button_p = QPushButton(QApplication.translate("Button","Set p",None))
        button_p.setFocusPolicy(Qt.NoFocus)
        button_i = QPushButton(QApplication.translate("Button","Set i",None))
        button_i.setFocusPolicy(Qt.NoFocus)
        button_d = QPushButton(QApplication.translate("Button","Set d",None))
        button_d.setFocusPolicy(Qt.NoFocus)
        plabel =  QLabel("p")
        ilabel =  QLabel("i")
        dlabel =  QLabel("d")
        self.pedit = QLineEdit(str(aw.fujipid.PXR["p"][0]))
        self.iedit = QLineEdit(str(aw.fujipid.PXR["i"][0]))
        self.dedit = QLineEdit(str(aw.fujipid.PXR["d"][0]))
        self.pedit.setMaximumWidth(60)
        self.iedit.setMaximumWidth(60)
        self.dedit.setMaximumWidth(60)
        self.pedit.setValidator(QIntValidator(0., 999, self.pedit))
        self.iedit.setValidator(QIntValidator(0, 3200, self.iedit))
        self.dedit.setValidator(QIntValidator(0., 999, self.dedit))
        button_autotuneON = QPushButton(QApplication.translate("Button","Autotune ON",None))
        button_autotuneON.setFocusPolicy(Qt.NoFocus)
        button_autotuneOFF = QPushButton(QApplication.translate("Button","Autotune OFF",None))
        button_autotuneOFF.setFocusPolicy(Qt.NoFocus)
        button_readpid = QPushButton(QApplication.translate("Button","Read PID Values",None))
        button_readpid.setFocusPolicy(Qt.NoFocus)
        button_autotuneON.clicked.connect(self.setONautotune)
        button_autotuneOFF.clicked.connect(self.setOFFautotune)
        button_p.clicked.connect(self.setpid_p)
        button_i.clicked.connect(self.setpid_i)
        button_d.clicked.connect(self.setpid_d)
        button_readpid.clicked.connect(self.getpid)
        #TAB4
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan settings",None))
        self.ETthermocombobox = QComboBox()
        self.BTthermocombobox = QComboBox()
        #self.BTthermocombobox.setStyleSheet("background-color:'lightgrey';")
        self.ETthermocombobox.addItems(aw.fujipid.PXRthermotypes)
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(aw.fujipid.PXGthermotypes)
        elif aw.ser.readBTpid[0] == 1:      #fuji PXR
            self.BTthermocombobox.addItems(aw.fujipid.PXRthermotypes)
        else: # fuji PXF
            self.BTthermocombobox.addItems(aw.fujipid.PXFthermotypes)
        if aw.fujipid.PXR["pvinputtype"][0] in aw.fujipid.PXRconversiontoindex:
            self.ETthermocombobox.setCurrentIndex(aw.fujipid.PXRconversiontoindex.index(aw.fujipid.PXR["pvinputtype"][0]))
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None))
        setETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None))
        setBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None))
        getETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None))
        getBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        setETthermocouplebutton.clicked.connect(self.setthermocoupletypeET)
        setBTthermocouplebutton.clicked.connect(self.setthermocoupletypeBT)
        getETthermocouplebutton.clicked.connect(self.readthermocoupletypeET)
        getBTthermocouplebutton.clicked.connect(self.readthermocoupletypeBT)
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None))
        PointButtonET.setFocusPolicy(Qt.NoFocus)
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None))
        PointButtonBT.setFocusPolicy(Qt.NoFocus)
        PointButtonET.setMaximumWidth(250)
        PointButtonBT.setMaximumWidth(250)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None))
        PointButtonET.clicked.connect(self.setpointET)
        PointButtonBT.clicked.connect(self.setpointBT)
        
                
        # Follow Background 
        self.followBackground = QCheckBox(QApplication.translate("CheckBox", "Follow Background",None))
        self.followBackground.setChecked(aw.fujipid.followBackground)
        self.followBackground.setFocusPolicy(Qt.NoFocus)
        self.followBackground.stateChanged.connect(self.changeFollowBackground)         #toggle
        # Follow Background Lookahead
        self.pidSVLookahead = QSpinBox()
        self.pidSVLookahead.setAlignment(Qt.AlignRight)
        self.pidSVLookahead.setRange(0,999)
        self.pidSVLookahead.setSingleStep(1)
        self.pidSVLookahead.setValue(aw.fujipid.lookahead)  
        self.pidSVLookahead.setSuffix(" s")
        self.pidSVLookahead.setFocusPolicy(Qt.NoFocus)
        self.pidSVLookahead.valueChanged.connect(self.changeLookAhead)
        pidSVLookaheadLabel = QLabel(QApplication.translate("Label","Lookahead",None))  
        followLayout = QHBoxLayout()
        followLayout.addStretch()
        followLayout.addWidget(pidSVLookaheadLabel)
        followLayout.addWidget(self.pidSVLookahead)
        followLayout.addStretch() 
        
        
        #create layouts
        buttonMasterLayout = QGridLayout()
        buttonRampSoakLayout1 = QVBoxLayout()
        buttonRampSoakLayout2 = QVBoxLayout()
        tab3layout = QGridLayout()
        svlayout = QGridLayout()
        #place rs buttoms in RampSoakLayout1
        buttonRampSoakLayout1.addWidget(self.labelrs1,0)
        buttonRampSoakLayout1.addWidget(self.label_rs1,1)
        buttonRampSoakLayout1.addWidget(self.label_rs2,2)
        buttonRampSoakLayout1.addWidget(self.label_rs3,3)
        buttonRampSoakLayout1.addWidget(self.label_rs4,4)
        buttonRampSoakLayout2.addWidget(self.labelrs2,0)
        buttonRampSoakLayout2.addWidget(self.label_rs5,1)
        buttonRampSoakLayout2.addWidget(self.label_rs6,2)
        buttonRampSoakLayout2.addWidget(self.label_rs7,3)
        buttonRampSoakLayout2.addWidget(self.label_rs8,4)
        buttonMasterLayout.addLayout(buttonRampSoakLayout1,0,0)
        buttonMasterLayout.addLayout(buttonRampSoakLayout2,0,1)
        buttonMasterLayout.addWidget(labelpattern,1,0)
        buttonMasterLayout.addWidget(self.patternComboBox,1,1)
        buttonMasterLayout.addWidget(button_rson,2,0)
        buttonMasterLayout.addWidget(button_rsoff,2,1)
        buttonMasterLayout.addWidget(button_autotuneOFF,3,1)
        buttonMasterLayout.addWidget(button_autotuneON,3,0)
        buttonMasterLayout.addWidget(button_standbyOFF,4,0)
        buttonMasterLayout.addWidget(button_standbyON,4,1)
        buttonMasterLayout.addWidget(self.followBackground,5,0)
        buttonMasterLayout.addLayout(followLayout,5,1)
        buttonMasterLayout.addWidget(button_getall,6,0)

        ############################
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addStretch()
        buttonLayout.addWidget(button_exit)
        
                
        #tab 2
        svlayout.addWidget(svwarning2,0,0)
        svlayout.addWidget(svwarning1,0,1)
        svlayout.addWidget(self.readsvedit,1,0)
        svlayout.addWidget(tab2getsvbutton,1,1)
        svlayout.addWidget(self.svedit,2,0)
        svlayout.addWidget(tab2svbutton,2,1)
        svlayout.addWidget(self.tab2easySVbuttonsFlag,3,0)
        svlayout.addWidget(self.tab2easySVsliderFlag,3,1)
        #tab 3
        tab3layout.addWidget(plabel,0,0)
        tab3layout.addWidget(self.pedit,0,1)
        tab3layout.addWidget(button_p,0,2)
        tab3layout.addWidget(ilabel,1,0)
        tab3layout.addWidget(self.iedit,1,1)
        tab3layout.addWidget(button_i,1,2)
        tab3layout.addWidget(dlabel,2,0)
        tab3layout.addWidget(self.dedit,2,1)
        tab3layout.addWidget(button_d,2,2)
        tab3layout.addWidget(button_autotuneON,3,1)
        tab3layout.addWidget(button_autotuneOFF,3,2)
        tab3layout.addWidget(button_readpid,4,1)
        #tab4
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        
        #tab5
        thermolayoutET = QHBoxLayout()
        thermolayoutET.addWidget(self.ETthermocombobox)
        thermolayoutET.addStretch()
        thermolayoutET.addWidget(getETthermocouplebutton)
        thermolayoutET.addWidget(setETthermocouplebutton)
        ETGroupBox = QGroupBox(QApplication.translate("Label","ET Thermocouple type",None))
        ETGroupBox.setLayout(thermolayoutET)
        thermolayoutBT = QHBoxLayout()
        thermolayoutBT.addWidget(self.BTthermocombobox)
        thermolayoutBT.addStretch()
        thermolayoutBT.addWidget(getBTthermocouplebutton)
        thermolayoutBT.addWidget(setBTthermocouplebutton)
        BTGroupBox = QGroupBox(QApplication.translate("Label","BT Thermocouple type",None))
        BTGroupBox.setLayout(thermolayoutBT)
        tab5Layout = QVBoxLayout()
        tab5Layout.addWidget(ETGroupBox)
        tab5Layout.addWidget(BTGroupBox)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        ###################################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(buttonMasterLayout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None))
        C2Widget = QWidget()
        C2Widget.setLayout(svlayout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None))
        tab3Hlayout = QHBoxLayout()
        tab3Hlayout.addStretch()
        tab3Hlayout.addLayout(tab3layout)
        tab3Hlayout.addStretch()
        tab3Vlayout = QVBoxLayout()
        tab3Vlayout.addStretch()
        tab3Vlayout.addLayout(tab3Hlayout)
        tab3Vlayout.addStretch()
        C3Widget = QWidget()        
        C3Widget.setLayout(tab3Vlayout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None))
        #incorporate layouts
        Mlayout = QVBoxLayout()
        Mlayout.addWidget(self.status,0)
        Mlayout.addWidget(TabWidget,1)
        Mlayout.addLayout(buttonLayout,2)
        self.setLayout(Mlayout)
    
    @pyqtSlot(int)
    def setSVbuttons(self,flag):
        aw.pidcontrol.svButtons = bool(flag)
    
    @pyqtSlot(int)
    def setSVsliderSlot(self,flag):
        self.setSVslider(flag)
        aw.pidcontrol.activateSVSlider(flag)

    def setSVslider(self,flag):
        aw.pidcontrol.svSlider = bool(flag)

    @pyqtSlot(int)
    def changeLookAhead(self,_):
        aw.fujipid.lookahead = int(self.pidSVLookahead.value())     
    
    @pyqtSlot(int)
    def changeFollowBackground(self,_):
        aw.fujipid.followBackground = not aw.fujipid.followBackground

    @pyqtSlot(int)
    def paintlabels(self,_=0):
        str1 = "T = " + str(aw.fujipid.PXR["segment1sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment1soak"][0]))
        str2 = "T = " + str(aw.fujipid.PXR["segment2sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment2soak"][0]))
        str3 = "T = " + str(aw.fujipid.PXR["segment3sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment3soak"][0]))
        str4 = "T = " + str(aw.fujipid.PXR["segment4sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment4soak"][0]))
        str5 = "T = " + str(aw.fujipid.PXR["segment5sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment5soak"][0]))
        str6 = "T = " + str(aw.fujipid.PXR["segment6sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment6soak"][0]))
        str7 = "T = " + str(aw.fujipid.PXR["segment7sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment7soak"][0]))
        str8 = "T = " + str(aw.fujipid.PXR["segment8sv"][0]) + ", Ramp = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8ramp"][0])) + ", Soak = " + str(aw.qmc.stringfromseconds(aw.fujipid.PXR["segment8soak"][0]))
        self.label_rs1.setText(u(str1))
        self.label_rs2.setText(u(str2))
        self.label_rs3.setText(u(str3))
        self.label_rs4.setText(u(str4))
        self.label_rs5.setText(u(str5))
        self.label_rs6.setText(u(str6))
        self.label_rs7.setText(u(str7))
        self.label_rs8.setText(u(str8))
        pattern = [[1,1,1,1,0,0,0,0],
                  [0,0,0,0,1,1,1,1],
                  [1,1,1,1,1,1,1,1]]
        aw.fujipid.PXR["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]:   
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][2]:   
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][3]:   
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][4]:   
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][5]:   
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][6]:   
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXR["rampsoakpattern"][0]][7]:   
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")

    @pyqtSlot(bool)
    def setONautotune(self,_):
        self.setONOFFautotune(1)
    
    @pyqtSlot(bool)
    def setOFFautotune(self,_):
        self.setONOFFautotune(0)
    
    def setONOFFautotune(self,flag):
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None),500)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["autotuning"][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["autotuning"][1],flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
        if len(r) == 8:
            if flag == 0:
                aw.fujipid.PXR["autotuning"][0] = 0
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None),5000)
            if flag == 1:
                aw.fujipid.PXR["autotuning"][0] = 1
                self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None),5000)
        else:
            mssg = QApplication.translate("Error Message","Exception:",None) + " setONOFFautotune()"
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None) + " setONOFFautotune()")

    @pyqtSlot(bool)
    def setONstandby(self,_):
        self.setONOFFstandby(1)
    
    @pyqtSlot(bool)
    def setOFFstandby(self,_):
        self.setONOFFstandby(0)

    def setONOFFstandby(self,flag):
        try:
            #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
            #flag = 0 standby OFF, flag = 1 standby ON (pid off)
            self.status.showMessage(QApplication.translate("StatusBar","wait...",None),500)
            res = aw.fujipid.setONOFFstandby(flag)
            if res:
                if flag == 1:
                    message = QApplication.translate("StatusBar","PID OFF",None)     #put pid in standby 1 (pid off)
                else:
                    message = QApplication.translate("StatusBar","PID ON",None)      #put pid in standby 0 (pid on)
                self.status.showMessage(message,5000)
            else:
                mssg = QApplication.translate("Error Message","Exception:",None) + " setONOFFstandby()"
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " setONOFFstandby() {0}").format(str(e)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def setsv(self,_):
        self.svedit.setText(aw.comma2dot(str(self.svedit.text())))
        if self.svedit.text() != "":
            newSVvalue = int(float(self.svedit.text())*10) #multiply by 10 because of decimal point
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["sv0"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newSVvalue)
                message = QApplication.translate("StatusBar","SV successfully set to {0}",None).format(self.svedit.text())
                aw.fujipid.PXR["sv0"][0] = float(str(self.svedit.text()))
                self.status.showMessage(message,5000)
                #record command as an Event 
                strcommand = "SETSV::"+ str("%.1f"%(newSVvalue/10.))
                aw.qmc.DeviceEventRecord(strcommand)
            else:          
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],newSVvalue)
                r = aw.ser.sendFUJIcommand(command,8)
                if r == command:
                    message = QApplication.translate("StatusBar","SV successfully set to {0}",None).format(self.svedit.text())
                    aw.fujipid.PXR["sv0"][0] = float(str(self.svedit.text()))
                    self.status.showMessage(message,5000)
                    #record command as an Event 
                    strcommand = "SETSV::"+ str("%.1f"%(newSVvalue/10.))
                    aw.qmc.DeviceEventRecord(strcommand)
                else:
                    mssg = QApplication.translate("Error Message","Exception:",None) + " setsv()"
                    self.status.showMessage(mssg,5000)
                    aw.qmc.adderror(mssg)
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Empty SV box",None),5000)
            
    @pyqtSlot(bool)
    def getsv(self,_):
        temp = aw.fujipid.readcurrentsv()
        if temp != -1:
            aw.fujipid.PXR["sv0"][0] =  temp
            aw.lcd6.display(aw.fujipid.PXR["sv0"][0])
            self.readsvedit.setText(str(aw.fujipid.PXR["sv0"][0]))
        else:
            self.status.showMessage(QApplication.translate("StatusBar","Unable to read SV",None),5000)

    def checkrampsoakmode(self):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["rampsoakmode"][1],3)
            currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["rampsoakmode"][1],1)
            currentmode = aw.fujipid.readoneword(msg)
        aw.fujipid.PXR["rampsoakmode"][0] = currentmode
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        else:
            return -1
        string =  QApplication.translate("Message","The rampsoak-mode tells how to start and end the ramp/soak",None) + "\n\n"
        string += QApplication.translate("Message","Your rampsoak mode in this pid is:",None) + "\n\n"
        string += QApplication.translate("Message","Mode = {0}",None).format(mode[0]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Start to run from PV value: {0}",None).format(mode[1]) + "\n"
        string += QApplication.translate("Message","End output status at the end of ramp/soak: {0}",None).format(mode[2]) + "\n"
        string += QApplication.translate("Message","Output status while ramp/soak operation set to OFF: {0}",None).format(mode[3]) + "\n"
        string += QApplication.translate("Message","\nRepeat Operation at the end: {0}",None).format(mode[4]) + "\n"
        string += "-----------------------------------------------------------------------\n"
        string += QApplication.translate("Message","Recomended Mode = 0",None) + "\n\n"
        string += QApplication.translate("Message","If you need to change it, change it now and come back later",None) + "\n"
        string += QApplication.translate("Message","Use the Parameter Loader Software by Fuji if you need to\n\n",None) + "\n\n\n"
        string += QApplication.translate("Message","Continue?",None)
        reply = QMessageBox.question(aw,QApplication.translate("Message","Ramp Soak start-end mode",None),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            return 0
        elif reply == QMessageBox.Yes:
            return 1

    @pyqtSlot(bool)
    def setONrampsoak(self,_):
        self.setONOFFrampsoak(1)
    
    @pyqtSlot(bool)
    def setOFFrampsoak(self,_):
        self.setONOFFrampsoak(0)
    
    def setONOFFrampsoak(self,flag):
        #flag =0 OFF, flag = 1 ON, flag = 2 hold
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None), 5000)
            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None),500)
            #0 = 1-4
            #1 = 5-8
            #2 = 1-8
            selectedmode = self.patternComboBox.currentIndex()
            currentmode = aw.fujipid.getrampsoakmode()           
            if currentmode != -1:
                aw.fujipid.PXR["rampsoakpattern"][0] = currentmode
                if currentmode != selectedmode:
                    #set mode in pid to match the mode selected in the combobox
                    self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None),1000)
                    res = aw.fujipid.setrampsoakmode(selectedmode)
                    if res:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None), 500)
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None), 5000)
                        return
                #combobox mode matches pid mode
                #set ramp soak mode ON/OFF
                res = aw.fujipid.setrampsoak(flag)
                if res:
                    #record command as an Event if flag = 1
                    self.status.showMessage(QApplication.translate("StatusBar","RS ON",None), 5000)
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    pattern =[[1,4],[5,8],[1,8]]
                    start = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][0]
                    end = pattern[aw.fujipid.PXR["rampsoakpattern"][0]][1]+1
                    strcommand = "SETRS"
                    result = ""
                    for i in range(start,end):
                        svkey = "segment"+str(i)+"sv"
                        rampkey = "segment"+str(i)+"ramp"
                        soakkey = "segment"+str(i)+"soak"
                        strcommand += "::" + str(aw.fujipid.PXR[svkey][0]) + "::" + str(aw.fujipid.PXR[rampkey][0]) + "::" + str(aw.fujipid.PXR[soakkey][0])+"::"
                        result += strcommand
                        strcommand = "SETRS"
                    result = result.strip("::")
                    aw.qmc.DeviceEventRecord(result)
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None), 5000)
            else:
                mssg = QApplication.translate("Error Message","Exception:",None) + " setONOFFrampsoak()"
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None),500)
            aw.fujipid.setrampsoak(flag)

    #get all Ramp Soak values for all 8 segments
    @pyqtSlot(bool)
    def getallsegments(self,_):
        for i in range(8):
            msg = QApplication.translate("StatusBar","Reading Ramp/Soak {0} ...",None).format(str(i+1))
            self.status.showMessage(msg,500)
            k = aw.fujipid.getsegment(i+1)
            libtime.sleep(0.03)
            if k == -1:
                self.status.showMessage(QApplication.translate("StatusBar","problem reading Ramp/Soak",None),5000)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None),5000)
        self.createsegmenttable()

    @pyqtSlot(bool)
    def getpid(self,_):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["p"][1],3)
            p = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:    
            pcommand= aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["p"][1],1)
            p = aw.fujipid.readoneword(pcommand)/10.
        if p == -1 :
            return -1
        else:
            self.pedit.setText(str(int(p)))
            aw.fujipid.PXR["p"][0] = p
        #i is int range 0-3200
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["i"][1],3)
            i = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:
            icommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["i"][1],1)
            i = aw.fujipid.readoneword(icommand)/10.
        if i == -1:
            return -1
        else:
            self.iedit.setText(str(int(i)))
            aw.fujipid.PXR["i"][0] = i
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXR["d"][1],3)
            d = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
        else:
            dcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXR["d"][1],1)
            d = aw.fujipid.readoneword(dcommand)/10.
        if d == -1:
            return -1
        else:
            self.dedit.setText(str(int(d)))
            aw.fujipid.PXR["d"][0] = d
            
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading pid values",None),5000)

    @pyqtSlot(bool)
    def setpid_p(self,_):
        if str(self.pedit.text()).isdigit():
            p = int(str(self.pedit.text()))
            aw.fujipid.setpidPXR("p",p)
    
    @pyqtSlot(bool)
    def setpid_i(self,_):
        if str(self.iedit.text()).isdigit():
            i = int(str(self.iedit.text()))
            aw.fujipid.setpidPXR("i",i)
    
    @pyqtSlot(bool)
    def setpid_d(self,_):
        if str(self.dedit.text()).isdigit():
            d = int(str(self.dedit.text()))
            aw.fujipid.setpidPXR("d",d)

    def createsegmenttable(self):
        self.segmenttable.setRowCount(8)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("Table","SV",None),
                                                     QApplication.translate("Table","Ramp HH:MM",None),
                                                     QApplication.translate("Table","Soak HH:MM",None),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        self.segmenttable.verticalHeader().setSectionResizeMode(2)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(8):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            
            svedit = QLineEdit(str(aw.fujipid.PXR[svkey][0]))
            svedit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXR[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))
            setButton = QPushButton(QApplication.translate("Button","Set",None))
            setButton.clicked.connect(self.setsegment)
            setButton.setFocusPolicy(Qt.NoFocus)
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    @pyqtSlot(bool)
    def setsegment(self,_):
        i = aw.findWidgetsRow(self.segmenttable,self.sender(),3)
        if i is not None:
            idn = i+1
            svedit =  self.segmenttable.cellWidget(i,0)
            rampedit = self.segmenttable.cellWidget(i,1)
            soakedit = self.segmenttable.cellWidget(i,2)
            sv = float(aw.comma2dot(str(svedit.text())))
            ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
            soak = aw.qmc.stringtoseconds(str(soakedit.text()))
            svkey = "segment" + str(idn) + "sv"
            rampkey = "segment" + str(idn) + "ramp"
            soakkey = "segment" + str(idn) + "soak"
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR[svkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(sv*10))
                libtime.sleep(0.1) #important time between writings
                reg = aw.modbus.address2register(aw.fujipid.PXR[rampkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,ramp)
                libtime.sleep(0.1) #important time between writings
                reg = aw.modbus.address2register(aw.fujipid.PXR[soakkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,soak)
                r1 = r2 = r3 = "        "
            else:
                svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[svkey][1],int(sv*10))
                r1 = aw.ser.sendFUJIcommand(svcommand,8)
                libtime.sleep(0.1) #important time between writings
                rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[rampkey][1],ramp)
                r2 = aw.ser.sendFUJIcommand(rampcommand,8)
                libtime.sleep(0.1) #important time between writings
                soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR[soakkey][1],soak)
                r3 = aw.ser.sendFUJIcommand(soakcommand,8)
            #check if OK
            if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
                aw.fujipid.PXR[svkey][0] = sv
                aw.fujipid.PXR[rampkey][0] = ramp
                aw.fujipid.PXR[soakkey][0] = soak
                self.paintlabels()
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully written",None),5000) 
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None))


        
############################################################################
######################## FUJI PXG4 PID CONTROL DIALOG ######################
############################################################################

class PXG4pidDlgControl(PXpidDlgControl):
    def __init__(self, parent = None):
        super(PXG4pidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        if aw.ser.controlETpid[0] == 0:
            self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXG PID Control",None))
        else:
            self.setWindowTitle(QApplication.translate("Form Caption","Fuji PXF PID Control",None))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Ready",None),5000)
        #*************    TAB 1 WIDGETS
        labelrs1 = QLabel()
        labelrs1.setContentsMargins(5,5,5,5)
        labelrs1.setStyleSheet("background-color:'#CCCCCC';")
        labelrs1.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(1-7)",None) + "</b></font>")
        #labelrs1.setMaximumSize(90, 42)
        #labelrs1.setMinimumHeight(50)
        labelrs2 = QLabel()
        labelrs2.setContentsMargins(5,5,5,5)
        labelrs2.setStyleSheet("background-color:'#CCCCCC';")
        labelrs2.setText("<font color='white'><b>" + QApplication.translate("Label", "Ramp Soak (MM:SS)<br>(8-16)",None) + "</b></font>")
        #labelrs2.setMaximumSize(90, 42)
        #labelrs2.setMinimumHeight(50)
        self.label_rs1 =  QLabel()
        self.label_rs2 =  QLabel()
        self.label_rs3 =  QLabel()
        self.label_rs4 =  QLabel()
        self.label_rs5 =  QLabel()
        self.label_rs6 =  QLabel()
        self.label_rs7 =  QLabel()
        self.label_rs8 =  QLabel()
        self.label_rs9 =  QLabel()
        self.label_rs10 =  QLabel()
        self.label_rs11 =  QLabel()
        self.label_rs12 =  QLabel()
        self.label_rs13 =  QLabel()
        self.label_rs14 =  QLabel()
        self.label_rs15 =  QLabel()
        self.label_rs16 =  QLabel()
        self.label_rs1.setMinimumWidth(170)
        self.label_rs2.setMinimumWidth(170)
        self.label_rs3.setMinimumWidth(170)
        self.label_rs4.setMinimumWidth(170)
        self.label_rs5.setMinimumWidth(170)
        self.label_rs6.setMinimumWidth(170)
        self.label_rs7.setMinimumWidth(170)
        self.label_rs8.setMinimumWidth(170)
        self.label_rs9.setMinimumWidth(170)
        self.label_rs10.setMinimumWidth(170)
        self.label_rs11.setMinimumWidth(170)
        self.label_rs12.setMinimumWidth(170)
        self.label_rs13.setMinimumWidth(170)
        self.label_rs14.setMinimumWidth(170)
        self.label_rs15.setMinimumWidth(170)
        self.label_rs16.setMinimumWidth(170)
        self.patternComboBox =  QComboBox()
        self.patternComboBox.addItems(["1-4","5-8","1-8","9-12","13-16","9-16","1-16"])
        if aw.ser.controlETpid[0] == 0:
            self.patternComboBox.setCurrentIndex(aw.fujipid.PXG4["rampsoakpattern"][0])
        else:
            self.patternComboBox.setCurrentIndex(aw.fujipid.PXF["rampsoakpattern"][0])
        self.patternComboBox.setFocusPolicy(Qt.NoFocus)
        self.patternComboBox.currentIndexChanged.connect(self.paintlabels)
        self.paintlabels()
        button_load = QPushButton(QApplication.translate("Button","Load",None))
        button_load.setFocusPolicy(Qt.NoFocus)
        button_save = QPushButton(QApplication.translate("Button","Save",None))
        button_save.setFocusPolicy(Qt.NoFocus)
        button_writeall = QPushButton(QApplication.translate("Button","Write All",None))
        button_writeall.setFocusPolicy(Qt.NoFocus)
        patternlabel = QLabel(QApplication.translate("Label","Pattern",None))
        patternlabel.setAlignment(Qt.AlignRight)
        button_getall = QPushButton(QApplication.translate("Button","Read RS values",None))
        button_getall.setFocusPolicy(Qt.NoFocus)
        button_writeallrs = QPushButton(QApplication.translate("Button","Write RS values",None))
        button_writeallrs.setFocusPolicy(Qt.NoFocus)
        button_rson =  QPushButton(QApplication.translate("Button","RampSoak ON",None)) 
        button_rson.setFocusPolicy(Qt.NoFocus)
        button_rsoff =  QPushButton(QApplication.translate("Button","RampSoak OFF",None))
        button_rsoff.setFocusPolicy(Qt.NoFocus)
        button_exit = QPushButton(QApplication.translate("Button","OK",None))
        button_standbyON = QPushButton(QApplication.translate("Button","PID OFF",None))
        button_standbyON.setFocusPolicy(Qt.NoFocus)
        button_standbyOFF = QPushButton(QApplication.translate("Button","PID ON",None))
        button_standbyOFF.setFocusPolicy(Qt.NoFocus)
        button_getall.clicked.connect(self.getallsegments)
        button_writeallrs.clicked.connect(self.writeRSValues)
        button_rson.clicked.connect(self.setONrampsoak)
        button_rsoff.clicked.connect(self.setOFFrampsoak)
        button_standbyON.clicked.connect(self.setONstandby)
        button_standbyOFF.clicked.connect(self.setOFFstandby)
        button_exit.clicked.connect(self.accept)
        button_load.clicked.connect(self.load)
        button_save.clicked.connect(self.save)
        button_writeall.clicked.connect(self.writeAll)

        #create layouts and place tab1 widgets inside 
        buttonRampSoakLayout1 = QVBoxLayout() #TAB1/COLUNM 1
        buttonRampSoakLayout1.setSpacing(10)
        buttonRampSoakLayout2 = QVBoxLayout() #TAB1/COLUMN 2
        buttonRampSoakLayout2.setSpacing(10)
        #place rs labels in RampSoakLayout1 #TAB1/COLUNM 1
        buttonRampSoakLayout1.addWidget(labelrs1)
        buttonRampSoakLayout1.addWidget(self.label_rs1)
        buttonRampSoakLayout1.addWidget(self.label_rs2)
        buttonRampSoakLayout1.addWidget(self.label_rs3)
        buttonRampSoakLayout1.addWidget(self.label_rs4)
        buttonRampSoakLayout1.addWidget(self.label_rs5)
        buttonRampSoakLayout1.addWidget(self.label_rs6)
        buttonRampSoakLayout1.addWidget(self.label_rs7)
        buttonRampSoakLayout1.addWidget(self.label_rs8)
        #place rs labels in RampSoakLayout2 #TAB1/COLUMN 2
        buttonRampSoakLayout2.addWidget(labelrs2)
        buttonRampSoakLayout2.addWidget(self.label_rs9)
        buttonRampSoakLayout2.addWidget(self.label_rs10)
        buttonRampSoakLayout2.addWidget(self.label_rs11)
        buttonRampSoakLayout2.addWidget(self.label_rs12)
        buttonRampSoakLayout2.addWidget(self.label_rs13)
        buttonRampSoakLayout2.addWidget(self.label_rs14)
        buttonRampSoakLayout2.addWidget(self.label_rs15)
        buttonRampSoakLayout2.addWidget(self.label_rs16)
        
        # Follow Background 
        self.followBackground = QCheckBox(QApplication.translate("CheckBox", "Follow Background",None))
        self.followBackground.setChecked(aw.fujipid.followBackground)
        self.followBackground.setFocusPolicy(Qt.NoFocus)
        self.followBackground.stateChanged.connect(self.changeFollowBackground)         #toggle
        # Follow Background Lookahead
        self.pidSVLookahead = QSpinBox()
        self.pidSVLookahead.setAlignment(Qt.AlignRight)
        self.pidSVLookahead.setRange(0,999)
        self.pidSVLookahead.setSingleStep(1)
        self.pidSVLookahead.setValue(aw.fujipid.lookahead)
        self.pidSVLookahead.setSuffix(" s")
        self.pidSVLookahead.setFocusPolicy(Qt.NoFocus)
        self.pidSVLookahead.valueChanged.connect(self.changeLookAhead)
        pidSVLookaheadLabel = QLabel(QApplication.translate("Label","Lookahead",None))
        
        # *************** TAB 2 WIDGETS
        labelsv = QLabel()
        labelsv.setContentsMargins(10,10,10,10)
        labelsv.setStyleSheet("background-color:'#CCCCCC';")
        labelsv.setText("<font color='white'><b>" + QApplication.translate("Label", "SV (7-0)",None) + "</b></font>")
        labelsv.setMaximumSize(100, 42)
        labelsv.setMinimumHeight(50)
        labelsvedit = QLabel()
        labelsvedit.setContentsMargins(10,10,10,10)
        labelsvedit.setStyleSheet("background-color:'#CCCCCC';")
        labelsvedit.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None) + "</b></font>")
        labelsvedit.setMaximumSize(100, 42)
        labelsvedit.setMinimumHeight(50)
        button_sv1 =QPushButton(QApplication.translate("Button","Write SV1",None))
        button_sv1.setFocusPolicy(Qt.NoFocus)
        button_sv2 =QPushButton(QApplication.translate("Button","Write SV2",None))
        button_sv2.setFocusPolicy(Qt.NoFocus)
        button_sv3 =QPushButton(QApplication.translate("Button","Write SV3",None))
        button_sv3.setFocusPolicy(Qt.NoFocus)
        button_sv4 =QPushButton(QApplication.translate("Button","Write SV4",None))
        button_sv4.setFocusPolicy(Qt.NoFocus)
        button_sv5 =QPushButton(QApplication.translate("Button","Write SV5",None))
        button_sv5.setFocusPolicy(Qt.NoFocus)
        button_sv6 =QPushButton(QApplication.translate("Button","Write SV6",None))
        button_sv6.setFocusPolicy(Qt.NoFocus)
        button_sv7 =QPushButton(QApplication.translate("Button","Write SV7",None))
        button_sv7.setFocusPolicy(Qt.NoFocus)
        button_sv1.clicked.connect(self.setsv1)
        button_sv2.clicked.connect(self.setsv2)
        button_sv3.clicked.connect(self.setsv3)
        button_sv4.clicked.connect(self.setsv4)
        button_sv5.clicked.connect(self.setsv5)
        button_sv6.clicked.connect(self.setsv6)
        button_sv7.clicked.connect(self.setsv7)
        self.sv1edit = QLineEdit(u(str(aw.fujipid.PXG4["sv1"][0])))
        self.sv2edit = QLineEdit(u(str(aw.fujipid.PXG4["sv2"][0])))
        self.sv3edit = QLineEdit(u(str(aw.fujipid.PXG4["sv3"][0])))
        self.sv4edit = QLineEdit(u(str(aw.fujipid.PXG4["sv4"][0])))
        self.sv5edit = QLineEdit(u(str(aw.fujipid.PXG4["sv5"][0])))
        self.sv6edit = QLineEdit(u(str(aw.fujipid.PXG4["sv6"][0])))
        self.sv7edit = QLineEdit(u(str(aw.fujipid.PXG4["sv7"][0])))
        self.sv1edit.setMaximumWidth(80)
        self.sv2edit.setMaximumWidth(80)
        self.sv3edit.setMaximumWidth(80)
        self.sv4edit.setMaximumWidth(80)
        self.sv5edit.setMaximumWidth(80)
        self.sv6edit.setMaximumWidth(80)
        self.sv7edit.setMaximumWidth(80)
        self.sv1edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv1edit))
        self.sv2edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv2edit))
        self.sv3edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv3edit))
        self.sv4edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv4edit))
        self.sv5edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv5edit))
        self.sv6edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv6edit))
        self.sv7edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.sv7edit))
        self.radiosv1 = QRadioButton()
        self.radiosv2 = QRadioButton()
        self.radiosv3 = QRadioButton()
        self.radiosv4 = QRadioButton()
        self.radiosv5 = QRadioButton()
        self.radiosv6 = QRadioButton()
        self.radiosv7 = QRadioButton()
        N = aw.fujipid.PXG4["selectsv"][0]
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        self.tab2easySVbuttonsFlag = QCheckBox(QApplication.translate("Label","SV Buttons",None))
        self.tab2easySVbuttonsFlag.setChecked(aw.pidcontrol.svButtons)
        self.tab2easySVbuttonsFlag.stateChanged.connect(self.setSVbuttons)
        self.tab2easySVsliderFlag = QCheckBox(QApplication.translate("Label","SV Slider",None))
        self.tab2easySVsliderFlag.setChecked(aw.pidcontrol.svSlider)
        self.tab2easySVsliderFlag.stateChanged.connect(self.setSVsliderSlot)
        self.pidSVSliderMin = QSpinBox()
        self.pidSVSliderMin.setAlignment(Qt.AlignRight)
        self.pidSVSliderMin.setRange(0,999)
        self.pidSVSliderMin.setSingleStep(10)
        self.pidSVSliderMin.setValue(aw.pidcontrol.svSliderMin)
        self.pidSVSliderMin.valueChanged.connect(self.sliderMinValueChangedSlot)
        pidSVSliderMinLabel = QLabel(QApplication.translate("Label","SV min",None))
        self.pidSVSliderMax = QSpinBox()
        self.pidSVSliderMax.setAlignment(Qt.AlignRight)
        self.pidSVSliderMax.setRange(0,999)
        self.pidSVSliderMax.setSingleStep(10)
        self.pidSVSliderMax.setValue(aw.pidcontrol.svSliderMax)
        self.pidSVSliderMax.valueChanged.connect(self.sliderMaxValueChangedSlot)
        pidSVSliderMaxLabel = QLabel(QApplication.translate("Label","SV max",None))
        if aw.qmc.mode == "F":
            self.pidSVSliderMin.setSuffix(" F")
            self.pidSVSliderMax.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.pidSVSliderMin.setSuffix(" C")
            self.pidSVSliderMax.setSuffix(" C")

        tab2getsvbutton = QPushButton(QApplication.translate("Button","Read SV (7-0)",None))
        tab2getsvbutton.setFocusPolicy(Qt.NoFocus)
        tab2putsvbutton = QPushButton(QApplication.translate("Button","Write SV (7-0)",None))
        tab2putsvbutton.setFocusPolicy(Qt.NoFocus)
        tab2getsvbutton.clicked.connect(self.getallsv)
        tab2putsvbutton.clicked.connect(self.writeSetValues)
        self.radiosv1.clicked.connect(self.setNsvSlot)
        self.radiosv2.clicked.connect(self.setNsvSlot)
        self.radiosv3.clicked.connect(self.setNsvSlot)
        self.radiosv4.clicked.connect(self.setNsvSlot)
        self.radiosv5.clicked.connect(self.setNsvSlot)
        self.radiosv6.clicked.connect(self.setNsvSlot)
        self.radiosv7.clicked.connect(self.setNsvSlot)
        #****************   TAB 3 WIDGETS
        plabel = QLabel()
        plabel.setContentsMargins(10,10,10,10)
        plabel.setStyleSheet("background-color:'#CCCCCC';")
        plabel.setText("<font color='white'><b>" + QApplication.translate("Label", "P",None) + "</b></font>")
        plabel.setMaximumSize(50, 42)
        plabel.setMinimumHeight(50)
        ilabel = QLabel()
        ilabel.setContentsMargins(10,10,10,10)
        ilabel.setStyleSheet("background-color:'#CCCCCC';")
        ilabel.setText("<font color='white'><b>" + QApplication.translate("Label", "I",None) + "</b></font>")
        ilabel.setMaximumSize(50, 42)
        ilabel.setMinimumHeight(50)
        dlabel = QLabel()
        dlabel.setContentsMargins(10,10,10,10)
        dlabel.setStyleSheet("background-color:'#CCCCCC';")
        dlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "D",None) + "</b></font>")
        dlabel.setMaximumSize(50, 42)
        dlabel.setMinimumHeight(50)
        wlabel = QLabel()
        wlabel.setContentsMargins(10,10,10,10)
        wlabel.setStyleSheet("background-color:'#CCCCCC';")
        wlabel.setText("<font color='white'><b>" + QApplication.translate("Label", "Write",None) + "</b></font>")
        wlabel.setMaximumSize(100, 42)
        wlabel.setMinimumHeight(50)
        self.p1edit =  QLineEdit(u(str(aw.fujipid.PXG4["p1"][0])))
        self.p2edit =  QLineEdit(u(str(aw.fujipid.PXG4["p2"][0])))
        self.p3edit =  QLineEdit(u(str(aw.fujipid.PXG4["p3"][0])))
        self.p4edit =  QLineEdit(u(str(aw.fujipid.PXG4["p4"][0])))
        self.p5edit =  QLineEdit(u(str(aw.fujipid.PXG4["p5"][0])))
        self.p6edit =  QLineEdit(u(str(aw.fujipid.PXG4["p6"][0])))
        self.p7edit =  QLineEdit(u(str(aw.fujipid.PXG4["p7"][0])))
        self.i1edit =  QLineEdit(u(str(aw.fujipid.PXG4["i1"][0])))
        self.i2edit =  QLineEdit(u(str(aw.fujipid.PXG4["i2"][0])))
        self.i3edit =  QLineEdit(u(str(aw.fujipid.PXG4["i3"][0])))
        self.i4edit =  QLineEdit(u(str(aw.fujipid.PXG4["i4"][0])))
        self.i5edit =  QLineEdit(u(str(aw.fujipid.PXG4["i5"][0])))
        self.i6edit =  QLineEdit(u(str(aw.fujipid.PXG4["i6"][0])))
        self.i7edit =  QLineEdit(u(str(aw.fujipid.PXG4["i7"][0])))
        self.d1edit =  QLineEdit(u(str(aw.fujipid.PXG4["d1"][0])))
        self.d2edit =  QLineEdit(u(str(aw.fujipid.PXG4["d2"][0])))
        self.d3edit =  QLineEdit(u(str(aw.fujipid.PXG4["d3"][0])))
        self.d4edit =  QLineEdit(u(str(aw.fujipid.PXG4["d4"][0])))
        self.d5edit =  QLineEdit(u(str(aw.fujipid.PXG4["d5"][0])))
        self.d6edit =  QLineEdit(u(str(aw.fujipid.PXG4["d6"][0])))
        self.d7edit =  QLineEdit(u(str(aw.fujipid.PXG4["d7"][0])))
        self.p1edit.setMaximumSize(50, 42)
        self.p2edit.setMaximumSize(50, 42)
        self.p3edit.setMaximumSize(50, 42)
        self.p4edit.setMaximumSize(50, 42)
        self.p5edit.setMaximumSize(50, 42)
        self.p6edit.setMaximumSize(50, 42)
        self.p7edit.setMaximumSize(50, 42)
        self.i1edit.setMaximumSize(50, 42)
        self.i2edit.setMaximumSize(50, 42)
        self.i3edit.setMaximumSize(50, 42)
        self.i4edit.setMaximumSize(50, 42)
        self.i5edit.setMaximumSize(50, 42)
        self.i6edit.setMaximumSize(50, 42)
        self.i7edit.setMaximumSize(50, 42)
        self.d1edit.setMaximumSize(50, 42)
        self.d2edit.setMaximumSize(50, 42)
        self.d3edit.setMaximumSize(50, 42)
        self.d4edit.setMaximumSize(50, 42)
        self.d5edit.setMaximumSize(50, 42)
        self.d6edit.setMaximumSize(50, 42)
        self.d7edit.setMaximumSize(50, 42)
        #p = 0-999.9
        self.p1edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p1edit))
        self.p2edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p2edit))
        self.p3edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p3edit))
        self.p4edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p4edit))
        self.p5edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p5edit))
        self.p6edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p6edit))
        self.p7edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.p7edit))
        #i are int 0-3200
        self.i1edit.setValidator(QIntValidator(0, 3200, self.i1edit))
        self.i2edit.setValidator(QIntValidator(0, 3200, self.i2edit))
        self.i3edit.setValidator(QIntValidator(0, 3200, self.i3edit))
        self.i4edit.setValidator(QIntValidator(0, 3200, self.i4edit))
        self.i5edit.setValidator(QIntValidator(0, 3200, self.i5edit))
        self.i6edit.setValidator(QIntValidator(0, 3200, self.i6edit))
        self.i7edit.setValidator(QIntValidator(0, 3200, self.i7edit))
        #d 0-999.9
        self.d1edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d1edit))
        self.d2edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d2edit))
        self.d3edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d3edit))
        self.d4edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d4edit))
        self.d5edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d5edit))
        self.d6edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d6edit))
        self.d7edit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, self.d7edit))
        self.pid1button = QPushButton(QApplication.translate("Button","pid 1",None))
        self.pid1button.setFocusPolicy(Qt.NoFocus)
        self.pid2button = QPushButton(QApplication.translate("Button","pid 2",None))
        self.pid2button.setFocusPolicy(Qt.NoFocus)
        self.pid3button = QPushButton(QApplication.translate("Button","pid 3",None))
        self.pid3button.setFocusPolicy(Qt.NoFocus)
        self.pid4button = QPushButton(QApplication.translate("Button","pid 4",None))
        self.pid4button.setFocusPolicy(Qt.NoFocus)
        self.pid5button = QPushButton(QApplication.translate("Button","pid 5",None))
        self.pid5button.setFocusPolicy(Qt.NoFocus)
        self.pid6button = QPushButton(QApplication.translate("Button","pid 6",None))
        self.pid6button.setFocusPolicy(Qt.NoFocus)
        self.pid7button = QPushButton(QApplication.translate("Button","pid 7",None))
        self.pid7button.setFocusPolicy(Qt.NoFocus)
        pidreadallbutton = QPushButton(QApplication.translate("Button","Read PIDs",None))
        pidreadallbutton.setFocusPolicy(Qt.NoFocus)
        pidwriteallbutton = QPushButton(QApplication.translate("Button","Write PIDs",None))
        pidwriteallbutton.setFocusPolicy(Qt.NoFocus)
        autotuneONbutton = QPushButton(QApplication.translate("Button","Autotune ON",None))
        autotuneONbutton.setFocusPolicy(Qt.NoFocus)
        autotuneOFFbutton = QPushButton(QApplication.translate("Button","Autotune OFF",None))
        autotuneOFFbutton.setFocusPolicy(Qt.NoFocus)
        cancel3button = QPushButton(QApplication.translate("Button","Cancel",None))
        cancel3button.setFocusPolicy(Qt.NoFocus)
        self.radiopid1 = QRadioButton()
        self.radiopid2 = QRadioButton()
        self.radiopid3 = QRadioButton()
        self.radiopid4 = QRadioButton()
        self.radiopid5 = QRadioButton()
        self.radiopid6 = QRadioButton()
        self.radiopid7 = QRadioButton()
        pidreadallbutton.clicked.connect(self.getallpid)
        pidwriteallbutton.clicked.connect(self.writePIDValues)
        self.radiopid1.clicked.connect(self.setNpidSlot)
        self.radiopid2.clicked.connect(self.setNpidSlot)
        self.radiopid3.clicked.connect(self.setNpidSlot)
        self.radiopid4.clicked.connect(self.setNpidSlot)
        self.radiopid5.clicked.connect(self.setNpidSlot)
        self.radiopid6.clicked.connect(self.setNpidSlot)
        self.radiopid7.clicked.connect(self.setNpidSlot)
        self.pid1button.clicked.connect(self.setpidSlot)
        self.pid2button.clicked.connect(self.setpidSlot)
        self.pid3button.clicked.connect(self.setpidSlot)
        self.pid4button.clicked.connect(self.setpidSlot)
        self.pid5button.clicked.connect(self.setpidSlot)
        self.pid6button.clicked.connect(self.setpidSlot)
        self.pid7button.clicked.connect(self.setpidSlot)
        cancel3button.clicked.connect(self.cancelAction)
        autotuneONbutton.clicked.connect(self.setONautotune)
        autotuneOFFbutton.clicked.connect(self.setOFFautotune)
        #****************************   TAB4 WIDGETS
        #table for setting segments
        self.segmenttable = QTableWidget()
        self.createsegmenttable()
        #****************************   TAB5 WIDGETS
        BTthermolabelnote = QLabel(QApplication.translate("Label","NOTE: BT Thermocouple type is not stored in the Artisan settings",None))
        self.ETthermocombobox = QComboBox()
        self.ETthermocombobox.setFocusPolicy(Qt.NoFocus)
        self.BTthermocombobox = QComboBox()
        self.BTthermocombobox.setFocusPolicy(Qt.NoFocus)
        if aw.ser.controlETpid[0] == 0: # PXG
            self.ETthermocombobox.addItems(aw.fujipid.PXGthermotypes)
            if aw.fujipid.PXG4["pvinputtype"][0] in aw.fujipid.PXGconversiontoindex:
                self.ETthermocombobox.setCurrentIndex(aw.fujipid.PXGconversiontoindex.index(aw.fujipid.PXG4["pvinputtype"][0]))
        else: # PXF
            self.ETthermocombobox.addItems(aw.fujipid.PXFthermotypes)
            if aw.fujipid.PXF["pvinputtype"][0] in aw.fujipid.PXFconversiontoindex:
                self.ETthermocombobox.setCurrentIndex(aw.fujipid.PXFconversiontoindex.index(aw.fujipid.PXF["pvinputtype"][0]))
        if aw.ser.readBTpid[0] == 0:        #fuji PXG
            self.BTthermocombobox.addItems(aw.fujipid.PXGthermotypes)
        elif aw.ser.readBTpid[0] == 1:      #fuji PXR
            self.BTthermocombobox.addItems(aw.fujipid.PXRthermotypes)
        else:      #fuji PXF
            self.BTthermocombobox.addItems(aw.fujipid.PXFthermotypes)
        setETthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None))
        setETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setBTthermocouplebutton = QPushButton(QApplication.translate("Button","Set",None))
        setBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getETthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None))
        getETthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        getBTthermocouplebutton = QPushButton(QApplication.translate("Button","Read",None))
        getBTthermocouplebutton.setFocusPolicy(Qt.NoFocus)
        setETthermocouplebutton.setMaximumWidth(80)
        getETthermocouplebutton.setMaximumWidth(80)
        setBTthermocouplebutton.setMaximumWidth(80)
        getBTthermocouplebutton.setMaximumWidth(80)
        setETthermocouplebutton.clicked.connect(self.setthermocoupletypeET)
        setBTthermocouplebutton.clicked.connect(self.setthermocoupletypeBT)
        getETthermocouplebutton.clicked.connect(self.readthermocoupletypeET)
        getBTthermocouplebutton.clicked.connect(self.readthermocoupletypeBT)
        PointButtonET = QPushButton(QApplication.translate("Button","Set ET PID to 1 decimal point",None))
        PointButtonET.setFocusPolicy(Qt.NoFocus)
        PointButtonBT = QPushButton(QApplication.translate("Button","Set BT PID to 1 decimal point",None))
        PointButtonBT.setFocusPolicy(Qt.NoFocus)
        timeunitsbutton = QPushButton(QApplication.translate("Button","Set ET PID to MM:SS time units",None))
        timeunitsbutton.setFocusPolicy(Qt.NoFocus)
        pointlabel = QLabel(QApplication.translate("Label","Artisan uses 1 decimal point",None))
        if aw.ser.controlETpid[0] == 0:
            timelabel = QLabel(QApplication.translate("Label","Artisan Fuji PXG uses MINUTES:SECONDS units in Ramp/Soaks",None))
        else:
            timelabel = QLabel(QApplication.translate("Label","Artisan Fuji PXF uses MINUTES:SECONDS units in Ramp/Soaks",None))
        PointButtonET.clicked.connect(self.setpointET)
        PointButtonBT.clicked.connect(self.setpointBT)
        timeunitsbutton.clicked.connect(self.settimeunits)
        # LAYOUTS
        tab1Layout = QGridLayout() #TAB1
        tab1Layout.setSpacing(10)
        tab1Layout.setSizeConstraint(2)
        tab1Layout.addLayout(buttonRampSoakLayout1,0,0)
        tab1Layout.addLayout(buttonRampSoakLayout2,0,1)
        tab1Layout.addWidget(button_rson,1,0)
        tab1Layout.addWidget(button_rsoff,1,1)
        tab1Layout.addWidget(button_standbyOFF,2,0)
        tab1Layout.addWidget(button_standbyON,2,1)
        tab1Layout.addWidget(patternlabel,3,0)
        tab1Layout.addWidget(self.patternComboBox,3,1)
        tab1Layout.addWidget(button_getall,4,0)
        tab1Layout.addWidget(button_writeallrs,4,1)
        tab2Layout = QGridLayout() #TAB2 
        tab2Layout.setSpacing(10)
        tab2Layout.setSizeConstraint(2)
        tab2Layout.addWidget(labelsv,0,0)
        tab2Layout.addWidget(labelsvedit,0,1)
        tab2Layout.addWidget(self.sv7edit,1,0)
        tab2Layout.addWidget(button_sv7,1,1)
        tab2Layout.addWidget(self.sv6edit,2,0)
        tab2Layout.addWidget(button_sv6,2,1)
        tab2Layout.addWidget(self.sv5edit,3,0)
        tab2Layout.addWidget(button_sv5,3,1)
        tab2Layout.addWidget(self.sv4edit,4,0)
        tab2Layout.addWidget(button_sv4,4,1)
        tab2Layout.addWidget(self.sv3edit,5,0)
        tab2Layout.addWidget(button_sv3,5,1)
        tab2Layout.addWidget(self.sv2edit,6,0)
        tab2Layout.addWidget(button_sv2,6,1)
        tab2Layout.addWidget(self.sv1edit,7,0)
        tab2Layout.addWidget(button_sv1,7,1)
        tab2Layout.addWidget(self.radiosv7,1,2)
        tab2Layout.addWidget(self.radiosv6,2,2)
        tab2Layout.addWidget(self.radiosv5,3,2)
        tab2Layout.addWidget(self.radiosv4,4,2)
        tab2Layout.addWidget(self.radiosv3,5,2)
        tab2Layout.addWidget(self.radiosv2,6,2)
        tab2Layout.addWidget(self.radiosv1,7,2)
        tab2Layout.addWidget(self.tab2easySVbuttonsFlag,8,0)
        tab2Layout.addWidget(self.tab2easySVsliderFlag,8,1)
        tab2Layout.addWidget(pidSVSliderMinLabel,8,3)
        tab2Layout.addWidget(self.pidSVSliderMin,8,4)
#        tab2Layout.addWidget(tab2easyOFFsvslider,9,0)
#        tab2Layout.addWidget(tab2easyONsvslider,9,1)
        tab2Layout.addWidget(pidSVSliderMaxLabel,9,3)
        tab2Layout.addWidget(self.pidSVSliderMax,9,4)
        tab2Layout.addWidget(tab2getsvbutton,9,0)
        tab2Layout.addWidget(tab2putsvbutton,9,1)
        tab3Layout = QGridLayout() #TAB3
        tab3Layout.setSpacing(10)
        tab3Layoutbutton = QGridLayout()
        tab3MasterLayout = QVBoxLayout()
        tab3MasterLayout.addLayout(tab3Layout,0)
        tab3MasterLayout.addLayout(tab3Layoutbutton,1)
        tab3Layout.addWidget(plabel,0,0)
        tab3Layout.addWidget(ilabel,0,1)
        tab3Layout.addWidget(dlabel,0,2)
        tab3Layout.addWidget(wlabel,0,3)
        tab3Layout.addWidget(self.p1edit,1,0)
        tab3Layout.addWidget(self.i1edit,1,1)
        tab3Layout.addWidget(self.d1edit,1,2)
        tab3Layout.addWidget(self.pid1button,1,3)
        tab3Layout.addWidget(self.p2edit,2,0)
        tab3Layout.addWidget(self.i2edit,2,1)
        tab3Layout.addWidget(self.d2edit,2,2)
        tab3Layout.addWidget(self.pid2button,2,3)
        tab3Layout.addWidget(self.p3edit,3,0)
        tab3Layout.addWidget(self.i3edit,3,1)
        tab3Layout.addWidget(self.d3edit,3,2)
        tab3Layout.addWidget(self.pid3button,3,3)
        tab3Layout.addWidget(self.p4edit,4,0)
        tab3Layout.addWidget(self.i4edit,4,1)
        tab3Layout.addWidget(self.d4edit,4,2)
        tab3Layout.addWidget(self.pid4button,4,3)
        tab3Layout.addWidget(self.p5edit,5,0)
        tab3Layout.addWidget(self.i5edit,5,1)
        tab3Layout.addWidget(self.d5edit,5,2)
        tab3Layout.addWidget(self.pid5button,5,3)
        tab3Layout.addWidget(self.p6edit,6,0)
        tab3Layout.addWidget(self.i6edit,6,1)
        tab3Layout.addWidget(self.d6edit,6,2)
        tab3Layout.addWidget(self.pid6button,6,3)
        tab3Layout.addWidget(self.p7edit,7,0)
        tab3Layout.addWidget(self.i7edit,7,1)
        tab3Layout.addWidget(self.d7edit,7,2)
        tab3Layout.addWidget(self.pid7button,7,3)
        tab3Layout.addWidget(self.radiopid1,1,4)
        tab3Layout.addWidget(self.radiopid2,2,4)
        tab3Layout.addWidget(self.radiopid3,3,4)
        tab3Layout.addWidget(self.radiopid4,4,4)
        tab3Layout.addWidget(self.radiopid5,5,4)
        tab3Layout.addWidget(self.radiopid6,6,4)
        tab3Layout.addWidget(self.radiopid7,7,4)
        tab3Layoutbutton.addWidget(autotuneONbutton,0,0)
        tab3Layoutbutton.addWidget(autotuneOFFbutton,0,1)
        tab3Layoutbutton.addWidget(pidreadallbutton,1,0)
        tab3Layoutbutton.addWidget(pidwriteallbutton,1,1)
        #tab 4
        tab4layout = QVBoxLayout()
        tab4layout.addWidget(self.segmenttable)
        #tab5
        thermolayoutET = QHBoxLayout()
        thermolayoutET.addWidget(self.ETthermocombobox)
        thermolayoutET.addStretch()
        thermolayoutET.addWidget(getETthermocouplebutton)
        thermolayoutET.addWidget(setETthermocouplebutton)
        ETGroupBox = QGroupBox(QApplication.translate("Label","ET Thermocouple type",None))
        ETGroupBox.setLayout(thermolayoutET)
        thermolayoutBT = QHBoxLayout()
        thermolayoutBT.addWidget(self.BTthermocombobox)
        thermolayoutBT.addStretch()
        thermolayoutBT.addWidget(getBTthermocouplebutton)
        thermolayoutBT.addWidget(setBTthermocouplebutton)
        BTGroupBox = QGroupBox(QApplication.translate("Label","BT Thermocouple type",None))
        BTGroupBox.setLayout(thermolayoutBT)
        tab5Layout = QVBoxLayout()
        tab5Layout.addStretch()
        tab5Layout.addWidget(ETGroupBox)
        tab5Layout.addWidget(BTGroupBox)
        tab5Layout.addWidget(BTthermolabelnote)
        tab5Layout.addStretch()
        tab5Layout.addWidget(pointlabel)
        tab5Layout.addWidget(PointButtonET)
        tab5Layout.addWidget(PointButtonBT)
        tab5Layout.addStretch()
        tab5Layout.addWidget(timelabel)
        tab5Layout.addWidget(timeunitsbutton)
        tab5Layout.addStretch()
        ############################
        followLayout = QHBoxLayout()
        followLayout.addStretch()
        followLayout.addWidget(self.followBackground)
        followLayout.addStretch()
        followLayout.addWidget(pidSVLookaheadLabel)
        followLayout.addWidget(self.pidSVLookahead)
        followLayout.addStretch()
        ############################
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(button_load)
        buttonLayout.addWidget(button_save)
        buttonLayout.addStretch()
        buttonLayout.addWidget(button_writeall)
        buttonLayout.addStretch()
        buttonLayout.addWidget(button_exit)
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","RS",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        TabWidget.addTab(C2Widget,QApplication.translate("Tab","SV",None))
        C3Widget = QWidget()
        C3Widget.setLayout(tab3MasterLayout)
        TabWidget.addTab(C3Widget,QApplication.translate("Tab","PID",None))
        C4Widget = QWidget()
        C4Widget.setLayout(tab4layout)
        TabWidget.addTab(C4Widget,QApplication.translate("Tab","Set RS",None))
        C5Widget = QWidget()
        C5Widget.setLayout(tab5Layout)
        TabWidget.addTab(C5Widget,QApplication.translate("Tab","Extra",None))
        #incorporate layouts
        layout = QVBoxLayout()
        layout.addWidget(self.status,0)
        layout.addWidget(TabWidget,1)
        layout.addLayout(followLayout,2)
        layout.addLayout(buttonLayout,3)
        self.setLayout(layout)
    
    @pyqtSlot(bool)
    def cancelAction(self,_):
        self.reject()
    
    @pyqtSlot(int)
    def sliderMinValueChangedSlot(self,i):
        aw.pidcontrol.sliderMinValueChanged(i)
    
    @pyqtSlot(int)
    def sliderMaxValueChangedSlot(self,i):
        aw.pidcontrol.sliderMaxValueChanged(i)
    
    @pyqtSlot(int)
    def setSVbuttons(self,flag):
        aw.pidcontrol.svButtons = bool(flag)
        
    @pyqtSlot(int)
    def setSVsliderSlot(self,i):
        self.setSVslider(i)
        aw.pidcontrol.activateSVSlider(i)

    def setSVslider(self,flag):
        aw.pidcontrol.svSlider = bool(flag)

    @pyqtSlot(int)
    def changeLookAhead(self,_):
        aw.fujipid.lookahead = int(self.pidSVLookahead.value())
    
    @pyqtSlot(int)
    def changeFollowBackground(self,_):
        aw.fujipid.followBackground = not aw.fujipid.followBackground
    
    @pyqtSlot(bool)
    def load(self,_):
        aw.fileImport(QApplication.translate("Message", "Load PID Settings",None),self.loadPIDJSON)

    def loadPIDJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            from json import load as json_load
            pids = json_load(infile)
            infile.close()
            # load set values
            setvalues = pids["setvalues"]
            for i in range(7):
                svkey = "sv" + str(i+1)
                aw.fujipid.PXG4[svkey][0] = setvalues[svkey]
            self.sv1edit.setText(u(str(aw.fujipid.PXG4["sv1"][0])))
            self.sv2edit.setText(u(str(aw.fujipid.PXG4["sv2"][0])))
            self.sv3edit.setText(u(str(aw.fujipid.PXG4["sv3"][0])))
            self.sv4edit.setText(u(str(aw.fujipid.PXG4["sv4"][0])))
            self.sv5edit.setText(u(str(aw.fujipid.PXG4["sv5"][0])))
            self.sv6edit.setText(u(str(aw.fujipid.PXG4["sv6"][0])))
            self.sv7edit.setText(u(str(aw.fujipid.PXG4["sv7"][0])))
            # load PID values
            pidvalues = pids["pidvalues"]
            for i in range(7):
                pkey = "p" + str(i+1)
                ikey = "i" + str(i+1)
                dkey = "d" + str(i+1)
                aw.fujipid.PXG4[pkey][0] = pidvalues[pkey]
                aw.fujipid.PXG4[ikey][0] = pidvalues[ikey]
                aw.fujipid.PXG4[dkey][0] = pidvalues[dkey]
            self.p1edit.setText(u(str(aw.fujipid.PXG4["p1"][0])))
            self.p2edit.setText(u(str(aw.fujipid.PXG4["p2"][0])))
            self.p3edit.setText(u(str(aw.fujipid.PXG4["p3"][0])))
            self.p4edit.setText(u(str(aw.fujipid.PXG4["p4"][0])))
            self.p5edit.setText(u(str(aw.fujipid.PXG4["p5"][0])))
            self.p6edit.setText(u(str(aw.fujipid.PXG4["p6"][0])))
            self.p7edit.setText(u(str(aw.fujipid.PXG4["p7"][0])))
            self.i1edit.setText(u(str(aw.fujipid.PXG4["i1"][0])))
            self.i2edit.setText(u(str(aw.fujipid.PXG4["i2"][0])))
            self.i3edit.setText(u(str(aw.fujipid.PXG4["i3"][0])))
            self.i4edit.setText(u(str(aw.fujipid.PXG4["i4"][0])))
            self.i5edit.setText(u(str(aw.fujipid.PXG4["i5"][0])))
            self.i6edit.setText(u(str(aw.fujipid.PXG4["i6"][0])))
            self.i7edit.setText(u(str(aw.fujipid.PXG4["i7"][0])))
            self.d1edit.setText(u(str(aw.fujipid.PXG4["d1"][0])))
            self.d2edit.setText(u(str(aw.fujipid.PXG4["d2"][0])))
            self.d3edit.setText(u(str(aw.fujipid.PXG4["d3"][0])))
            self.d4edit.setText(u(str(aw.fujipid.PXG4["d4"][0])))
            self.d5edit.setText(u(str(aw.fujipid.PXG4["d5"][0])))
            self.d6edit.setText(u(str(aw.fujipid.PXG4["d6"][0])))
            self.d7edit.setText(u(str(aw.fujipid.PXG4["d7"][0])))
            # load ramp-soak segments
            segments = pids["segments"]
            for i in range(16):
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                aw.fujipid.PXG4[svkey][0] = segments[svkey]
                aw.fujipid.PXG4[rampkey][0] = aw.qmc.stringtoseconds(segments[rampkey])
                aw.fujipid.PXG4[soakkey][0] = aw.qmc.stringtoseconds(segments[soakkey])
            self.createsegmenttable()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " loadPIDJSON() {0}").format(str(ex)),exc_tb.tb_lineno)

    @pyqtSlot(bool)
    def writeSetValues(self,_=False):
        for i in range(7):
            self.setsv(i+1)

    @pyqtSlot(bool)
    def writePIDValues(self,_=False):
        for i in range(7):
            self.setpid(i+1)

    @pyqtSlot(bool)
    def writeRSValues(self,_=False):
        for i in range(16):
            self.setsegment(i)

    @pyqtSlot(bool)
    def writeAll(self,_):
        self.writeSetValues()
        self.writePIDValues()
        self.writeRSValues()

    @pyqtSlot(bool)
    def save(self,_):
        aw.fileExport(QApplication.translate("Message", "Save PID Settings",None),"*.apid",self.savePIDJSON)

    def savePIDJSON(self,filename):
        try:
            pids = {}
            # store set values
            setvalues = {}
            for i in range(7):
                svkey = "sv" + str(i+1)
                setvalues[svkey] = aw.fujipid.PXG4[svkey][0]
            pids["setvalues"] = setvalues
            # store PID values
            pidvalues = {}
            for i in range(7):
                pkey = "p" + str(i+1)
                ikey = "i" + str(i+1)
                dkey = "d" + str(i+1)
                pidvalues[pkey] = aw.fujipid.PXG4[pkey][0]
                pidvalues[ikey] = aw.fujipid.PXG4[ikey][0]
                pidvalues[dkey] = aw.fujipid.PXG4[dkey][0]
            pids["pidvalues"] = pidvalues
            # store ramp-soak segments
            segments = {}
            for i in range(16):
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                segments[svkey] = aw.fujipid.PXG4[svkey][0]
                segments[rampkey] = aw.qmc.stringfromseconds(aw.fujipid.PXG4[rampkey][0])
                segments[soakkey] = aw.qmc.stringfromseconds(aw.fujipid.PXG4[soakkey][0])
            pids["segments"] = segments
            outfile = open(filename, 'w')
            from json import dump as json_dump
            json_dump(pids, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " savePIDJSON(): {0}").format(str(ex)),exc_tb.tb_lineno)
            return False

    @pyqtSlot(bool)
    def settimeunits(self,_):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        try:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict["timeunits"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,1)
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict["timeunits"][1],1)
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                message = QApplication.translate("StatusBar","Time Units successfully set to MM:SS",None)
                self.status.showMessage(message, 5000)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","Problem setting time units",None),5000)
        except Exception as e:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " settimeunits(): {0}").format(str(e)),exc_tb.tb_lineno)
    
    @pyqtSlot(int)
    def paintlabels(self,_=0):
        #read values of computer variables (not the actual pid values) to place in buttons
        str1 = "1 [T " + str(aw.fujipid.PXG4["segment1sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment1soak"][0])) + "]"
        str2 = "2 [T " + str(aw.fujipid.PXG4["segment2sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment2soak"][0])) + "]"
        str3 = "3 [T " + str(aw.fujipid.PXG4["segment3sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment3soak"][0])) + "]"
        str4 = "4 [T " + str(aw.fujipid.PXG4["segment4sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment4soak"][0])) + "]"
        str5 = "5 [T " + str(aw.fujipid.PXG4["segment5sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment5soak"][0])) + "]"
        str6 = "6 [T " + str(aw.fujipid.PXG4["segment6sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment6soak"][0])) + "]"
        str7 = "7 [T " + str(aw.fujipid.PXG4["segment7sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment7soak"][0])) + "]"
        str8 = "8 [T " + str(aw.fujipid.PXG4["segment8sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment8soak"][0])) + "]"
        str9 = "9 [T " + str(aw.fujipid.PXG4["segment9sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment9soak"][0])) + "]"
        str10 = "10 [T " + str(aw.fujipid.PXG4["segment10sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment10soak"][0])) + "]"
        str11 = "11 [T " + str(aw.fujipid.PXG4["segment11sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment11soak"][0])) + "]"
        str12 = "12 [T " + str(aw.fujipid.PXG4["segment12sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment12soak"][0])) + "]"
        str13 = "13 [T " + str(aw.fujipid.PXG4["segment13sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment13soak"][0])) + "]"
        str14 = "14 [T " + str(aw.fujipid.PXG4["segment14sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment14soak"][0])) + "]"
        str15 = "15 [T " + str(aw.fujipid.PXG4["segment15sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment15soak"][0])) + "]"
        str16 = "16 [T " + str(aw.fujipid.PXG4["segment16sv"][0]) + "] [R " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16ramp"][0])) + "] [S " + str(aw.qmc.stringfromseconds(aw.fujipid.PXG4["segment16soak"][0])) + "]"
        self.label_rs1.setText(u(str1))
        self.label_rs2.setText(u(str2))
        self.label_rs3.setText(u(str3))
        self.label_rs4.setText(u(str4))
        self.label_rs5.setText(u(str5))
        self.label_rs6.setText(u(str6))
        self.label_rs7.setText(u(str7))
        self.label_rs8.setText(u(str8))
        self.label_rs9.setText(u(str9))
        self.label_rs10.setText(u(str10))
        self.label_rs11.setText(u(str11))
        self.label_rs12.setText(u(str12))
        self.label_rs13.setText(u(str13))
        self.label_rs14.setText(u(str14))
        self.label_rs15.setText(u(str15))
        self.label_rs16.setText(u(str16))
        pattern = [[1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                  [0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                  [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                  [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                  [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
                  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][0]:
            self.label_rs1.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs1.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][1]:
            self.label_rs2.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs2.setStyleSheet("background-color:white;")

        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][2]:
            self.label_rs3.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs3.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][3]:
            self.label_rs4.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs4.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][4]:
            self.label_rs5.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs5.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][5]:
            self.label_rs6.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs6.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][6]:
            self.label_rs7.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs7.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][7]:
            self.label_rs8.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs8.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][8]:
            self.label_rs9.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs9.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][9]:
            self.label_rs10.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs10.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][10]:
            self.label_rs11.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs11.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][11]:
            self.label_rs12.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs12.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][12]:
            self.label_rs13.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs13.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][13]:
            self.label_rs14.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs14.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][14]:
            self.label_rs15.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs15.setStyleSheet("background-color:white;")
        if pattern[aw.fujipid.PXG4["rampsoakpattern"][0]][15]:
            self.label_rs16.setStyleSheet("background-color:'#FFCC99';")
        else:
            self.label_rs16.setStyleSheet("background-color:white;")

    @pyqtSlot(bool)
    def setNsvSlot(self,_):
        widget = self.sender()
        if widget == self.radiosv1:
            self.setNsv(1)
        elif widget == self.radiosv2:
            self.setNsv(2)
        elif widget == self.radiosv3:
            self.setNsv(3)
        elif widget == self.radiosv4:
            self.setNsv(4)
        elif widget == self.radiosv5:
            self.setNsv(5)
        elif widget == self.radiosv6:
            self.setNsv(6)
        elif widget == self.radiosv7:
            self.setNsv(7)

    #selects an sv
    def setNsv(self,svn):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        # read current sv N
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict["selectsv"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectsv"][1],1)
            N = aw.fujipid.readoneword(command)
        # if current svN is different than requested svN
        if N != -1:
            if N != svn:
                string = QApplication.translate("Message","Current sv = {0}. Change now to sv = {1}?",None).format(str(N),str(svn))
                reply = QMessageBox.question(aw,QApplication.translate("Message","Change svN",None),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(reg_dict["selectsv"][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,svn)
                        r = command = ""
                    else:
                        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict["selectsv"][1],svn)
                        r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        if svn > 0:
                            reg_dict["selectsv"][0] = svn
                            key = "sv" + str(svn)
                            message = QApplication.translate("StatusBar","SV{0} set to {1}",None).format(str(svn),str(reg_dict[key][0]))
                            aw.lcd6.display(str(reg_dict[key][0]))
                            self.status.showMessage(message, 5000)
                    else:
                        self.status.showMessage(QApplication.translate("StatusBar","Problem setting SV",None),5000)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled svN change",None),5000)
                    #set radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                    return 
            else:
                mssg = QApplication.translate("StatusBar","PID already using sv{0}",None).format(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNsv(): bad response",None)
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    def setNpidSlot(self,_):
        widget = self.sender()
        if widget == self.radiopid1:
            self.setNpid(1)
        elif widget == self.radiopid2:
            self.setNpid(2)
        elif widget == self.radiopid3:
            self.setNpid(3)
        elif widget == self.radiopid4:
            self.setNpid(4)
        elif widget == self.radiopid5:
            self.setNpid(5)
        elif widget == self.radiopid6:
            self.setNpid(6)
        elif widget == self.radiopid7:
            self.setNpid(7)
        
    #selects an sv
    def setNpid(self,pidn):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        # read current sv N
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        if N is not None and N != -1:
            reg_dict["selectedpid"][0] = N
            # if current svN is different than requested svN
            if N != pidn:
                string = QApplication.translate("Message","Current pid = {0}. Change now to pid ={1}?",None).format(str(N),str(pidn))
                reply = QMessageBox.question(aw,QApplication.translate("Message","Change svN",None),string,
                                    QMessageBox.Yes|QMessageBox.Cancel)
                if reply == QMessageBox.Yes:
                    #change variable svN
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(reg_dict["selectedpid"][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,pidn)
                        r = command = ""
                    else:
                        command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict["selectedpid"][1],pidn)
                        r = aw.ser.sendFUJIcommand(command,8)
                    #check response from pid and update message on main window
                    if r == command:
                        reg_dict["selectedpid"][0] = pidn
                        #key = "sv" + str(pidn)
                        message = QApplication.translate("StatusBar","pid changed to {0}",None).format(str(pidn))
                        self.status.showMessage(message, 5000)
                    else:
                        mssg = QApplication.translate("StatusBar","setNpid(): bad confirmation",None)
                        self.status.showMessage(mssg,1000)
                        aw.qmc.adderror(mssg)
                elif reply == QMessageBox.Cancel:
                    self.status.showMessage(QApplication.translate("StatusBar","Cancelled pid change",None),5000)
                    #put back radio button
                    if N == 1:
                        self.radiosv1.setChecked(True)
                        self.radiopid1.setChecked(True)
                    elif N == 2:
                        self.radiosv2.setChecked(True)
                        self.radiopid2.setChecked(True)
                    elif N == 3:
                        self.radiosv3.setChecked(True)
                        self.radiopid3.setChecked(True)
                    elif N == 4:
                        self.radiosv4.setChecked(True)
                        self.radiopid4.setChecked(True)
                    elif N == 5:
                        self.radiosv5.setChecked(True)
                        self.radiopid5.setChecked(True)
                    elif N == 6:
                        self.radiosv6.setChecked(True)
                        self.radiopid6.setChecked(True)
                    elif N == 7:
                        self.radiosv7.setChecked(True)
                        self.radiopid7.setChecked(True)
                    return
            else:
                mssg = QApplication.translate("StatusBar","PID was already using pid {0}",None).format(str(N))
                self.status.showMessage(mssg,1000)
        else:
            mssg = QApplication.translate("StatusBar","setNpid(): Unable to set pid {0} ",None).format(str(N))
            self.status.showMessage(mssg,1000)
            aw.qmc.adderror(mssg)

    @pyqtSlot(bool)
    def setsv1(self,_):
        self.setsv(1)
    @pyqtSlot(bool)
    def setsv2(self,_):
        self.setsv(2)
    @pyqtSlot(bool)
    def setsv3(self,_):
        self.setsv(3)
    @pyqtSlot(bool)
    def setsv4(self,_):
        self.setsv(4)
    @pyqtSlot(bool)
    def setsv5(self,_):
        self.setsv(5)
    @pyqtSlot(bool)
    def setsv6(self,_):
        self.setsv(6)
    @pyqtSlot(bool)
    def setsv7(self,_):
        self.setsv(7)

    #writes new value on sv(i)
    def setsv(self,i):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        #first get the new sv value from the correspondig edit line
        if i == 1:
            self.sv1edit.setText(aw.comma2dot(str(self.sv1edit.text())))
            if self.sv1edit.text() != "":
                newSVvalue = int(float(str(self.sv1edit.text()))*10.) #multiply by 10 because of decimal point. Then convert to int.
        elif i == 2:
            self.sv2edit.setText(aw.comma2dot(str(self.sv2edit.text())))
            if self.sv2edit.text() != "":
                newSVvalue = int(float(str(self.sv2edit.text()))*10.)
        elif i == 3:
            self.sv3edit.setText(aw.comma2dot(str(self.sv3edit.text())))
            if self.sv3edit.text() != "":
                newSVvalue = int(float(str(self.sv3edit.text()))*10.)
        elif i == 4:
            self.sv4edit.setText(aw.comma2dot(str(self.sv4edit.text())))
            if self.sv4edit.text() != "":
                newSVvalue = int(float(str(self.sv4edit.text()))*10.)
        elif i == 5:
            self.sv5edit.setText(aw.comma2dot(str(self.sv5edit.text())))
            if self.sv5edit.text() != "":
                newSVvalue = int(float(str(self.sv5edit.text()))*10.)
        elif i == 6:
            self.sv6edit.setText(aw.comma2dot(str(self.sv6edit.text())))
            if self.sv6edit.text() != "":
                newSVvalue = int(float(str(self.sv6edit.text()))*10.)
        elif i == 7:
            self.sv7edit.setText(aw.comma2dot(str(self.sv7edit.text())))
            if self.sv7edit.text() != "":
                newSVvalue = int(float(str(self.sv7edit.text()))*10.)
        #send command to the right sv
        svkey = "sv"+ str(i)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict[svkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newSVvalue)
            r = "00000000"
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[svkey][1],newSVvalue)
            r = aw.ser.sendFUJIcommand(command,8)
        #verify it went ok
        if len(r) == 8:
            if i == 1:
                self.sv1edit.setText(aw.comma2dot(str(self.sv1edit.text())))
                reg_dict[svkey][0] = float(str(self.sv1edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv1edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(1)
                aw.lcd6.display(str(self.sv1edit.text()))
            elif i == 2:
                self.sv2edit.setText(aw.comma2dot(str(self.sv2edit.text())))
                reg_dict[svkey][0] = float(str(self.sv2edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv2edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(2)
                aw.lcd6.display(str(self.sv2edit.text()))
            elif i == 3:
                self.sv3edit.setText(aw.comma2dot(str(self.sv3edit.text())))
                reg_dict[svkey][0] = float(str(self.sv3edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv3edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(3)
                aw.lcd6.display(str(self.sv3edit.text()))
            elif i == 4:
                self.sv4edit.setText(aw.comma2dot(str(self.sv4edit.text())))
                reg_dict[svkey][0] = float(str(self.sv4edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv4edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(4)
                aw.lcd6.display(str(self.sv4edit.text()))
            elif i == 5:
                self.sv5edit.setText(aw.comma2dot(str(self.sv5edit.text())))
                reg_dict[svkey][0] = float(str(self.sv5edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv5edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(5)
                aw.lcd6.display(str(self.sv5edit.text()))
            elif i == 6:
                self.sv6edit.setText(aw.comma2dot(str(self.sv6edit.text())))
                reg_dict[svkey][0] = float(str(self.sv6edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv6edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(6)
                aw.lcd6.display(str(self.sv6edit.text()))
            elif i == 7:
                self.sv7edit.setText(aw.comma2dot(str(self.sv7edit.text())))
                reg_dict[svkey][0] = float(str(self.sv7edit.text()))
                message = QApplication.translate("StatusBar","SV{0} successfully set to {1}",None).format(str(i),str(self.sv7edit.text()))
                self.status.showMessage(message,5000)
                self.setNsv(7)
                aw.lcd6.display(str(self.sv7edit.text()))
            #record command as an Event 
            strcommand = "SETSV::" + str("%.1f"%(newSVvalue/10.))
            aw.qmc.DeviceEventRecord(strcommand)
        else:
            mssg = QApplication.translate("StatusBar","setsv(): Unable to set SV",None)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    @pyqtSlot(bool)
    def setpidSlot(self,_):
        widget = self.sender()
        if widget == self.pid1button:
            self.setpid(1)
        elif widget == self.pid2button:
            self.setpid(2)
        elif widget == self.pid3button:
            self.setpid(3)
        elif widget == self.pid4button:
            self.setpid(4)
        elif widget == self.pid5button:
            self.setpid(5)
        elif widget == self.pid6button:
            self.setpid(6)
        elif widget == self.pid7button:
            self.setpid(7)

    #writes new values for p - i - d
    def setpid(self,k):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        #first get the new sv value from the correspondig edit ine
        if k == 1:
            if self.p1edit.text() != "" and self.i1edit.text() != "" and self.d1edit.text() != "":
                newPvalue = int(float(str(self.p1edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i1edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d1edit.text().replace(',','.')))*10.)
        elif k == 2:
            if self.p2edit.text() != "" and self.i2edit.text() != "" and self.d2edit.text() != "":
                newPvalue = int(float(str(self.p2edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i2edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d2edit.text().replace(',','.')))*10.) 
        elif k == 3:
            if self.p3edit.text() != "" and self.i3edit.text() != "" and self.d3edit.text() != "":
                newPvalue = int(float(str(self.p3edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i3edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d3edit.text().replace(',','.')))*10.)
        elif k == 4:
            if self.p4edit.text() != "" and self.i4edit.text() != "" and self.d4edit.text() != "":
                newPvalue = int(float(str(self.p4edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i4edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d4edit.text().replace(',','.')))*10.) 
        elif k == 5:
            if self.p5edit.text() != "" and self.i5edit.text() != "" and self.d5edit.text() != "":
                newPvalue = int(float(str(self.p5edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i5edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d5edit.text().replace(',','.')))*10.) 
        elif k == 6:
            if self.p6edit.text() != "" and self.i6edit.text() != "" and self.d6edit.text() != "":
                newPvalue = int(float(str(self.p6edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i6edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d6edit.text().replace(',','.')))*10.) 
        elif k == 7:
            if self.p7edit.text() != "" and self.i7edit.text() != "" and self.d7edit.text() != "":
                newPvalue = int(float(str(self.p7edit.text().replace(',','.')))*10.) #multiply by 10 because of decimal point. Then convert to int.
                newIvalue = int(float(str(self.i7edit.text().replace(',','.')))*10.)
                newDvalue = int(float(str(self.d7edit.text().replace(',','.')))*10.) 
        #send command to the right sv
        pkey = "p" + str(k)
        ikey = "i" + str(k)
        dkey = "d" + str(k)
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict[pkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newPvalue)
            reg = aw.modbus.address2register(reg_dict[ikey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newIvalue)
            reg = aw.modbus.address2register(reg_dict[dkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newDvalue)
            p = i = d = "        "
        else:
            commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[pkey][1],newPvalue)
            commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[ikey][1],newIvalue)
            commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[dkey][1],newDvalue)
            p = aw.ser.sendFUJIcommand(commandp,8)
            libtime.sleep(0.035) 
            i = aw.ser.sendFUJIcommand(commandi,8)
            libtime.sleep(0.035) 
            d = aw.ser.sendFUJIcommand(commandd,8)
            libtime.sleep(0.035) 
        #verify it went ok
        if len(p) == 8 and len(i)==8 and len(d) == 8:
            if k == 1:               
                reg_dict[pkey][0] = float(str(self.p1edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i1edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d1edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p1edit.text()),str(self.i1edit.text()),str(self.d1edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(1)
            elif k == 2:
                reg_dict[pkey][0] = float(str(self.p2edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i2edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d2edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p2edit.text()),str(self.i2edit.text()),str(self.d2edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(2)
            elif k == 3:
                reg_dict[pkey][0] = float(str(self.p3edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i3edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d3edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p3edit.text()),str(self.i3edit.text()),str(self.d3edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(3)
            elif k == 4:
                reg_dict[pkey][0] = float(str(self.p4edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i4edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d4edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p4edit.text()),str(self.i4edit.text()),str(self.d4edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(4)
            elif k == 5:
                reg_dict[pkey][0] = float(str(self.p5edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i5edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d5edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p5edit.text()),str(self.i5edit.text()),str(self.d5edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(5)
            elif k == 6:
                reg_dict[pkey][0] = float(str(self.p6edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i6edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d6edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p6edit.text()),str(self.i6edit.text()),str(self.d6edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(6)
            elif k == 7:
                reg_dict[pkey][0] = float(str(self.p7edit.text().replace(',','.')))
                reg_dict[ikey][0] = float(str(self.i7edit.text().replace(',','.')))
                reg_dict[dkey][0] = float(str(self.d7edit.text().replace(',','.')))
                message = (QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                   )).format(str(k),str(self.p7edit.text()),str(self.i7edit.text()),str(self.d7edit.text()))
                self.status.showMessage(message,5000)
                self.setNpid(7) 
        else:
            lp = len(p)
            li = len(i)
            ld = len(d)
            mssg = QApplication.translate("StatusBar","pid command failed. Bad data at pid{0} (8,8,8): ({1},{2},{3}) ",None
                                                   ).format(str(k),str(lp),str(li),str(ld))
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)
    
    @pyqtSlot(bool)
    def getallpid(self,_):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        for k in range(1,8):
            pkey = "p" + str(k)
            ikey = "i" + str(k)
            dkey = "d" + str(k)
            msg = QApplication.translate("StatusBar","sending commands for p{0} i{1} d{2}",None
                                                   ).format(str(k),str(k),str(k))
            self.status.showMessage(msg,1000)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict[pkey][1],3)
                p = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict[pkey][1],1)
                p = aw.fujipid.readoneword(commandp)/10.
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict[ikey][1],3)
                i = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict[ikey][1],1)
                i = aw.fujipid.readoneword(commandi)/10.
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict[dkey][1],3)
                dd = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict[dkey][1],1)
                dd = aw.fujipid.readoneword(commandd)/10.
            p = float(p)
            i = float(i)
            dd = float(dd)
            if p != -1 and i != -1 and dd != -1:
                reg_dict[pkey][0] = p
                reg_dict[ikey][0] = i
                reg_dict[dkey][0] = dd
                if k == 1:
                    self.p1edit.setText(str(p))
                    self.i1edit.setText(str(i))
                    self.d1edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd) # No translation needed here
                    self.status.showMessage(mssg,1000)
                if k == 2:
                    self.p2edit.setText(str(p))
                    self.i2edit.setText(str(i))
                    self.d2edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 3:
                    self.p3edit.setText(str(p))
                    self.i3edit.setText(str(i))
                    self.d3edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 4:
                    self.p4edit.setText(str(p))
                    self.i4edit.setText(str(i))
                    self.d4edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 5:
                    self.p5edit.setText(str(p))
                    self.i5edit.setText(str(i))
                    self.d5edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 6:
                    self.p6edit.setText(str(p))
                    self.i6edit.setText(str(i))
                    self.d6edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
                elif k == 7:
                    self.p7edit.setText(str(p))
                    self.i7edit.setText(str(i))
                    self.d7edit.setText(str(dd))
                    mssg = pkey + "=" + str(p) + " " + ikey + "=" + str(i) + " " + dkey + "=" + str(dd)
                    self.status.showMessage(mssg,1000)
            else:
                mssg = QApplication.translate("StatusBar","getallpid(): Unable to read pid values",None)
                self.status.showMessage(mssg,5000)
                aw.qmc.adderror(mssg)
                return
        #read current pidN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        libtime.sleep(0.035) 
        if N != -1:
            aw.fujipid.PXG4["selectedpid"][0] = N
            if N == 1:
                self.radiopid1.setChecked(True)
            elif N == 2:
                self.radiopid2.setChecked(True)
            elif N == 3:
                self.radiopid3.setChecked(True)
            elif N == 4:
                self.radiopid4.setChecked(True)
            elif N == 5:
                self.radiopid5.setChecked(True)
            elif N == 6:
                self.radiopid6.setChecked(True)
            elif N == 7:
                self.radiopid7.setChecked(True)
            mssg = QApplication.translate("StatusBar","PID is using pid = {0}",None).format(str(N))
            self.status.showMessage(mssg,5000)
        else:
            mssg = QApplication.translate("StatusBar","getallpid(): Unable to read current sv",None)
            self.status.showMessage(mssg,5000)
            aw.qmc.adderror(mssg)

    @pyqtSlot(bool)
    def getallsv(self,_):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        for i in reversed(list(range(1,8))):
            svkey = "sv" + str(i)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict[svkey][1],3)
                sv = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)/10.
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict[svkey][1],1)
                sv = aw.fujipid.readoneword(command)/10.
            aw.fujipid.PXG4[svkey][0] = sv
            if i == 1:
                self.sv1edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 2:
                self.sv2edit.setText(str(sv))
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
            elif i == 3:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv3edit.setText(str(sv))
            elif i == 4:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv4edit.setText(str(sv))
            elif i == 5:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv5edit.setText(str(sv))
            elif i == 6:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv6edit.setText(str(sv))
            elif i == 7:
                mssg = svkey + " = " + str(sv)
                self.status.showMessage(mssg,1000)
                self.sv7edit.setText(str(sv))
        #read current svN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict["selectsv"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectsv"][1],1)
            N = aw.fujipid.readoneword(command)
        if N > 0:
            reg_dict["selectsv"][0] = N
        if N == 1:
            self.radiosv1.setChecked(True)
        elif N == 2:
            self.radiosv2.setChecked(True)
        elif N == 3:
            self.radiosv3.setChecked(True)
        elif N == 4:
            self.radiosv4.setChecked(True)
        elif N == 5:
            self.radiosv5.setChecked(True)
        elif N == 6:
            self.radiosv6.setChecked(True)
        elif N == 7:
            self.radiosv7.setChecked(True)
        mssg = QApplication.translate("StatusBar","PID is using SV = {0}",None).format(str(N))
        self.status.showMessage(mssg,5000)

    def checkrampsoakmode(self):
        currentmode = aw.fujipid.getCurrentRampSoakMode()
        if currentmode == 0:
            mode = ["0",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 1:
            mode = ["1",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 2:
            mode = ["2",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 3:
            mode = ["3",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 4:
            mode = ["4",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 5:
            mode = ["5",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 6:
            mode = ["6",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 7:
            mode = ["7",
                    QApplication.translate("Message","OFF",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 8:
            mode = ["8",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 9:
            mode = ["9",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 10:
            mode = ["10",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 11:
            mode = ["11",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 12:
            mode = ["12",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 13:
            mode = ["13",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","CONTINUOUS CONTROL",None),
                    QApplication.translate("Message","ON",None)]
        elif currentmode == 14:
            mode = ["14",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","OFF",None)]
        elif currentmode == 15:
            mode = ["15",
                    QApplication.translate("Message","ON",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","STANDBY MODE",None),
                    QApplication.translate("Message","ON",None)]
        else:
            return -1
        string = "The rampsoak-mode tells how to start and end the ramp/soak\n\n"
        string += "Your rampsoak mode in this pid is:\n"
        string += "\nMode = " + mode[0]
        string += "\n-----------------------------------------------------------------------"
        string += "\nStart to run from PV value: " + mode[1]
        string += "\nEnd output status at the end of ramp/soak: " + mode[2]
        string += "\nOutput status while ramp/soak opearion set to OFF: " + mode[3] 
        string += "\nRepeat Operation at the end: " + mode[4]
        string += "\n-----------------------------------------------------------------------"
        string += "\n\nRecomended Mode = 0\n"
        string += "\nIf you need to change it, change it now and come back later"
        string += "\nUse the Parameter Loader Software by Fuji if you need to\n\n"
        string += "\n\n\nContinue?" 
        reply = QMessageBox.question(aw,QApplication.translate("Message","Ramp Soak start-end mode",None),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            return 0
        elif reply == QMessageBox.Yes:
            return 1

    @pyqtSlot(bool)
    def setONrampsoak(self,_):
        self.setONOFFrampsoak(1)
    
    @pyqtSlot(bool)
    def setOFFrampsoak(self,_):
        self.setONOFFrampsoak(0)
    
    def setONOFFrampsoak(self,flag):
        #warning check how it ends at "rampsoakend":[0,41081] can let pid inop till value changed    UNFINISHED
        # you can come out of this mode by putting the pid in standby (pid off) 
        #flag =0 OFF, flag = 1 ON, flag = 2 hold        
        #set rampsoak pattern ON
        if flag == 1:
            check = self.checkrampsoakmode()
            if check == 0:
                self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak operation cancelled",None), 5000)
                return
            elif check == -1:
                self.status.showMessage(QApplication.translate("StatusBar","No RX data",None), 5000)
            self.status.showMessage(QApplication.translate("StatusBar","RS ON",None),500)
            selectedmode = self.patternComboBox.currentIndex()
            currentmode = aw.fujipid.getrampsoakmode()
            if currentmode != selectedmode:
                #set mode in pid to match the mode selected in the combobox
                self.status.showMessage(QApplication.translate("StatusBar","Need to change pattern mode...",None),1000)
                res = aw.fujipid.setrampsoakmode(selectedmode)
                if res:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern has been changed. Wait 5 secs.",None), 500)
                else:
                    self.status.showMessage(QApplication.translate("StatusBar","Pattern could not be changed",None), 5000)
                    return                    
            #combobox mode matches pid mode
            #set ramp soak mode ON/OFF
            res = aw.fujipid.setrampsoak(flag)
            if res:
                #record command as an Event if flag = 1
                self.status.showMessage(QApplication.translate("StatusBar","RS ON",None), 5000)
                pattern =[[1,4],[5,8],[1,8],[9,12],[13,16],[9,16],[1,16]]
                if aw.ser.controlETpid[0] == 0: #Fuji PXG
                    reg_dict = aw.fujipid.PXG4
                elif aw.ser.controlETpid[0] == 4: #Fuji PXF
                    reg_dict = aw.fujipid.PXF
                start = pattern[reg_dict["rampsoakpattern"][0]][0]
                end = pattern[reg_dict["rampsoakpattern"][0]][1]+1
                strcommand = "SETRS"
                result = ""
                for i in range(start,end):
                    svkey = "segment"+str(i)+"sv"
                    rampkey = "segment"+str(i)+"ramp"
                    soakkey = "segment"+str(i)+"soak"
                    strcommand += "::" + str(reg_dict[svkey][0]) + "::" + str(reg_dict[rampkey][0]) + "::" + str(reg_dict[soakkey][0])+"::"
                    result += strcommand
                    strcommand = "SETRS"
                result = result.strip("::")
                aw.qmc.DeviceEventRecord(result)
            else:
                self.status.showMessage(QApplication.translate("StatusBar","RampSoak could not be changed",None), 5000)
        #set ramp soak OFF
        elif flag == 0:
            self.status.showMessage(QApplication.translate("StatusBar","RS OFF",None),500)
            aw.fujipid.setrampsoak(flag)

    def setpattern(self):
        #Need to make sure that RampSoak is not ON in order to change pattern:
        onoff = self.getONOFFrampsoak()
        if onoff == 0:
            aw.fujipid.PXG4["rampsoakpattern"][0] = self.patternComboBox.currentIndex()
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4["rampsoakpattern"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,aw.fujipid.PXG4["rampsoakpattern"][0])
                r = command = ""
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4["rampsoakpattern"][1],aw.fujipid.PXG4["rampsoakpattern"][0])
                #TX and RX
                r = aw.ser.sendFUJIcommand(command,8)
            #check response from pid and update message on main window
            if r == command:
                patterns = ["1-4","5-8","1-8","9-12","13-16","9-16","1-16"]
                message = QApplication.translate("Message","Pattern changed to {0}", None).format(patterns[aw.fujipid.PXG4["rampsoakpattern"][0]])
            else:
                message = QApplication.translate("Message","Pattern did not changed",None)
            aw.sendmessage(message)
        elif onoff == 1:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found ON! Turn it off before changing the pattern", None))
        elif onoff == 2:
            aw.sendmessage(QApplication.translate("Message","Ramp/Soak was found in Hold! Turn it off before changing the pattern", None))

    @pyqtSlot(bool)
    def setONstandby(self,_):
        self.setONOFFstandby(1)
    
    @pyqtSlot(bool)
    def setOFFstandby(self,_):
        self.setONOFFstandby(0)
    
    def setONOFFstandby(self,flag):
        try:
            #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
            #flag = 0 standby OFF, flag = 1 standby ON (pid off)
            self.status.showMessage(QApplication.translate("StatusBar","wait...",None),500)
            res = aw.fujipid.setONOFFstandby(flag)
            if res:
                if flag == 1:
                    message = QApplication.translate("StatusBar","PID set to OFF",None)     #put pid in standby 1 (pid on)
                else:
                    message = QApplication.translate("StatusBar","PID set to ON",None)      #put pid in standby 0 (pid off)
                self.status.showMessage(message,5000)
            else:
                message = QApplication.translate("StatusBar","Unable",None)
                self.status.showMessage(QApplication.translate("StatusBar","No data received",None),5000)
        except Exception as e:
            #import traceback
            #traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " setONOFFstandby() {0}").format(str(e)),exc_tb.tb_lineno)

    #get all Ramp Soak values for all 8 segments
    @pyqtSlot(bool)
    def getallsegments(self,_):
        for i in range(1,17):
            msg = QApplication.translate("StatusBar","Reading Ramp/Soak {0} ...",None).format(str(i))
            self.status.showMessage(msg,500)
            k = aw.fujipid.getsegment(i)
            libtime.sleep(0.035)
            if k == -1:
                self.status.showMessage(QApplication.translate("StatusBar","problem reading Ramp/Soak",None),5000)
                return
            self.paintlabels()
        self.status.showMessage(QApplication.translate("StatusBar","Finished reading Ramp/Soak val.",None),5000)
        self.createsegmenttable()

    @pyqtSlot(bool)
    def setONautotune(self,_):
        self.setONOFFautotune(1)
        
    @pyqtSlot(bool)
    def setOFFautotune(self,_):
        self.setONOFFautotune(0)

    def setONOFFautotune(self,flag):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = aw.fujipid.PXG4
        else:
            reg_dict = aw.fujipid.PXF
        self.status.showMessage(QApplication.translate("StatusBar","setting autotune...",None),500)
        #read current pidN
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        reg_dict["selectedpid"][0] = N
        string = QApplication.translate("StatusBar","Current pid = {0}. Proceed with autotune command?",None).format(str(N))
        reply = QMessageBox.question(aw,QApplication.translate("Message","Ramp Soak start-end mode",None),string,
                            QMessageBox.Yes|QMessageBox.Cancel)
        if reply == QMessageBox.Cancel:
            self.status.showMessage(QApplication.translate("StatusBar","Autotune cancelled",None),5000)
            return 0
        elif reply == QMessageBox.Yes:
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict["autotuning"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                r = "00000000"
            else:        
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict["autotuning"][1],flag)
                #TX and RX
                r = aw.ser.sendFUJIcommand(command,8)
            if len(r) == 8:
                if flag == 0:
                    reg_dict["autotuning"][0] = 0
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned OFF",None),5000)
                if flag == 1:
                    reg_dict["autotuning"][0] = 1
                    self.status.showMessage(QApplication.translate("StatusBar","Autotune successfully turned ON",None),5000) 
            else:
                self.status.showMessage(QApplication.translate("StatusBar","UNABLE to set Autotune",None),5000) 
    
    @pyqtSlot(bool)
    def accept(self,_):
        # store set values
        aw.fujipid.PXG4["sv1"][0] = float(aw.comma2dot(self.sv1edit.text()))
        aw.fujipid.PXG4["sv2"][0] = float(aw.comma2dot(self.sv2edit.text()))
        aw.fujipid.PXG4["sv3"][0] = float(aw.comma2dot(self.sv3edit.text()))
        aw.fujipid.PXG4["sv4"][0] = float(aw.comma2dot(self.sv4edit.text()))
        aw.fujipid.PXG4["sv5"][0] = float(aw.comma2dot(self.sv5edit.text()))
        aw.fujipid.PXG4["sv6"][0] = float(aw.comma2dot(self.sv6edit.text()))
        aw.fujipid.PXG4["sv7"][0] = float(aw.comma2dot(self.sv7edit.text()))
        # store set values
        aw.fujipid.PXG4["p1"][0] = float(self.p1edit.text())
        aw.fujipid.PXG4["p2"][0] = float(self.p2edit.text())
        aw.fujipid.PXG4["p3"][0] = float(self.p3edit.text())
        aw.fujipid.PXG4["p4"][0] = float(self.p4edit.text())
        aw.fujipid.PXG4["p5"][0] = float(self.p5edit.text())
        aw.fujipid.PXG4["p6"][0] = float(self.p6edit.text())
        aw.fujipid.PXG4["p7"][0] = float(self.p7edit.text())
        aw.fujipid.PXG4["i1"][0] = float(self.i1edit.text())
        aw.fujipid.PXG4["i2"][0] = float(self.i2edit.text())
        aw.fujipid.PXG4["i3"][0] = float(self.i3edit.text())
        aw.fujipid.PXG4["i4"][0] = float(self.i4edit.text())
        aw.fujipid.PXG4["i5"][0] = float(self.i5edit.text())
        aw.fujipid.PXG4["i6"][0] = float(self.i6edit.text())
        aw.fujipid.PXG4["i7"][0] = float(self.i7edit.text())
        aw.fujipid.PXG4["d1"][0] = float(self.d1edit.text())
        aw.fujipid.PXG4["d2"][0] = float(self.d2edit.text())
        aw.fujipid.PXG4["d3"][0] = float(self.d3edit.text())
        aw.fujipid.PXG4["d4"][0] = float(self.d4edit.text())
        aw.fujipid.PXG4["d5"][0] = float(self.d5edit.text())
        aw.fujipid.PXG4["d6"][0] = float(self.d6edit.text())
        aw.fujipid.PXG4["d7"][0] = float(self.d7edit.text())
        # store segment table
        for i in range(16):
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            aw.fujipid.PXG4[svkey][0] = float(self.segmenttable.cellWidget(i,0).text())
            aw.fujipid.PXG4[rampkey][0] = aw.qmc.stringtoseconds(self.segmenttable.cellWidget(i,1).text())
            aw.fujipid.PXG4[soakkey][0] = aw.qmc.stringtoseconds(self.segmenttable.cellWidget(i,2).text())
        # SV slider
        aw.pidcontrol.svSliderMin = min(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        aw.pidcontrol.svSliderMax = max(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        self.close()

    def createsegmenttable(self):
        self.segmenttable.setRowCount(16)
        self.segmenttable.setColumnCount(4)
        self.segmenttable.setHorizontalHeaderLabels([QApplication.translate("StatusBar","SV",None),
                                                     QApplication.translate("StatusBar","Ramp (MM:SS)",None),
                                                     QApplication.translate("StatusBar","Soak (MM:SS)",None),""])
        self.segmenttable.setEditTriggers(QTableWidget.NoEditTriggers)
        self.segmenttable.setSelectionBehavior(QTableWidget.SelectRows)
        self.segmenttable.setSelectionMode(QTableWidget.SingleSelection)
        self.segmenttable.setShowGrid(True)
        self.segmenttable.verticalHeader().setSectionResizeMode(2)
        regextime = QRegExp(r"^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$")
        #populate table
        for i in range(16):
            #create widgets
            svkey = "segment" + str(i+1) + "sv"
            rampkey = "segment" + str(i+1) + "ramp"
            soakkey = "segment" + str(i+1) + "soak"
            svedit = QLineEdit(str(aw.fujipid.PXG4[svkey][0]))
            svedit.setValidator(aw.createCLocaleDoubleValidator(0., 999., 1, svedit))
            rampedit = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[rampkey][0])))
            rampedit.setValidator(QRegExpValidator(regextime,self))    
            soakedit  = QLineEdit(str(aw.qmc.stringfromseconds(aw.fujipid.PXG4[soakkey][0])))
            soakedit.setValidator(QRegExpValidator(regextime,self))    
            setButton = QPushButton(QApplication.translate("Button","Set",None))
            setButton.setFocusPolicy(Qt.NoFocus)
            setButton.clicked.connect(self.setsegment)
            #add widgets to the table
            self.segmenttable.setCellWidget(i,0,svedit)
            self.segmenttable.setCellWidget(i,1,rampedit)
            self.segmenttable.setCellWidget(i,2,soakedit)
            self.segmenttable.setCellWidget(i,3,setButton)

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    @pyqtSlot(bool)
    def setsegment(self,_):
        i = aw.findWidgetsRow(self.segmenttable,self.sender(),3)
        idn = i+1
        svedit =  self.segmenttable.cellWidget(i,0)
        rampedit = self.segmenttable.cellWidget(i,1)
        soakedit = self.segmenttable.cellWidget(i,2)
        sv = float(aw.comma2dot(str(svedit.text())))
        ramp = aw.qmc.stringtoseconds(str(rampedit.text()))
        soak = aw.qmc.stringtoseconds(str(soakedit.text()))
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.controlETpid[0] == 0: # PXG
            reg_dict = aw.fujipid.PXG4
        else: # PXF
            reg_dict = aw.fujipid.PXF
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(reg_dict[svkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(sv*10))
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(reg_dict[rampkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,ramp)
            libtime.sleep(0.1) #important time between writings
            reg = aw.modbus.address2register(reg_dict[soakkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,soak)
            r1 = r2 = r3 = "        "
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[svkey][1],int(sv*10))
            r1 = aw.ser.sendFUJIcommand(svcommand,8)
            libtime.sleep(0.1) #important time between writings
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[rampkey][1],ramp)
            r2 = aw.ser.sendFUJIcommand(rampcommand,8)
            libtime.sleep(0.1) #important time between writings
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],6,reg_dict[soakkey][1],soak)
            r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1) == 8 and len(r2) == 8 and len(r3) == 8:
            aw.fujipid.PXG4[svkey][0] = sv
            aw.fujipid.PXG4[rampkey][0] = ramp
            aw.fujipid.PXG4[soakkey][0] = soak
            self.paintlabels()
            self.status.showMessage(QApplication.translate("StatusBar","Ramp/Soak successfully written",None),5000) 
        else:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None))

###################################################################################
##########################  FUJI PID CLASS DEFINITION  ############################
###################################################################################

# This class can work for either one Fuji PXR or one Fuji PXG. It is used for the controlling PID only.
# NOTE: There is only one controlling PID. The second pid is only used for reading BT and therefore,
# there is no need to create a second PID object since the second pid all it does is read temperature (always use the same command).
# All is needed for the second pid is its unit id number stored in aw.qmc.device[].
# The command to read T is the always the same for PXR and PXG but with the unit ID changed.

class FujiPID(object):
    def __init__(self):
    
        # follow background: if True, Artisan sends SV values taken from the current background profile if any
        self.followBackground = False
        self.lookahead = 0 # the lookahead in seconds
        self.rampsoak = False # True if RS is active
        self.sv = None # the last sv send to the Fuji PID

        ## FUJI PXG input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##9 (no function)
        ##10 (no function)
        ##11 (no function)
        ##12 (N)
        ##13 (PL- 2)
        ##14 (no function)
        ##15 (0V to 5V / 0mA to 20mA
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)
        self.PXGthermotypes = ["JPT 100",#0
                            "PT 100",    #1
                            "J",         #2
                            "K",         #3
                            "R",         #4
                            "B",         #5
                            "S",         #6
                            "T",         #7
                            "E",         #8
                            "N",         #12
                            "PL-2",      #13
                            "0V-5V/0mA-20mA", #15
                            "1V-5V/4mA-20mA", #16
                            "0mV-10V",   #17
                            "2V to 10V", #18
                            "0mV-100mV"  #19
                            ]
        self.PXGconversiontoindex = [0,1,2,3,4,5,6,7,8,12,13,15,16,17,18,19]  #converts fuji PID PXG types to indexes
        self.PXFthermotypes = [
                            "PT 100-2 (0-500C)",    #8
                            "PT 100-3 (0-600C)",    #9
                            "PT 100-7 (-199-600C)", #13
                            "PT 100-8 (-200-850C)", #14
                            "J-1 (0-400C)",         #15
                            "J-2 (-20-400C)",       #16
                            "J-3 (0-800C)",         #17
                            "J-4 (-2000-1300C)",    #18
                            "K-1 (0-400C)",         #19
                            "K-2 (-20-500C)",       #20
                            "K-3 (0-800C)",         #21
                            "K-4 (-200-1300C)",     #22
                            "R",                    #23
                            "B",                    #24
                            "S",                    #25
                            "T-2 (-199-400C)",      #27
                            "E-1 (0-800C)",         #28
                            "E-2 (-150-800C)",      #29
                            "E-3 (-200-800C)",      #30
                            "N",                    #34
                            "PL-2",                 #36
                            "0V to 5V",             #37
                            "1V to 5V",             #38
                            "0V to 10V",            #39
                            "0mA to 20mA",          #42
                            "4mA to 20mA",          #43
                            ]        
        self.PXFconversiontoindex = [8,9,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,34,36,37,38,39,42,43]  #converts fuji PID PXF types to indexes
        ## FUJI PXR input types
        ##0 (JPT 100'3f)
        ##1 (PT 100'3f)
        ##2 (J)
        ##3 (K)
        ##4 (R)
        ##5 (B)
        ##6 (S)
        ##7 (T)
        ##8 (E)
        ##12 (N)
        ##13 (PL- 2)
        ##15 (0V to 5V/0mA to 20mA)
        ##16 (1V to 5V/4mA to 20mA)
        ##17 (0mV to 10V)
        ##18 (2V to 10V)
        ##19 (0mV to 100mV)        
        self.PXRthermotypes = [
                            "PT 100",   #1
                            "J",        #2
                            "K",        #3
                            "R",        #4
                            "B",        #5
                            "S",        #6
                            "T",        #7
                            "E",        #8
                            "N",        #12
                            "PL-2",     #13
                            "1V to 5V/4mA to 20mA" #16
                            ]
        self.PXRconversiontoindex = [1,2,3,4,5,6,7,8,12,13,16]  #converts fuji PID PXR types to indexes
                
        #refer to Fuji PID instruction manual for more information about the parameters and channels
        #dictionary "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXG4={
                  ############ CH1  Selects controller modes 
                  # manual mode 0 = OFF(auto), 1 = ON(manual)
                  "manual": [0,41121],
                  #run or standby 0=OFF(during run), 1 = ON(during standby)
                  "runstandby": [0,41004],
                  #autotuning run command modes available 0=off, 1=on, 2=low
                  "autotuning": [0,41005],
                  #rampsoak command modes available 0=off, 1=run; 2=hold
                  "rampsoak": [0,41082],
                  #select SV sv1,...,sv7
                  "selectsv": [1,41221],
                  #selects PID number behaviour mode: pid1,...,pid7
                  "selectpid": [0,41222],
                  ############ CH2  Main operating pid parameters.
                  #proportional band  P0 (0% to 999.9%)
                  "p": [5,41006],
                  #integration time i0 (0 to 3200.0 sec)
                  "i": [240,41007],
                  #differential time d0 (0.0 to 999.9 sec)
                  "d": [60,41008],
                   ############ CH3 These are 7 pid storage locations
                  "sv1": [300.0,41241], "p1": [5,41242], "i1": [240,41243], "d1": [60,41244],
                  "sv2": [350.0,41251], "p2": [5,41252], "i2": [240,41253], "d2": [60,41254],
                  "sv3": [400.0,41261], "p3": [5,41262], "i3": [240,41263], "d3": [60,41264],
                  "sv4": [450.0,41271], "p4": [5,41272], "i4": [240,41273], "d4": [60,41274],
                  "sv5": [500.0,41281], "p5": [5,41282], "i5": [240,41283], "d5": [60,41284],
                  "sv6": [550.0,41291], "p6": [5,41292], "i6": [240,41293], "d6": [60,41294],
                  "sv7": [575.0,41301], "p7": [5,41302], "i7": [240,41303], "d7": [60,41304],
                  "selectedpid":[7,41225],
                  ############# CH4      Creates a pattern of temperatures (profiles) using ramp soak combination
                  #sv stands for Set Value (desired temperature value)
                  #the time to reach sv is called ramp 
                  #the time to hold the temperature at sv is called soak 
                  "timeunits": [1,41562],  #0=hh.MM (hour:min)  1=MM.SS (min:sec)                             # PXG has two time formats HH:MM (factory default) and MM:SS 
                  # Example. Dry roast phase. selects 3 or 4 minutes                                          # PXG needs to have parameter TIMU set to 1 (MM:SS)
                  "segment1sv": [270.0,41581],"segment1ramp": [180,41582],"segment1soak": [0,41583],          # See PXG Manual chapter 6: Ramp/Soak Time Units to set the parameter TIMU    
                  "segment2sv": [300.0,41584],"segment2ramp": [180,41585],"segment2soak": [0,41586],
                  "segment3sv": [350.0,41587],"segment3ramp": [180,41588],"segment3soak": [0,41589],
                  "segment4sv": [400.0,41590],"segment4ramp": [180,41591],"segment4soak": [0,41592],
                  # Example. Phase to 1C. selects 6 or 8 mins
                  "segment5sv": [530.0,41593],"segment5ramp": [180,41594],"segment5soak": [0,41595],
                  "segment6sv": [530.0,41596],"segment6ramp": [180,41597],"segment6soak": [0,41598],
                  "segment7sv": [540.0,41599],"segment7ramp": [180,41600],"segment7soak": [0,41601],
                  "segment8sv": [540.0,41602],"segment8ramp": [180,41603],"segment8soak": [0,41604],
                  "segment9sv": [550.0,41605],"segment9ramp": [180,41606],"segment9soak": [0,41607],
                  "segment10sv": [550.0,41608],"segment10ramp": [180,41609],"segment10soak": [0,41610],
                  "segment11sv": [560.0,41611],"segment11ramp": [180,41612],"segment11soak": [0,41613],
                  "segment12sv": [560.0,41614],"segment12ramp": [180,41615],"segment12soak": [0,41616],
                  # Eaxample. Finish phase. selects 3 mins for regular coffee or 5 mins for espresso
                  "segment13sv": [570.0,41617],"segment13ramp": [180,41618],"segment13soak": [0,41619],
                  "segment14sv": [570.0,41620],"segment14ramp": [180,41621],"segment14soak": [0,41622],
                  "segment15sv": [580.0,41623],"segment15ramp": [180,41624],"segment15soak": [0,41625],
                  "segment16sv": [580.0,41626],"segment16ramp": [180,41627],"segment16soak": [0,41628],
                  # "rampsoakmode" 0-15 = 1-16 IMPORTANT: Factory setting is 3 (BAD). Set it up to number 0 or it will
                  # sit on stanby (SV blinks) at the end till rampsoakmode changes. It will appear as if the PID broke (unresponsive)
                  "rampsoakmode":[0,41081],
                  "rampsoakpattern": [6,41561],  #ramp soak activation pattern 0=(1-4) 1=(5-8) 2=(1-8) 3=(9-12) 4=(13-16) 5=(9-16) 6=(1-16)
                  ################  CH5    Checks the ramp soak progress, control output, remaining time and other status functions
                  "stat":[41561], #reads only. 0=off,1=1ramp,2=1soak,3=2ramp,4=2soak,...31=16ramp,32=16soak,33=end
                  ################  CH6    Sets up the thermocouple type, input range, output range and other items for the controller
                  #input type: 0=NA,1=PT100ohms,2=J,3=K,4=R,5=B,6=S,7=T,8=E,12=N,13=PL2,15=(0-5volts),16=(1-5V),17=(0-10V),18=(2-10V),19=(0-100mV)
                  "pvinputtype": [3,41016],
                  "pvinputlowerlimit":[0,41018],
                  "pvinputupperlimit":[9999,41019],
                  "decimalposition": [1,41020],
                  "unitdisplay":[1,41345],         #0=Celsius; 1=Fahrenheit
                  #################  CH7    Assigns functions for DI (digital input), DO (digital output), LED lamp and other controls
                  "rampslopeunit":[1,41432], #0=hour,1=min
                  "controlmethod":[0,41002],  #0=pid,2=fuzzy,2=self,3=pid2
                  #################  CH8     Sets the defect conditions for each type of alarm
                  #################  CH9     Sets the station number _id and communication parameters of the PID controller
                  #################  CH10    Changes settings for valve control 
                  #################  CH11    Sets passwords
                  #################  CH12    Sets the parameters mask functions to hide parameters from the user
                  ################# READ ONLY MEMORY (address starts with digit 3)
                  "pv?":[0,31001],"sv?":[0,31002],"alarm?":[31007],"fault?":[31008],"stat?":[31041],"mv1":[0,31042]
                  }
        
        # "KEY": [VALUE,MEMORY_ADDRESS]
        self.PXR = {"autotuning":[0,41005],
                    "segment1sv":[100.0,41057],"segment1ramp":[3,41065],"segment1soak":[0,41066], #PXR uses only HH:MM time format but stored as minutes in artisan
                    "segment2sv":[100.0,41058],"segment2ramp":[3,41067],"segment2soak":[0,41068],
                    "segment3sv":[100.0,41059],"segment3ramp":[3,41069],"segment3soak":[0,41070],
                    "segment4sv":[100.0,41060],"segment4ramp":[3,41071],"segment4soak":[0,41072],
                    "segment5sv":[100.0,41061],"segment5ramp":[3,41073],"segment5soak":[0,41074],
                    "segment6sv":[100.0,41062],"segment6ramp":[3,41075],"segment6soak":[0,41076],
                    "segment7sv":[100.0,41063],"segment7ramp":[3,41077],"segment7soak":[0,41078],
                    "segment8sv":[100.0,41064],"segment8ramp":[3,41079],"segment8soak":[0,41080],
                    #Tells what to do after finishing or how to start. See documentation under ramp soak pattern: 0-15 
                    "rampsoakmode":[0,41081],
                    #rampsoak command 0=OFF, 1= RUN, 2= HALTED, 3=END
                    "rampsoak":[0,41082],
                    #ramp soak pattern. 0=executes 1 to 4; 1=executes 5 to 8; 2=executes 1 to 8
                    "rampsoakpattern":[0,41083],
                    #PID=0,FUZZY=1,SELF=2
                    "controlmethod":[0,41002],
                    #sv set value
                    "sv0":[0,41003],
                    # run standby 0=RUN 1=STANDBY
                    "runstandby": [0,41004],
                    "p":[5,41006],
                    "i":[240,41007],
                    "d":[60,41008],
                    "decimalposition": [1,41020],
                    "svlowerlimit":[0,41031],
                    "svupperlimit":[0,41032],
                    "pvinputtype":[3,41016],
                    #READ ONLY
                    #current pv
                    "pv?":[0,31001],
                    #current sv on display (during ramp soak it changes)
                    "sv?":[0,31002],
                    #rampsoak current running position (1-8)
                    "segment?":[0,31009],
                    "mv1":[0,31004]   #duty cycle rx -300 to 10300  = -3.00% to 103.00%
                    }
        self.PXF=dict(self.PXG4)
        # initialize the PXF register numbers from the PXG and an offset of 1000
        for k in self.PXF.keys():
            if len(self.PXF[k]) > 1:
                self.PXF[k] = [self.PXF[k][0],self.PXF[k][1]+1000]
            else:
                self.PXF[k] = [self.PXF[k][0]+1000]

    #writes new values for p - i - d
    def setpidPXG(self,k,newPvalue,newIvalue,newDvalue):
        if k is not None and k > 0:
            #send command to the right sv
            pkey = "p" + str(k)
            ikey = "i" + str(k)
            dkey = "d" + str(k)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXG4[pkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(float(newPvalue)*10.))
                libtime.sleep(0.035)
                reg = aw.modbus.address2register(aw.fujipid.PXG4[ikey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(float(newIvalue)*10.))
                libtime.sleep(0.035)
                reg = aw.modbus.address2register(aw.fujipid.PXG4[dkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(float(newDvalue)*10.))
                libtime.sleep(0.035)
                p = i = d = "        "
            else:
                commandp = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[pkey][1],int(float(newPvalue)*10.))
                commandi = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[ikey][1],int(float(newIvalue)*10.))
                commandd = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXG4[dkey][1],int(float(newDvalue)*10.))
                p = aw.ser.sendFUJIcommand(commandp,8)
                libtime.sleep(0.035) 
                i = aw.ser.sendFUJIcommand(commandi,8)
                libtime.sleep(0.035) 
                d = aw.ser.sendFUJIcommand(commandd,8)
                libtime.sleep(0.035) 
            #verify it went ok
            if len(p) == 8 and len(i)==8 and len(d) == 8:
                aw.fujipid.PXG4[pkey][0] = float(newPvalue)
                aw.fujipid.PXG4[ikey][0] = float(newIvalue)
                aw.fujipid.PXG4[dkey][0] = float(newDvalue)
                message = QApplication.translate("StatusBar","pid #{0} successfully set to ({1},{2},{3})",None
                                                       ).format(str(k),str(newPvalue),str(newIvalue),str(newDvalue))
                aw.sendmessage(message)
            else:
                lp = len(p)
                li = len(i)
                ld = len(d)
                message = QApplication.translate("StatusBar","pid command failed. Bad data at pid{0} (8,8,8): ({1},{2},{3}) ",None
                                                       ).format(str(k),str(lp),str(li),str(ld))
                aw.sendmessage(message)
                aw.qmc.adderror(message)

    # updates and returns the current ramp soak mode
    def getCurrentRampSoakMode(self):
        if aw.ser.controlETpid[0] == 0: # PXG
            register = aw.fujipid.PXG4["rampsoakmode"][1]
        elif aw.ser.controlETpid[0] == 1: # PXR
            register = aw.fujipid.PXR["rampsoakmode"][1]
        elif aw.ser.controlETpid[0] == 4: # PXF
            register = aw.fujipid.PXF["rampsoakmode"][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            msg = aw.fujipid.message2send(aw.ser.controlETpid[1],3,register,1)
            currentmode = aw.fujipid.readoneword(msg)
        if aw.ser.controlETpid[0] == 0: # PXG
            aw.fujipid.PXG4["rampsoakmode"][0] = currentmode
        elif aw.ser.controlETpid[0] == 1: # PXR
            aw.fujipid.PXG4["rampsoakmode"][0] = currentmode
        elif aw.ser.controlETpid[0] == 4: # PXF
            aw.fujipid.PXG4["rampsoakmode"][0] = currentmode
        return currentmode                
                                    
    def getCurrentPIDnumberPXG(self):
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(aw.fujipid.PXG4["selectedpid"][1],3)
            N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,aw.fujipid.PXG4["selectedpid"][1],1)
            N = aw.fujipid.readoneword(command)
        libtime.sleep(0.035) 
        return N
                        
    def setpidPXR(self,var,v):
        r = ""
        if var == "p":
            p = int(v*10)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["p"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,p)
                r = "        "
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["p"][1],p)
                r = aw.ser.sendFUJIcommand(command,8)
        elif var == "i":
            i = int(v*10)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["i"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,i)
                r = "        "
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["i"][1],i)
                r = aw.ser.sendFUJIcommand(command,8)
        elif var == "d":
            d = int(v*10)
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["d"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,d)
                r = "        "
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["d"][1],d)
                r = aw.ser.sendFUJIcommand(command,8)

        if len(r) == 8:
            message = QApplication.translate("StatusBar","{0} successfully sent to pid ",None).format(var)
            aw.sendmessage(message)
            if var == "p":
                aw.fujipid.PXR["p"][0] = int(v)
            elif var == "i":
                aw.fujipid.PXR["i"][0] = int(v)
            elif var == "d":
                aw.fujipid.PXR["d"][0] = int(v)
        else:
            message = QApplication.translate("StatusBar","setpid(): There was a problem setting {0}",None).format(var)
            aw.sendmessage(message)
            aw.qmc.adderror(message)
                    
    def calcSV(self,tx):
        if aw.qmc.background:
            # Follow Background mode
            if aw.qmc.swapETBT: # we observe the BT
                res = aw.qmc.backgroundSmoothedBTat(tx + self.lookahead) # smoothed and approximated background
                if res == -1:
                    return None # no background value for that time point
                else:
                    return res
            else: # we observe the ET
                res = aw.qmc.backgroundSmoothedETat(tx + self.lookahead) # smoothed and approximated background
                if res == -1:
                    return None # no background value for that time point
                else:
                    return res
        else:
            return None
    
    ##TX/RX FUNCTIONS
    #This function reads read-only memory (with 3xxxx memory we need function=4)
    #both PXR3 and PXG4 use the same memory location 31001 (3xxxx = read only)
    # pidType: 0=PXG, 1=PXR, 2=None, 3=DTA, 4=PXF (here we support only 0, 1 and 4 for now)
    def gettemperature(self, pidType, stationNo):
        if pidType == 0:
            reg = self.PXG4["pv?"][1]
        elif pidType == 1:
            reg = self.PXR["pv?"][1]
        elif pidType == 4:
            reg = self.PXF["pv?"][1]
        else:
            return -1
        if aw.ser.useModbusPort:
            # we use the pymodbus implementation
            return aw.modbus.readSingleRegister(stationNo,aw.modbus.address2register(reg,4),4)
        else:
            #we compose a message then we send it by using self.readoneword()
            return self.readoneword(self.message2send(stationNo,4,reg,1))

    # activates the SV slider
    def activateONOFFsliderSV(self,flag):
        aw.pidcontrol.activateSVSlider(flag)

    def readcurrentsv(self):
        if aw.ser.useModbusPort:
            reg = None
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                reg = aw.modbus.address2register(self.PXG4["sv?"][1],4)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                reg = aw.modbus.address2register(self.PXR["sv?"][1],4)
            #or if control pid is fuji PXF
            elif aw.ser.controlETpid[0] == 4:
                reg = aw.modbus.address2register(self.PXF["sv?"][1],4)
            if reg is not None:
                val = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,4)/10.
            else:
                val = -0.1
        else:
            command = ""
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["sv?"][1],1)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["sv?"][1],1)
            elif aw.ser.controlETpid[0] == 4:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXF["sv?"][1],1)
            val = self.readoneword(command)/10.
        if val != -0.1:
            return val
        else:
            return -1

    # returns Fuji duty signal in the range 0-100 or -1
    def readdutycycle(self):
        if aw.ser.useModbusPort:
            reg = None
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                reg = aw.modbus.address2register(self.PXG4["mv1"][1],4)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                reg = aw.modbus.address2register(self.PXR["mv1"][1],4)
            #or if control pid is fuji PXF
            elif aw.ser.controlETpid[0] == 4:
                reg = aw.modbus.address2register(self.PXF["mv1"][1],4)
            if reg is not None:
                v = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,4)
            else:
                val = -1
        else:
            command = ""
            #if control pid is fuji PXG4
            if aw.ser.controlETpid[0] == 0:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXG4["mv1"][1],1)
                v = self.readoneword(command)
            #or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXR["mv1"][1],1)
                v = self.readoneword(command)
            #or if control pid is fuji PXF
            elif aw.ser.controlETpid[0] == 4:
                command = self.message2send(aw.ser.controlETpid[1],4,self.PXF["mv1"][1],1)
                v = self.readoneword(command)
        if v is None:
            val = -1
        elif v >= 65236: # -3% to 0%
            val = 0   
        elif v <= 10300: # <= 103%
            val = v/100.
        else: # value out of range (possible a communication error)
            val = -1   
        #val range -3 to 103%. Check for possible decimal digit user settings
        return val

    #turns ON turns OFF current ramp soak mode
    #flag =0 OFF, flag = 1 ON, flag = 2 hold
    #A ramp soak pattern defines a whole profile. They have a minimum of 4 segments.
    # returns True on success, False otherwise
    def setrampsoak(self,flag):
        register = None
        if aw.ser.controlETpid[0] == 0: #Fuji PXG
            register = self.PXG4["rampsoak"][1]        
        elif aw.ser.controlETpid[0] == 1: #Fuji PXR
            register = self.PXR["rampsoak"][1]
        elif aw.ser.controlETpid[0] == 4:
            register = self.PXF["rampsoak"][1]
        if aw.ser.useModbusPort:
            if register is not None:
                reg = aw.modbus.address2register(register,6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
                if flag == 1:
                    aw.fujipid.rampsoak = True
                    aw.sendmessage(QApplication.translate("Message","RS ON", None))
                elif flag == 0:
                    aw.fujipid.rampsoak = False
                    aw.sendmessage(QApplication.translate("Message","RS OFF", None))
                else:
                    aw.sendmessage(QApplication.translate("Message","RS on HOLD", None))
                return True         
        elif register is not None:
            command = self.message2send(aw.ser.controlETpid[1],6,register,flag)
            r = aw.ser.sendFUJIcommand(command,8)
            #if OK
            if r == command:
                if flag == 1:
                    aw.fujipid.rampsoak = True
                    aw.sendmessage(QApplication.translate("Message","RS ON", None))
                elif flag == 0:
                    aw.fujipid.rampsoak = False
                    aw.sendmessage(QApplication.translate("Message","RS OFF", None))
                else:
                    aw.sendmessage(QApplication.translate("Message","RS on HOLD", None))
                return True
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","RampSoak could not be changed",None))
                return False
        return False
        
    def getrampsoakmode(self):
        if aw.ser.controlETpid[0] == 0: #Fuji PXG
            register = self.PXG4["rampsoakpattern"][1]
        elif aw.ser.controlETpid[0] == 1: #Fuji PXR
            register = self.PXR["rampsoakpattern"][1]
        elif aw.ser.controlETpid[0] == 4: #Fuji PXF
            register = self.PXF["rampsoakpattern"][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            currentmode = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:                
            msg = self.message2send(aw.ser.controlETpid[1],3,register,1)
            currentmode = self.readoneword(msg)
        if aw.ser.controlETpid[0] == 0: #Fuji PXG
            self.PXG4["rampsoakpattern"][0] = currentmode
        elif aw.ser.controlETpid[0] == 1: #Fuji PXR
            self.PXR["rampsoakpattern"][0] = currentmode
        elif aw.ser.controlETpid[0] == 4: #Fuji PXF
            self.PXF["rampsoakpattern"][0] = currentmode
        return currentmode
        
    # returns True on success and Fails otherwise
    def setrampsoakmode(self,mode):
        if aw.ser.controlETpid[0] == 0: #Fuji PXG
            register = self.PXG4["rampsoakpattern"][1]
        elif aw.ser.controlETpid[0] == 1: #Fuji PXR
            register = self.PXR["rampsoakpattern"][1]
        elif aw.ser.controlETpid[0] == 4: #Fuji PXF
            register = self.PXF["rampsoakpattern"][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,mode)
        else:                
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,register,mode)
            r = aw.ser.sendFUJIcommand(command,8)
        if aw.ser.useModbusPort or len(r) == 8:
            if aw.ser.controlETpid[0] == 0: #Fuji PXG
                self.PXG4["rampsoakpattern"][0] = mode
            elif aw.ser.controlETpid[0] == 1: #Fuji PXR
                self.PXR["rampsoakpattern"][0] = mode
            elif aw.ser.controlETpid[0] == 4: #Fuji PXF
                self.PXF["rampsoakpattern"][0] = mode
            return True
        else:
            return False

    # returns True on success, False otherwise
    def setONOFFstandby(self,flag):
        #flag = 0 standby OFF, flag = 1 standby ON (pid off)
        #standby ON (pid off) will reset: rampsoak modes/autotuning/self tuning
        #Fuji PXG
        if aw.ser.controlETpid[0] == 0:
            register = aw.fujipid.PXG4["runstandby"][1]
        elif aw.ser.controlETpid[0] == 1:
            register = aw.fujipid.PXR["runstandby"][1]
        elif aw.ser.controlETpid[0] == 4:
            register = aw.fujipid.PXF["runstandby"][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,flag)
        else:
            command = aw.fujipid.message2send(aw.ser.controlETpid[1],6,register,flag)
            #TX and RX
            r = aw.ser.sendFUJIcommand(command,8)
        if r == command or aw.ser.useModbusPort:
            if aw.ser.controlETpid[0] == 0:
                aw.fujipid.PXG4["runstandby"][0] = flag
            elif aw.ser.controlETpid[0] == 1:
                aw.fujipid.PXR["runstandby"][0] = flag
            elif aw.ser.controlETpid[0] == 4:
                aw.fujipid.PXF["runstandby"][0] = flag
            return True
        else:
            mssg = QApplication.translate("Error Message","Exception:",None) + " setONOFFstandby()"
            aw.qmc.adderror(mssg)
            return False
                
    #sets a new sv value (if slient=False, no output nor event recording is done)
    def setsv(self,value,silent=False):
        command = ""
        #Fuji PXG / PXF
        if aw.ser.controlETpid[0] in [0,4]:  # Fuji PXG or PXF
            if aw.ser.controlETpid[0] == 0:
                reg_dict = self.PXG4
            elif aw.ser.controlETpid[0] == 4:
                reg_dict = self.PXF
            
            #send command to the current sv (1-7)
            
            #-- experimental begin
            # read the current svN (1-7) being used
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict["selectsv"][1],3)
                N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
            else:
                command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,reg_dict["selectsv"][1],1)
                N = aw.fujipid.readoneword(command)
            if N > 0:
                reg_dict["selectsv"][0] = N
            #-- experimental end
            
            svkey = "sv"+ str(reg_dict["selectsv"][0]) #current sv
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(reg_dict[svkey][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(value*10))
            else:
                command = self.message2send(aw.ser.controlETpid[1],6,reg_dict[svkey][1],int(value*10))
                r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if aw.ser.useModbusPort or r == command:
                if not silent:
                    # [Not sure the following will translate or even format properly... Need testing!]
                    message = QApplication.translate("Message","PXG/PXF sv#{0} set to {1}",None).format(reg_dict["selectsv"][0],"%.1f" % float(value))
                    aw.sendmessage(message)
                    reg_dict[svkey][0] = value
                    #record command as an Event 
                    strcommand = "SETSV::" + str("%.1f"%float(value))
                    aw.qmc.DeviceEventRecord(strcommand)
                self.sv = value
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None) + " setsv()")
                return -1
        #Fuji PXR
        elif aw.ser.controlETpid[0] == 1:  
            if aw.ser.useModbusPort:
                reg = aw.modbus.address2register(aw.fujipid.PXR["sv0"][1],6)
                aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,int(value*10))
            else:
                command = self.message2send(aw.ser.controlETpid[1],6,aw.fujipid.PXR["sv0"][1],int(value*10))
                r = aw.ser.sendFUJIcommand(command,8)
            #check response
            if aw.ser.useModbusPort or r == command:
                if not silent:
                    # [Not sure the following will translate or even format properly... Need testing!]
                    message = QApplication.translate("Message","PXR sv set to {0}",None).format("%.1f" % float(value))
                    aw.fujipid.PXR["sv0"][0] = value
                    aw.sendmessage(message)
                    #record command as an Event 
                    strcommand = "SETSV::" + str("%.1f"%float(value))
                    aw.qmc.DeviceEventRecord(strcommand)
                self.sv = value
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None) + " setPXRsv()")
                return -1

    #used to set up or down SV by diff degrees from current sv setting
    def adjustsv(self,diff):
        currentsv = self.readcurrentsv()
        if currentsv != -1:
            newsv = int((currentsv + diff)*10.)          #multiply by 10 because we use a decimal point
            #   if control pid is fuji PXG
            if aw.ser.controlETpid[0] == 0:
                # read the current svN (1-7) being used
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(aw.fujipid.PXG4["selectsv"][1],3)
                    N = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
                else:
                    command = aw.fujipid.message2send(aw.ser.controlETpid[1],3,self.PXG4["selectsv"][1],1)
                    N = aw.fujipid.readoneword(command)
                if N > 0:
                    aw.fujipid.PXG4["selectsv"][0] = N
                    svkey = "sv" + str(N)
                    if aw.ser.useModbusPort:
                        reg = aw.modbus.address2register(self.PXG4[svkey][1],6)
                        aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newsv)
                    else:
                        command = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],newsv)
                        r = aw.ser.sendFUJIcommand(command,8)
                    if aw.ser.useModbusPort or len(r) == 8:
                        message = QApplication.translate("Message","SV{0} changed from {1} to {2})",None).format(str(N),str(currentsv),str(newsv/10.))
                        aw.sendmessage(message)
                        self.PXG4[svkey][0] = newsv/10
                        #record command as an Event to replay (not binary as it needs to be stored in a text file)
                        strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                        aw.qmc.DeviceEventRecord(strcommand)
                        aw.lcd6.display("%.1f"%float(newsv/10.))
                    else:
                        msg = QApplication.translate("Message","Unable to set sv{0}",None).format(str(N))
                        aw.sendmessage(msg)
            #   or if control pid is fuji PXR
            elif aw.ser.controlETpid[0] == 1:
                if aw.ser.useModbusPort:
                    reg = aw.modbus.address2register(self.PXR["sv0"][1],6)
                    aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg,newsv)
                else:
                    command = self.message2send(aw.ser.controlETpid[1],6,self.PXR["sv0"][1],newsv)
                    r = aw.ser.sendFUJIcommand(command,8)
                if aw.ser.useModbusPort or len(r) == 8:
                    message = QApplication.translate("Message","SV changed from {0} to {1}",None).format(str(currentsv),str(newsv/10.))                           
                    aw.sendmessage(message)
                    self.PXR["sv0"][0] = newsv/10
                    #record command as an Event to replay (not binary as it needs to be stored in a text file)
                    strcommand = "SETSV::" + str("%.1f"%(newsv/10.))
                    aw.qmc.DeviceEventRecord(strcommand)
                    aw.lcd6.display("%.1f"%float(newsv/10.))
                else:
                    aw.sendmessage(QApplication.translate("Message","Unable to set sv", None))
        else:
            aw.sendmessage(QApplication.translate("Message","Unable to set new sv", None))

    #format of the input string Command: COMMAND::VALUE1::VALUE2::VALUE3::ETC
    def replay(self,CommandString):
        parts = CommandString.split("::")
        command = parts[0]
        values = parts[1:]
        if command == "SETSV":
            self.setsv(float(values[0]))
            return
        elif command == "SETRS":
            self.replaysetrs(CommandString)
            return

    #example of command string with four segments (minimum for Fuji PIDs)
    # SETRS::270.0::3::0::SETRS::300.0::3::0::SETRS::350.0::3::0::SETRS::400.0::3::0
    def replaysetrs(self,CommandString):
        segments =CommandString.split("SETRS")
        if len(segments[0]) == 0:
            segments = segments[1:]          #remove first empty [""] list [[""],[etc]]
        if len(segments[-1]) == 0:
            segments = segments[:-1]          #remove last empty [""] list [[etc][""]]
        n = len(segments)
        #if parts is < 4, make it compatible with Fuji PID (4 segments needed)
        if n < 4:
            for i in range(4-n):
                #last temperature
                lasttemp = segments[-1].split("::")[1]
                #create a string with 4 segments ("SETRS" alredy removed) 
                string = "::" + lasttemp + "::0::0"   #add zero ramp time and zero soak time
                segments.append(string)
        rs = []
        changeflag = 0
        for i in range(n):
            rs.append(segments[i].split("::"))
            if len(rs[i][0]) == 0:          #remove first empty "" [u"",u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][1:]
            if len(rs[i][-1]) == 0:          #remove last empty "" [u"300.5",u"3",u"0",u""] if one found
                rs[i] = rs[i][:-1]
            if len(rs[i]) == 3:
                svkey = "segment" + str(i+1) + "sv"
                rampkey = "segment" + str(i+1) + "ramp"
                soakkey = "segment" + str(i+1) + "soak"
                if aw.ser.controlETpid[0] == 0:             #PXG4
                    if not n%4 or n > 16:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PXG4 replaysetrs(): {0}").format(n))
                        return
                    if self.PXG4[svkey][0] != float(rs[i][0]):
                        self.PXG4[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXG4[rampkey][0] != int(rs[i][1]):
                        self.PXG4[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXG4[soakkey][0] != int(rs[i][2]):
                        self.PXG4[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXG4[svkey][0], self.PXG4[rampkey][0] ,self.PXG4[soakkey][0])
                        changeflag = 0
                elif aw.ser.controlETpid[0] == 1:           #PXR
                    if not n%4 or n > 8:
                        aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " PXR replaysetrs(): {0}").format(n))
                        return
                    if self.PXR[svkey][0] != float(rs[i][0]):
                        self.PXR[svkey][0] = float(rs[i][0])
                        changeflag = 1
                    if self.PXR[rampkey][0] != int(rs[i][1]):
                        self.PXR[rampkey][0] = int(rs[i][1])
                        changeflag = 1
                    if self.PXR[soakkey][0] != int(rs[i][2]):
                        self.PXR[soakkey][0] = int(rs[i][2])
                        changeflag = 1
                    if changeflag:
                        self.setsegment((i+1), self.PXR[svkey][0], self.PXR[rampkey][0] ,self.PXR[soakkey][0])
                        changeflag = 0
            else:
                aw.qmc.adderror(QApplication.translate("Error Message","Exception:",None) + " replaysetrs()")
                return
        #start ramp soak ON
        self.setrampsoak(1)
        
    def getsegment(self, idn):
        if aw.ser.controlETpid[0] == 0:
            reg_dict = self.PXG4
        elif aw.ser.controlETpid[0] == 1:
            reg_dict = self.PXR
        elif aw.ser.controlETpid[0] == 4:
            reg_dict = self.PXF
        svkey = "segment" + str(idn) + "sv"
        register = reg_dict[svkey][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            sv = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            svcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,register,1)
            sv = aw.fujipid.readoneword(svcommand)
        if sv == -1:
            return -1
        reg_dict[svkey][0] = sv/10.              #divide by 10 because the decimal point is not sent by the PID
        
        rampkey = "segment" + str(idn) + "ramp"
        register = reg_dict[rampkey][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            ramp = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            rampcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,register,1)
            ramp = aw.fujipid.readoneword(rampcommand)
        
        if ramp == -1:
            return -1
        reg_dict[rampkey][0] = ramp
        
        soakkey = "segment" + str(idn) + "soak"
        register = reg_dict[soakkey][1]
        if aw.ser.useModbusPort:
            reg = aw.modbus.address2register(register,3)
            soak = aw.modbus.readSingleRegister(aw.ser.controlETpid[1],reg,3)
        else:
            soakcommand = aw.fujipid.message2send(aw.ser.controlETpid[1],3,register,1)
            soak = aw.fujipid.readoneword(soakcommand)
        if soak == -1:
            return -1
        reg_dict[soakkey][0] = soak
        

    #idn = id number, sv = float set value, ramp = ramp value, soak = soak value
    #used in replaysetrs()    
    def setsegment(self,idn,sv,ramp,soak):
        svkey = "segment" + str(idn) + "sv"
        rampkey = "segment" + str(idn) + "ramp"
        soakkey = "segment" + str(idn) + "soak"
        if aw.ser.useModbusPort:
            if aw.ser.controlETpid[0] == 0:
                reg1 = aw.modbus.address2register(self.PXG4[svkey][1],6)
                reg2 = aw.modbus.address2register(self.PXG4[rampkey][1],6)
                reg3 = aw.modbus.address2register(self.PXG4[soakkey][1],6)
            elif  aw.ser.controlETpid[0] == 1:
                reg1 = aw.modbus.address2register(self.PXR[svkey][1],6)
                reg2 = aw.modbus.address2register(self.PXR[rampkey][1],6)
                reg3 = aw.modbus.address2register(self.PXR[soakkey][1],6)
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg1,int(sv*10))
            libtime.sleep(0.11) #important time between writings
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg2,ramp)
            libtime.sleep(0.11) #important time between writings
            aw.modbus.writeSingleRegister(aw.ser.controlETpid[1],reg3,soak)
            r1 = r2 = r3 = "        "
        else:
            if aw.ser.controlETpid[0] == 0:
                svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[svkey][1],int(sv*10))
                rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[rampkey][1],ramp)
                soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXG4[soakkey][1],soak)
            elif  aw.ser.controlETpid[0] == 1:
                svcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[svkey][1],int(sv*10))
                rampcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[rampkey][1],ramp)
                soakcommand = self.message2send(aw.ser.controlETpid[1],6,self.PXR[soakkey][1],soak)
            r1 = aw.ser.sendFUJIcommand(svcommand,8)
            libtime.sleep(0.11) #important time between writings
            r2 = aw.ser.sendFUJIcommand(rampcommand,8)
            libtime.sleep(0.11) #important time between writings
            r3 = aw.ser.sendFUJIcommand(soakcommand,8)
        #check if OK
        if len(r1)!=8 or len(r2)!=8 or len(r3)!=8:
            aw.qmc.adderror(QApplication.translate("Error Message","Segment values could not be written into PID",None))

    def dec2HexRaw(self,decimal):
        # This method converts a decimal to a raw string appropiate for Fuji serial TX
        # Used to compose serial messages
        Nbytes = []
        while decimal:
            decimal, rem = divmod(decimal, 256)
            Nbytes.append(rem)
        Nbytes.reverse()
        if not Nbytes:
            Nbytes.append(0)
        return decs2string(Nbytes)

    def message2send(self, stationNo, FunctionCode, memory, Nword):
        # This method takes the arguments to compose a Fuji serial command and returns the complete raw string with crc16 included
        # memory must be given as the Resistor Number Engineering unit (example of memory = 41057 )
        #check to see if Nword is < 257. If it is, then add extra zero pad. 2^8 = 256 = 1 byte but 2 bytes always needed to send Nword
        if Nword < 257:
            pad1 = self.dec2HexRaw(0)
        else:
            pad1 = decs2string("")
        part1 = self.dec2HexRaw(stationNo)
        part2 = self.dec2HexRaw(FunctionCode)
        _,r = divmod(memory,10000)
        part3 = self.dec2HexRaw(r - 1)
        part4 = self.dec2HexRaw(Nword)
        datastring = part1 + part2 + part3 + pad1 + part4
        # calculate the crc16 of all this data string
        crc16int = self.fujiCrc16(datastring)
        #convert crc16 to hex string to change the order of the 2 bytes from AB.CD to CD.AB to match Fuji requirements
        crc16hex= hex(crc16int)[2:]
        #we need 4 chars but sometimes we get only three or two because of abreviations by hex(). Therefore, add "0" if needed.
        ll = 4 - len(crc16hex)
        pad =["","0","00","000"]
        crc16hex = pad[ll] + crc16hex
        #change now from AB.CD to CD.AB and convert from hex string to int
        crc16end = int(crc16hex[2:]+crc16hex[:2],16)
        #now convert the crc16 from int to binary
        part5 = self.dec2HexRaw(crc16end)
        #return total sum of binary parts  (assembled message)
        return (datastring + part5)

    #input string command. Output integer (not binary string); used for example to read temperature or to obtain the value of a variable
    def readoneword(self,command):
        #takes an already formated command to read 1 word data and returns the response from the pid
        #SEND command and RECEIVE 7 bytes back
        r = aw.ser.sendFUJIcommand(command,7)
        if len(r) == 7:
            # EVERYTHINK OK: convert data part binary string to hex representation
            s1 = hex2int(r[3],r[4])
            #conversion from hex to dec
            return s1
        else:
            #bad number of RX bytes 
            errorcode = QApplication.translate("Error Message","pid.readoneword(): {0} RX bytes received (7 needed) for unit ID={1}",None).format(len(r),command[0])
            aw.qmc.adderror(errorcode)
            return -1

    #FUJICRC16 function calculates the CRC16 of the data. It expects a binary string as input and returns an int
    def fujiCrc16(self,string):
        crc16tab = (0x0000,
                    0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
                    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880,
                    0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0,
                    0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100,
                    0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,
                    0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80,
                    0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0,
                    0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200,
                    0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
                    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80,
                    0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0,
                    0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700,
                    0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,
                    0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80,
                    0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0,
                    0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400,
                    0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040)
        cr=0xFFFF 
        for j in string:
            tmp = cr ^(j)
            cr =(cr >> 8)^crc16tab[(tmp & 0xff)]
        return cr

############################################################################
######################## Arduino CONTROL DIALOG ######################
############################################################################

class PID_DlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(PID_DlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","PID Control",None))
        
        settings = QSettings()
        if settings.contains("PIDGeometry"):
            self.restoreGeometry(settings.value("PIDGeometry"))
        
        # PID tab
        tab1Layout = QVBoxLayout()
        pidGrp = QGroupBox(QApplication.translate("GroupBox","p-i-d",None))
        self.pidKp = QDoubleSpinBox()
        self.pidKp.setAlignment(Qt.AlignRight)
        self.pidKp.setRange(.0,999.)
        self.pidKp.setSingleStep(.1)
        self.pidKp.setValue(aw.pidcontrol.pidKp)
        pidKpLabel = QLabel("kp")
        self.pidKi = QDoubleSpinBox()
        self.pidKi.setAlignment(Qt.AlignRight)
        self.pidKi.setRange(.0,999.)
        self.pidKi.setSingleStep(.1)
        self.pidKi.setValue(aw.pidcontrol.pidKi)
        pidKiLabel = QLabel("ki")
        self.pidKd = QDoubleSpinBox()
        self.pidKd.setAlignment(Qt.AlignRight)
        self.pidKd.setRange(.0,999.)
        self.pidKd.setSingleStep(.1)
        self.pidKd.setValue(aw.pidcontrol.pidKd)
        pidKdLabel = QLabel("kd")
        pidSetPID = QPushButton(QApplication.translate("Button","Set",None))
        pidSetPID.clicked.connect(self.pidConf)
        pidSetPID.setFocusPolicy(Qt.NoFocus)
        
        self.pidSource = QComboBox()
        if aw.qmc.device == 19 and aw.qmc.PIDbuttonflag:
            # Arduino/TC4
            pidSourceItems = ["1","2","3","4"]
            self.pidSource.addItems(pidSourceItems)
            self.pidSource.setCurrentIndex(aw.pidcontrol.pidSource - 1)
        else:
            # Hottop or MODBUS or others (self.qmc.device in [53,29])
            pidSourceItems = ["BT","ET"]
            self.pidSource.addItems(pidSourceItems)
            if aw.pidcontrol.pidSource == 1:
                self.pidSource.setCurrentIndex(0)
            else:
                self.pidSource.setCurrentIndex(1)
        
        pidSourceLabel = QLabel(QApplication.translate("Label","Source",None))

        pidGrid = QGridLayout()
        pidGrid.addWidget(pidKpLabel,0,0)
        pidGrid.addWidget(self.pidKp,0,1)
        pidGrid.addWidget(pidKiLabel,1,0)
        pidGrid.addWidget(self.pidKi,1,1)
        pidGrid.addWidget(pidKdLabel,2,0)
        pidGrid.addWidget(self.pidKd,2,1)


        pidSourceBox = QHBoxLayout()
        pidSourceBox.addStretch()
        pidSourceBox.addWidget(pidSourceLabel)
        pidSourceBox.addWidget(self.pidSource)
        #pidSourceBox.addSpacing(80)
        pidSourceBox.addStretch()
        
        self.pidCycle = QSpinBox()
        self.pidCycle.setAlignment(Qt.AlignRight)
        self.pidCycle.setRange(0,99999)
        self.pidCycle.setSingleStep(100)
        self.pidCycle.setValue(aw.pidcontrol.pidCycle)
        self.pidCycle.setSuffix(" ms")
        pidCycleLabel = QLabel(QApplication.translate("Label","Cycle",None))
        
        pidCycleBox = QHBoxLayout()
        pidCycleBox.addStretch()  
        pidCycleBox.addWidget(pidCycleLabel)
        pidCycleBox.addWidget(self.pidCycle)
        pidCycleBox.addStretch()  
        
        pidSetBox = QHBoxLayout()
        pidSetBox.addStretch()
        pidSetBox.addWidget(pidSetPID)
        
        self.pOnGroup = QButtonGroup()
        self.pOnGroup.setExclusive(True)
        self.pOnE = QRadioButton("P on Error")
        self.pOnGroup.addButton(self.pOnE)
        self.pOnM = QRadioButton("P on Input")
        self.pOnGroup.addButton(self.pOnM)
        self.pOnE.setChecked(aw.pidcontrol.pOnE)
        self.pOnM.setChecked(not aw.pidcontrol.pOnE)
        if aw.pidcontrol.externalPIDControl() in [1,2]:
            self.pOnE.setEnabled(False)
            self.pOnM.setEnabled(False)
        
        pOnLayout = QVBoxLayout() 
        pOnLayout.addWidget(self.pOnE)
        pOnLayout.addWidget(self.pOnM)
        
        pidVBox = QVBoxLayout()
        pidVBox.addLayout(pidSourceBox)
        if aw.qmc.device == 19 and aw.qmc.PIDbuttonflag: # ArduinoTC4
            pidVBox.addLayout(pidCycleBox)
        pidVBox.addLayout(pOnLayout)
        pidVBox.setAlignment(pOnLayout,Qt.AlignRight)
        pidVBox.addLayout(pidSetBox)
        pidVBox.setAlignment(pidSetBox,Qt.AlignRight)
        
        #PID target (only shown if interal PID for hottop/modbus/TC4 is active
        controlItems = ["None",aw.qmc.etypesf(0),aw.qmc.etypesf(1),aw.qmc.etypesf(2),aw.qmc.etypesf(3)]
        #positiveControl
        positiveControlLabel = QLabel(QApplication.translate("Label","Positive", None))
        self.positiveControlCombo = QComboBox()
        self.positiveControlCombo.addItems(controlItems)
        self.positiveControlCombo.setFocusPolicy(Qt.NoFocus)
        self.positiveControlCombo.setCurrentIndex(aw.pidcontrol.pidPositiveTarget)
        #negativeControl
        negativeControlLabel = QLabel(QApplication.translate("Label","Negative", None))
        self.negativeControlCombo = QComboBox()
        self.negativeControlCombo.addItems(controlItems)
        self.negativeControlCombo.setFocusPolicy(Qt.NoFocus)
        self.negativeControlCombo.setCurrentIndex(aw.pidcontrol.pidNegativeTarget)
        
        controlSelectorLayout = QGridLayout()
        controlSelectorLayout.addWidget(positiveControlLabel,0,0)
        controlSelectorLayout.addWidget(self.positiveControlCombo,0,1)
        controlSelectorLayout.addWidget(negativeControlLabel,1,0)
        controlSelectorLayout.addWidget(self.negativeControlCombo,1,1)
                
        self.invertControlFlag = QCheckBox(QApplication.translate("Label", "Invert Control", None))
        self.invertControlFlag.setFocusPolicy(Qt.NoFocus)
        self.invertControlFlag.setChecked(aw.pidcontrol.invertControl)

        controlVBox = QVBoxLayout()
        controlVBox.addLayout(controlSelectorLayout)
        controlVBox.addWidget(self.invertControlFlag)
        
        controlHBox = QHBoxLayout()
        controlHBox.addStretch()
        controlHBox.addLayout(controlVBox)
        controlHBox.addStretch()
        
        pidTargetGrp = QGroupBox(QApplication.translate("GroupBox","Target",None))
        pidTargetGrp.setLayout(controlHBox)
        pidTargetGrp.setContentsMargins(0,10,0,0)
        
        pidGridBox = QHBoxLayout()
        pidGridBox.addLayout(pidGrid)
        pidGridBox.addStretch()
        pidGridBox.addLayout(pidVBox)
        if not (aw.qmc.device == 19 and aw.qmc.PIDbuttonflag): # don't show Targets if TC4 firmware PID is in use
            pidGridBox.addWidget(pidTargetGrp)
        
        pidGridVBox = QVBoxLayout()
        pidGridVBox.addLayout(pidGridBox)
        pidGrp.setLayout(pidGridVBox)
        pidGrp.setContentsMargins(0,10,0,0)
        
        self.pidSV = QSpinBox()
        self.pidSV.setAlignment(Qt.AlignRight)
        self.pidSV.setRange(0,999)
        self.pidSV.setSingleStep(10)
        self.pidSV.setValue(aw.pidcontrol.svValue)
        pidSVLabel = QLabel(QApplication.translate("Label","SV",None))
        
        self.pidSVLookahead = QSpinBox()
        self.pidSVLookahead.setAlignment(Qt.AlignRight)
        self.pidSVLookahead.setRange(0,999)
        self.pidSVLookahead.setSingleStep(1)
        self.pidSVLookahead.setValue(aw.pidcontrol.svLookahead)  
        self.pidSVLookahead.setSuffix(" s")
        pidSVLookaheadLabel = QLabel(QApplication.translate("Label","Lookahead",None))
        
        self.pidDutySteps = QSpinBox()
        self.pidDutySteps.setAlignment(Qt.AlignRight)
        self.pidDutySteps.setRange(1,10)
        self.pidDutySteps.setSingleStep(1)
        self.pidDutySteps.setValue(aw.pidcontrol.dutySteps)  
        self.pidDutySteps.setSuffix(" %")
        pidDutyStepsLabel = QLabel(QApplication.translate("Label","Steps",None))
        
        pidSetSV = QPushButton(QApplication.translate("Button","Set",None))
        pidSetSV.clicked.connect(self.setSV)
        pidSetSV.setFocusPolicy(Qt.NoFocus)

        pidSVModeLabel = QLabel(QApplication.translate("Label","Mode",None))
        pidModeItems = [
            QApplication.translate("Label", "Manual",None),
            QApplication.translate("Label", "Ramp/Soak",None),
            QApplication.translate("Label", "Background",None)]
        self.pidMode = QComboBox()
        self.pidMode.addItems(pidModeItems)
        self.pidMode.setCurrentIndex(aw.pidcontrol.svMode)
        
        self.pidSVbuttonsFlag = QCheckBox(QApplication.translate("Label","Buttons",None))
        self.pidSVbuttonsFlag.setChecked(aw.pidcontrol.svButtons)
        self.pidSVbuttonsFlag.stateChanged.connect(self.activateONOFFeasySVslot)
        self.pidSVsliderFlag = QCheckBox(QApplication.translate("Label","Slider",None))
        self.pidSVsliderFlag.setChecked(aw.pidcontrol.svSlider)
        self.pidSVsliderFlag.stateChanged.connect(self.activateSVSlider)
        
        self.pidSVSliderMin = QSpinBox()
        self.pidSVSliderMin.setAlignment(Qt.AlignRight)
        self.pidSVSliderMin.setRange(0,999)
        self.pidSVSliderMin.setSingleStep(10)
        self.pidSVSliderMin.setValue(aw.pidcontrol.svSliderMin)
        pidSVSliderMinLabel = QLabel(QApplication.translate("Label","Min",None))
        self.pidSVSliderMin.valueChanged.connect(self.sliderMinValueChangedSlot)
        
        self.pidSVSliderMax = QSpinBox()
        self.pidSVSliderMax.setAlignment(Qt.AlignRight)
        self.pidSVSliderMax.setRange(0,999)
        self.pidSVSliderMax.setSingleStep(10)
        self.pidSVSliderMax.setValue(aw.pidcontrol.svSliderMax)   
        pidSVSliderMaxLabel = QLabel(QApplication.translate("Label","Max",None))
        self.pidSVSliderMax.valueChanged.connect(self.sliderMaxValueChangedSlot)
        
        if aw.qmc.mode == "F":
            self.pidSVSliderMin.setSuffix(" F")
            self.pidSVSliderMax.setSuffix(" F")
            self.pidSV.setSuffix(" F")
        elif aw.qmc.mode == "C":
            self.pidSVSliderMin.setSuffix(" C")
            self.pidSVSliderMax.setSuffix(" C")
            self.pidSV.setSuffix(" C")
        
        modeBox = QHBoxLayout()
        modeBox.addWidget(pidSVModeLabel)
        modeBox.addWidget(self.pidMode)
        modeBox.addStretch()
        modeBox.addWidget(pidSVLookaheadLabel)
        modeBox.addWidget(self.pidSVLookahead)
        
        sliderBox = QHBoxLayout()
        sliderBox.addWidget(self.pidSVsliderFlag)
        sliderBox.addStretch()
        sliderBox.addWidget(pidSVSliderMinLabel)
        sliderBox.addWidget(self.pidSVSliderMin)
        sliderBox.addSpacing(10)
        sliderBox.addWidget(pidSVSliderMaxLabel)
        sliderBox.addWidget(self.pidSVSliderMax)
        
        svInputBox = QHBoxLayout()
        svInputBox.addWidget(self.pidSVbuttonsFlag)
        svInputBox.addStretch()
        svInputBox.addWidget(pidSVLabel)
        svInputBox.addWidget(self.pidSV)
        svInputBox.addWidget(pidSetSV)
        
        self.dutyMin = QSpinBox()
        self.dutyMin.setAlignment(Qt.AlignRight)
        self.dutyMin.setRange(-100,100)
        self.dutyMin.setSingleStep(10)
        self.dutyMin.setValue(aw.pidcontrol.dutyMin)
        self.dutyMin.setSuffix(" %")
        dutyMinLabel = QLabel(QApplication.translate("Label","Min",None))
        
        self.dutyMax = QSpinBox()
        self.dutyMax.setAlignment(Qt.AlignRight)
        self.dutyMax.setRange(-100,100)
        self.dutyMax.setSingleStep(10)
        self.dutyMax.setValue(aw.pidcontrol.dutyMax) 
        self.dutyMax.setSuffix(" %")
        dutyMaxLabel = QLabel(QApplication.translate("Label","Max",None))
        
        svGrpBox = QVBoxLayout()
        svGrpBox.addStretch()
        svGrpBox.addLayout(modeBox)
        svGrpBox.addLayout(sliderBox)
        svGrpBox.addLayout(svInputBox)
        svGrpBox.addStretch()
        svGrp = QGroupBox(QApplication.translate("GroupBox","Set Value",None))
        svGrp.setLayout(svGrpBox)
        svGrp.setContentsMargins(0,10,0,0)
        
        dutyGrid = QGridLayout()
        dutyGrid.addWidget(pidDutyStepsLabel,0,0)
        dutyGrid.addWidget(self.pidDutySteps,0,1)
        dutyGrid.addWidget(dutyMaxLabel,1,0)
        dutyGrid.addWidget(self.dutyMax,1,1)
        dutyGrid.addWidget(dutyMinLabel,2,0)
        dutyGrid.addWidget(self.dutyMin,2,1)
        
        
        dutyGrpBox = QVBoxLayout()
        dutyGrpBox.addStretch()
        dutyGrpBox.addLayout(dutyGrid)
        dutyGrpBox.addStretch()
        dutyGrp = QGroupBox(QApplication.translate("GroupBox","Duty",None))
        dutyGrp.setLayout(dutyGrpBox)
        dutyGrp.setContentsMargins(0,15,0,0)
        
        pidBox = QHBoxLayout()
        pidBox.addWidget(pidGrp)
        
        svBox = QHBoxLayout()
        svBox.addWidget(svGrp)
        svBox.addWidget(dutyGrp)
                
        self.startPIDonCHARGE = QCheckBox(QApplication.translate("CheckBox", "Start PID on CHARGE",None))
        self.startPIDonCHARGE.setChecked(aw.pidcontrol.pidOnCHARGE)

        tab1Layout.addLayout(pidBox)
        tab1Layout.addLayout(svBox)
        tab1Layout.addWidget(self.startPIDonCHARGE)
        tab1Layout.addStretch()
        
        
        # Ramp/Soak tab
        tab2Layout = QVBoxLayout()
        tab2InnerLayout = QHBoxLayout()
        tab2Layout.addLayout(tab2InnerLayout)
        rsGrid = QGridLayout()
        self.SVWidgets = []
        self.RampWidgets = []
        self.SoakWidgets = []
        rsGrid.addWidget(QLabel("SV"),0,1)
        rsGrid.addWidget(QLabel("Ramp"),0,2)
        rsGrid.addWidget(QLabel("Soak"),0,3)
        for i in range(8):
            n = i+1
            svwidget = QSpinBox()
            svwidget.setAlignment(Qt.AlignRight)
            svwidget.setRange(0,999)
            svwidget.setSingleStep(10)
            if aw.qmc.mode == "F":
                svwidget.setSuffix(" F")
            elif aw.qmc.mode == "C":
                svwidget.setSuffix(" C")
            self.SVWidgets.append(svwidget)
            rampwidget = QTimeEdit()
            rampwidget.setDisplayFormat("mm:ss")
            rampwidget.setAlignment(Qt.AlignRight)
            self.RampWidgets.append(rampwidget)
            soakwidget = QTimeEdit()
            soakwidget.setDisplayFormat("mm:ss")
            soakwidget.setAlignment(Qt.AlignRight)
            self.SoakWidgets.append(soakwidget)
            rsGrid.addWidget(QLabel(str(n)),n,0)
            rsGrid.addWidget(svwidget,n,1)
            rsGrid.addWidget(self.RampWidgets[i],n,2)
            rsGrid.addWidget(self.SoakWidgets[i],n,3)
        self.setrampsoaks()
        importButton = QPushButton(QApplication.translate("Button","Load",None))
        importButton.setMinimumWidth(80)
        importButton.clicked.connect(self.importrampsoaks)
        exportButton = QPushButton(QApplication.translate("Button","Save",None))
        exportButton.setMinimumWidth(80)
        exportButton.clicked.connect(self.exportrampsoaks)
        buttonLayout = QHBoxLayout()
        buttonLayout.addStretch()
        buttonLayout.addWidget(importButton)
        buttonLayout.addWidget(exportButton)
        buttonLayout.addStretch()
        self.loadRampSoakFromProfile = QCheckBox(QApplication.translate("CheckBox", "Load Ramp/Soak table from profile",None))
        self.loadRampSoakFromProfile.setChecked(aw.pidcontrol.loadRampSoakFromProfile)

        tab2InnerLayout.addStretch()
        tab2InnerLayout.addLayout(rsGrid)
        tab2InnerLayout.addStretch()
        tab2Layout.addLayout(buttonLayout)
        tab2Layout.addStretch()
        tab2Layout.addWidget(self.loadRampSoakFromProfile)


        ############################
        okButton = QPushButton(QApplication.translate("Button","OK",None))
        okButton.clicked.connect(self.okAction)
        onButton = QPushButton(QApplication.translate("Button","On",None))
        onButton.clicked.connect(self.pidONAction)
        offButton = QPushButton(QApplication.translate("Button","Off",None))
        offButton.clicked.connect(self.pidOFFAction)
        okButtonLayout = QHBoxLayout()
        okButtonLayout.addWidget(onButton)
        okButtonLayout.addWidget(offButton)
        okButtonLayout.addStretch()
        okButtonLayout.addWidget(okButton)        
        okButtonLayout.setContentsMargins(0,0,0,0)
        tab1Layout.setContentsMargins(0,0,0,0) # left, top, right, bottom
        tab1Layout.setSpacing(5)
        tab2Layout.setContentsMargins(0,0,0,0)
        tab2Layout.setSpacing(5)
        tabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        tabWidget.addTab(C1Widget,QApplication.translate("Tab","PID",None))
        C2Widget = QWidget()
        C2Widget.setLayout(tab2Layout)
        tabWidget.addTab(C2Widget,QApplication.translate("Tab","Ramp/Soak",None))
        tabWidget.setContentsMargins(0,0,0,0)
        mainLayout = QVBoxLayout()
        mainLayout.addWidget(tabWidget)
        mainLayout.addLayout(okButtonLayout)
        mainLayout.setContentsMargins(2,10,2,2)
        self.setLayout(mainLayout)
        okButton.setFocus()
    
    @pyqtSlot(int)
    def activateSVSlider(self,i):
        aw.pidcontrol.activateSVSlider(i)
        
    @pyqtSlot(bool)
    def pidONAction(self,_):
        aw.pidcontrol.pidOn()
    
    @pyqtSlot(bool)
    def pidOFFAction(self,_):
        aw.pidcontrol.pidOff()
    
    @pyqtSlot(bool)
    def okAction(self,_):
        self.close()
    
    @pyqtSlot(int)
    def activateONOFFeasySVslot(self,i):
        aw.pidcontrol.activateONOFFeasySV(bool(i))

    @pyqtSlot(int)
    def sliderMinValueChangedSlot(self,i):
        aw.pidcontrol.sliderMinValueChanged(i)
    
    @pyqtSlot(int)
    def sliderMaxValueChangedSlot(self,i):
        aw.pidcontrol.sliderMaxValueChanged(i)
    
    @pyqtSlot(bool)
    def importrampsoaks(self,_):
        aw.fileImport(QApplication.translate("Message", "Load Ramp/Soak Table",None),self.importrampsoaksJSON)
        
    def importrampsoaksJSON(self,filename):
        try:
            import io
            infile = io.open(filename, 'r', encoding='utf-8')
            from json import load as json_load
            rampsoaks = json_load(infile)
            infile.close()
            aw.pidcontrol.svValues = rampsoaks["svValues"]
            aw.pidcontrol.svRamps = rampsoaks["svRamps"]
            aw.pidcontrol.svSoaks = rampsoaks["svSoaks"]
            self.setrampsoaks()
        except Exception as ex:
#            import traceback
#            traceback.print_exc(file=sys.stdout)
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message","Exception:",None) + " importrampsoaksJSON() {0}").format(str(ex)),exc_tb.tb_lineno)
    
    @pyqtSlot(bool)
    def exportrampsoaks(self,_):
        aw.fileExport(QApplication.translate("Message", "Save Ramp/Soak Table",None),"*.ars",self.exportrampsoaksJSON)
        
    def exportrampsoaksJSON(self,filename):
        try:
            self.saverampsoaks()
            rampsoaks = {}
            rampsoaks["svValues"] = aw.pidcontrol.svValues
            rampsoaks["svRamps"] = aw.pidcontrol.svRamps
            rampsoaks["svSoaks"] = aw.pidcontrol.svSoaks
            rampsoaks["mode"] = aw.qmc.mode
            outfile = open(filename, 'w')
            from json import dump as json_dump
            json_dump(rampsoaks, outfile, ensure_ascii=True)
            outfile.write('\n')
            outfile.close()
            return True
        except Exception as ex:
            _, _, exc_tb = sys.exc_info()
            aw.qmc.adderror((QApplication.translate("Error Message", "Exception:",None) + " exportrampsoaksJSON(): {0}").format(str(ex)),exc_tb.tb_lineno)
            return False
            
    def saverampsoaks(self):
        for i in range(8):
            aw.pidcontrol.svValues[i] = self.SVWidgets[i].value()
            aw.pidcontrol.svRamps[i] = aw.pidcontrol.QTime2time(self.RampWidgets[i].time())
            aw.pidcontrol.svSoaks[i] = aw.pidcontrol.QTime2time(self.SoakWidgets[i].time())
            
    def setrampsoaks(self):
        for i in range(8):
            self.SVWidgets[i].setValue(aw.pidcontrol.svValues[i])
            self.RampWidgets[i].setTime(aw.pidcontrol.time2QTime(aw.pidcontrol.svRamps[i]))
            self.SoakWidgets[i].setTime(aw.pidcontrol.time2QTime(aw.pidcontrol.svSoaks[i]))

    @pyqtSlot(bool)
    def pidConf(self,_):
        kp = self.pidKp.value() # 5.00
        ki = self.pidKi.value() # 0.15
        kd = self.pidKd.value() # 0.00
        source = self.pidSource.currentIndex() + 1 # 1-4, def 1
        cycle = self.pidCycle.value() # def 1000 in ms
        pOnE = bool(self.pOnE.isChecked())
        aw.pidcontrol.confPID(kp,ki,kd,source,cycle,pOnE)
        if not (aw.qmc.device == 19 and aw.qmc.PIDbuttonflag): # don't show Targets if TC4 firmware PID is in use
            aw.pidcontrol.pidPositiveTarget = self.positiveControlCombo.currentIndex()
            aw.pidcontrol.pidNegativeTarget = self.negativeControlCombo.currentIndex()
            aw.pidcontrol.invertControl = self.invertControlFlag.isChecked()
    
    @pyqtSlot(bool)
    def setSV(self,_): # and DutySteps
        aw.pidcontrol.setSV(self.pidSV.value())
        aw.pidcontrol.setDutySteps(self.pidDutySteps.value())
        
    def close(self):
        kp = self.pidKp.value() # 5.00
        ki = self.pidKi.value() # 0.15
        kd = self.pidKd.value() # 0.00
        
        source = self.pidSource.currentIndex() + 1 # 1-4, def 1
        if not (aw.qmc.device == 19 and aw.qmc.PIDbuttonflag): # don't show Targets if TC4 firmware PID is in use
            aw.pidcontrol.pidPositiveTarget = self.positiveControlCombo.currentIndex()
            aw.pidcontrol.pidNegativeTarget = self.negativeControlCombo.currentIndex()
            aw.pidcontrol.invertControl = self.invertControlFlag.isChecked()
        cycle = self.pidCycle.value() # def 1000 in ms
        pOnE = bool(self.pOnE.isChecked())
        aw.pidcontrol.setPID(kp,ki,kd,source,cycle,pOnE)
        #
        aw.pidcontrol.pidOnCHARGE = self.startPIDonCHARGE.isChecked()
        aw.pidcontrol.loadRampSoakFromProfile = self.loadRampSoakFromProfile.isChecked()
        aw.pidcontrol.svSliderMin = min(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        aw.pidcontrol.svSliderMax = max(self.pidSVSliderMin.value(),self.pidSVSliderMax.value())
        aw.pidcontrol.svValue = self.pidSV.value()
        aw.pidcontrol.svSlider = self.pidSVsliderFlag.isChecked()
        aw.pidcontrol.activateSVSlider(aw.pidcontrol.svSlider)
        aw.pidcontrol.svButtons = self.pidSVbuttonsFlag.isChecked()
        aw.pidcontrol.activateONOFFeasySV(aw.pidcontrol.svButtons)
        aw.pidcontrol.svMode = self.pidMode.currentIndex()
        aw.pidcontrol.dutyMin = min(self.dutyMin.value(),self.dutyMax.value())
        aw.pidcontrol.dutyMax = max(self.dutyMin.value(),self.dutyMax.value())
        aw.pidcontrol.svLookahead = self.pidSVLookahead.value()
        aw.pidcontrol.dutySteps = self.pidDutySteps.value()
        #
        self.saverampsoaks()
        #
        self.closeEvent(None)

    def closeEvent(self,_):
        settings = QSettings()
        #save window geometry
        settings.setValue("PIDGeometry",self.saveGeometry()) 
        self.accept()


############################################################################
######################## DTA PID CONTROL DIALOG ######################
############################################################################

class DTApidDlgControl(ArtisanDialog):
    def __init__(self, parent = None):
        super(DTApidDlgControl,self).__init__(parent)
        self.setModal(True)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setWindowTitle(QApplication.translate("Form Caption","Delta DTA PID Control",None))
        self.status = QStatusBar()
        self.status.setSizeGripEnabled(False)
        self.status.showMessage(QApplication.translate("StatusBar","Work in Progress",None),5000)
        svlabel = QLabel(QApplication.translate("Label", "SV", None))
        self.svedit = QLineEdit(str(aw.dtapid.dtamem["sv"][0]))
        self.svedit.setValidator(aw.createCLocaleDoubleValidator(0., 999.,1, self.svedit))
        readsvbutton = QPushButton(QApplication.translate("Button","Read", None))
        writesvbutton = QPushButton(QApplication.translate("Button","Write", None))
        readsvbutton.clicked.connect(self.readsv)
        writesvbutton.clicked.connect(self.writesv)
        tab1Layout = QGridLayout()
        tab1Layout.addWidget(svlabel,0,0)
        tab1Layout.addWidget(self.svedit,0,1)
        tab1Layout.addWidget(readsvbutton,0,2)
        tab1Layout.addWidget(writesvbutton,0,3)
        ############################
        TabWidget = QTabWidget()
        C1Widget = QWidget()
        C1Widget.setLayout(tab1Layout)
        TabWidget.addTab(C1Widget,QApplication.translate("Tab","General",None))
        mainlayout = QVBoxLayout()
        mainlayout.addWidget(self.status,0)
        mainlayout.addWidget(TabWidget,1)
        self.setLayout(mainlayout)

    @pyqtSlot(bool)
    def readsv(self,_):
        ### create command message2send(unitID,function,address,ndata)
        command = aw.dtapid.message2send(aw.ser.controlETpid[1],3,aw.dtapid.dtamem["sv"][1],1)
        #read sv
        sv = aw.ser.sendDTAcommand(command)
        #update SV value 
        aw.dtapid.dtamem["sv"][0] = sv
        #update svedit
        self.svedit.setText(str(sv)) 
        #update sv LCD
        aw.lcd6.display(sv)
        #update status
        message = QApplication.translate("StatusBar","SV = %s"%(str(sv)),None)
        self.status.showMessage(message,5000)

    #write uses function = 6
    @pyqtSlot(bool)
    def writesv(self,_):
        v = aw.comma2dot(self.svedit.text())
        if v:
            newsv = hex(int(abs(float(str(v)))*10.))[2:].upper()
            ### create command message2send(unitID,function,address,ndata)
            command = aw.dtapid.message2send(aw.ser.controlETpid[1],6,aw.dtapid.dtamem["sv"][1],newsv)
                #read sv
        aw.ser.sendDTAcommand(command)

###################################################################################
##########################  ARDUINO CLASS DEFINITION  ############################
###################################################################################

class PIDcontrol(object):
    def __init__(self):
        self.pidActive = False
        self.sv = None # the last sv send to the Arduino
        #
        self.pidOnCHARGE = False
        self.loadRampSoakFromProfile = False
        self.svValues = [0,0,0,0,0,0,0,0] # sv temp as int per 8 channels
        self.svRamps = [0,0,0,0,0,0,0,0] # seconds as int per 8 channels
        self.svSoaks = [0,0,0,0,0,0,0,0] # seconds as int per 8 channels
        self.svSlider = False
        self.svButtons = False
        self.svMode = 0 # 0: manual, 1: Ramp/Soak, 2: Follow (background profile)
        self.svLookahead = 0
        self.dutySteps = 1
        self.svSliderMin = 0
        self.svSliderMax = 480
        self.svValue = 390 # the value in the setSV textinput box of the PID dialog
        self.dutyMin = -100
        self.dutyMax = 100
        self.pidKp = 20.0
        self.pidKi = 0.01
        self.pidKd = 3.0
        self.lastEnergy = None
        # Proposional on Measurement mode see: http://brettbeauregard.com/blog/2017/06/introducing-proportional-on-measurement/
        self.pOnE = True # True for Proposional on Error mode, False for Proposional on Measurement Mode
        # pidSource
        #   either the TC4 input channel from [1,..,4] if self.qmc.device == 19 (Arduino/TC4)
        #   in all other cases (HOTTOP, MODBUS,..), 1 is interpreted as BT and 2 as ET
        self.pidSource = 1
        self.pidCycle = 1000
        # the positive target should increase with positive PID duty
        self.pidPositiveTarget = 0 # one of [0,1,..,4] with 0: None, 1,..,4: for slider event 1-4
        # the negative target should decrease with negative PID duty
        self.pidNegativeTarget = 0 # one of [0,1,..,4] with 0: None, 1,..,4: for slider event 1-4
        # if invertControl is True, a PID duty of 100% delivers 0% positive duty and a 0% PID duty delivers 100% positive duty
        self.invertControl = False
        # PID sv smoothing
        self.sv_smoothing_factor = 0 # off if 0
        self.sv_decay_weights = None
        self.previous_svs = []

    # returns True if an external PID controller is in use (MODBUS or TC4 PID firmware)
    # and False if the internal software PID is in charge
    # the returned value indicates the type of external PID control:
    #  0: internal PID
    #  1: MODBUS
    #  2: S7
    #  3: TC4
    def externalPIDControl(self):
        # TC4 with PID firmware or MODBUS and SV register set or S7 and SV area set
        if aw.modbus.PID_slave_ID != 0:
            return 1
        elif aw.s7.PID_area != 0:
            return 2
        elif (aw.qmc.device == 19 and aw.qmc.PIDbuttonflag):
            return 3
        else:
            return 0
             
    # v is from [-min,max]
    def setEnergy(self,v):
        # only update control signal if different to previous (cache reset by PID_ON)
        if self.lastEnergy is None or self.lastEnergy != v:
            try: 
                if aw.pidcontrol.pidPositiveTarget:
                    slidernr = aw.pidcontrol.pidPositiveTarget - 1
                    if aw.pidcontrol.invertControl:
                        vp = abs(100 - v)
                    else:
                        vp = v
                    vp = min(100,max(0,int(vp)))
                    # we need to map the duty [0%,100%] to the [slidermin,slidermax] range
                    heat = int(round(numpy.interp(vp,[0,100],[aw.eventslidermin[slidernr],aw.eventslidermax[slidernr]])))
                    aw.block_quantification_sampling_ticks[slidernr] = aw.sampling_ticks_to_block_quantifiction
                    aw.qmc.temporarymovepositiveslider = (slidernr,heat)
                if aw.pidcontrol.pidNegativeTarget:
                    slidernr = aw.pidcontrol.pidNegativeTarget - 1
                    if aw.pidcontrol.invertControl:
                        vn = 0 - v
                    else:
                        vn = v
                    vn = min(0,max(-100,int(vn)))
                    # we need to map the duty [0%,-100%] to the [slidermin,slidermax] range
                    aw.block_quantification_sampling_ticks[slidernr] = aw.sampling_ticks_to_block_quantifiction
                    cool = int(round(numpy.interp(vn,[-100,0],[aw.eventslidermax[slidernr],aw.eventslidermin[slidernr]])))
                    aw.qmc.temporarymovenegativeslider = (slidernr,cool)
            except:
#                import traceback
#                traceback.print_exc(file=sys.stdout)
                pass
        self.lastEnergy = v

    def conv2celsius(self):
        try:
            self.svValue = int(round(aw.qmc.fromFtoC(self.svValue)))
            self.svSliderMin = int(round(aw.qmc.fromFtoC(self.svSliderMin)))
            self.svSliderMax = int(round(aw.qmc.fromFtoC(self.svSliderMax)))
            # establish ne limits on sliders
            aw.sliderSV.setMinimum(self.svSliderMin)
            aw.sliderSV.setMaximum(self.svSliderMax)
            self.pidKp = self.pidKp * (9/5.)
            self.pidKi = self.pidKi * (9/5.)
            self.pidKd = self.pidKd * (9/5.)
            for i in range(self.svValues):
                self.svValues[i] = aw.qmc.fromFtoC(self.svValues[i])
        except Exception:
            pass
    
    def conv2fahrenheit(self):
        try:
            self.svValue = aw.qmc.fromCtoF(self.svValue)
            self.svSliderMin = aw.qmc.fromCtoF(self.svSliderMin)
            self.svSliderMax = aw.qmc.fromCtoF(self.svSliderMax)
            # establish ne limits on sliders
            aw.sliderSV.setMinimum(self.svSliderMin)
            aw.sliderSV.setMaximum(self.svSliderMax)
            self.pidKp = self.pidKp / (9/5.)
            self.pidKi = self.pidKi / (9/5.)
            self.pidKd = self.pidKd / (9/5.)
            for i in range(self.svValues):
                self.svValues[i] = aw.qmc.fromCtoF(self.svValues[i])
        except Exception:
            pass
    
    # takes an "Arduino" float time in seconds and returns the corresponding QTime() object
    def time2QTime(self,t):
        return QTime(0,t/60,t%60)
        
    def QTime2time(self,t):
        return t.minute() * 60 + t.second()
        
    def togglePID(self):
        if self.pidActive:
            self.pidOff()
        else:
            self.pidOn()

    def pidOn(self):
        if aw.qmc.flagon:
            aw.qmc.temporayslider_force_move = True
            self.lastEnergy = None
            # TC4 hardware PID
            # MODBUS hardware PID
            if (aw.pidcontrol.externalPIDControl() == 1 and aw.modbus.PID_ON_action and aw.modbus.PID_ON_action != ""):
                aw.eventaction(4,aw.modbus.PID_ON_action)
                self.pidActive = True
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"])
            # S7 hardware PID
            elif (aw.pidcontrol.externalPIDControl() == 2 and aw.s7.PID_ON_action and aw.s7.PID_ON_action != ""):
                aw.eventaction(15,aw.s7.PID_ON_action)
                self.pidActive = True
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"]) 
            elif aw.qmc.device == 19 and aw.qmc.PIDbuttonflag: # ArduinoTC4 firmware PID
                if aw.ser.ArduinoIsInitialized:
                    self.confPID(self.pidKp,self.pidKi,self.pidKd,self.pidSource,self.pidCycle,aw.pidcontrol.pOnE) # first configure PID according to the actual settings
                    try:
                        #### lock shared resources #####
                        aw.ser.COMsemaphore.acquire(1)
                        if aw.ser.SP.isOpen():
                            duty_min = min(100,max(0,aw.pidcontrol.dutyMin))
                            duty_max = min(100,max(0,aw.pidcontrol.dutyMax))
                            aw.ser.SP.write(str2cmd("PID;LIMIT;" + str(duty_min) + ";" + str(duty_max) + "\n"))
                            aw.ser.SP.write(str2cmd("PID;ON\n"))
                            self.pidActive = True
                            aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"])
                            aw.sendmessage(QApplication.translate("Message","PID turned on", None))
                    finally:
                        if aw.ser.COMsemaphore.available() < 1:
                            aw.ser.COMsemaphore.release(1)
            # software PID
            elif aw.qmc.Controlbuttonflag:
                aw.qmc.pid.setPID(self.pidKp,self.pidKi,self.pidKd,self.pOnE)
                aw.qmc.pid.setLimits((-100 if aw.pidcontrol.pidNegativeTarget else 0),(100 if aw.pidcontrol.pidPositiveTarget else 0))
                aw.qmc.pid.setDutySteps(aw.pidcontrol.dutySteps)
                aw.qmc.pid.setDutyMin(aw.pidcontrol.dutyMin)
                aw.qmc.pid.setDutyMax(aw.pidcontrol.dutyMax)
                aw.qmc.pid.setControl(lambda v: aw.pidcontrol.setEnergy(v))
                if aw.pidcontrol.svMode == 0:
                    aw.pidcontrol.setSV(aw.sliderSV.value())
#                    aw.pidcontrol.setSV(aw.pidcontrol.svValue)
                self.pidActive = True
                aw.qmc.pid.on()
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PIDactive"])

    def pidOff(self):
        # MODBUS hardware PID
        if (aw.pidcontrol.externalPIDControl() == 1 and aw.modbus.PID_OFF_action and aw.modbus.PID_OFF_action != ""):
            aw.eventaction(4,aw.modbus.PID_OFF_action)
            if not aw.HottopControlActive:
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])
            self.pidActive = False  
        # S7 hardware PID
        elif (aw.pidcontrol.externalPIDControl() == 2 and aw.s7.PID_OFF_action and aw.s7.PID_OFF_action != ""):
            aw.eventaction(15,aw.s7.PID_OFF_action)
            if not aw.HottopControlActive:
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])
            self.pidActive = False   
        # TC4 hardware PID
        elif aw.qmc.device == 19 and aw.qmc.PIDbuttonflag and aw.qmc.Controlbuttonflag: # ArduinoTC4 firmware PID
            if aw.ser.ArduinoIsInitialized:
                try:
                    #### lock shared resources #####
                    aw.ser.COMsemaphore.acquire(1)
                    if aw.ser.SP.isOpen():
                        aw.ser.SP.reset_input_buffer() # aw.ser.SP.flushInput() # deprecated in v3
                        aw.ser.SP.reset_output_buffer() # aw.ser.SP.flushOutput() # deprecated in v3
                        aw.ser.SP.write(str2cmd("PID;OFF\n"))
                        aw.sendmessage(QApplication.translate("Message","PID turned off", None))
                finally:
                    if aw.ser.COMsemaphore.available() < 1:
                        aw.ser.COMsemaphore.release(1)
                if not aw.HottopControlActive:
                    aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])
                self.pidActive = False
        # software PID
        elif aw.qmc.Controlbuttonflag:
            aw.qmc.pid.setControl(lambda _: _)
            self.pidActive = False
            aw.qmc.pid.off()
            if not aw.HottopControlActive:
                aw.button_10.setStyleSheet(aw.pushbuttonstyles["PID"])

    @pyqtSlot(int)
    def sliderMinValueChanged(self,i):
        self.svSliderMin = i
        aw.sliderSV.setMinimum(self.svSliderMin)

    @pyqtSlot(int)
    def sliderMaxValueChanged(self,i):
        self.svSliderMax = i
        aw.sliderSV.setMaximum(self.svSliderMax)

    # returns SV (or None) wrt. to the ramp-soak table and the given time t
    # (used only internally)
    def svRampSoak(self,t):
        segment_end_time = 0 # the (end) time of the segments
        prev_segment_end_time = 0 # the (end) time of the previous segment
        segment_start_sv = 0 # the (target) sv of the segment
        prev_segment_start_sv = 0 # the (target) sv of the previous segment
        for i in range(len(self.svValues)):
            # Ramp
            segment_end_time = segment_end_time + self.svRamps[i]
            segment_start_sv = self.svValues[i]
            if segment_end_time > t:
                # t is within the current segment
                k = float(segment_start_sv - prev_segment_start_sv) / float(segment_end_time - prev_segment_end_time)
                return prev_segment_start_sv + k*(t - prev_segment_end_time)
            prev_segment_end_time = segment_end_time
            prev_segment_start_sv = segment_start_sv
            # Soak
            segment_end_time = segment_end_time + self.svSoaks[i]
            segment_start_sv = self.svValues[i]
            if segment_end_time > t:
                # t is within the current segment
                return prev_segment_start_sv
            prev_segment_end_time = segment_end_time
            prev_segment_start_sv = segment_start_sv
        return None
    
    def smooth_sv(self,sv):
        if self.sv_smoothing_factor:
            # create or update smoothing decay weights
            if self.sv_decay_weights is None or len(self.sv_decay_weights) != self.sv_smoothing_factor: # recompute only on changes
                self.sv_decay_weights = numpy.arange(1,self.sv_smoothing_factor+1)
            # add new value
            self.previous_svs.append(sv)
            # throw away superflous values
            self.previous_svs = self.previous_svs[-self.sv_smoothing_factor:]
            # compute smoothed output
            if len(self.previous_svs) < self.sv_smoothing_factor:
                res = sv # no smoothing yet
            else:
                res = numpy.average(self.previous_svs,weights=self.sv_decay_weights)
            return res
        else:
            return sv

    # returns None if in manual mode or no other sv (via ramp/soak or follow mode) defined
    def calcSV(self,tx):
        if self.svMode == 1:
            # Ramp/Soak mode
            # actual time (after CHARGE):
            return self.svRampSoak(tx)
        elif self.svMode == 2 and aw.qmc.background:
            # Follow Background mode
            followBT = True # if false, follow ET
            if aw.qmc.device == 19 and aw.pidcontrol.externalPIDControl(): # in case we run TC4 with the PIDfirmware
                if int(aw.ser.arduinoETChannel) == self.pidSource: # we observe the ET 
                    followBT = False
                elif int(aw.ser.arduinoBTChannel) == self.pidSource: # we observe the BT
                    followBT = True
                else:
                    return None
            else:
                if self.pidSource == 1: # we observe the BT
                    followBT = True
                else:
                    followBT = False
                    
#            if aw.qmc.timeindex[0] < 0 or aw.qmc.timeindex[6] > 0:
#                # before and after DROP the SV configured in the dialog is returned (min/maxed)
#                return max(aw.pidcontrol.svSliderMin,(min(aw.pidcontrol.svSliderMax,aw.pidcontrol.svValue)))
            if aw.qmc.timeindex[6] > 0: # after DROP, the SV configured in the dialog is returned (min/maxed)
                return max(aw.pidcontrol.svSliderMin,(min(aw.pidcontrol.svSliderMax,aw.pidcontrol.svValue)))
            elif aw.qmc.timeindex[0] < 0: # before CHARGE, the CHARGE temp of the background profile is returned
                if aw.qmc.timeindexB[0] < 0:
                    # no CHARGE in background, return manual SV
                    return max(aw.pidcontrol.svSliderMin,(min(aw.pidcontrol.svSliderMax,aw.pidcontrol.svValue)))
                else:
                    # if background contains a CHARGE event
                    if followBT:
                        res = aw.qmc.backgroundBTat(aw.qmc.timeB[aw.qmc.timeindexB[0]]) # smoothed and approximated background
                    else: # in all other cases we observe the ET
                        res = aw.qmc.backgroundETat(aw.qmc.timeB[aw.qmc.timeindexB[0]]) # smoothed and approximated background
                    return self.smooth_sv(res)
            elif ((not aw.qmc.timeB or tx+self.svLookahead > aw.qmc.timeB[-1]) or (aw.qmc.timeindexB[6] > 0 and tx+self.svLookahead > aw.qmc.timeB[aw.qmc.timeindexB[6]])):
                # if tx+self.svLookahead > last background data or background has a DROP and tx+self.svLookahead index is beyond that DROP index
                return None # "deactivate" background follow mode
            else:
                if followBT:
                    res = aw.qmc.backgroundSmoothedBTat(tx + self.svLookahead) # smoothed and approximated background
                    if res == -1:
                        return None # no background value for that time point
                    else:
    #                    j = aw.qmc.backgroundtime2index(tx + self.svLookahead)
    #                    res = aw.qmc.stemp2B[j] # smoothed background  
                        return self.smooth_sv(res)
                else: # in all other cases we observe the ET
                    res = aw.qmc.backgroundSmoothedETat(tx + self.svLookahead) # smoothed and approximated background
                    if res == -1:
                        return None
    #                    j = aw.qmc.backgroundtime2index(tx + self.svLookahead)
    #                    res = aw.qmc.stemp1B[j] # smoothed background
                    else:
                        return self.smooth_sv(res)
        else:
            # return None in manual mode
            return None

    def setDutySteps(self,dutySteps):
        if aw.qmc.Controlbuttonflag and not aw.pidcontrol.externalPIDControl():
            aw.qmc.pid.setDutySteps(dutySteps)

    
    def setSV(self,sv,move=True,init=False):
#        if not move:            
#            aw.sendmessage(QApplication.translate("Message","SV set to %s"%sv, None))
        if (aw.pidcontrol.externalPIDControl() == 1): # MODBUS PID and Control ticked
            self.sv = max(0,sv)
            if move:
                aw.moveSVslider(sv,setValue=True)
            aw.modbus.setTarget(sv)
            self.sv = sv # remember last sv
        elif (aw.pidcontrol.externalPIDControl() == 2): # S7 PID and Control ticked
            self.sv = max(0,sv)
            if move:
                aw.moveSVslider(sv,setValue=True)
            aw.s7.setTarget(sv,aw.s7.SVmultiplier)
            self.sv = sv # remember last sv
        elif aw.qmc.device == 19 and aw.pidcontrol.externalPIDControl(): # ArduinoTC4 firmware PID
            if aw.ser.ArduinoIsInitialized:
                sv = max(0,aw.float2float(sv,2))
                if self.sv != sv: # nothing to do (avoid loops via moveslider!)
                    if move == True and aw.pidcontrol.svSlider:
                        aw.moveSVslider(sv,setValue=True) # only move the slider
                        self.sv = sv # remember last sv
                    try:
                        #### lock shared resources #####
                        aw.ser.COMsemaphore.acquire(1)
                        if aw.ser.SP.isOpen():
                            aw.ser.SP.reset_input_buffer() # aw.ser.SP.flushInput() # deprecated in v3
                            aw.ser.SP.reset_output_buffer() # aw.ser.SP.flushOutput() # deprecated in v3
                            aw.ser.SP.write(str2cmd("PID;SV;" + str(sv) +"\n"))
                            self.sv = sv # remember last sv
                    finally:
                        if aw.ser.COMsemaphore.available() < 1:
                            aw.ser.COMsemaphore.release(1)
        elif aw.qmc.Controlbuttonflag: # in all other cases if the "Control" flag is ticked
            if move and aw.pidcontrol.svSlider:
                aw.moveSVslider(sv,setValue=True)
            aw.qmc.pid.setTarget(sv,init=init)
            self.sv = sv # remember last sv

    def adjustsv(self,diff):
        self.setSV(self.sv + diff,True)
    
    def activateSVSlider(self,flag):
        if flag:
            aw.sliderGrpBoxSV.setVisible(True)
            aw.sliderSV.blockSignals(True)
            aw.sliderSV.setMinimum(self.svSliderMin)
            aw.sliderSV.setMaximum(self.svSliderMax)
            # we set the SV slider/lcd to the last SV issues or the minimum
            if aw.pidcontrol.sv is not None:
                sv = aw.pidcontrol.sv
            else:
                sv = self.svSliderMin
            aw.updateSVSliderLCD(sv)
            aw.sliderSV.setValue(sv)
            aw.sliderSV.blockSignals(False)
            self.svSlider = True
            aw.slidersAction.setEnabled(True)
        else:
            aw.sliderGrpBoxSV.setVisible(False)
            self.svSlider = False
            aw.slidersAction.setEnabled(any(aw.eventslidervisibilities))

    def activateONOFFeasySV(self,flag):
        if flag:
            if aw.qmc.flagon:
                aw.button_12.setVisible(True)
                aw.button_13.setVisible(True)
                aw.button_14.setVisible(True)
                aw.button_15.setVisible(True)
                aw.button_16.setVisible(True)
                aw.button_17.setVisible(True)
        else:
            aw.button_12.setVisible(False)
            aw.button_13.setVisible(False)
            aw.button_14.setVisible(False)
            aw.button_15.setVisible(False)
            aw.button_16.setVisible(False)
            aw.button_17.setVisible(False)

    # just store the p-i-d configuration
    def setPID(self,kp,ki,kd,source=None,cycle=None,pOnE=True):
        self.pidKp = kp
        self.pidKi = ki
        self.pidKd = kd
        self.pOnE = pOnE
        if source is not None:
            self.pidSource = source
        if cycle is not None:
            self.pidCycle = cycle
    
    # send conf to connected PID
    def confPID(self,kp,ki,kd,source=None,cycle=None,pOnE=True):
        if (aw.pidcontrol.externalPIDControl() == 1): # MODBUS (external) Control active
            aw.modbus.setPID(kp,ki,kd)
            self.pidKp = kp
            self.pidKi = ki
            self.pidKd = kd
            aw.sendmessage(QApplication.translate("Message","p-i-d values updated", None))
        elif (aw.pidcontrol.externalPIDControl() == 2): # S7 (external) Control active
            aw.s7.setPID(kp,ki,kd,aw.s7.PIDmultiplier)
            self.pidKp = kp
            self.pidKi = ki
            self.pidKd = kd
            aw.sendmessage(QApplication.translate("Message","p-i-d values updated", None))
        elif aw.qmc.device == 19 and aw.pidcontrol.externalPIDControl(): # ArduinoTC4 firmware PID
            if aw.ser.ArduinoIsInitialized:
                try:
                    #### lock shared resources #####
                    aw.ser.COMsemaphore.acquire(1)
                    if aw.ser.SP.isOpen():
                        aw.ser.SP.reset_input_buffer() # aw.ser.SP.flushInput() # deprecated in v3
                        aw.ser.SP.reset_output_buffer() # aw.ser.SP.flushOutput() # deprecated in v3
                        if pOnE:
                            aw.ser.SP.write(str2cmd("PID;T;" + str(kp) + ";" + str(ki) + ";" + str(kd) + "\n"))
                        else:
                            aw.ser.SP.write(str2cmd("PID;T_POM;" + str(kp) + ";" + str(ki) + ";" + str(kd) + "\n"))
                        self.pidKp = kp
                        self.pidKi = ki
                        self.pidKd = kd
                        if source is not None:
                            libtime.sleep(.03)
                            aw.ser.SP.write(str2cmd("PID;CHAN;" + str(source) + "\n"))
                        if cycle is not None:
                            libtime.sleep(.03)
                            aw.ser.SP.write(str2cmd("PID;CT;" + str(cycle) + "\n"))
                        aw.sendmessage(QApplication.translate("Message","p-i-d values updated", None))
                finally:
                    if aw.ser.COMsemaphore.available() < 1:
                        aw.ser.COMsemaphore.release(1)
        elif aw.qmc.Controlbuttonflag: # in all other cases if the "Control" flag is ticked
            aw.qmc.pid.setPID(kp,ki,kd,pOnE)
            self.pidKp = kp
            self.pidKi = ki
            self.pidKd = kd
            self.pOnE = pOnE
            aw.qmc.pid.setLimits((-100 if aw.pidcontrol.pidNegativeTarget else 0),(100 if aw.pidcontrol.pidPositiveTarget else 0))
            aw.sendmessage(QApplication.translate("Message","p-i-d values updated", None))

###################################################################################
##########################  DTA PID CLASS DEFINITION  ############################
###################################################################################
# documentation
# http://www.deltaww.hu/homersekletszabalyozok/DTA_series_temperature_controller_instruction_sheet_English.pdf
class DtaPID(object):
    def __init__(self):
        #refer to Delta instruction manual for more information
        #dictionary "KEY": [VALUE,ASCII_MEMORY_ADDRESS]  note: address contains hex alpha characters
        self.dtamem={
                  "pv": [0,"4700"],             # process value (temperature reading)
                  "sv": [100.0,"4701"],         # set point
                  "p": [5,"4708"],              # p value 0-9999
                  "i": [240,"4709"],            # i value 0-9999
                  "d": [60,"470A"],             # d value 0-9999
                  "duty" : [0,"471D"],          # duty
                  "sensortype": [0,"4710"],     # 0 = K type1; 1 = K type2; 2 = J type1; 3 = J type2
                                                # 4 = T type1; 5 = T type2; 6 = E ; 7 = N; 8 = R; 9 = S; 10 = B
                                                # 11 = JPT100 type1; 12 = JPT100 type2; 13 = PT100 type1; 14 = PT100 type2
                                                # 15 = PT100 type3; 16 = L ; 17 = U; 18 = Txk
                  "controlmethod":[0,"4711"],   # 0 = pid; 1 = ON/OFF; 2 = manual
                  "units":[1,"4717"],           # units C = 1; F = 2
                  "controlsetting":[1,"4719"],  # 1=Run; 0 = Stop
                  "error":[0,"472B"]            # note: read only memory. Values:
                                                # 0 = Normal,1 = Initial process; 2 = Initial status;
                                                # 3 = sensor not connected; 4 = sensor input error
                                                # 5 = Exceeds max temperature; 6 = Number Internal error
                                                # 7 EEPROM error
                  }
    #command  string = ID (ADR)+ FUNCTION (CMD) + ADDRESS + NDATA + LRC_CHK
    def writeDTE(self,value,DTAaddress):
        newsv = hex(int(abs(float(str(value)))))[2:].upper()
        slaveID = aw.ser.controlETpid[1]
        if aw.ser.controlETpid[0] != 2: # control pid is not a DTA PID
            slaveID = aw.ser.readBTpid[1]
        command = aw.dtapid.message2send(slaveID,6,str(DTAaddress),newsv)
        aw.ser.sendDTAcommand(command)

    def message2send(self,unitID,FUNCTION,ADDRESS, NDATA):
        #compose command
        string_unitID = str(unitID).zfill(2)
        string_FUNCTION = str(FUNCTION).zfill(2)
        string_ADDRESS = ADDRESS                 #ADDRESS is a 4 char string
        string_NDATA = str(NDATA).zfill(4)
        cmd = string_unitID + string_FUNCTION + string_ADDRESS + string_NDATA
        checksum = hex(self.DTACalcChecksum(cmd))[2:].zfill(2).upper()
        command = ":" + cmd + checksum + "\r\n"
        return command

    def DTACalcChecksum(self,string):
        def tobin(x, count=8):
            return "".join([str((x>>y)&1) for y in range(count-1, -1, -1)])
        def twoscomp(num_str):
            return tobin(-int(num_str,2),len(num_str))
        length = len(string)
        # start at index 1 because of heading ':' cmd
        count = 0
        val = 0x00
        while count < length:
            val +=  int(string[count] + string[count+1], 16)  #string[count+1] goes out of range
            count += 2
        h_bs = bin(val)[2:]
        h2comp = twoscomp(h_bs)
        rval = int(h2comp,2)
        if (val & 0x80) == 0:
            rval = rval | 0x80
        return rval

###########################################################################################################################################
###########################################################################################################################################


def excepthook(excType, excValue, tracebackobj):
    """
    Global function to catch unhandled exceptions.
    
    @param excType exception type
    @param excValue exception value
    @param tracebackobj traceback object
    """
    separator = '-' * 80
    logFile = "simple.log"
    notice = \
        """An unhandled exception occurred. Please report the problem on Github:\n"""\
        """https://github.com/artisan-roaster-scope/artisan/issues\n"""\
        """When reporting this issue, please include your settings file (export \n"""\
        """via menu Help >> Save Settings) and the details below.\n\n"""\
        """An entry has been written to the error log (menu Help >> Error).\n\n"""
    versionInfo= "Version: " + str(__version__) + ", revision: " + str(__revision__) + "\n"
    timeString = libtime.strftime("%Y-%m-%d, %H:%M:%S")
    
    import io
    tbinfofile = io.StringIO()
    
    import traceback
    traceback.print_tb(tracebackobj, None, tbinfofile)
    tbinfofile.seek(0)
    tbinfo = tbinfofile.read()
    errmsg = '%s: \n%s' % (str(excType), str(excValue))
    stack = []
    variables = ""
    tb = tracebackobj
    while tb:
        stack.append(tb.tb_frame)
        tb = tb.tb_next

    for frame in stack:
        variables += "%s::%s:%s\n" % (frame.f_code.co_filename,
                                      frame.f_code.co_name,
                                      frame.f_lineno)
        for key, value in frame.f_locals.items():
            variables += "\t%20s = " % key
            try:                   
                s = str(value)
            except:
                s = "<???>"
            variables += "%s\n" % s
    sections = [timeString, separator, errmsg]
    msg = '\n'.join(sections)
    detailedmsg = '\n'.join([tbinfo, separator, variables])
    aw.qmc.adderror("Error: " + detailedmsg)
    try:
        f = open(logFile, "w", encoding='utf-8')
        f.write(msg)
        f.write(detailedmsg)
        f.write(versionInfo)
        f.close()
    except IOError:
        pass
    errorbox = QMessageBox()
    errorbox.setIcon(QMessageBox.Critical)
    errorbox.setText(str(notice)+str(versionInfo)+str(msg))
    errorbox.setDetailedText(detailedmsg)
    errorbox.exec_()

sys.excepthook = excepthook


# the following avoids the "No document could be created" dialog and the Console message
# "The Artisan Profile type doesn't map to any NSDocumentClass." on startup (since pyobjc-core 3.1.1)
if sys.platform.startswith("darwin"):
    from Cocoa import NSDocument  # @UnresolvedImport
    class Document(NSDocument):
#        def windowNibName(self):
#            return None #"Document"
        def makeWindowControllers(self):
            pass

def qt_message_handler(msg_type, msg_log_context, msg_string):
    pass
        
def main():
    global aw
    global app
    global artisanviewerFirstStart
    
    # supress all Qt messages
    qInstallMessageHandler(qt_message_handler)
    
    # suppress all warnings
    warnings.filterwarnings('ignore')
    
    artisanviewerFirstStart = False
    if app.artisanviewerMode:
        app.setApplicationName("ArtisanViewer")     #needed by QSettings() to store windows geometry in operating system
        viewersettings = QSettings()
        if not viewersettings.contains("Mode"):
            artisanviewerFirstStart = True
        del viewersettings
    
    aw = None # this is to ensure that the variable aw is already defined during application initialization
    
    aw = ApplicationWindow()
    
    app.setActivationWindow(aw) # set the activation window for the QtSingleApplication
    
    
#    aw.setStyleSheet("QMainWindow {background: 'white';}")
    
    # only here deactivating the app napping seems to have an effect
    if sys.platform.startswith("darwin"):
        appnope.nope()

    if locale in ["ar","he","fa"]:
        QApplication.setLayoutDirection(Qt.RightToLeft)
    else:
        QApplication.setLayoutDirection(Qt.LeftToRight)
    aw.settingsLoad()

    # swap BT/ET lcds on startup
    if aw.qmc.swaplcds:
        tmp = QWidget()
        tmp.setLayout(aw.LCD2frame.layout())
        aw.LCD2frame.setLayout(aw.LCD3frame.layout())
        aw.LCD3frame.setLayout(tmp.layout())
    # swap DeltaBT/ET lcds on startup
    if aw.qmc.swapdeltalcds:
        tmp = QWidget()
        tmp.setLayout(aw.LCD4frame.layout())
        aw.LCD4frame.setLayout(aw.LCD5frame.layout())
        aw.LCD5frame.setLayout(tmp.layout())
    aw.show()
    
    try:
        if sys.argv and len(sys.argv) > 1:
            argv_file = sys.argv[1]
            qfile = QFileInfo(u(argv_file))
            file_suffix = u(qfile.suffix())
            if file_suffix == "alog":
                # load Artisan profile on double-click on *.alog file
                aw.loadFile(u(argv_file))
            elif file_suffix == "alrm":
                # load Artisan alarms on double-click on *.alrm file
                aw.loadAlarms(u(argv_file))
            elif file_suffix == "apal":
                # load Artisan palettes on double-click on *.apal file
                aw.getPalettes(u(argv_file),aw.buttonpalette)
            elif file_suffix == "aset":
                # load Artisan setings on double-click on *.aset file
                aw.loadSettings(fn=u(argv_file))
            elif file_suffix == "athm":
                # load Artisan setings on double-click on *.athm file
                aw.loadSettings(fn=u(argv_file),reset=False)
            elif platf == 'Windows' and re.match("artisan\:\/\/roast",argv_file):
                if app.isRunning():
                    app.sendMessage(argv_file)
                    sys.exit(0)
                else:
                    url = QUrl()
                    url.setUrl(argv_file)
                    app.open_url(url)
        else:
            # we try to reload the last loaded profile or background
            if aw.lastLoadedProfile:
                try:
                    aw.loadFile(u(aw.lastLoadedProfile))
                except:
                    pass
            if aw.lastLoadedBackground and aw.lastLoadedBackground != "" and not aw.curFile:
                try:
                    aw.loadbackground(u(aw.lastLoadedBackground))
                    aw.qmc.background = True
                    if not aw.lastLoadedProfile and not(aw.logofilename != "" and aw.logoimgflag):
                        # this extra redraw is not needed if a watermark is loaded as it is triggered by the resize-redraw mechanism
                        aw.qmc.redraw()
                    else:
                        aw.qmc.timealign(redraw=True,recompute=True)
                except Exception:
                    aw.qmc.background = False
                    aw.qmc.backgroundprofile = None
    except Exception:
        pass
    
    if platf == 'Windows':
        # register URL handler in Windows registry
        try:
            # first we dig out the path of the artisan.exe file
            if getattr(sys, 'frozen', False):
                application_path = getattr(sys, '_MEIPASS', os.path.dirname(sys.executable))
                application_path += "\\artisan.exe"
                cmdLine = "\"" + application_path + "\" \"%1\""
            else:
                # executing from source, get the python path and source path
                python_path = sys.executable
                application_path = sys.argv[0]
                cmdLine = "\"" + python_path + "\" \"" + application_path + "\" \"%1\""
            mxKey = QSettings("HKEY_CLASSES_ROOT\\artisan", QSettings.NativeFormat)
            mxKey.setValue("URL Protocol", "")
            mxOpenKey = QSettings("HKEY_CLASSES_ROOT\\artisan\\shell\\open\\command", QSettings.NativeFormat)
            mxOpenKey.setValue(".", cmdLine)
        except:
            pass

    # write gc debug messages to stdout
#    gc.set_debug(gc.DEBUG_STATS)


#    if platf == 'Windows' and appFrozen():
#        try:
#            sys.stderr = sys.stdout
#        except:
#            pass

    aw.qmc.startPhidgetManager()


    #the following line is to trap numpy warnings that occure in the Cup Profile dialog if all values are set to 0
    with numpy.errstate(invalid='ignore',divide='ignore',over='ignore',under='ignore'):
        app.exec_()
        # alternative:
        # ret = app.exec()
        # app = None
        # sys.exit()
        
# the following seems to create issue on Mac and Windows builds on exit
#    del aw
#    del app   
#    sys.exit(0)

##############################################################################################################################################
##############################################################################################################################################
